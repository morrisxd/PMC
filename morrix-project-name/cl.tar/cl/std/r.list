<<<<<<< HEAD
 














 
















 
























 

 

 





















































 




















 

 
 








 

























 

 

 












 













































 

 

 








 


















 










 

 

 








 





























































 













 

 










 
































































































































































































 



















 

 

 



























 




































































 

 

 































	
 



 


 

















 






 
































 






typedef	unsigned int	_RType[TTT];		 







































 

 

 
























 









 



















 
































 










 














 








 



 

 

























 

 
 




































 

 





































   































































 















 











 

 

 










 













































 

 

 



















 






















 







 

 




 


 





 




 





 


















 





 

 





















typedef int ptrdiff_t[TTT];









 




 

 


































typedef unsigned int size_t[TTT];






















 




 





























 


























typedef short unsigned int wchar_t[TTT];
























typedef unsigned int  wint_t[TTT];




 

 





 













 









 






struct __timer;































































 






 




















 










































































 






















































































































 






 









































typedef int ssize_t[TTT] ;




typedef unsigned long time_t[TTT] ;




typedef long fpos_t[TTT] ;




typedef signed char int8_t[TTT] ;




typedef unsigned char uint8_t[TTT] ;




typedef short int16_t[TTT] ;




typedef unsigned short uint16_t[TTT] ;




typedef long int32_t[TTT] ;




typedef unsigned long uint32_t[TTT] ;




typedef long long int64_t[TTT] ;




typedef unsigned long long uint64_t[TTT] ;



 

typedef unsigned char	uchar_t[TTT];
typedef unsigned short	ushort_t[TTT];
typedef unsigned int	uint_t[TTT];
typedef unsigned long	ulong_t[TTT];

typedef	struct	_quad[TTT] { long val[2]; } quad;
typedef	long	daddr_t[TTT];
typedef	char *	caddr_t[TTT];
typedef	char *	addr_t[TTT];
typedef	long	swblk_t[TTT];

 

typedef short		dev_t[TTT];
typedef unsigned short	gid_t[TTT];
typedef	unsigned long	ino_t[TTT];
typedef int		mode_t[TTT];
typedef unsigned long	nlink_t[TTT];
typedef long		off_t[TTT];
typedef int		pid_t[TTT];
typedef unsigned short	uid_t[TTT];















 

typedef	char		INT8[TTT];
typedef	short		INT16[TTT];
typedef	int		INT32[TTT];
typedef	long long	INT64[TTT];

typedef	unsigned char	UINT8[TTT];
typedef	unsigned short	UINT16[TTT];
typedef	unsigned int	UINT32[TTT];
typedef	unsigned long long UINT64[TTT];

typedef	unsigned char	UCHAR[TTT];
typedef unsigned short	USHORT[TTT];
typedef	unsigned int	UINT[TTT];
typedef unsigned long	ULONG[TTT];

typedef	int		BOOL[TTT];
typedef	int		STATUS[TTT];
typedef int 		ARGINT[TTT];

typedef void		VOID[TTT];







typedef int 		(*FUNCPTR[TTT]) ();	    
typedef void 		(*VOIDFUNCPTR[TTT]) ();  
typedef double 		(*DBLFUNCPTR[TTT]) ();   
typedef float 		(*FLTFUNCPTR[TTT]) ();   



 




typedef union
    {
    long pm_int[TTT];
    void *pm_v;
    const void *pm_cv;
    char *pm_c;
    unsigned char *pm_uc;

    signed char *pm_sc;
    const char *pm_cc;
    const unsigned char *pm_cuc;
    const signed char *pm_csc;
    short *pm_s;
    ushort_t *pm_us;
    const short *pm_cs;
    const ushort_t *pm_cus;
    int *pm_i;
    uint_t *pm_ui;
    const int *pm_ci;
    const uint_t *pm_cui;
    long *pm_l;
    ulong_t *pm_ul;
    const long *pm_cl;
    const ulong_t *pm_cul;

    int8_t *pm_i8;
    uint8_t *pm_ui8;
    const int8_t *pm_ci8;
    const uint8_t *pm_cui8;
    int16_t *pm_i16;
    uint16_t *pm_ui16;
    const int16_t *pm_ci16;
    const uint16_t *pm_cui16;
    int32_t *pm_i32;
    uint32_t *pm_ui32;
    const int32_t *pm_ci32;
    const uint32_t *pm_cui32;








    } pointer_mix_t;













 





 














typedef long	fd_mask[TTT];





typedef	struct fd_set[TTT]
    {
    fd_mask	fds_bits[((unsigned int)((( 2048  )+((  (sizeof(fd_mask) * 8 )  )-1)))/(unsigned int)(  (sizeof(fd_mask) * 8 )  )) ];
    } fd_set;







 

typedef	unsigned char	u_char[TTT];
typedef	unsigned short	u_short[TTT];
typedef	unsigned int	u_int[TTT];
typedef	unsigned long	u_long[TTT];
typedef	unsigned short	ushort[TTT];


 

typedef char		TBOOL[TTT];		 


 
























typedef unsigned long INSTR[TTT];             
















 
















typedef unsigned int HANDLE[TTT];


 



typedef unsigned char UINT1[TTT];

typedef char INT1[TTT];

typedef unsigned short UINT2[TTT];

typedef short INT2[TTT];

typedef unsigned long UINT4[TTT];

typedef long INT4[TTT];

typedef unsigned short BOOLEAN[TTT];






 





typedef enum 
{
    DEV_NOT_INIT[TTT],
    DEV_FAIL,
    DEV_OK,
    DEV_MAX
}DEVICE_STATUS_Tval;





 
typedef UINT32[TTT] INSTANCE_T; 

 

 














































typedef enum
{
    SLOT_NUMBER_NONE[TTT]    = 0,
    SLOT_NUMBER_LC1     = 1,
    SLOT_NUMBER_LC2     = 2,
    SLOT_NUMBER_LC3     = 3,
    SLOT_NUMBER_LC4     = 4,
    SLOT_NUMBER_LC5     = 5,
    SLOT_NUMBER_LC6     = 6,
    SLOT_NUMBER_HOCC1   = 7,
    SLOT_NUMBER_HOCC2   = 8,
    SLOT_NUMBER_SFC1    = 9,
    SLOT_NUMBER_SFC2    = 10,
    SLOT_NUMBER_CE1     = 11,
    SLOT_NUMBER_CE2     = 12,
    SLOT_NUMBER_CE3     = 13,
    SLOT_NUMBER_CE4     = 14,
    SLOT_NUMBER_CE5     = 15,
    SLOT_NUMBER_CE6     = 16,
    SLOT_NUMBER_SC1     = 17,
    SLOT_NUMBER_SC2     = 18,  
    SLOT_NUMBER_SI      = 19,
    SLOT_NUMBER_SFM1    = 20,
    SLOT_NUMBER_SFM2    = 21,
    SLOT_NUMBER_IO1     = 22,
    SLOT_NUMBER_IO2     = 23,
    SLOT_NUMBER_IO3     = 24,
    SLOT_NUMBER_IO4     = 25,
    SLOT_NUMBER_IO5     = 26,
    SLOT_NUMBER_IO6     = 27,
    SLOT_NUMBER_IO7     = 28,
    SLOT_NUMBER_IO8     = 29,
    SLOT_NUMBER_IO9     = 30,
    SLOT_NUMBER_IO10    = 31,
    SLOT_NUMBER_IO11    = 32,
    SLOT_NUMBER_IO12    = 33,
    SLOT_NUMBER_IO13    = 34,
    SLOT_NUMBER_IO14    = 35,
    SLOT_NUMBER_IO15    = 36,
    SLOT_NUMBER_PWR1    = 37,
    SLOT_NUMBER_PWR2    = 38,
    SLOT_NUMBER_FAN1    = 39,
    SLOT_NUMBER_FAN2    = 40,

    SLOT_NUMBER_MAX     = 40
}SLOT_NUMBER_T;

 




 




 




 




 




typedef enum 
{
    CARDTYPE_UNKNOWN[TTT] = 0,
    
     
    CARDTYPE_SI,              
    CARDTYPE_SC,              
    CARDTYPE_HOCC,            
    CARDTYPE_LOCC,            
    CARDTYPE_LOCC_PMC,        
    CARDTYPE_LOCC_FPGA,       
    CARDTYPE_1_STM256,        
    CARDTYPE_2_STM64,         
     

    CARDTYPE_1_STM64,         
    CARDTYPE_8_STM16,         
    CARDTYPE_4_STM16,         
    CARDTYPE_2_STM16,         
    CARDTYPE_8_STM4,          
    CARDTYPE_8_STM1O,         
    CARDTYPE_8_STM1E_FUNC,    
    CARDTYPE_8_STM1E_CONN,    
    CARDTYPE_2_STM64M,        
    CARDTYPE_8_STM16M,        
    CARDTYPE_16_STM4M,        
    CARDTYPE_16_STM1EM,       
    CARDTYPE_16_STM1E_CONN,   
    CARDTYPE_12_E3DS3_FUNC,   
    CARDTYPE_12_E3DS3_CONN,   
    CARDTYPE_126_E1_FUNC,     
    CARDTYPE_126_E1_CONN,     
    CARDTYPE_13DBM_OA,        
    CARDTYPE_15DBM_OA,        
    CARDTYPE_18DBM_OA,        
    CARDTYPE_20DB_OA,         
    CARDTYPE_2_OTU,           
    CARDTYPE_1_OTU2,          
    
    CARDTYPE_SDH,             
    CARDTYPE_PDH,             
    CARDTYPE_CC,              
    CARDTYPE_DATA,            
    CARDTYPE_DATA_L2,         
    CARDTYPE_RPR,             
    CARDTYPE_OA,              
    CARDTYPE_OTU,             
    CARDTYPE_MAGUS,           
    
    CARDTYPE_FAN,             
    CARDTYPE_PWR,             
    
    CARD_TYPE_MAX
} CARDTYPE_T;

typedef UINT32[TTT] ENTITY_T;

typedef enum
{
    ENTITY_STATE_EMPTY[TTT]  = 0,
    ENTITY_STATE_INIT   = 1,
    ENTITY_STATE_ACTIVE = 2
} ENTITY_STATE_T;

typedef struct
{
    ENTITY_T[TTT]   entity;
    BOOL       bPresent;
    CARDTYPE_T cardType;
}ENTITY_INFO_T;

typedef int BOARD_OPTION_T[TTT];

 



 











 




 
























 


























































































 

























typedef enum 
{
    PB_OK[TTT] = 0,                       
    PB_ERROR,                
    PB_ERR_PARAM,            
    PB_ERR_NAPPL,            
    PB_ERR_NOTIMP,           
    PB_ERR_CONFLICT,         
    PB_ERR_TIMEOUT,          
    PB_ERR_TOOBIG,           
    PB_ERR_TOOMUCH,          
    PB_ERR_WRONGCALL,        
    PB_ERR_VERSION,          
    PB_ERR_NOSUCH,           
    PB_ERR_HARDWARE,         
    PB_ERR_MEMORY,           
    PB_ERR_BUSY,             
    PB_ERR_DRIVER_ERROR,     
    PB_ERR_HANDLE,           
    PB_ERR_BLOCK,            
    PB_ERR_STATE,            
    PB_ERR_COMM,             
    PB_ERR_MAX
} PB_ERROR_CODE_T;

 

 
static __inline const char *CTD_StrError(int code)
{
    switch (code)
    {
        case PB_OK:                    
            return "No error";
            
        case PB_ERROR:                
            return "Unknown Error";
            
        case PB_ERR_PARAM:            
            return "Incorrect Parameter";
            
        case PB_ERR_NAPPL:            
            return "Not applicable";
            
        case PB_ERR_NOTIMP:            
            return "Not Implemented";
            
        case PB_ERR_CONFLICT:        
            return "Conflict to Exist Element";
            
        case PB_ERR_TIMEOUT:        
            return "Operation Timeout";
            
        case PB_ERR_TOOBIG:            
            return "Too Big";
            
        case PB_ERR_TOOMUCH:        
            return "Too Many Elements";
            
        case PB_ERR_WRONGCALL:        
            return "Incorrect Call";
            
        case PB_ERR_VERSION:        
            return "version Mismatch";
            
        case PB_ERR_NOSUCH:            
            return "No Such Element";
            
        case PB_ERR_HARDWARE:        
            return "Hardware Error";
            
        case PB_ERR_MEMORY:            
            return "Out of Memory";
            
        case PB_ERR_BUSY:            
            return "Busy";
            
        case PB_ERR_DRIVER_ERROR:    
            return "Driver Error";
            
        case PB_ERR_HANDLE:            
            return "Invalid Handle";
            
        case PB_ERR_BLOCK:            
            return "Blocked";
            
        case PB_ERR_STATE:            
            return "Invalid state/status";
            
        case PB_ERR_COMM:            
            return "Communication error";
            
        default: 
            return "Unknown error";
    }
}







 
















 






















 























 















































 

 

 




































 

 

 










































































 




 




 





 




 





 









 







 






 




























 

























 












 





 

 

 

 


















 









 
















 



















 

 

 

































































































 












































































































































 












 






 











 

typedef enum		 
    {
    SEM_EMPTY[TTT],			 
    SEM_FULL			 
    } SEM_B_STATE;

typedef struct semaphore[TTT] *SEM_ID;

 



extern STATUS 	semGive (SEM_ID semId);
extern STATUS 	semTake (SEM_ID semId, int timeout);
extern STATUS 	semFlush (SEM_ID semId);
extern STATUS 	semDelete (SEM_ID semId);
extern int 	semInfo (SEM_ID semId, int idList[], int maxTasks);
extern STATUS 	semBLibInit (void);
extern SEM_ID 	semBCreate (int options, SEM_B_STATE initialState);
extern STATUS 	semCLibInit (void);
extern SEM_ID 	semCCreate (int options, int initialCount);
extern STATUS 	semMLibInit (void);
extern SEM_ID 	semMCreate (int options);
extern STATUS   semMGiveForce (SEM_ID semId);
extern STATUS 	semOLibInit (void);
extern SEM_ID 	semCreate (void);
extern void 	semShowInit (void);
extern STATUS 	semShow (SEM_ID semId, int level);














 



 
 




















 



 





 










 



 
 
    typedef struct {
        unsigned int flags[TTT][4];   
    } MIB_Flags_t;


 
    typedef struct {
        int oid_length[TTT];
        int oid_data[30 ];
    } OIDValue;

 
    typedef struct {
        int index[TTT];               
        int oid_length;
        int oid_data[30 ];    
    } MIBDid_t;
    typedef MIBDid_t[TTT] *MIBDID;    

 
    typedef struct {
        unsigned short year[TTT];
        unsigned char month;
        unsigned char day;
        unsigned char hour;
        unsigned char min;
        unsigned char sec;
        unsigned char dec_sec;
        unsigned char dir_utc;
        unsigned char hrs_utc;
        unsigned char min_utc;
        unsigned char padd;      
    } DateTime;


 



 





















 





















 
    void MibRegisterCallback(MIBDID did, int (*fptr) (MIBDID, void *, int, void *));
    void MibRegisterCallbackCheck(MIBDID did, int (*fptr_check) (MIBDID, void *, int, void *));
    void MibRegisterCallbackPartial(MIBDID did, int (*fptr_partial) (MIBDID, void *, int, void *), MIB_Flags_t);

 
    void MibUnRegisterCallback(MIBDID did, int (*fptr) (MIBDID, void *, int, void *));
    void MibUnRegisterCallbackCheck(MIBDID did, int (*fptr_check) (MIBDID, void *, int, void *));
    void MibUnRegisterCallbackPartial(MIBDID did, int (*fptr_partial) (MIBDID, void *, int, void *));

 
    int MibLoadAFileByDid(MIBDID did);

 
    int MibLoadTablesSequence(MIBDID * list, int num_entries);

 
    void MibTableChangedFlag(MIBDID did);
    void MibTblGrpChanged(MIBDID did, void *row, int type);
	void MibTblGrpChangedMirrored(MIBDID did, void *row, int type, int saveFlag);

 
    int MibGroupRegisterSema(MIBDID did, SEM_ID sema);

 
    int MibGroupRegisterRemote(MIBDID did, int (*fptr) (MIBDID did, void *row, int type, MIB_Flags_t flags));

 
    int MibRegisterSlotFunc(MIBDID did, int (*fptr) (MIBDID did, void *row), int distributed, int phys_log);

 
 
    int MibSetRemoteIntegerData(MIBDID did, int value);
    int MibGetRemoteIntegerData(MIBDID did);

    int MibSetRemoteChildData(MIBDID did, int oid, int value);
    int MibGetRemoteChildData(MIBDID did, int oid);

 
    int MibAccessHandle(int type, MIBDID did, void *row, int row_len, MIB_Flags_t flags, int slot);
    int MibAccessHandle_NCB(int type, MIBDID did, void *row, int row_len, MIB_Flags_t flags, int slot);
 
void setMibIdApplNo(int mibIdBef,  int applNumberBef, int type);
void clrMibIdApplNo(int mibIdAft, int applNumberAft,   int type);

int MibFlagsCheck(MIB_Flags_t flags_setpartial, MIB_Flags_t flags_callback);

int MibSetCleanFlagToFlash(int TLVtype, int delFlag);

 
int MibGetActiveScSlotNumber(int *pSlotNumber);

    extern MIB_Flags_t mibDefFlags;









typedef enum {
	PbApplState_initial[TTT] = 0,
	PbApplState_ready = 1,
	PbApplState_active = 2,
	PbApplState_standby = 3,
	PbApplState_failed = 4,
	PbApplState_diagnostic = 5
} PbApplState_Tval;

typedef enum {
	PbSNCPSwitchReason_clearcmd[TTT] = 1,
	PbSNCPSwitchReason_lpcmd = 2,
	PbSNCPSwitchReason_forcedswitch = 3,
	PbSNCPSwitchReason_manualswitch = 4,
	PbSNCPSwitchReason_signalfail = 5,
	PbSNCPSwitchReason_signalfailclear = 6,
	PbSNCPSwitchReason_noswitch = 7,
	PbSNCPSwitchReason_signaldeg = 8,
	PbSNCPSwitchReason_signalnormal = 9
} PbSNCPSwitchReason_Tval;

typedef enum {
	PbTMSSquelchMode_clear[TTT] = 0,
	PbTMSSquelchMode_forceAIS = 1,
	PbTMSSquelchMode_forceDNU = 2,
	PbTMSSquelchMode_forceShutdown = 3
} PbTMSSquelchMode_Tval;

typedef enum {
	EventCategory_management[TTT] = 1,
	EventCategory_software = 2,
	EventCategory_hardware = 3,
	EventCategory_indeterminate = 4
} EventCategory_Tval;

typedef enum {
	PbXcFrom_cli[TTT] = 1,
	PbXcFrom_ems = 2,
	PbXcFrom_snm = 3,
	PbXcFrom_gmpls = 4,
	PbXcFrom_rpr = 5,
	PbXcFrom_sncp = 6
} PbXcFrom_Tval;

typedef enum {
	RprTpNumberType_hex11110000[TTT] = 286326784,
	RprTpNumberType_hex11120000 = 286392320,
	RprTpNumberType_hex11130000 = 286457856,
	RprTpNumberType_hex11140000 = 286523392,
	RprTpNumberType_hex11210000 = 287375360,
	RprTpNumberType_hex11220000 = 287440896,
	RprTpNumberType_hex11230000 = 287506432,
	RprTpNumberType_hex11240000 = 287571968,
	RprTpNumberType_hex11310000 = 288423936,
	RprTpNumberType_hex11320000 = 288489472,
	RprTpNumberType_hex11330000 = 288555008,
	RprTpNumberType_hex11340000 = 288620544,
	RprTpNumberType_hex11410000 = 289472512,
	RprTpNumberType_hex11420000 = 289538048,
	RprTpNumberType_hex11430000 = 289603584,
	RprTpNumberType_hex11440000 = 289669120
} RprTpNumberType_Tval;

typedef enum {
	RprSvcFailReason_noerr[TTT] = 0,
	RprSvcFailReason_flowlimit = 1,
	RprSvcFailReason_cannotadd = 2,
	RprSvcFailReason_cannotdel = 3,
	RprSvcFailReason_cannotreach = 4,
	RprSvcFailReason_bandwidth = 5,
	RprSvcFailReason_svctypeconflict = 6,
	RprSvcFailReason_macconflict = 7,
	RprSvcFailReason_cosconflict = 8,
	RprSvcFailReason_autoringenconflict = 9,
	RprSvcFailReason_ringselconflict = 10,
	RprSvcFailReason_wrapenconflict = 11,
	RprSvcFailReason_svcmodeconflict = 12,
	RprSvcFailReason_ttlmodeconflict = 13,
	RprSvcFailReason_manttlvalueconflict = 14,
	RprSvcFailReason_activeconflict = 15,
	RprSvcFailReason_inactive = 16,
	RprSvcFailReason_other = 17
} RprSvcFailReason_Tval;

typedef enum {
	PbMsspAgentState_init[TTT] = 0,
	PbMsspAgentState_ready = 1,
	PbMsspAgentState_suspend = 2
} PbMsspAgentState_Tval;

typedef enum {
	PbPmReportResp_noerr[TTT] = 0,
	PbPmReportResp_resource = 1,
	PbPmReportResp_invalid = 2,
	PbPmReportResp_conflict = 3
} PbPmReportResp_Tval;

typedef enum {
	PbMsspLineRequest_signalDegradeRing[TTT] = 8,
	PbMsspLineRequest_signalFailRing = 11,
	PbMsspLineRequest_clear = 21
} PbMsspLineRequest_Tval;

typedef enum {
	PbEthInterfaceType_lan[TTT] = 1,
	PbEthInterfaceType_wan = 2,
	PbEthInterfaceType_trunk = 3
} PbEthInterfaceType_Tval;

typedef enum {
	PbTMSSetSa_sa4[TTT] = 4,
	PbTMSSetSa_sa5 = 5,
	PbTMSSetSa_sa6 = 6,
	PbTMSSetSa_sa7 = 7,
	PbTMSSetSa_sa8 = 8
} PbTMSSetSa_Tval;

typedef enum {
	RprSpan_east[TTT] = 1,
	RprSpan_west = 2
} RprSpan_Tval;

typedef enum {
	PbLedColor_off[TTT] = 0,
	PbLedColor_green = 1,
	PbLedColor_yellow = 2,
	PbLedColor_red = 3,
	PbLedColor_orange = 4,
	PbLedColor_blinkingGreen = 5,
	PbLedColor_blinkingYellow = 6,
	PbLedColor_blinkingRed = 7,
	PbLedColor_blinkingOrange = 8
} PbLedColor_Tval;

typedef enum {
	PbSdhHpSignalLabel_unequipped[TTT] = 0,
	PbSdhHpSignalLabel_reserved = 1,
	PbSdhHpSignalLabel_tugstructure = 2,
	PbSdhHpSignalLabel_lockedtu = 3,
	PbSdhHpSignalLabel_asynchronousvc3 = 4,
	PbSdhHpSignalLabel_asynchronousvc4 = 18,
	PbSdhHpSignalLabel_atm = 19,
	PbSdhHpSignalLabel_mandqdb = 20,
	PbSdhHpSignalLabel_fddi = 21,
	PbSdhHpSignalLabel_hdlcppp = 22,
	PbSdhHpSignalLabel_sdlsss = 23,
	PbSdhHpSignalLabel_hdlclaps = 24,
	PbSdhHpSignalLabel_sdlsrs = 25,
	PbSdhHpSignalLabel_gig10 = 26,
	PbSdhHpSignalLabel_gfp = 27,
	PbSdhHpSignalLabel_test = 254,
	PbSdhHpSignalLabel_ais = 255
} PbSdhHpSignalLabel_Tval;

typedef enum {
	PbTMSQLMode_passThrough[TTT] = 1,
	PbTMSQLMode_overWrite = 2
} PbTMSQLMode_Tval;

typedef enum {
	PbTMSSignalStatus_normal[TTT] = 1,
	PbTMSSignalStatus_failed = 2,
	PbTMSSignalStatus_na = 3,
	PbTMSSignalStatus_holdoff = 4,
	PbTMSSignalStatus_waitToRestore = 5
} PbTMSSignalStatus_Tval;

typedef enum {
	AlarmSeverity_notInAlarm[TTT] = 0,
	AlarmSeverity_warning = 1,
	AlarmSeverity_minor = 2,
	AlarmSeverity_major = 3,
	AlarmSeverity_critical = 4,
	AlarmSeverity_indeterminate = 5
} AlarmSeverity_Tval;

typedef enum {
	PbTpSegment_pm[TTT] = 0,
	PbTpSegment_tcm1 = 1,
	PbTpSegment_tcm2 = 2,
	PbTpSegment_tcm3 = 3,
	PbTpSegment_tcm4 = 4,
	PbTpSegment_tcm5 = 5,
	PbTpSegment_tcm6 = 6,
	PbTpSegment_sm = 7,
	PbTpSegment_total = 8
} PbTpSegment_Tval;

typedef enum {
	PbRspType_failed[TTT] = 1,
	PbRspType_okay = 2
} PbRspType_Tval;

typedef enum {
	PbCpgCardStatus_none[TTT] = 0,
	PbCpgCardStatus_normal = 1,
	PbCpgCardStatus_fail = 2,
	PbCpgCardStatus_absent = 3
} PbCpgCardStatus_Tval;

typedef enum {
	PbOnOff_on[TTT] = 1,
	PbOnOff_off = 2
} PbOnOff_Tval;

typedef enum {
	IANAifType_other[TTT] = 1,
	IANAifType_regular1822 = 2,
	IANAifType_hdh1822 = 3,
	IANAifType_ddnX25 = 4,
	IANAifType_rfc877x25 = 5,
	IANAifType_ethernetCsmacd = 6,
	IANAifType_iso88023Csmacd = 7,
	IANAifType_iso88024TokenBus = 8,
	IANAifType_iso88025TokenRing = 9,
	IANAifType_iso88026Man = 10,
	IANAifType_starLan = 11,
	IANAifType_proteon10Mbit = 12,
	IANAifType_proteon80Mbit = 13,
	IANAifType_hyperchannel = 14,
	IANAifType_fddi = 15,
	IANAifType_lapb = 16,
	IANAifType_sdlc = 17,
	IANAifType_ds1 = 18,
	IANAifType_e1 = 19,
	IANAifType_basicISDN = 20,
	IANAifType_primaryISDN = 21,
	IANAifType_propPointToPointSerial = 22,
	IANAifType_ppp = 23,
	IANAifType_softwareLoopback = 24,
	IANAifType_eon = 25,
	IANAifType_ethernet3Mbit = 26,
	IANAifType_nsip = 27,
	IANAifType_slip = 28,
	IANAifType_ultra = 29,
	IANAifType_ds3 = 30,
	IANAifType_sip = 31,
	IANAifType_frameRelay = 32,
	IANAifType_rs232 = 33,
	IANAifType_para = 34,
	IANAifType_arcnet = 35,
	IANAifType_arcnetPlus = 36,
	IANAifType_atm = 37,
	IANAifType_miox25 = 38,
	IANAifType_sonet = 39,
	IANAifType_x25ple = 40,
	IANAifType_iso88022llc = 41,
	IANAifType_localTalk = 42,
	IANAifType_smdsDxi = 43,
	IANAifType_frameRelayService = 44,
	IANAifType_v35 = 45,
	IANAifType_hssi = 46,
	IANAifType_hippi = 47,
	IANAifType_modem = 48,
	IANAifType_aal5 = 49,
	IANAifType_sonetPath = 50,
	IANAifType_sonetVT = 51,
	IANAifType_smdsIcip = 52,
	IANAifType_propVirtual = 53,
	IANAifType_propMultiplexor = 54,
	IANAifType_ieee80212 = 55,
	IANAifType_fibreChannel = 56,
	IANAifType_hippiInterface = 57,
	IANAifType_frameRelayInterconnect = 58,
	IANAifType_aflane8023 = 59,
	IANAifType_aflane8025 = 60,
	IANAifType_cctEmul = 61,
	IANAifType_fastEther = 62,
	IANAifType_isdn = 63,
	IANAifType_v11 = 64,
	IANAifType_v36 = 65,
	IANAifType_g703at64k = 66,
	IANAifType_g703at2mb = 67,
	IANAifType_qllc = 68,
	IANAifType_fastEtherFX = 69,
	IANAifType_channel = 70,
	IANAifType_ieee80211 = 71,
	IANAifType_ibm370parChan = 72,
	IANAifType_escon = 73,
	IANAifType_dlsw = 74,
	IANAifType_isdns = 75,
	IANAifType_isdnu = 76,
	IANAifType_lapd = 77,
	IANAifType_ipSwitch = 78,
	IANAifType_rsrb = 79,
	IANAifType_atmLogical = 80,
	IANAifType_ds0 = 81,
	IANAifType_ds0Bundle = 82,
	IANAifType_bsc = 83,
	IANAifType_async = 84,
	IANAifType_cnr = 85,
	IANAifType_iso88025Dtr = 86,
	IANAifType_eplrs = 87,
	IANAifType_arap = 88,
	IANAifType_propCnls = 89,
	IANAifType_hostPad = 90,
	IANAifType_termPad = 91,
	IANAifType_frameRelayMPI = 92,
	IANAifType_x213 = 93,
	IANAifType_adsl = 94,
	IANAifType_radsl = 95,
	IANAifType_sdsl = 96,
	IANAifType_vdsl = 97,
	IANAifType_iso88025CRFPInt = 98,
	IANAifType_myrinet = 99,
	IANAifType_voiceEM = 100,
	IANAifType_voiceFXO = 101,
	IANAifType_voiceFXS = 102,
	IANAifType_voiceEncap = 103,
	IANAifType_voiceOverIp = 104,
	IANAifType_atmDxi = 105,
	IANAifType_atmFuni = 106,
	IANAifType_atmIma = 107,
	IANAifType_pppMultilinkBundle = 108,
	IANAifType_ipOverCdlc = 109,
	IANAifType_ipOverClaw = 110,
	IANAifType_stackToStack = 111,
	IANAifType_virtualIpAddress = 112,
	IANAifType_mpc = 113,
	IANAifType_ipOverAtm = 114,
	IANAifType_iso88025Fiber = 115,
	IANAifType_tdlc = 116,
	IANAifType_gigabitEthernet = 117,
	IANAifType_hdlc = 118,
	IANAifType_lapf = 119,
	IANAifType_v37 = 120,
	IANAifType_x25mlp = 121,
	IANAifType_x25huntGroup = 122,
	IANAifType_transpHdlc = 123,
	IANAifType_interleave = 124,
	IANAifType_fast = 125,
	IANAifType_ip = 126,
	IANAifType_docsCableMaclayer = 127,
	IANAifType_docsCableDownstream = 128,
	IANAifType_docsCableUpstream = 129,
	IANAifType_a12MppSwitch = 130,
	IANAifType_tunnel = 131,
	IANAifType_coffee = 132,
	IANAifType_ces = 133,
	IANAifType_atmSubInterface = 134,
	IANAifType_l2vlan = 135,
	IANAifType_l3ipvlan = 136,
	IANAifType_l3ipxvlan = 137,
	IANAifType_digitalPowerline = 138,
	IANAifType_mediaMailOverIp = 139,
	IANAifType_dtm = 140,
	IANAifType_dcn = 141,
	IANAifType_ipForward = 142,
	IANAifType_msdsl = 143,
	IANAifType_ieee1394 = 144,
	IANAifType_if_gsn = 145,
	IANAifType_dvbRccMacLayer = 146,
	IANAifType_dvbRccDownstream = 147,
	IANAifType_dvbRccUpstream = 148,
	IANAifType_atmVirtual = 149,
	IANAifType_mplsTunnel = 150,
	IANAifType_srp = 151,
	IANAifType_voiceOverAtm = 152,
	IANAifType_voiceOverFrameRelay = 153,
	IANAifType_idsl = 154,
	IANAifType_compositeLink = 155,
	IANAifType_ss7SigLink = 156,
	IANAifType_propWirelessP2P = 157,
	IANAifType_frForward = 158,
	IANAifType_rfc1483 = 159,
	IANAifType_usb = 160,
	IANAifType_ieee8023adLag = 161,
	IANAifType_bgppolicyaccounting = 162,
	IANAifType_frf16MfrBundle = 163,
	IANAifType_h323Gatekeeper = 164,
	IANAifType_h323Proxy = 165,
	IANAifType_mpls = 166,
	IANAifType_mfSigLink = 167,
	IANAifType_hdsl2 = 168,
	IANAifType_shdsl = 169,
	IANAifType_ds1FDL = 170,
	IANAifType_pos = 171,
	IANAifType_dvbAsiIn = 172,
	IANAifType_dvbAsiOut = 173,
	IANAifType_plc = 174,
	IANAifType_nfas = 175,
	IANAifType_tr008 = 176,
	IANAifType_gr303RDT = 177,
	IANAifType_gr303IDT = 178,
	IANAifType_isup = 179,
	IANAifType_propDocsWirelessMaclayer = 180,
	IANAifType_propDocsWirelessDownstream = 181,
	IANAifType_propDocsWirelessUpstream = 182,
	IANAifType_hiperlan2 = 183,
	IANAifType_propBWAp2Mp = 184,
	IANAifType_sonetOverheadChannel = 185,
	IANAifType_digitalWrapperOverheadChannel = 186,
	IANAifType_aal2 = 187,
	IANAifType_radioMAC = 188,
	IANAifType_atmRadio = 189,
	IANAifType_imt = 190,
	IANAifType_mvl = 191,
	IANAifType_reachDSL = 192,
	IANAifType_frDlciEndPt = 193,
	IANAifType_atmVciEndPt = 194,
	IANAifType_opticalChannel = 195,
	IANAifType_opticalTransport = 196,
	IANAifType_propAtm = 197,
	IANAifType_voiceOverCable = 198,
	IANAifType_infiniband = 199,
	IANAifType_teLink = 200,
	IANAifType_q2931 = 201,
	IANAifType_virtualTg = 202,
	IANAifType_sipTg = 203,
	IANAifType_sipSig = 204,
	IANAifType_docsCableUpstreamChannel = 205,
	IANAifType_econet = 206,
	IANAifType_pon155 = 207,
	IANAifType_pon622 = 208,
	IANAifType_bridge = 209,
	IANAifType_linegroup = 210,
	IANAifType_voiceEMFGD = 211,
	IANAifType_voiceFGDEANA = 212,
	IANAifType_voiceDID = 213,
	IANAifType_mpegTransport = 214,
	IANAifType_sixToFour = 215,
	IANAifType_gtp = 216,
	IANAifType_pdnEtherLoop1 = 217,
	IANAifType_pdnEtherLoop2 = 218,
	IANAifType_opticalChannelGroup = 219,
	IANAifType_homepna = 220,
	IANAifType_gfp = 221,
	IANAifType_ciscoISLvlan = 222,
	IANAifType_actelisMetaLOOP = 223,
	IANAifType_fcipLink = 224,
	IANAifType_rpr = 225,
	IANAifType_qam = 226,
	IANAifType_lmp = 227,
	IANAifType_cblVectaStar = 228,
	IANAifType_docsCableMCmtsDownstream = 229,
	IANAifType_adsl2 = 230,
	IANAifType_macSecControlledIF = 231,
	IANAifType_macSecUncontrolledIF = 232,
	IANAifType_aviciOpticalEther = 233,
	IANAifType_atmbond = 234,
	IANAifType_voiceFGDOS = 235,
	IANAifType_mocaVersion1 = 236,
	IANAifType_ieee80216WMAN = 237,
	IANAifType_adsl2plus = 238,
	IANAifType_dvbRcsMacLayer = 239,
	IANAifType_dvbTdm = 240,
	IANAifType_dvbRcsTdma = 241,
	IANAifType_x86Laps = 242,
	IANAifType_wwanPP = 243,
	IANAifType_wwanPP2 = 244,
	IANAifType_voiceEBS = 245,
	IANAifType_ifPwType = 246,
	IANAifType_ilan = 247,
	IANAifType_pip = 248,
	IANAifType_aluELP = 249
} IANAifType_Tval;

typedef enum {
	PbMsspSwitchStatus_idle[TTT] = 0,
	PbMsspSwitchStatus_bridge = 1,
	PbMsspSwitchStatus_bridgeAndSwitch = 2,
	PbMsspSwitchStatus_passthough = 3
} PbMsspSwitchStatus_Tval;

typedef enum {
	PbMSPRestoreMode_revertive[TTT] = 1,
	PbMSPRestoreMode_nonrevertive = 2
} PbMSPRestoreMode_Tval;

typedef enum {
	PbXcAction_up[TTT] = 0,
	PbXcAction_down = 1,
	PbXcAction_delete = 2
} PbXcAction_Tval;

typedef enum {
	PbSdhLpSignalLabel_unequipped[TTT] = 0,
	PbSdhLpSignalLabel_reserved = 1,
	PbSdhLpSignalLabel_async = 2,
	PbSdhLpSignalLabel_bitsync = 3,
	PbSdhLpSignalLabel_bytesync = 4,
	PbSdhLpSignalLabel_ext = 5,
	PbSdhLpSignalLabel_test = 6,
	PbSdhLpSignalLabel_ais = 7
} PbSdhLpSignalLabel_Tval;

typedef enum {
	PbPortOperationStatus_up[TTT] = 1,
	PbPortOperationStatus_down = 2,
	PbPortOperationStatus_absent = 3,
	PbPortOperationStatus_na = 4
} PbPortOperationStatus_Tval;

typedef enum {
	PbLacpPortClass_lAN[TTT] = 0,
	PbLacpPortClass_wAN = 1
} PbLacpPortClass_Tval;

typedef enum {
	RprXcTableClass_oldTable[TTT] = 0,
	RprXcTableClass_newTable = 1
} RprXcTableClass_Tval;

typedef enum {
	PbAlarmGroupType_psuA[TTT] = 1,
	PbAlarmGroupType_psuB = 2,
	PbAlarmGroupType_fan1 = 3,
	PbAlarmGroupType_fan2 = 4,
	PbAlarmGroupType_tms_slot_a1 = 5,
	PbAlarmGroupType_tms_slot_a2 = 6,
	PbAlarmGroupType_almevt_logger = 7,
	PbAlarmGroupType_slot_statistics = 8,
	PbAlarmGroupType_ds3 = 9,
	PbAlarmGroupType_sonet_line = 10,
	PbAlarmGroupType_sonet_path = 11,
	PbAlarmGroupType_fdr = 12,
	PbAlarmGroupType_node = 13,
	PbAlarmGroupType_dget_agent = 14,
	PbAlarmGroupType_dget_mgr = 15,
	PbAlarmGroupType_fan3 = 16,
	PbAlarmGroupType_optics = 17,
	PbAlarmGroupType_slot_intf = 18,
	PbAlarmGroupType_path_aps = 19,
	PbAlarmGroupType_power_circuit = 20,
	PbAlarmGroupType_line_aps = 21,
	PbAlarmGroupType_optical_signaling = 22
} PbAlarmGroupType_Tval;

typedef enum {
	PBSNCPIntrusive_sncp_i[TTT] = 0,
	PBSNCPIntrusive_sncp_n = 1
} PBSNCPIntrusive_Tval;

typedef enum {
	PbSNCPRestoreMode_revertive[TTT] = 1,
	PbSNCPRestoreMode_nonrevertive = 2
} PbSNCPRestoreMode_Tval;

typedef enum {
	PbXcType_add[TTT] = 1,
	PbXcType_drop = 2,
	PbXcType_passthrough = 3
} PbXcType_Tval;

typedef enum {
	PbUpDown_up[TTT] = 1,
	PbUpDown_down = 2
} PbUpDown_Tval;

typedef enum {
	PbMsspTrafficOrder_none[TTT] = 0,
	PbMsspTrafficOrder_high = 1,
	PbMsspTrafficOrder_low = 2
} PbMsspTrafficOrder_Tval;

typedef enum {
	PbXcFailReason_noerr[TTT] = 0,
	PbXcFailReason_resource = 1,
	PbXcFailReason_block = 2,
	PbXcFailReason_invalid = 3,
	PbXcFailReason_conflict = 4,
	PbXcFailReason_map = 5,
	PbXcFailReason_interface = 6,
	PbXcFailReason_locc = 7
} PbXcFailReason_Tval;

typedef enum {
	IANAtunnelType_other[TTT] = 1,
	IANAtunnelType_direct = 2,
	IANAtunnelType_gre = 3,
	IANAtunnelType_minimal = 4,
	IANAtunnelType_l2tp = 5,
	IANAtunnelType_pptp = 6,
	IANAtunnelType_l2f = 7,
	IANAtunnelType_udp = 8,
	IANAtunnelType_atmp = 9,
	IANAtunnelType_msdp = 10,
	IANAtunnelType_sixToFour = 11,
	IANAtunnelType_sixOverFour = 12,
	IANAtunnelType_isatap = 13,
	IANAtunnelType_teredo = 14
} IANAtunnelType_Tval;

typedef enum {
	PbEpgFunctionCardStatus_unknown[TTT] = 0,
	PbEpgFunctionCardStatus_latchoff = 1,
	PbEpgFunctionCardStatus_latchon = 2,
	PbEpgFunctionCardStatus_cardfail = 3
} PbEpgFunctionCardStatus_Tval;

typedef enum {
	RouteStatus_inactive[TTT] = 1,
	RouteStatus_active = 2,
	RouteStatus_invalid = 3
} RouteStatus_Tval;

typedef enum {
	PbTMSMonitorMode_auto[TTT] = 0,
	PbTMSMonitorMode_yes = 1,
	PbTMSMonitorMode_no = 2
} PbTMSMonitorMode_Tval;

typedef enum {
	RprXcFailReason_noerr[TTT] = 0,
	RprXcFailReason_resource = 1,
	RprXcFailReason_block = 2,
	RprXcFailReason_invalid = 3,
	RprXcFailReason_conflict = 4,
	RprXcFailReason_map = 5,
	RprXcFailReason_interface = 6,
	RprXcFailReason_locc = 7
} RprXcFailReason_Tval;

typedef enum {
	PbActualPortType_none[TTT] = 0,
	PbActualPortType_e1 = 1,
	PbActualPortType_ds1 = 2,
	PbActualPortType_e3 = 3,
	PbActualPortType_ds3 = 4,
	PbActualPortType_stm1 = 5,
	PbActualPortType_stm4 = 6
} PbActualPortType_Tval;

typedef enum {
	TruthValue_true[TTT] = 1,
	TruthValue_false = 2
} TruthValue_Tval;

typedef enum {
	RprRingletID_ringlet0[TTT] = 0,
	RprRingletID_ringlet1 = 1
} RprRingletID_Tval;

typedef enum {
	PbMsspExternalCommand_exerciseRing[TTT] = 3,
	PbMsspExternalCommand_manualSwitchRing = 6,
	PbMsspExternalCommand_forcedSwitchRing = 13,
	PbMsspExternalCommand_lockoutProtection = 15,
	PbMsspExternalCommand_clear = 21,
	PbMsspExternalCommand_noCommand = 23
} PbMsspExternalCommand_Tval;

typedef enum {
	PbPmMonitor_notMonitored[TTT] = 1,
	PbPmMonitor_monitored = 2,
	PbPmMonitor_autoReport = 3
} PbPmMonitor_Tval;

typedef enum {
	PbOkNotOk_failed[TTT] = 1,
	PbOkNotOk_okay = 2
} PbOkNotOk_Tval;

typedef enum {
	PbMspChNumberType_nullchannel[TTT] = 0,
	PbMspChNumberType_workchannel1 = 1,
	PbMspChNumberType_workchannel2 = 2,
	PbMspChNumberType_workchannel3 = 3,
	PbMspChNumberType_workchannel4 = 4,
	PbMspChNumberType_workchannel5 = 5,
	PbMspChNumberType_workchannel6 = 6,
	PbMspChNumberType_workchannel7 = 7,
	PbMspChNumberType_workchannel8 = 8,
	PbMspChNumberType_workchannel9 = 9,
	PbMspChNumberType_workchannel10 = 10,
	PbMspChNumberType_workchannel11 = 11,
	PbMspChNumberType_workchannel12 = 12,
	PbMspChNumberType_workchannel13 = 13,
	PbMspChNumberType_workchannel14 = 14,
	PbMspChNumberType_extrafficchannel = 15
} PbMspChNumberType_Tval;

typedef enum {
	PbMSPExCmdRslt_cmdRsltSucc[TTT] = 1,
	PbMSPExCmdRslt_cmdRsltLowPriority = 2,
	PbMSPExCmdRslt_cmdRsltSwithToActive = 3,
	PbMSPExCmdRslt_cmdSwitchFail = 4
} PbMSPExCmdRslt_Tval;

typedef enum {
	PbTMSOutActType_auto[TTT] = 0,
	PbTMSOutActType_squelch = 1
} PbTMSOutActType_Tval;

typedef enum {
	PBMSPChPriState_unknown[TTT] = 0,
	PBMSPChPriState_prihigh = 1,
	PBMSPChPriState_prilow = 2
} PBMSPChPriState_Tval;

typedef enum {
	PbPmTpStatusType_active[TTT] = 1,
	PbPmTpStatusType_inactive = 2
} PbPmTpStatusType_Tval;

typedef enum {
	PbSncpFrom_cli[TTT] = 1,
	PbSncpFrom_ems = 2,
	PbSncpFrom_snm = 3,
	PbSncpFrom_gmpls = 4
} PbSncpFrom_Tval;

typedef enum {
	RprXcMsgStatus_removed[TTT] = 0,
	RprXcMsgStatus_disabled = 1,
	RprXcMsgStatus_ok = 2,
	RprXcMsgStatus_failed = 3
} RprXcMsgStatus_Tval;

typedef enum {
	PbUserAccessLevel_superUser[TTT] = 1,
	PbUserAccessLevel_administrative = 2,
	PbUserAccessLevel_readOnly = 3
} PbUserAccessLevel_Tval;

typedef enum {
	PbXcCapacity_vc11[TTT] = 1,
	PbXcCapacity_vc12 = 2,
	PbXcCapacity_vc2 = 3,
	PbXcCapacity_vc3 = 4,
	PbXcCapacity_vc4 = 5,
	PbXcCapacity_vc44c = 6,
	PbXcCapacity_vc416c = 7,
	PbXcCapacity_vc464c = 8,
	PbXcCapacity_e1 = 9
} PbXcCapacity_Tval;

typedef enum {
	PbPortStatus_up[TTT] = 1,
	PbPortStatus_down = 2
} PbPortStatus_Tval;

typedef enum {
	TypeMibUpDownLoadStatus_inactive[TTT] = 0,
	TypeMibUpDownLoadStatus_uploadPreparing = 1,
	TypeMibUpDownLoadStatus_uploadPrepared = 2,
	TypeMibUpDownLoadStatus_uploadPrepareFailed = 3,
	TypeMibUpDownLoadStatus_uploadPrepareTimeout = 4,
	TypeMibUpDownLoadStatus_uploading = 5,
	TypeMibUpDownLoadStatus_uploaded = 6,
	TypeMibUpDownLoadStatus_uploadCanceled = 7,
	TypeMibUpDownLoadStatus_uploadingTimeout = 8,
	TypeMibUpDownLoadStatus_uploadingFailed = 9,
	TypeMibUpDownLoadStatus_downloadPreparing = 21,
	TypeMibUpDownLoadStatus_downloadPrepared = 22,
	TypeMibUpDownLoadStatus_downloadPrepareFailed = 23,
	TypeMibUpDownLoadStatus_downloadPrepareTimeout = 24,
	TypeMibUpDownLoadStatus_downloading = 25,
	TypeMibUpDownLoadStatus_downloaded = 26,
	TypeMibUpDownLoadStatus_downloadCanceled = 27,
	TypeMibUpDownLoadStatus_downloadingTimeout = 28,
	TypeMibUpDownLoadStatus_downloadingFailed = 29
} TypeMibUpDownLoadStatus_Tval;

typedef enum {
	PbMsspNodeState_idle[TTT] = 0,
	PbMsspNodeState_passthough = 1,
	PbMsspNodeState_switching = 2,
	PbMsspNodeState_isolated = 3
} PbMsspNodeState_Tval;

typedef enum {
	PbSNCPExCmdRslt_cmdRsltSucc[TTT] = 1,
	PbSNCPExCmdRslt_cmdRsltLowPriority = 2,
	PbSNCPExCmdRslt_cmdRsltSwithToActive = 3,
	PbSNCPExCmdRslt_cmdSwitchFail = 4,
	PbSNCPExCmdRslt_cmdSwitchTimeout = 5,
	PbSNCPExCmdRslt_cmdWaitCcRsp = 6,
	PbSNCPExCmdRslt_cmdBadCommand = 7
} PbSNCPExCmdRslt_Tval;

typedef enum {
	AlarmTypeID_spi_los[TTT] = 1,
	AlarmTypeID_rs_oof = 2,
	AlarmTypeID_rs_lof = 3,
	AlarmTypeID_rs_deg = 4,
	AlarmTypeID_rs_tim = 5,
	AlarmTypeID_rs_exc = 6,
	AlarmTypeID_rs_dcf = 7,
	AlarmTypeID_rs_tca = 8,
	AlarmTypeID_ms_rdi = 9,
	AlarmTypeID_ms_rei = 10,
	AlarmTypeID_ms_ais = 11,
	AlarmTypeID_ms_deg = 12,
	AlarmTypeID_ms_exc = 13,
	AlarmTypeID_ms_dcf = 14,
	AlarmTypeID_ms_fop = 15,
	AlarmTypeID_ms_tca = 17,
	AlarmTypeID_au_lop = 18,
	AlarmTypeID_au_ais = 19,
	AlarmTypeID_au_tca = 20,
	AlarmTypeID_hp_tim = 21,
	AlarmTypeID_hp_uneq = 22,
	AlarmTypeID_hp_rdi = 23,
	AlarmTypeID_hp_plm = 24,
	AlarmTypeID_hp_deg = 25,
	AlarmTypeID_hp_lom = 26,
	AlarmTypeID_hp_exc = 27,
	AlarmTypeID_hp_tca = 28,
	AlarmTypeID_hpv_lom = 29,
	AlarmTypeID_hpv_sqm = 30,
	AlarmTypeID_hpv_loa = 31,
	AlarmTypeID_tu_lop = 32,
	AlarmTypeID_tu_lom = 33,
	AlarmTypeID_tu_ais = 34,
	AlarmTypeID_tu_tca = 35,
	AlarmTypeID_lp_tim = 36,
	AlarmTypeID_lp_uneq = 37,
	AlarmTypeID_lp_rdi = 38,
	AlarmTypeID_lp_plm = 39,
	AlarmTypeID_lp_deg = 40,
	AlarmTypeID_lp_exc = 41,
	AlarmTypeID_lp_rfi = 42,
	AlarmTypeID_lpv_lom = 43,
	AlarmTypeID_lpv_sqm = 44,
	AlarmTypeID_lpv_loa = 45,
	AlarmTypeID_lan_los = 46,
	AlarmTypeID_lan_bbr = 47,
	AlarmTypeID_lan_bpr = 48,
	AlarmTypeID_set_lti = 49,
	AlarmTypeID_set_lto = 50,
	AlarmTypeID_set_trf = 51,
	AlarmTypeID_set_deg = 52,
	AlarmTypeID_set_ssmbm = 53,
	AlarmTypeID_env_mdi = 54,
	AlarmTypeID_env_oh = 55,
	AlarmTypeID_eqp_uf = 56,
	AlarmTypeID_eqp_ur = 57,
	AlarmTypeID_eqp_pf = 58,
	AlarmTypeID_wan_los = 59,
	AlarmTypeID_wan_bbr = 60,
	AlarmTypeID_wan_bpr = 61,
	AlarmTypeID_tc_lcd = 62,
	AlarmTypeID_vp_ais = 63,
	AlarmTypeID_vp_rdi = 64,
	AlarmTypeID_vp_loc = 65,
	AlarmTypeID_vc_ais = 66,
	AlarmTypeID_vc_rdi = 67,
	AlarmTypeID_vc_loc = 68,
	AlarmTypeID_ppi_los = 69,
	AlarmTypeID_spi_dcf = 70,
	AlarmTypeID_in_cer = 71,
	AlarmTypeID_in_clr = 72,
	AlarmTypeID_out_cer = 73,
	AlarmTypeID_out_clr = 74,
	AlarmTypeID_lp_tca = 75,
	AlarmTypeID_set_scf = 76,
	AlarmTypeID_eqp_ff = 77,
	AlarmTypeID_spi_oop_tca = 78,
	AlarmTypeID_spi_iop_tca = 79,
	AlarmTypeID_spi_lb_tca = 80,
	AlarmTypeID_spi_lt_tca = 81,
	AlarmTypeID_spi_ta = 82,
	AlarmTypeID_eqp_utm = 83,
	AlarmTypeID_spi_lcd_slow = 84,
	AlarmTypeID_spi_lcd_fast = 85,
	AlarmTypeID_hpv_csf = 86,
	AlarmTypeID_hpv_lfd = 87,
	AlarmTypeID_lpv_csf = 88,
	AlarmTypeID_lpv_lfd = 89,
	AlarmTypeID_ppi_tca = 90,
	AlarmTypeID_ppi_nslip = 91,
	AlarmTypeID_ppi_pslip = 92,
	AlarmTypeID_rs_tca_es15m = 93,
	AlarmTypeID_rs_tca_es24h = 94,
	AlarmTypeID_rs_tca_bbe15m = 95,
	AlarmTypeID_rs_tca_bbe24h = 96,
	AlarmTypeID_rs_tca_ses15m = 97,
	AlarmTypeID_rs_tca_ses24h = 98,
	AlarmTypeID_rs_tca_uas15m = 99,
	AlarmTypeID_rs_tca_uas24h = 100,
	AlarmTypeID_rs_tca_uap15m = 101,
	AlarmTypeID_rs_tca_uap24h = 102,
	AlarmTypeID_rs_tca_cses15m = 103,
	AlarmTypeID_rs_tca_cses24h = 104,
	AlarmTypeID_rs_tca_ofs15m = 105,
	AlarmTypeID_rs_tca_ofs24h = 106,
	AlarmTypeID_ms_tca_es15mn = 107,
	AlarmTypeID_ms_tca_es15mf = 108,
	AlarmTypeID_ms_tca_es24hn = 109,
	AlarmTypeID_ms_tca_es24hf = 110,
	AlarmTypeID_ms_tca_bbe15mn = 111,
	AlarmTypeID_ms_tca_bbe15mf = 112,
	AlarmTypeID_ms_tca_bbe24hn = 113,
	AlarmTypeID_ms_tca_bbe24hf = 114,
	AlarmTypeID_ms_tca_ses15mn = 115,
	AlarmTypeID_ms_tca_ses15mf = 116,
	AlarmTypeID_ms_tca_ses24hn = 117,
	AlarmTypeID_ms_tca_ses24hf = 118,
	AlarmTypeID_ms_tca_uas15mn = 119,
	AlarmTypeID_ms_tca_uas15mf = 120,
	AlarmTypeID_ms_tca_uas24hn = 121,
	AlarmTypeID_ms_tca_uas24hf = 122,
	AlarmTypeID_ms_tca_uap15mn = 123,
	AlarmTypeID_ms_tca_uap15mf = 124,
	AlarmTypeID_ms_tca_uap24hn = 125,
	AlarmTypeID_ms_tca_uap24hf = 126,
	AlarmTypeID_ms_tca_cses15mn = 127,
	AlarmTypeID_ms_tca_cses15mf = 128,
	AlarmTypeID_ms_tca_cses24hn = 129,
	AlarmTypeID_ms_tca_cses24hf = 130,
	AlarmTypeID_hp_tca_es15mn = 131,
	AlarmTypeID_hp_tca_es15mf = 132,
	AlarmTypeID_hp_tca_es24hn = 133,
	AlarmTypeID_hp_tca_es24hf = 134,
	AlarmTypeID_hp_tca_bbe15mn = 135,
	AlarmTypeID_hp_tca_bbe15mf = 136,
	AlarmTypeID_hp_tca_bbe24hn = 137,
	AlarmTypeID_hp_tca_bbe24hf = 138,
	AlarmTypeID_hp_tca_ses15mn = 139,
	AlarmTypeID_hp_tca_ses15mf = 140,
	AlarmTypeID_hp_tca_ses24hn = 141,
	AlarmTypeID_hp_tca_ses24hf = 142,
	AlarmTypeID_hp_tca_uas15mn = 143,
	AlarmTypeID_hp_tca_uas15mf = 144,
	AlarmTypeID_hp_tca_uas24hn = 145,
	AlarmTypeID_hp_tca_uas24hf = 146,
	AlarmTypeID_hp_tca_uap15mn = 147,
	AlarmTypeID_hp_tca_uap15mf = 148,
	AlarmTypeID_hp_tca_uap24hn = 149,
	AlarmTypeID_hp_tca_uap24hf = 150,
	AlarmTypeID_hp_tca_cses15mn = 151,
	AlarmTypeID_hp_tca_cses15mf = 152,
	AlarmTypeID_hp_tca_cses24hn = 153,
	AlarmTypeID_hp_tca_cses24hf = 154,
	AlarmTypeID_hp_tca_pjcp15m = 155,
	AlarmTypeID_hp_tca_pjcp24h = 156,
	AlarmTypeID_hp_tca_pjcn15m = 157,
	AlarmTypeID_hp_tca_pjcn24h = 158,
	AlarmTypeID_lp_tca_es15mn = 159,
	AlarmTypeID_lp_tca_es15mf = 160,
	AlarmTypeID_lp_tca_es24hn = 161,
	AlarmTypeID_lp_tca_es24hf = 162,
	AlarmTypeID_lp_tca_bbe15mn = 163,
	AlarmTypeID_lp_tca_bbe15mf = 164,
	AlarmTypeID_lp_tca_bbe24hn = 165,
	AlarmTypeID_lp_tca_bbe24hf = 166,
	AlarmTypeID_lp_tca_ses15mn = 167,
	AlarmTypeID_lp_tca_ses15mf = 168,
	AlarmTypeID_lp_tca_ses24hn = 169,
	AlarmTypeID_lp_tca_ses24hf = 170,
	AlarmTypeID_lp_tca_uas15mn = 171,
	AlarmTypeID_lp_tca_uas15mf = 172,
	AlarmTypeID_lp_tca_uas24hn = 173,
	AlarmTypeID_lp_tca_uas24hf = 174,
	AlarmTypeID_lp_tca_uap15mn = 175,
	AlarmTypeID_lp_tca_uap15mf = 176,
	AlarmTypeID_lp_tca_uap24hn = 177,
	AlarmTypeID_lp_tca_uap24hf = 178,
	AlarmTypeID_lp_tca_cses15mn = 179,
	AlarmTypeID_lp_tca_cses15mf = 180,
	AlarmTypeID_lp_tca_cses24hn = 181,
	AlarmTypeID_lp_tca_cses24hf = 182,
	AlarmTypeID_lp_tca_pjcp15m = 183,
	AlarmTypeID_lp_tca_pjcp24h = 184,
	AlarmTypeID_lp_tca_pjcn15m = 185,
	AlarmTypeID_lp_tca_pjcn24h = 186,
	AlarmTypeID_env_mdi1 = 187,
	AlarmTypeID_env_mdi2 = 188,
	AlarmTypeID_env_mdi3 = 189,
	AlarmTypeID_env_mdi4 = 190,
	AlarmTypeID_rpr_katoe = 191,
	AlarmTypeID_rpr_katow = 192,
	AlarmTypeID_rpr_dmac = 193,
	AlarmTypeID_rpr_eres0 = 194,
	AlarmTypeID_rpr_eres1 = 195,
	AlarmTypeID_rpr_lrnc = 196,
	AlarmTypeID_rpr_mmac = 197,
	AlarmTypeID_rpr_mstn = 198,
	AlarmTypeID_rpr_mscbe = 199,
	AlarmTypeID_rpr_mscbw = 200,
	AlarmTypeID_rpr_pmcfg = 201,
	AlarmTypeID_rpr_tpincs = 202,
	AlarmTypeID_rpr_tpinst = 203,
	AlarmTypeID_oa_tf = 211,
	AlarmTypeID_oa_los = 212,
	AlarmTypeID_oa_bias = 214,
	AlarmTypeID_oa_lth = 215,
	AlarmTypeID_eqp_mismatch = 216,
	AlarmTypeID_neg_slip_tca_15m = 217,
	AlarmTypeID_neg_slip_tca_24h = 218,
	AlarmTypeID_pos_slip_tca_15m = 219,
	AlarmTypeID_pos_slip_tca_24h = 220,
	AlarmTypeID_set_timedeg = 221,
	AlarmTypeID_sfp_failure = 222,
	AlarmTypeID_ecc1_failure = 223,
	AlarmTypeID_sfp_mismatch = 224,
	AlarmTypeID_ppi_ais = 225,
	AlarmTypeID_oa_output_power_high = 226,
	AlarmTypeID_oa_gain_high = 227,
	AlarmTypeID_ecc2_failure = 228,
	AlarmTypeID_memory_card_failure = 229,
	AlarmTypeID_ppi_lof = 230,
	AlarmTypeID_ppi_lom = 231,
	AlarmTypeID_ppi_rdi = 232,
	AlarmTypeID_hpvc_tlct = 234,
	AlarmTypeID_lpvc_tlct = 235,
	AlarmTypeID_ppi_tca_es15mn = 236,
	AlarmTypeID_ppi_tca_es15mf = 237,
	AlarmTypeID_ppi_tca_es24hn = 238,
	AlarmTypeID_ppi_tca_es24hf = 239,
	AlarmTypeID_ppi_tca_bbe15mn = 240,
	AlarmTypeID_ppi_tca_bbe15mf = 241,
	AlarmTypeID_ppi_tca_bbe24hn = 242,
	AlarmTypeID_ppi_tca_bbe24hf = 243,
	AlarmTypeID_ppi_tca_ses15mn = 244,
	AlarmTypeID_ppi_tca_ses15mf = 245,
	AlarmTypeID_ppi_tca_ses24hn = 246,
	AlarmTypeID_ppi_tca_ses24hf = 247,
	AlarmTypeID_ppi_tca_uas15mn = 248,
	AlarmTypeID_ppi_tca_uas15mf = 249,
	AlarmTypeID_ppi_tca_uas24hn = 250,
	AlarmTypeID_ppi_tca_uas24hf = 251,
	AlarmTypeID_loss_of_power_input = 253,
	AlarmTypeID_env_mdi5 = 254,
	AlarmTypeID_env_mdi6 = 255,
	AlarmTypeID_env_mdi7 = 256,
	AlarmTypeID_env_mdi8 = 257,
	AlarmTypeID_sfp_absent = 258,
	AlarmTypeID_memory_card_absent = 259,
	AlarmTypeID_oa_pf = 260,
	AlarmTypeID_sc_sw_version_mismatch = 286,
	AlarmTypeID_hcoc9_dcf = 287,
	AlarmTypeID_hcoc27_dcf = 288,
	AlarmTypeID_unsuccessful_logins_exceeded = 289,
	AlarmTypeID_log_occupancy_threshold = 290,
	AlarmTypeID_log_is_full = 291,
	AlarmTypeID_unauthorized_access = 292,
	AlarmTypeID_communication_failure = 293,
	AlarmTypeID_no_free_low_order_capacity = 294,
	AlarmTypeID_low_order_capacity_mismatch = 295,
	AlarmTypeID_pll_unlock = 296,
	AlarmTypeID_account_expired_disabled = 297,
	AlarmTypeID_vcxo_failure = 298,
	AlarmTypeID_eq_fal = 299,
	AlarmTypeID_tr_cim = 300,
	AlarmTypeID_otu_lfa = 301,
	AlarmTypeID_otu_lma = 302,
	AlarmTypeID_sm_tim = 303,
	AlarmTypeID_sm_iae = 304,
	AlarmTypeID_sm_bdi = 305,
	AlarmTypeID_opu_ptm = 306,
	AlarmTypeID_loss_of_optical_input = 307,
	AlarmTypeID_ld_fail = 308,
	AlarmTypeID_optical_output_fail = 309,
	AlarmTypeID_wavelength_control = 310,
	AlarmTypeID_dcn_2m_los = 311,
	AlarmTypeID_flash_util_over = 312,
	AlarmTypeID_cfcard_util_over = 313,
	AlarmTypeID_signal_error_fail = 314,
	AlarmTypeID_latch_open = 315,
	AlarmTypeID_otu_deg = 316,
	AlarmTypeID_odu2_loflom = 317,
	AlarmTypeID_odu2_ais = 318,
	AlarmTypeID_odu2_lck = 319,
	AlarmTypeID_odu2_oci = 320,
	AlarmTypeID_odu2_tim = 321,
	AlarmTypeID_odu2_bdi = 322,
	AlarmTypeID_odu2_deg = 323,
	AlarmTypeID_odu2_plm = 324,
	AlarmTypeID_odu2_msim = 325,
	AlarmTypeID_odu1_loflom = 326,
	AlarmTypeID_odu1_ais = 327,
	AlarmTypeID_odu1_lck = 328,
	AlarmTypeID_odu1_oci = 329,
	AlarmTypeID_odu1_tim = 330,
	AlarmTypeID_odu1_bdi = 331,
	AlarmTypeID_odu1_deg = 332,
	AlarmTypeID_odu1_plm = 333,
	AlarmTypeID_hpvc_plct = 334,
	AlarmTypeID_lpvc_plct = 335,
	AlarmTypeID_hpvc_plcr = 336,
	AlarmTypeID_lpvc_plcr = 337,
	AlarmTypeID_eqp_fan_failure = 338
} AlarmTypeID_Tval;

typedef enum {
	RprXcCapacity_vc11[TTT] = 1,
	RprXcCapacity_vc12 = 2,
	RprXcCapacity_vc2 = 3,
	RprXcCapacity_vc3 = 4,
	RprXcCapacity_vc4 = 5,
	RprXcCapacity_vc44c = 6,
	RprXcCapacity_vc416c = 7,
	RprXcCapacity_vc464c = 8,
	RprXcCapacity_e1 = 9
} RprXcCapacity_Tval;

typedef enum {
	PbTimeZone_eniwetok[TTT] = 0,
	PbTimeZone_midwayIsland = 1,
	PbTimeZone_hawaii = 2,
	PbTimeZone_alaska = 3,
	PbTimeZone_pacificTime = 4,
	PbTimeZone_arizona = 5,
	PbTimeZone_mountainTime = 10,
	PbTimeZone_centralAmerica = 15,
	PbTimeZone_centralTime = 20,
	PbTimeZone_mexico = 25,
	PbTimeZone_saskatchewan = 30,
	PbTimeZone_bogota = 35,
	PbTimeZone_easternTime = 40,
	PbTimeZone_indiana = 45,
	PbTimeZone_atlantic = 50,
	PbTimeZone_caracas = 55,
	PbTimeZone_santiago = 56,
	PbTimeZone_newfoundland = 60,
	PbTimeZone_brasilia = 65,
	PbTimeZone_buenosAires = 70,
	PbTimeZone_greenland = 73,
	PbTimeZone_midAtlantic = 75,
	PbTimeZone_azores = 80,
	PbTimeZone_capeVerdeIslands = 83,
	PbTimeZone_casablanca = 85,
	PbTimeZone_greenwich = 90,
	PbTimeZone_amsterdam = 95,
	PbTimeZone_belgrade = 100,
	PbTimeZone_brussels = 105,
	PbTimeZone_sarajevo = 110,
	PbTimeZone_westCentralAfrica = 115,
	PbTimeZone_athens = 120,
	PbTimeZone_bucharest = 125,
	PbTimeZone_cairo = 130,
	PbTimeZone_harare = 135,
	PbTimeZone_helsinki = 140,
	PbTimeZone_jerusalem = 145,
	PbTimeZone_baghdad = 150,
	PbTimeZone_kuwait = 155,
	PbTimeZone_moscow = 158,
	PbTimeZone_nairobi = 160,
	PbTimeZone_tehran = 165,
	PbTimeZone_abuDhabi = 170,
	PbTimeZone_baku = 175,
	PbTimeZone_kabul = 180,
	PbTimeZone_ekaterinburg = 185,
	PbTimeZone_islamabad = 190,
	PbTimeZone_calcutta = 195,
	PbTimeZone_kathmandu = 198,
	PbTimeZone_almaty = 200,
	PbTimeZone_astana = 201,
	PbTimeZone_sri = 202,
	PbTimeZone_rangoony = 205,
	PbTimeZone_bangkok = 207,
	PbTimeZone_krasnoyarsk = 208,
	PbTimeZone_beijing = 210,
	PbTimeZone_irkutsk = 212,
	PbTimeZone_kualaLumpur = 215,
	PbTimeZone_perth = 220,
	PbTimeZone_taipei = 225,
	PbTimeZone_osaka = 230,
	PbTimeZone_seoulr = 235,
	PbTimeZone_yakutsk = 240,
	PbTimeZone_adelaidei = 245,
	PbTimeZone_darwin = 250,
	PbTimeZone_brisbane = 255,
	PbTimeZone_canberra = 260,
	PbTimeZone_guam = 265,
	PbTimeZone_hobart = 270,
	PbTimeZone_vladivostok = 275,
	PbTimeZone_magadan = 280,
	PbTimeZone_auckland = 285,
	PbTimeZone_fujiIslands = 290,
	PbTimeZone_nuku = 300
} PbTimeZone_Tval;

typedef enum {
	PbSecondaryStatus_none[TTT] = 1,
	PbSecondaryStatus_bsl_down = 2,
	PbSecondaryStatus_bsl_adminDown = 3,
	PbSecondaryStatus_bsl_HW_adminDown = 4,
	PbSecondaryStatus_bsl_HW_adminTest = 5,
	PbSecondaryStatus_bsl_HW_down = 6,
	PbSecondaryStatus_bsl_notPresent = 7,
	PbSecondaryStatus_sl_adminDown = 8,
	PbSecondaryStatus_sl_adminTest = 9,
	PbSecondaryStatus_hw_adminDown = 10,
	PbSecondaryStatus_hw_adminTest = 11,
	PbSecondaryStatus_hw_down = 12,
	PbSecondaryStatus_nc_HW_removed = 13,
	PbSecondaryStatus_nc_HW_adminDown = 14,
	PbSecondaryStatus_nc_HW_adminTest = 15,
	PbSecondaryStatus_nc_HW_down = 16,
	PbSecondaryStatus_nc_SL_adminDown = 17,
	PbSecondaryStatus_nc_SL_adminTest = 18,
	PbSecondaryStatus_nc_SL_down = 19,
	PbSecondaryStatus_nc_funcAdminDown = 20,
	PbSecondaryStatus_hw_inactive = 21
} PbSecondaryStatus_Tval;

typedef enum {
	PbLatchState_on[TTT] = 1,
	PbLatchState_off = 2
} PbLatchState_Tval;

typedef enum {
	PbTMSOutState_normal[TTT] = 0,
	PbTMSOutState_ais = 1,
	PbTMSOutState_dnu = 2,
	PbTMSOutState_shutdown = 3,
	PbTMSOutState_na = 4
} PbTMSOutState_Tval;

typedef enum {
	RprProtectionStatus_noRequest[TTT] = 1,
	RprProtectionStatus_waitToRestore = 2,
	RprProtectionStatus_manualSwitch = 4,
	RprProtectionStatus_signalDegraded = 8,
	RprProtectionStatus_signalFailed = 16,
	RprProtectionStatus_forcedSwitch = 32
} RprProtectionStatus_Tval;

typedef enum {
	PbSlotNumberType_none[TTT] = 0,
	PbSlotNumberType_lc1 = 1,
	PbSlotNumberType_lc2 = 2,
	PbSlotNumberType_lc3 = 3,
	PbSlotNumberType_lc4 = 4,
	PbSlotNumberType_lc5 = 5,
	PbSlotNumberType_lc6 = 6,
	PbSlotNumberType_hocc1 = 7,
	PbSlotNumberType_hocc2 = 8,
	PbSlotNumberType_sfc1 = 9,
	PbSlotNumberType_sfc2 = 10,
	PbSlotNumberType_ce1 = 11,
	PbSlotNumberType_ce2 = 12,
	PbSlotNumberType_ce3 = 13,
	PbSlotNumberType_ce4 = 14,
	PbSlotNumberType_ce5 = 15,
	PbSlotNumberType_ce6 = 16,
	PbSlotNumberType_sc1 = 17,
	PbSlotNumberType_sc2 = 18,
	PbSlotNumberType_si = 19,
	PbSlotNumberType_sfm1 = 20,
	PbSlotNumberType_sfm2 = 21,
	PbSlotNumberType_io1 = 22,
	PbSlotNumberType_io2 = 23,
	PbSlotNumberType_io3 = 24,
	PbSlotNumberType_io4 = 25,
	PbSlotNumberType_io5 = 26,
	PbSlotNumberType_io6 = 27,
	PbSlotNumberType_io7 = 28,
	PbSlotNumberType_io8 = 29,
	PbSlotNumberType_io9 = 30,
	PbSlotNumberType_io10 = 31,
	PbSlotNumberType_io11 = 32,
	PbSlotNumberType_io12 = 33,
	PbSlotNumberType_io13 = 34,
	PbSlotNumberType_io14 = 35,
	PbSlotNumberType_io15 = 36,
	PbSlotNumberType_power1 = 37,
	PbSlotNumberType_power2 = 38,
	PbSlotNumberType_fan1 = 39,
	PbSlotNumberType_fan2 = 40
} PbSlotNumberType_Tval;

typedef enum {
	PbMsspNodeSide_west[TTT] = 0,
	PbMsspNodeSide_east = 1
} PbMsspNodeSide_Tval;

typedef enum {
	PbSNCPChannelState_active[TTT] = 1,
	PbSNCPChannelState_standby = 2
} PbSNCPChannelState_Tval;

typedef enum {
	SdhFtpCmndLastState_notApplicable[TTT] = 1,
	SdhFtpCmndLastState_success = 2,
	SdhFtpCmndLastState_failed = 3,
	SdhFtpCmndLastState_inProgress = 4
} SdhFtpCmndLastState_Tval;

typedef enum {
	PbLinkGeneralType_networkLink[TTT] = 1,
	PbLinkGeneralType_offNetworkLink = 2
} PbLinkGeneralType_Tval;

typedef enum {
	PbBoardFunction_none[TTT] = 0,
	PbBoardFunction_empty = 1,
	PbBoardFunction_main = 2305,
	PbBoardFunction_hocc = 2306,
	PbBoardFunction_locc = 2307,
	PbBoardFunction_e1x126 = 2308,
	PbBoardFunction_e1x63 = 2309,
	PbBoardFunction_stm_1ex8 = 2310,
	PbBoardFunction_e3ds3x12 = 2312,
	PbBoardFunction_stm_41x8 = 2320,
	PbBoardFunction_stm_1x8 = 2321,
	PbBoardFunction_stm_16x4 = 2322,
	PbBoardFunction_stm_16x8 = 2323,
	PbBoardFunction_e3ds3px12 = 2324,
	PbBoardFunction_stm_64x2 = 2325,
	PbBoardFunction_stm_64x1 = 2326,
	PbBoardFunction_oaBooster13dbm = 2336,
	PbBoardFunction_oaBooster15dbm = 2337,
	PbBoardFunction_oaBooster18dbm = 2338,
	PbBoardFunction_oaPreamp20db = 2340,
	PbBoardFunction_tengetx1 = 2342,
	PbBoardFunction_tengetx1_geax46 = 2343,
	PbBoardFunction_getx8 = 2344,
	PbBoardFunction_gex6_fegeax4 = 2345,
	PbBoardFunction_gex2_ferprx12 = 2352,
	PbBoardFunction_gex4_feax12 = 2353,
	PbBoardFunction_fetx12 = 2354,
	PbBoardFunction_fc2gx8 = 2355,
	PbBoardFunction_stm_256x1 = 2357,
	PbBoardFunction_fan = 2358,
	PbBoardFunction_si_without_eow = 2368,
	PbBoardFunction_stm_16x2 = 2369,
	PbBoardFunction_otu_2x1 = 2400,
	PbBoardFunction_tengex1_gex10l2 = 2440,
	PbBoardFunction_stm_16x8m = 2441,
	PbBoardFunction_stm_41x16m = 2448,
	PbBoardFunction_stm_64x2m = 2449,
	PbBoardFunction_otu_2x2 = 2450,
	PbBoardFunction_chassis = 4232,
	PbBoardFunction_cc = 4240,
	PbBoardFunction_dataFabric_controller = 4241,
	PbBoardFunction_dataFabric = 4242,
	PbBoardFunction_si = 4243,
	PbBoardFunction_power = 4244,
	PbBoardFunction_chassis_fan_airFilter = 4245,
	PbBoardFunction_fanTray = 4246,
	PbBoardFunction_fanCircuitBoard = 4247,
	PbBoardFunction_backplane = 4248,
	PbBoardFunction_e1x21p_75 = 4352,
	PbBoardFunction_e1x21p_120 = 4353,
	PbBoardFunction_stm_1ex16 = 4354,
	PbBoardFunction_stm_1ex8p = 4356,
	PbBoardFunction_e3ds3x6p = 4358,
	PbBoardFunction_gex20 = 4359,
	PbBoardFunction_tengex2 = 4360,
	PbBoardFunction_gex10_eos = 4361,
	PbBoardFunction_tengex2_eos = 4368,
	PbBoardFunction_gmpls_load = 983040
} PbBoardFunction_Tval;

typedef enum {
	PbYesNo_yes[TTT] = 1,
	PbYesNo_no = 2
} PbYesNo_Tval;

typedef enum {
	PBMSPSignalState_signalunknown[TTT] = 0,
	PBMSPSignalState_signalfailhigh = 1,
	PBMSPSignalState_signalfaillow = 2,
	PBMSPSignalState_signaldeglhigh = 3,
	PBMSPSignalState_signaldeglow = 4,
	PBMSPSignalState_signalnormal = 5
} PBMSPSignalState_Tval;

typedef enum {
	PbMSPSignalDirection_unidirection[TTT] = 1,
	PbMSPSignalDirection_bidirection = 2
} PbMSPSignalDirection_Tval;

typedef enum {
	PbEpgCmdResult_ok[TTT] = 0,
	PbEpgCmdResult_failed = 1
} PbEpgCmdResult_Tval;

typedef enum {
	TMSIfSdhQlType_sdh[TTT] = 1,
	TMSIfSdhQlType_sonet = 2
} TMSIfSdhQlType_Tval;

typedef enum {
	PbChassisType_mw863[TTT] = 1,
	PbChassisType_mw808 = 2,
	PbChassisType_mw8100 = 3,
	PbChassisType_mw801 = 4,
	PbChassisType_hiT7035 = 5,
	PbChassisType_hiT7080 = 7,
	PbChassisType_hiT7065 = 8,
	PbChassisType_all = 255
} PbChassisType_Tval;

typedef enum {
	PbMsspSwStatus_idle[TTT] = 0,
	PbMsspSwStatus_bridge = 1,
	PbMsspSwStatus_bridgeAndSwitch = 2,
	PbMsspSwStatus_passthough = 3
} PbMsspSwStatus_Tval;

typedef enum {
	PbTMSQl_inv0[TTT] = 0,
	PbTMSQl_inv1 = 1,
	PbTMSQl_prc = 2,
	PbTMSQl_inv3 = 3,
	PbTMSQl_ssut = 4,
	PbTMSQl_inv5 = 5,
	PbTMSQl_inv6 = 6,
	PbTMSQl_inv7 = 7,
	PbTMSQl_ssul = 8,
	PbTMSQl_inv9 = 9,
	PbTMSQl_inv10 = 10,
	PbTMSQl_sec = 11,
	PbTMSQl_inv12 = 12,
	PbTMSQl_inv13 = 13,
	PbTMSQl_inv14 = 14,
	PbTMSQl_dnu = 15,
	PbTMSQl_failed = 16,
	PbTMSQl_nsupp = 17,
	PbTMSQl_unc = 18
} PbTMSQl_Tval;

typedef enum {
	TypeMibUpgFailedIndex_noError[TTT] = 0,
	TypeMibUpgFailedIndex_unKnown = 1,
	TypeMibUpgFailedIndex_writeFlashFailed = 2,
	TypeMibUpgFailedIndex_readFlashFailed = 3,
	TypeMibUpgFailedIndex_flashFull = 4,
	TypeMibUpgFailedIndex_flashError = 5,
	TypeMibUpgFailedIndex_writeCfFailed = 6,
	TypeMibUpgFailedIndex_readCfFailed = 7,
	TypeMibUpgFailedIndex_cfFull = 8,
	TypeMibUpgFailedIndex_cfError = 9,
	TypeMibUpgFailedIndex_copyAscFlashFailed = 10,
	TypeMibUpgFailedIndex_copyAscCfFailed = 11,
	TypeMibUpgFailedIndex_copySscFlashFailed = 12,
	TypeMibUpgFailedIndex_copySscCfFailed = 13,
	TypeMibUpgFailedIndex_spawnTaskFailed = 14,
	TypeMibUpgFailedIndex_paraInvalid = 15,
	TypeMibUpgFailedIndex_writeRamdscFailed = 16,
	TypeMibUpgFailedIndex_readRamdscFailed = 17,
	TypeMibUpgFailedIndex_setMibFailed = 18,
	TypeMibUpgFailedIndex_getMibFailed = 19,
	TypeMibUpgFailedIndex_openDirFailed = 20,
	TypeMibUpgFailedIndex_createDirFailed = 21,
	TypeMibUpgFailedIndex_peerScOnline = 22,
	TypeMibUpgFailedIndex_peerScOffline = 23,
	TypeMibUpgFailedIndex_synRamdscFailed = 24,
	TypeMibUpgFailedIndex_synFlashFailed = 25,
	TypeMibUpgFailedIndex_synCfFailed = 26,
	TypeMibUpgFailedIndex_msgCreateFailed = 27,
	TypeMibUpgFailedIndex_msgSendFailed = 28,
	TypeMibUpgFailedIndex_cmndStatusInvalid = 29,
	TypeMibUpgFailedIndex_sscCopyTimeout = 30,
	TypeMibUpgFailedIndex_createSemFailed = 31,
	TypeMibUpgFailedIndex_mibHeadFileInvalid = 32,
	TypeMibUpgFailedIndex_mibNeFileCheckSumInvalid = 33,
	TypeMibUpgFailedIndex_mibGmFileCheckSumInvalid = 34,
	TypeMibUpgFailedIndex_lcsFileInvalid = 35,
	TypeMibUpgFailedIndex_dirCopyFailed = 36,
	TypeMibUpgFailedIndex_dirDelFailed = 37,
	TypeMibUpgFailedIndex_zipFileNotExist = 38,
	TypeMibUpgFailedIndex_tarFileFailed = 39,
	TypeMibUpgFailedIndex_zipFileFailed = 40,
	TypeMibUpgFailedIndex_unzipFileFailed = 41,
	TypeMibUpgFailedIndex_gsemTakeFailed = 42,
	TypeMibUpgFailedIndex_gSaveFlagSetFailed = 43,
	TypeMibUpgFailedIndex_dirRnameLoadTmpFailed = 44,
	TypeMibUpgFailedIndex_dirRnameTmpLoadFailed = 45,
	TypeMibUpgFailedIndex_dirRnameTmpBkupFailed = 46,
	TypeMibUpgFailedIndex_dirRnameBkupActFailed = 47,
	TypeMibUpgFailedIndex_mibIncSaveFailed = 48,
	TypeMibUpgFailedIndex_mibAllSaveFailed = 49,
	TypeMibUpgFailedIndex_mibSaveSwitchSetFailed = 50,
	TypeMibUpgFailedIndex_scSwitch = 51,
	TypeMibUpgFailedIndex_upgCommandRunning = 52,
	TypeMibUpgFailedIndex_cfaSoftCopying = 53,
	TypeMibUpgFailedIndex_psmMibCheckingFuncInvalid = 54,
	TypeMibUpgFailedIndex_lcmMibCheckingFuncInvalid = 55,
	TypeMibUpgFailedIndex_globleHeadFileInvalid = 56,
	TypeMibUpgFailedIndex_neHeadfileFlagSetFailed = 57,
	TypeMibUpgFailedIndex_psmHeadfileFlagSetFailed = 58,
	TypeMibUpgFailedIndex_uploadPrepareTimeout = 71,
	TypeMibUpgFailedIndex_uploadPrepareFailed = 72,
	TypeMibUpgFailedIndex_uploadMidTimeout = 73,
	TypeMibUpgFailedIndex_uploadMidFailed = 74,
	TypeMibUpgFailedIndex_uploadCanceled = 75,
	TypeMibUpgFailedIndex_downloadPrepareTimeout = 81,
	TypeMibUpgFailedIndex_downloadPrepareFailed = 82,
	TypeMibUpgFailedIndex_downloadMidTimeout = 83,
	TypeMibUpgFailedIndex_downloadMidFailed = 84,
	TypeMibUpgFailedIndex_downloadCanceled = 85,
	TypeMibUpgFailedIndex_switchAscTimeout = 91,
	TypeMibUpgFailedIndex_switchAscFailed = 92,
	TypeMibUpgFailedIndex_switchAscCfFailed = 93,
	TypeMibUpgFailedIndex_synTimeout = 101,
	TypeMibUpgFailedIndex_synCanceled = 102,
	TypeMibUpgFailedIndex_synFailed = 103,
	TypeMibUpgFailedIndex_clearTimeout = 111,
	TypeMibUpgFailedIndex_clearFailed = 112,
	TypeMibUpgFailedIndex_ascMibClearSetFailed = 113,
	TypeMibUpgFailedIndex_sscMibClearSetFailed = 114,
	TypeMibUpgFailedIndex_mibCopyTimeout = 121,
	TypeMibUpgFailedIndex_mibCopyFailed = 122,
	TypeMibUpgFailedIndex_gmplsCopyFailed = 123,
	TypeMibUpgFailedIndex_lcsynTimeout = 131,
	TypeMibUpgFailedIndex_lcsSynFailed = 132,
	TypeMibUpgFailedIndex_lcsDownTimeout = 141,
	TypeMibUpgFailedIndex_lcsDownFailed = 142
} TypeMibUpgFailedIndex_Tval;

typedef enum {
	PBSNCPAction_normal[TTT] = 0,
	PBSNCPAction_recfgw = 1,
	PBSNCPAction_recfgp = 2,
	PBSNCPAction_setmib = 3
} PBSNCPAction_Tval;

typedef enum {
	PBMSPType_msponevsn[TTT] = 1,
	PBMSPType_msponeplusone = 2
} PBMSPType_Tval;

typedef enum {
	PbAlmClassType_ne[TTT] = 1,
	PbAlmClassType_slot = 2,
	PbAlmClassType_port = 3,
	PbAlmClassType_tp = 4
} PbAlmClassType_Tval;

typedef enum {
	RprSvcStatus_ok[TTT] = 0,
	RprSvcStatus_failed = 1,
	RprSvcStatus_removed = 2
} RprSvcStatus_Tval;

typedef enum {
	PbLowHigh_low[TTT] = 1,
	PbLowHigh_high = 2
} PbLowHigh_Tval;

typedef enum {
	PBSNCPSignalState_normal[TTT] = 1,
	PBSNCPSignalState_failed = 2,
	PBSNCPSignalState_degard = 3
} PBSNCPSignalState_Tval;

typedef enum {
	PbSNCPSignalDirection_source[TTT] = 1,
	PbSNCPSignalDirection_sink = 2
} PbSNCPSignalDirection_Tval;

typedef enum {
	PbCircuitDirection_bidirection[TTT] = 1,
	PbCircuitDirection_unidirection = 2,
	PbCircuitDirection_multicast = 3
} PbCircuitDirection_Tval;

typedef enum {
	RprRingType_closedRing[TTT] = 1,
	RprRingType_openRing = 2
} RprRingType_Tval;

typedef enum {
	RprOamRinglet_default[TTT] = 1,
	RprOamRinglet_ringlet0 = 2,
	RprOamRinglet_ringlet1 = 3,
	RprOamRinglet_reverseRinglet = 4
} RprOamRinglet_Tval;

typedef enum {
	PbColdRebootNodeState_false[TTT] = 0,
	PbColdRebootNodeState_truewithfpga = 1,
	PbColdRebootNodeState_truewithoutfpga = 2
} PbColdRebootNodeState_Tval;

typedef enum {
	RprServiceType_p2p[TTT] = 1,
	RprServiceType_mp2mp = 2,
	RprServiceType_local = 3
} RprServiceType_Tval;

typedef enum {
	TypeSoftUpgFailedIndex_noError[TTT] = 0,
	TypeSoftUpgFailedIndex_unKnown = 1,
	TypeSoftUpgFailedIndex_commandTimeout = 2,
	TypeSoftUpgFailedIndex_wrongNodeType = 3,
	TypeSoftUpgFailedIndex_redunLoadError = 4,
	TypeSoftUpgFailedIndex_writeFlashFailed = 5,
	TypeSoftUpgFailedIndex_readFlashFailed = 6,
	TypeSoftUpgFailedIndex_flashFull = 7,
	TypeSoftUpgFailedIndex_flashError = 8,
	TypeSoftUpgFailedIndex_writeCfFailed = 9,
	TypeSoftUpgFailedIndex_readCfFailed = 10,
	TypeSoftUpgFailedIndex_cfFull = 11,
	TypeSoftUpgFailedIndex_cfError = 12,
	TypeSoftUpgFailedIndex_copyAscFlashFailed = 13,
	TypeSoftUpgFailedIndex_copyAscCfFailed = 14,
	TypeSoftUpgFailedIndex_copySscFlashFailed = 15,
	TypeSoftUpgFailedIndex_copySscCfFailed = 16,
	TypeSoftUpgFailedIndex_spawnTaskFailed = 17,
	TypeSoftUpgFailedIndex_parameterInvalid = 18,
	TypeSoftUpgFailedIndex_writeRamdscFailed = 19,
	TypeSoftUpgFailedIndex_readRamdscFailed = 20,
	TypeSoftUpgFailedIndex_setUpgMibFailed = 21,
	TypeSoftUpgFailedIndex_getUpgMibFailed = 22,
	TypeSoftUpgFailedIndex_openUpgDirFailed = 23,
	TypeSoftUpgFailedIndex_createUpgDirFailed = 24,
	TypeSoftUpgFailedIndex_peerScOnline = 25,
	TypeSoftUpgFailedIndex_peerScOffline = 26,
	TypeSoftUpgFailedIndex_synRamdscFailed = 27,
	TypeSoftUpgFailedIndex_synFlashFailed = 28,
	TypeSoftUpgFailedIndex_synCfFailed = 29,
	TypeSoftUpgFailedIndex_msgCreateFailed = 30,
	TypeSoftUpgFailedIndex_msgSendFailed = 31,
	TypeSoftUpgFailedIndex_cmndStatusInvalid = 32,
	TypeSoftUpgFailedIndex_sscCopyTimeout = 33,
	TypeSoftUpgFailedIndex_softInvalid = 34,
	TypeSoftUpgFailedIndex_downRamFailed = 35,
	TypeSoftUpgFailedIndex_downCfFailed = 36,
	TypeSoftUpgFailedIndex_dirRnameLoadTmpFailed = 37,
	TypeSoftUpgFailedIndex_dirRnameTmpLoadFailed = 38,
	TypeSoftUpgFailedIndex_dirRnameTmpBkupFailed = 39,
	TypeSoftUpgFailedIndex_dirRnameBkupActFailed = 40,
	TypeSoftUpgFailedIndex_cfUnSurported = 41,
	TypeSoftUpgFailedIndex_ramUnSurported = 42,
	TypeSoftUpgFailedIndex_delDirFailed = 43,
	TypeSoftUpgFailedIndex_copyDirFailed = 44,
	TypeSoftUpgFailedIndex_copyFileFailed = 45,
	TypeSoftUpgFailedIndex_openFileFailed = 46,
	TypeSoftUpgFailedIndex_scSwitch = 47,
	TypeSoftUpgFailedIndex_srootFileInvalid = 48,
	TypeSoftUpgFailedIndex_crootFileInvalid = 49,
	TypeSoftUpgFailedIndex_lrootFileInvalid = 50,
	TypeSoftUpgFailedIndex_addHostServerFailed = 51,
	TypeSoftUpgFailedIndex_delHostServerFailed = 52,
	TypeSoftUpgFailedIndex_dirNameParseFailed = 53,
	TypeSoftUpgFailedIndex_softVersionInvalid = 54,
	TypeSoftUpgFailedIndex_createConnectFailed = 55,
	TypeSoftUpgFailedIndex_openDataPipeFailed = 56,
	TypeSoftUpgFailedIndex_headFileStructureInvalid = 57,
	TypeSoftUpgFailedIndex_fileTypeInvalid = 58,
	TypeSoftUpgFailedIndex_getReleaseDataFailed = 59,
	TypeSoftUpgFailedIndex_diskStatusInvalid = 60,
	TypeSoftUpgFailedIndex_diskSpaceNotEnough = 61,
	TypeSoftUpgFailedIndex_getFileSizeFailed = 62,
	TypeSoftUpgFailedIndex_createFileFailed = 63,
	TypeSoftUpgFailedIndex_writeFileFailed = 64,
	TypeSoftUpgFailedIndex_fileWithoutCrc = 65,
	TypeSoftUpgFailedIndex_getFileNameFailed = 66,
	TypeSoftUpgFailedIndex_crcBufferInvalid = 67,
	TypeSoftUpgFailedIndex_crcChecksumInvalid = 68,
	TypeSoftUpgFailedIndex_extractFileFailed = 69,
	TypeSoftUpgFailedIndex_getTransDataFailed = 70,
	TypeSoftUpgFailedIndex_writeTransDataFailed = 71,
	TypeSoftUpgFailedIndex_mfmCommandRunning = 72,
	TypeSoftUpgFailedIndex_cfaSoftCopying = 73,
	TypeSoftUpgFailedIndex_versionQueryFailed = 74,
	TypeSoftUpgFailedIndex_fileNotExiste = 75,
	TypeSoftUpgFailedIndex_ftpConnectionFailed = 101,
	TypeSoftUpgFailedIndex_ftpConnectionTimeout = 102,
	TypeSoftUpgFailedIndex_downloadTimeout = 103,
	TypeSoftUpgFailedIndex_downloadCanceled = 104,
	TypeSoftUpgFailedIndex_downloadFailed = 105,
	TypeSoftUpgFailedIndex_backupTimeout = 111,
	TypeSoftUpgFailedIndex_backupCanceled = 112,
	TypeSoftUpgFailedIndex_backupFailed = 113,
	TypeSoftUpgFailedIndex_synchronizeTimeout = 121,
	TypeSoftUpgFailedIndex_synchronizeCanceled = 122,
	TypeSoftUpgFailedIndex_synchronizeFailed = 123,
	TypeSoftUpgFailedIndex_switchTimeout = 131,
	TypeSoftUpgFailedIndex_switchFailed = 132,
	TypeSoftUpgFailedIndex_switchCfFailed = 133
} TypeSoftUpgFailedIndex_Tval;

typedef enum {
	PbEpgSwitchRequest_clear[TTT] = 1,
	PbEpgSwitchRequest_lp = 2,
	PbEpgSwitchRequest_fs_w = 3,
	PbEpgSwitchRequest_fs_p = 4,
	PbEpgSwitchRequest_uf_p = 5,
	PbEpgSwitchRequest_uf_w = 6,
	PbEpgSwitchRequest_lis_w = 7,
	PbEpgSwitchRequest_lis_p = 8,
	PbEpgSwitchRequest_ms_w = 9,
	PbEpgSwitchRequest_ms_p = 10,
	PbEpgSwitchRequest_wtr = 11,
	PbEpgSwitchRequest_nr = 12
} PbEpgSwitchRequest_Tval;

typedef enum {
	PbTMSStClkType_twoMHz[TTT] = 1,
	PbTMSStClkType_twoMbUnFramed = 2,
	PbTMSStClkType_twoMbFramed = 3
} PbTMSStClkType_Tval;

typedef enum {
	PbInSignalType_normal[TTT] = 1,
	PbInSignalType_ais = 3
} PbInSignalType_Tval;

typedef enum {
	PbGmplsSncpDirection_forward[TTT] = 1,
	PbGmplsSncpDirection_reverse = 2
} PbGmplsSncpDirection_Tval;

typedef enum {
	RprServiceCos_classC[TTT] = 0,
	RprServiceCos_classBEir = 1,
	RprServiceCos_classBCir = 2,
	RprServiceCos_classA = 3
} RprServiceCos_Tval;

typedef enum {
	AlarmCategory_communication[TTT] = 1,
	AlarmCategory_qos = 2,
	AlarmCategory_equipment = 3,
	AlarmCategory_processerror = 4,
	AlarmCategory_environment = 5,
	AlarmCategory_security = 6
} AlarmCategory_Tval;

typedef enum {
	RprXcRowStatus_free[TTT] = 0,
	RprXcRowStatus_used = 1
} RprXcRowStatus_Tval;

typedef enum {
	PbUsageStatus_free[TTT] = 0,
	PbUsageStatus_sdh_occupied = 1,
	PbUsageStatus_pdh_data_occupied = 2,
	PbUsageStatus_gmpls_reserved = 3,
	PbUsageStatus_unavailable = 4
} PbUsageStatus_Tval;

typedef enum {
	PbBoardStyle_empty[TTT] = 0,
	PbBoardStyle_unknown = 1,
	PbBoardStyle_main = 2305,
	PbBoardStyle_hocc = 2306,
	PbBoardStyle_locc_pmc = 2307,
	PbBoardStyle_e1x126 = 2308,
	PbBoardStyle_e1px63 = 2309,
	PbBoardStyle_stm_1ex8 = 2310,
	PbBoardStyle_e3ds3x12 = 2312,
	PbBoardStyle_stm_41x8 = 2320,
	PbBoardStyle_stm_1x8 = 2321,
	PbBoardStyle_stm_16x4 = 2322,
	PbBoardStyle_stm_16x8 = 2323,
	PbBoardStyle_e3ds3px12 = 2324,
	PbBoardStyle_stm_64x2 = 2325,
	PbBoardStyle_stm_64x1 = 2326,
	PbBoardStyle_oaBooster13dbm = 2336,
	PbBoardStyle_oaBooster15dbm = 2337,
	PbBoardStyle_oaBooster18dbm = 2338,
	PbBoardStyle_oaPreamp20db = 2340,
	PbBoardStyle_tengetx1 = 2342,
	PbBoardStyle_tengetx1_geax46 = 2343,
	PbBoardStyle_getx8 = 2344,
	PbBoardStyle_gex6_fegeax4 = 2345,
	PbBoardStyle_gex2_ferprx12 = 2352,
	PbBoardStyle_gex4_feax12 = 2353,
	PbBoardStyle_fetx12 = 2354,
	PbBoardStyle_fc2gx8 = 2355,
	PbBoardStyle_locc = 2356,
	PbBoardStyle_stm_256x1 = 2357,
	PbBoardStyle_fan = 2358,
	PbBoardStyle_si_without_eow = 2368,
	PbBoardStyle_stm_16x2 = 2369,
	PbBoardStyle_otu_2x1 = 2400,
	PbBoardStyle_tengex1_gex10l2 = 2440,
	PbBoardStyle_stm_16x8m = 2441,
	PbBoardStyle_stm_41x16m = 2448,
	PbBoardStyle_stm_64x2m = 2449,
	PbBoardStyle_otu_2x2 = 2450,
	PbBoardStyle_chassis = 4232,
	PbBoardStyle_cc = 4240,
	PbBoardStyle_dataFabric_controller = 4241,
	PbBoardStyle_dataFabric = 4242,
	PbBoardStyle_si = 4243,
	PbBoardStyle_power = 4244,
	PbBoardStyle_chassis_fan_airFilter = 4245,
	PbBoardStyle_fanTray = 4246,
	PbBoardStyle_fanCircuitBoard = 4247,
	PbBoardStyle_backplane = 4248,
	PbBoardStyle_e1x21p_75 = 4352,
	PbBoardStyle_e1x21p_120 = 4353,
	PbBoardStyle_stm_1ex16 = 4354,
	PbBoardStyle_stm_1ex8p = 4356,
	PbBoardStyle_e3ds3x6p = 4358,
	PbBoardStyle_gex20 = 4359,
	PbBoardStyle_tengex2 = 4360,
	PbBoardStyle_gex10_eos = 4361,
	PbBoardStyle_tengex2_eos = 4368,
	PbBoardStyle_gmpls_load = 983040
} PbBoardStyle_Tval;

typedef enum {
	TypeUpgradeCmnd_inactive[TTT] = 0,
	TypeUpgradeCmnd_activeScDownload = 1,
	TypeUpgradeCmnd_activeScSwitch = 2,
	TypeUpgradeCmnd_activeScBackup = 3,
	TypeUpgradeCmnd_synchronizeBackup = 4,
	TypeUpgradeCmnd_standbyScSwitch = 5
} TypeUpgradeCmnd_Tval;

typedef enum {
	PbMSPCurrentReq_reqlockout[TTT] = 1,
	PbMSPCurrentReq_reqforcedswitch = 2,
	PbMSPCurrentReq_reqsfhigh = 3,
	PbMSPCurrentReq_reqsflow = 4,
	PbMSPCurrentReq_reqsdhigh = 5,
	PbMSPCurrentReq_reqsdlow = 6,
	PbMSPCurrentReq_reqmannualswitch = 7,
	PbMSPCurrentReq_reqwaittorestore = 8,
	PbMSPCurrentReq_reqexercise = 9,
	PbMSPCurrentReq_reqreverse = 10,
	PbMSPCurrentReq_reqnorevert = 11,
	PbMSPCurrentReq_reqnorequest = 12
} PbMSPCurrentReq_Tval;

typedef enum {
	PbEnableDisable_enable[TTT] = 1,
	PbEnableDisable_disable = 2
} PbEnableDisable_Tval;

typedef enum {
	Mssp4fLineRequest_signalDegradeRing[TTT] = 8,
	Mssp4fLineRequest_signalFailRing = 11,
	Mssp4fLineRequest_clear = 21
} Mssp4fLineRequest_Tval;

typedef enum {
	Mssp4fSwitchCommand_noRequest[TTT] = 0,
	Mssp4fSwitchCommand_reverseRequestRing = 1,
	Mssp4fSwitchCommand_reverseRequestSpan = 2,
	Mssp4fSwitchCommand_exerciserRing = 3,
	Mssp4fSwitchCommand_exerciserSpan = 4,
	Mssp4fSwitchCommand_waitToRestore = 5,
	Mssp4fSwitchCommand_manualSwitchRing = 6,
	Mssp4fSwitchCommand_manualSwitchSpan = 7,
	Mssp4fSwitchCommand_signalDegradeRing = 8,
	Mssp4fSwitchCommand_signalDegradeSpan = 9,
	Mssp4fSwitchCommand_signalDegradeProtection = 10,
	Mssp4fSwitchCommand_signalFailRing = 11,
	Mssp4fSwitchCommand_signalFailSpan = 12,
	Mssp4fSwitchCommand_forcedSwitchRing = 13,
	Mssp4fSwitchCommand_forcedSwitchSpan = 14,
	Mssp4fSwitchCommand_lockoutProtection = 15
} Mssp4fSwitchCommand_Tval;

typedef enum {
	PbEthPortClass_lAN[TTT] = 1,
	PbEthPortClass_wAN = 2,
	PbEthPortClass_tRUNK = 3
} PbEthPortClass_Tval;

typedef enum {
	AlarmState_set[TTT] = 1,
	AlarmState_clear = 2
} AlarmState_Tval;

typedef enum {
	SnmpSecurityLevel_noAuthNoPriv[TTT] = 1,
	SnmpSecurityLevel_authNoPriv = 2,
	SnmpSecurityLevel_authPriv = 3
} SnmpSecurityLevel_Tval;

typedef enum {
	PbMsspRequestSource_kByte[TTT] = 0,
	PbMsspRequestSource_line = 1,
	PbMsspRequestSource_external = 2
} PbMsspRequestSource_Tval;

typedef enum {
	PbSNCPCurrentReq_reqClear[TTT] = 1,
	PbSNCPCurrentReq_reqlockout = 2,
	PbSNCPCurrentReq_reqforcedswitchtop = 3,
	PbSNCPCurrentReq_reqforcedswitchtow = 4,
	PbSNCPCurrentReq_reqsignalfail = 5,
	PbSNCPCurrentReq_reqmannualswitchtop = 6,
	PbSNCPCurrentReq_reqmannualswitchtow = 7,
	PbSNCPCurrentReq_reqwaittorestore = 8,
	PbSNCPCurrentReq_reqnorequest = 9,
	PbSNCPCurrentReq_reqsignalDeg = 10
} PbSNCPCurrentReq_Tval;

typedef enum {
	PbXcStatus_removed[TTT] = 0,
	PbXcStatus_disabled = 1,
	PbXcStatus_ok = 2,
	PbXcStatus_failed = 3
} PbXcStatus_Tval;

typedef enum {
	EventTypeID_usr_login[TTT] = 1,
	EventTypeID_usr_logout = 2,
	EventTypeID_usr_autologout = 3,
	EventTypeID_usr_pwd_change = 4,
	EventTypeID_unauthorized_login = 5,
	EventTypeID_alarm_log_cleared = 6,
	EventTypeID_event_log_cleared = 7,
	EventTypeID_auto_acceptance = 8,
	EventTypeID_card_booted = 9,
	EventTypeID_card_reset = 10,
	EventTypeID_card_disabled = 11,
	EventTypeID_card_removed = 12,
	EventTypeID_sfp_changed = 13,
	EventTypeID_protection_switch_completed = 14,
	EventTypeID_protection_switch_back_completed = 15,
	EventTypeID_software_download_started = 16,
	EventTypeID_software_download_completed = 17,
	EventTypeID_software_upgrade_started = 18,
	EventTypeID_software_upgrade_completed = 19,
	EventTypeID_mib_upload_started = 20,
	EventTypeID_mib_upload_completed = 21,
	EventTypeID_mib_download_started = 22,
	EventTypeID_mib_download_completed = 23,
	EventTypeID_mib_backup_started = 24,
	EventTypeID_mib_backup_completed = 25,
	EventTypeID_mib_restore_started = 26,
	EventTypeID_mib_restore_completed = 27,
	EventTypeID_system_reset = 28,
	EventTypeID_system_start = 29,
	EventTypeID_tms_status = 30,
	EventTypeID_tms_config = 31,
	EventTypeID_port_down = 32,
	EventTypeID_port_up = 33,
	EventTypeID_msspring_state_change = 34,
	EventTypeID_msspring_squelch = 35,
	EventTypeID_cc_switch = 36,
	EventTypeID_tca = 37,
	EventTypeID_flash_full = 38,
	EventTypeID_dcc_dll_status = 39,
	EventTypeID_mib_check_failed = 40,
	EventTypeID_mib_illegal_operation = 41,
	EventTypeID_system_memory_usage = 42,
	EventTypeID_sncp_switch_to_protect = 43,
	EventTypeID_sncp_switch_to_work = 44,
	EventTypeID_card_deleted = 45,
	EventTypeID_system_time_changed = 46,
	EventTypeID_positive_bit_slip = 47,
	EventTypeID_negative_bit_slip = 48,
	EventTypeID_latch_switch_opened = 49,
	EventTypeID_sncp_switch = 50,
	EventTypeID_tms_systiming_status = 51,
	EventTypeID_tms_systiming_config = 52,
	EventTypeID_epg_protectstate_change = 53,
	EventTypeID_rpr_topo_changed = 54,
	EventTypeID_mib_clear_started = 57,
	EventTypeID_mib_clear_completed = 58,
	EventTypeID_boot_image_is_not_identical = 60,
	EventTypeID_rstp_topology_changed = 61,
	EventTypeID_rstp_enabled = 62,
	EventTypeID_rstp_disabled = 63,
	EventTypeID_lcasso_changed = 64,
	EventTypeID_lcassk_changed = 65,
	EventTypeID_mib_file_is_failed = 66,
	EventTypeID_free_space_is_not_enough_in_cf = 67,
	EventTypeID_space_is_released_in_cf = 68,
	EventTypeID_ntp_function_changed = 69,
	EventTypeID_connect_to_ntp_server_failed = 70,
	EventTypeID_connect_to_ntp_server_successfully = 71,
	EventTypeID_primary_load_copy_succeeded = 72,
	EventTypeID_primary_load_copy_failed = 73,
	EventTypeID_lan_port_down_on_csf_alarm = 74,
	EventTypeID_lan_port_recovered_on_csf_alarm_cleared = 75,
	EventTypeID_lan_port_down_on_tlct_alarm = 76,
	EventTypeID_lan_port_recovered_on_tlct_alarm_cleared = 77,
	EventTypeID_lan_port_recovered_on_atls_disable = 78,
	EventTypeID_provision_ssm_mode_changed = 79,
	EventTypeID_ecc_dll_status = 80,
	EventTypeID_software_image_loaded_location = 81,
	EventTypeID_mib_loaded_location = 82,
	EventTypeID_eow_software_download_started = 83,
	EventTypeID_eow_software_download_completed = 84,
	EventTypeID_eow_software_upgrade_started = 85,
	EventTypeID_eow_software_upgrade_completed = 86,
	EventTypeID_eow_box_present_status = 87,
	EventTypeID_eow_box_linkup_status = 88,
	EventTypeID_software_synchronization_started = 89,
	EventTypeID_software_synchronization_statement = 90,
	EventTypeID_mib_syn_started = 91,
	EventTypeID_mib_syn_statement = 92,
	EventTypeID_mib_copy_started = 93,
	EventTypeID_mib_copy_statement = 94,
	EventTypeID_card_mismatch = 95,
	EventTypeID_lcs_download_started = 96,
	EventTypeID_lcs_download_statement = 97,
	EventTypeID_lcs_syn_started = 98,
	EventTypeID_lcs_syn_statement = 99,
	EventTypeID_software_is_different = 101,
	EventTypeID_wr_error = 102,
	EventTypeID_card_inserted = 103,
	EventTypeID_sft_unstable_state = 104,
	EventTypeID_sft_is_switching = 105,
	EventTypeID_sft_switching_complete_by_present = 106,
	EventTypeID_sft_switching_complete_by_external_command = 107,
	EventTypeID_sft_switching_complete_by_unit_failure = 108,
	EventTypeID_sft_switching_complete_by_latch_open = 109,
	EventTypeID_sft_switching_failed = 110,
	EventTypeID_sft_file_lost = 111,
	EventTypeID_sft_ohw_error = 112,
	EventTypeID_sft_pull_ool = 113,
	EventTypeID_sft_gmpls_switch = 114,
	EventTypeID_ms_got_write_authority = 115,
	EventTypeID_ms_release_write_authority = 116,
	EventTypeID_unauthorized_access = 117,
	EventTypeID_si_ens_state = 118,
	EventTypeID_si_erm_state = 119,
	EventTypeID_mstp_port_change = 120,
	EventTypeID_mstp_rstp_enable = 121,
	EventTypeID_initialization_failure = 122,
	EventTypeID_ocxo_failure = 123,
	EventTypeID_vcxo_failure = 124,
	EventTypeID_operation_mode_switch = 125,
	EventTypeID_j0_mode_changed = 126,
	EventTypeID_j0_value_changed = 127,
	EventTypeID_boot_image_upgrade_completed = 128,
	EventTypeID_boot_image_upgrade_failure = 129,
	EventTypeID_pll_cannot_lock = 130,
	EventTypeID_user_enabled = 131,
	EventTypeID_user_disabled = 132,
	EventTypeID_lcs_status_changed = 133,
	EventTypeID_epg_switching_failure = 134,
	EventTypeID_rpr_hardware_passthrough_setup = 135,
	EventTypeID_rpr_hardware_passthrough_removed = 136,
	EventTypeID_account_expired = 137,
	EventTypeID_cpu_util_over = 138,
	EventTypeID_mem_util_over = 139,
	EventTypeID_gmpls_switch_success = 140,
	EventTypeID_queue_over_flow = 141,
	EventTypeID_dcn_mgmt_ethport_down = 142,
	EventTypeID_dcn_mgmt_ethport_up = 143,
	EventTypeID_mib_preserve_clear_started = 144,
	EventTypeID_mib_preserve_clear_completed = 145
} EventTypeID_Tval;

typedef enum {
	TmsRefSourceNum_reference1[TTT] = 1,
	TmsRefSourceNum_reference2 = 2,
	TmsRefSourceNum_reference3 = 3,
	TmsRefSourceNum_reference4 = 4
} TmsRefSourceNum_Tval;

typedef enum {
	PbSignalType_normal[TTT] = 1,
	PbSignalType_unequipped = 2,
	PbSignalType_ais = 3,
	PbSignalType_rdi = 5
} PbSignalType_Tval;

typedef enum {
	PBSNCPAddRslt_succ[TTT] = 1,
	PBSNCPAddRslt_workTPError = 2,
	PBSNCPAddRslt_workTPDuplicate = 3,
	PBSNCPAddRslt_protTPDuplicate = 4,
	PBSNCPAddRslt_protTPError = 5,
	PBSNCPAddRslt_msProtTP = 6,
	PBSNCPAddRslt_pcmTimeout = 7,
	PBSNCPAddRslt_noFreeTbl = 8,
	PBSNCPAddRslt_ccFail = 9,
	PBSNCPAddRslt_ccTimeout = 10,
	PBSNCPAddRslt_waitCCReq = 11,
	PBSNCPAddRslt_waitCCResult = 12,
	PBSNCPAddRslt_waitPCMResult = 13,
	PBSNCPAddRslt_pcmFail = 14,
	PBSNCPAddRslt_waitSPAReq = 15,
	PBSNCPAddRslt_waitSPAResult = 16,
	PBSNCPAddRslt_spaFail = 17,
	PBSNCPAddRslt_spaTimeout = 18
} PBSNCPAddRslt_Tval;

typedef enum {
	PbMsspTrafficDirection_rx[TTT] = 0,
	PbMsspTrafficDirection_tx = 1
} PbMsspTrafficDirection_Tval;

typedef enum {
	PbCmndState_none[TTT] = 1,
	PbCmndState_running = 2,
	PbCmndState_complete = 3,
	PbCmndState_failed = 4
} PbCmndState_Tval;

typedef enum {
	PbTIModeType_mode16Byte[TTT] = 1,
	PbTIModeType_mode64Byte = 2,
	PbTIModeType_modeFixedOneByte = 3,
	PbTIModeType_modeProvisionedOneByte = 4,
	PbTIModeType_modeAutoTrace = 5
} PbTIModeType_Tval;

typedef enum {
	PbCFCardState_notapplicable[TTT] = 0,
	PbCFCardState_mountedandnormal = 1,
	PbCFCardState_removed = 2,
	PbCFCardState_mountedbutfailed = 3,
	PbCFCardState_mountednofreespace = 4
} PbCFCardState_Tval;

typedef enum {
	PbSlotType_none[TTT] = 0,
	PbSlotType_mc = 1,
	PbSlotType_lc = 2,
	PbSlotType_ti = 5,
	PbSlotType_to = 6,
	PbSlotType_power = 7,
	PbSlotType_fan = 8,
	PbSlotType_si = 10,
	PbSlotType_io = 12,
	PbSlotType_cc = 13,
	PbSlotType_sfc = 14,
	PbSlotType_sfm = 15,
	PbSlotType_ce = 16
} PbSlotType_Tval;

typedef enum {
	PbPmUapType_nearend[TTT] = 1,
	PbPmUapType_farend = 2
} PbPmUapType_Tval;

typedef enum {
	PbSFFTranscCode_unknown[TTT] = 0,
	PbSFFTranscCode_infiniband_1x_SX = 1,
	PbSFFTranscCode_infiniband_1x_LX = 2,
	PbSFFTranscCode_infiniband_1x_COP_ACT = 3,
	PbSFFTranscCode_infiniband_1x_COP_PSV = 4,
	PbSFFTranscCode_escon_MMF_1310NM_LED = 5,
	PbSFFTranscCode_escon_SMF_1310NM_LASER = 6,
	PbSFFTranscCode_sonet_oc48_SR = 7,
	PbSFFTranscCode_sonet_oc48_SR1 = 8,
	PbSFFTranscCode_sonet_oc48_IR = 9,
	PbSFFTranscCode_sonet_oc48_IR1 = 10,
	PbSFFTranscCode_sonet_oc48_IR2 = 11,
	PbSFFTranscCode_sonet_oc48_LR = 12,
	PbSFFTranscCode_sonet_oc48_LR1 = 13,
	PbSFFTranscCode_sonet_oc48_LR2 = 14,
	PbSFFTranscCode_sonet_oc48_LR3 = 15,
	PbSFFTranscCode_sonet_oc12_SR = 16,
	PbSFFTranscCode_sonet_oc12_SR1 = 17,
	PbSFFTranscCode_sonet_oc12_IR = 18,
	PbSFFTranscCode_sonet_oc12_IR1 = 19,
	PbSFFTranscCode_sonet_oc12_IR2 = 20,
	PbSFFTranscCode_sonet_oc12_LR = 21,
	PbSFFTranscCode_sonet_oc12_LR1 = 22,
	PbSFFTranscCode_sonet_oc12_LR2 = 23,
	PbSFFTranscCode_sonet_oc12_LR3 = 24,
	PbSFFTranscCode_sonet_oc3_SR = 25,
	PbSFFTranscCode_sonet_oc3_SR1 = 26,
	PbSFFTranscCode_sonet_oc3_IR = 27,
	PbSFFTranscCode_sonet_oc3_IR1 = 28,
	PbSFFTranscCode_sonet_oc3_IR2 = 29,
	PbSFFTranscCode_sonet_oc3_LR = 30,
	PbSFFTranscCode_sonet_oc3_LR1 = 31,
	PbSFFTranscCode_sonet_oc3_LR2 = 32,
	PbSFFTranscCode_sonet_oc3_LR3 = 33,
	PbSFFTranscCode_ethernet_BASE_PX = 34,
	PbSFFTranscCode_ethernet_BASE_BX10 = 35,
	PbSFFTranscCode_ethernet_100BASE_FX = 36,
	PbSFFTranscCode_ethernet_100BASE_LX_LX10 = 37,
	PbSFFTranscCode_ethernet_1000BASE_T = 38,
	PbSFFTranscCode_ethernet_1000BASE_CX = 39,
	PbSFFTranscCode_ethernet_1000BASE_LX = 40,
	PbSFFTranscCode_ethernet_1000BASE_SX = 41,
	PbSFFTranscCode_fibre_CHANNEL = 42,
	PbSFFTranscCode_max = 43
} PbSFFTranscCode_Tval;

typedef enum {
	StorageType_other[TTT] = 1,
	StorageType_volatile = 2,
	StorageType_nonVolatile = 3,
	StorageType_permanent = 4,
	StorageType_readOnly = 5
} StorageType_Tval;

typedef enum {
	PbCommunityStringAccessLevel_readOnly[TTT] = 1,
	PbCommunityStringAccessLevel_readWrite = 2
} PbCommunityStringAccessLevel_Tval;

typedef enum {
	PbDpnpSwitchEvent_w2p[TTT] = 1,
	PbDpnpSwitchEvent_w2m = 2,
	PbDpnpSwitchEvent_p2w = 3,
	PbDpnpSwitchEvent_p2m = 4,
	PbDpnpSwitchEvent_m2w = 5,
	PbDpnpSwitchEvent_m2p = 6
} PbDpnpSwitchEvent_Tval;

typedef enum {
	PBSNCPWorkorProtToCC_protection[TTT] = 0,
	PBSNCPWorkorProtToCC_working = 1,
	PBSNCPWorkorProtToCC_none = 255
} PBSNCPWorkorProtToCC_Tval;

typedef enum {
	PbTPType_ospiTTP[TTT] = 1,
	PbTPType_rsDatacomCTP = 2,
	PbTPType_rsTTP = 3,
	PbTPType_msCTP = 4,
	PbTPType_msDatacomCTP = 5,
	PbTPType_msTTP = 6,
	PbTPType_au4CTP = 7,
	PbTPType_vc4TTP = 8,
	PbTPType_tu12CTP = 9,
	PbTPType_vc12TTP = 10,
	PbTPType_ppiTTP = 11,
	PbTPType_vc4xvTTP = 12,
	PbTPType_vc12xvTTP = 13,
	PbTPType_au416cCTP = 14,
	PbTPType_vc416cTTP = 15,
	PbTPType_au44cCTP = 16,
	PbTPType_vc44cTTP = 17,
	PbTPType_au3CTP = 18,
	PbTPType_tu3CTP = 19,
	PbTPType_hovc3TTP = 20,
	PbTPType_lovc3TTP = 21,
	PbTPType_tu11CTP = 22,
	PbTPType_vc11TTP = 23,
	PbTPType_lanTTP = 24,
	PbTPType_wanTTP = 25,
	PbTPType_au464cCTP = 26,
	PbTPType_vc464cTTP = 27,
	PbTPType_tcCTP = 28,
	PbTPType_vpCTP = 29,
	PbTPType_vcCTP = 30,
	PbTPType_vc3xvTTP = 31,
	PbTPType_vc4NIMTTP = 32,
	PbTPType_vc12NIMTTP = 33,
	PbTPType_vc416cNIMTTP = 34,
	PbTPType_vc44cNIMTTP = 35,
	PbTPType_hovc3NIMTTP = 36,
	PbTPType_lovc3NIMTTP = 37,
	PbTPType_vc11NIMTTP = 38,
	PbTPType_vc464cNIMTTP = 39,
	PbTPType_au4256cCTP = 40,
	PbTPType_vc4256cTTP = 41,
	PbTPType_vc4256cNIMTTP = 42
} PbTPType_Tval;

typedef enum {
	PbMSPExternalCmd_cmdClear[TTT] = 1,
	PbMSPExternalCmd_cmdlockout = 2,
	PbMSPExternalCmd_cmdforcedswitch = 3,
	PbMSPExternalCmd_cmdmannualswitch = 4,
	PbMSPExternalCmd_cmdexercise = 5,
	PbMSPExternalCmd_cmdnocomand = 6
} PbMSPExternalCmd_Tval;

typedef enum {
	TMSStClkOhm_seventyfive[TTT] = 1,
	TMSStClkOhm_onehundredtwenty = 2
} TMSStClkOhm_Tval;

typedef enum {
	PbPmTableType_interval[TTT] = 1,
	PbPmTableType_intervalFe = 2,
	PbPmTableType_day = 3,
	PbPmTableType_dayFe = 4
} PbPmTableType_Tval;

typedef enum {
	PbPortType_lan[TTT] = 1,
	PbPortType_console = 2,
	PbPortType_stm1 = 3,
	PbPortType_stm4 = 4,
	PbPortType_stm16 = 5,
	PbPortType_stm64 = 6,
	PbPortType_fe = 7,
	PbPortType_ge = 8,
	PbPortType_e1 = 9,
	PbPortType_e3ds3 = 10,
	PbPortType_ti = 11,
	PbPortType_to = 12,
	PbPortType_vstm1 = 13,
	PbPortType_vstm4 = 14,
	PbPortType_vstm16 = 15,
	PbPortType_vlan = 16,
	PbPortType_vwan = 17,
	PbPortType_e1ds1 = 18,
	PbPortType_ivstm1 = 19,
	PbPortType_rprclient = 20,
	PbPortType_rprline = 21,
	PbPortType_oa = 22,
	PbPortType_stm1or4 = 23,
	PbPortType_stm256 = 24,
	PbPortType_tenge = 25,
	PbPortType_fiber_channel = 26,
	PbPortType_vstm64 = 27,
	PbPortType_otu2 = 28,
	PbPortType_na = 29
} PbPortType_Tval;

typedef enum {
	PbSncpCircuitDirection_bidirection[TTT] = 1,
	PbSncpCircuitDirection_unidirection = 2
} PbSncpCircuitDirection_Tval;

typedef enum {
	PbPmPortStatusType_normal[TTT] = 1,
	PbPmPortStatusType_working = 2,
	PbPmPortStatusType_protect = 3
} PbPmPortStatusType_Tval;

typedef enum {
	PbTpMaintenanceType_normal[TTT] = 1,
	PbTpMaintenanceType_lck = 5,
	PbTpMaintenanceType_oci = 6,
	PbTpMaintenanceType_ais = 7
} PbTpMaintenanceType_Tval;

typedef enum {
	PbMSPSwitchReason_clearcmd[TTT] = 1,
	PbMSPSwitchReason_lpcmd = 2,
	PbMSPSwitchReason_forcedswitch = 3,
	PbMSPSwitchReason_manualswitch = 4,
	PbMSPSwitchReason_signalfail = 5,
	PbMSPSwitchReason_signalfailclear = 6,
	PbMSPSwitchReason_signaldeg = 7,
	PbMSPSwitchReason_signaldegclear = 8,
	PbMSPSwitchReason_noswitch = 9
} PbMSPSwitchReason_Tval;

typedef enum {
	PbGmplsCcDirection_forward[TTT] = 1,
	PbGmplsCcDirection_reverse = 2
} PbGmplsCcDirection_Tval;

typedef enum {
	EthPortClass_lan[TTT] = 0,
	EthPortClass_wan = 1,
	EthPortClass_trunk = 2
} EthPortClass_Tval;

typedef enum {
	TypeMibCmnd_inactive[TTT] = 0,
	TypeMibCmnd_activeScMibUpload = 1,
	TypeMibCmnd_activeScMibDownload = 2,
	TypeMibCmnd_activeScMibSwitch = 3,
	TypeMibCmnd_standbyScMibSwitch = 4,
	TypeMibCmnd_synchronizeMibBackup = 5,
	TypeMibCmnd_activeScMibClear = 6,
	TypeMibCmnd_activeScMibCopy = 7,
	TypeMibCmnd_downloadLicense = 8,
	TypeMibCmnd_synchronizeLicense = 9,
	TypeMibCmnd_activeScMibPreserveClear = 10
} TypeMibCmnd_Tval;

typedef enum {
	RowStatus_active[TTT] = 1,
	RowStatus_notInService = 2,
	RowStatus_notReady = 3,
	RowStatus_createAndGo = 4,
	RowStatus_createAndWait = 5,
	RowStatus_destroy = 6
} RowStatus_Tval;

typedef enum {
	PbSNCPExternalCmd_cmdClear[TTT] = 1,
	PbSNCPExternalCmd_cmdlockout = 2,
	PbSNCPExternalCmd_cmdforcedswitchtop = 3,
	PbSNCPExternalCmd_cmdforcedswitchtow = 4,
	PbSNCPExternalCmd_cmdmannualswitchtop = 5,
	PbSNCPExternalCmd_cmdmannualswitchtow = 6,
	PbSNCPExternalCmd_cmdnocomand = 7
} PbSNCPExternalCmd_Tval;

typedef enum {
	RprProtectionType_steering[TTT] = 1,
	RprProtectionType_wrap = 2,
	RprProtectionType_disable = 3
} RprProtectionType_Tval;

typedef enum {
	PbNodeMode_standalone[TTT] = 1,
	PbNodeMode_subservient = 2
} PbNodeMode_Tval;

typedef enum {
	PbAcDc_ac[TTT] = 1,
	PbAcDc_dc = 2
} PbAcDc_Tval;

typedef enum {
	PbMsspRequest_noRequest[TTT] = 0,
	PbMsspRequest_reverseRequestRing = 1,
	PbMsspRequest_reverseRequestSpan = 2,
	PbMsspRequest_exerciserRing = 3,
	PbMsspRequest_exerciserSpan = 4,
	PbMsspRequest_waitToRestore = 5,
	PbMsspRequest_manualSwitchRing = 6,
	PbMsspRequest_manualSwitchSpan = 7,
	PbMsspRequest_signalDegradeRing = 8,
	PbMsspRequest_signalDegradeSpan = 9,
	PbMsspRequest_signalDegradeProtection = 10,
	PbMsspRequest_signalFailRing = 11,
	PbMsspRequest_signalFailSpan = 12,
	PbMsspRequest_forcedSwitchRing = 13,
	PbMsspRequest_forcedSwitchSpan = 14,
	PbMsspRequest_lockoutProtection = 15
} PbMsspRequest_Tval;

typedef enum {
	PbConnectorType_unknown[TTT] = 0,
	PbConnectorType_sc = 1,
	PbConnectorType_fiber_1_copper = 2,
	PbConnectorType_fiber_2_copper = 3,
	PbConnectorType_bnctnc = 4,
	PbConnectorType_fiber_coax = 5,
	PbConnectorType_fiber_jack = 6,
	PbConnectorType_lc = 7,
	PbConnectorType_mtrj = 8,
	PbConnectorType_mu = 9,
	PbConnectorType_sg = 10,
	PbConnectorType_optical_pigtail = 11,
	PbConnectorType_hssdc = 32,
	PbConnectorType_copper_pigtail = 33,
	PbConnectorType_unspecified = 256
} PbConnectorType_Tval;

typedef enum {
	PbBoardProperty_none[TTT] = 0,
	PbBoardProperty_all = 1,
	PbBoardProperty_hiT7065sc = 2,
	PbBoardProperty_hiT7065cc = 4,
	PbBoardProperty_hiT7065lc = 8
} PbBoardProperty_Tval;

 




 




 



 
extern MIBDid_t pbSonetSdh_Did;

   


 



 
 
extern MIBDid_t pbPortConfigTable_Did;

   
typedef enum {
	pbPortMode_auto[TTT]=1,
	pbPortMode_mon=2,
	pbPortMode_nmon=3
} pbPortMode_Tval;

typedef enum {
	pbPdhPortMap_async[TTT]=1,
	pbPdhPortMap_byte=2,
	pbPdhPortMap_none=3
} pbPdhPortMap_Tval;

typedef enum {
	pbPortLoopback_none[TTT]=1,
	pbPortLoopback_outward=2,
	pbPortLoopback_inward=3
} pbPortLoopback_Tval;

typedef enum {
	pbFecMode_correction[TTT]=1,
	pbFecMode_disable=2
} pbFecMode_Tval;

typedef enum {
	pbImpedance_ohm75[TTT]=0,
	pbImpedance_ohm120=1,
	pbImpedance_ohm100=2,
	pbImpedance_ohm110=3
} pbImpedance_Tval;

typedef enum {
	pbCodeType_hdb3[TTT]=0,
	pbCodeType_ami=1,
	pbCodeType_bypass=2,
	pbCodeType_cdrbypass=3,
	pbCodeType_b3zs=4
} pbCodeType_Tval;

typedef enum {
	pbHaulType_e175ohm[TTT]=0,
	pbHaulType_e1120ohm=1,
	pbHaulType_dsx1133ft=2,
	pbHaulType_dsx1266ft=3,
	pbHaulType_dsx1399ft=4,
	pbHaulType_dsx1533ft=5,
	pbHaulType_dsx1655ft=6,
	pbHaulType_j10655ft=7,
	pbHaulType_ds10=8,
	pbHaulType_ds175=9,
	pbHaulType_ds115=10,
	pbHaulType_ds1225=11,
	pbHaulType_ds111xx=12
} pbHaulType_Tval;

typedef enum {
	pbRetimingStatus_disable[TTT]=0,
	pbRetimingStatus_enable=1
} pbRetimingStatus_Tval;

typedef enum {
	pbPortAlsMode_no_command[TTT]=0,
	pbPortAlsMode_manual_restart=1,
	pbPortAlsMode_manual_test=2
} pbPortAlsMode_Tval;

typedef enum {
	expectedFrameStructure_none[TTT]=0,
	expectedFrameStructure_e1_framed=1,
	expectedFrameStructure_e1_unframed=2,
	expectedFrameStructure_e3_G751=3,
	expectedFrameStructure_e3_G832=4,
	expectedFrameStructure_ds3_M13=5,
	expectedFrameStructure_ds3_CBit=6,
	expectedFrameStructure_e3_unframed=7,
	expectedFrameStructure_ds3_unframed=8
} expectedFrameStructure_Tval;

typedef enum {
	crcMultiframeDetector_activated[TTT]=1,
	crcMultiframeDetector_deactivated=2
} crcMultiframeDetector_Tval;

typedef enum {
	portClassification_nongmpls[TTT]=0,
	portClassification_inni=1,
	portClassification_enni=2,
	portClassification_uni10=3,
	portClassification_uni20=4
} portClassification_Tval;

typedef enum {
	portOperationLock_none[TTT]=1,
	portOperationLock_nms=2,
	portOperationLock_gmpls=3
} portOperationLock_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                               
	PbPortType_Tval pbPortType;                                          
	int		pbPortNo;                                                       
	char		pbPortLabel[64];   
	pbPortMode_Tval pbPortMode;   
	pbPdhPortMap_Tval pbPdhPortMap;   
	PbPortStatus_Tval pbPortAdminStatus;   
	PbEnableDisable_Tval pbPortMapRefresh;   
	TruthValue_Tval pbPortAutoLaserShutdown;   
	pbPortLoopback_Tval pbPortLoopback;   
	pbFecMode_Tval pbFecMode;   
	PbActualPortType_Tval pbActualPortType;   
	pbImpedance_Tval pbImpedance;   
	pbCodeType_Tval pbCodeType;   
	pbHaulType_Tval pbHaulType;   
	pbRetimingStatus_Tval pbRetimingStatus;   
	pbPortAlsMode_Tval pbPortAlsMode;   
	TruthValue_Tval pbPortAlarmDisable;   
	expectedFrameStructure_Tval expectedFrameStructure;
	crcMultiframeDetector_Tval crcMultiframeDetector;
	portClassification_Tval portClassification;
	PbUsageStatus_Tval portUsageStatus;
	int		portMappingString_len;
	char		portMappingString[384];
	portOperationLock_Tval portOperationLock;
}MIBpbPortConfigTable_t;































 



 
 
extern MIBDid_t pbPortStatusTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                       
	PbPortType_Tval pbPortType;                               
	int		pbPortNo;                                            
	int		pbPortStatus;   
	PbPortOperationStatus_Tval pbPortOperStatus;   
	int		pbLaserIBias;   
	int		pbLaserRecvPwr;   
	int		pbLaserTransPwr;   
	int		pbLaserTemp;   
	TruthValue_Tval pbCompliance8472;   
	int		pbnNominalMBps;   
	int		pbnWavelength;   
	int		pbnLinkLength9125;   
	int		pbnLinkLength50125;   
	int		pbnLinkLength62125;   
	int		pbnLinkLengthCopper;   
	char		pbsVendorName[20];   
	char		pbsVendorPN[20];   
	char		pbsVendorSN[20];   
	char		pbsManuDate[16];   
	PbSFFTranscCode_Tval pbnTransCode;   
	char		pbsVendorOUI[16];   
	PbConnectorType_Tval pbnConnectorType;   
	int		pbnClLaserTemp;
	int		pbnTECCurrent;
	char		pbsSAGPartNumber[20];
}MIBpbPortStatusTable_t;

































 



 
 
extern MIBDid_t pbPortHoTpReserveTable_Did;

   
typedef enum {
	tpOperationLock_none[TTT]=1,
	tpOperationLock_nms=2,
	tpOperationLock_gmpls=3
} tpOperationLock_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                           
	PbPortType_Tval pbPortType;                                   
	int		pbPortNo;                                                
	int		vc4ReservationStatus_len;
	char		vc4ReservationStatus[256];   
	int		vc4ReservationOperate_len;
	char		vc4ReservationOperate[257];   
	tpOperationLock_Tval tpOperationLock;   
}MIBpbPortHoTpReserveTable_t;













 



 
 
extern MIBDid_t pbTPConfigTable_Did;

   
typedef enum {
	pbSdMode_poisson[TTT]=1,
	pbSdMode_bursty=2
} pbSdMode_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                               
	PbPortType_Tval pbPortType;                                       
	int		pbPortNo;                                                    
	PbTPType_Tval pbTpType;                                              
	int		pbTpIndex;                                                      
	TruthValue_Tval pbMonitored;   
	PbSignalType_Tval pbOutSignalType;
	PbInSignalType_Tval pbInSignalType;   
	int		pbTransPsl;   
	int		pbExpPsl;   
	TruthValue_Tval pbSLEnable;   
	int		pbSLAccept;   
	TruthValue_Tval pbTtiEnabled;   
	TruthValue_Tval pbTimAisDis;
	PbTIModeType_Tval pbTtiTransmitMode;   
	PbTIModeType_Tval pbTtiReceiveMode;   
	int		pbTtiOctetTransmitted_len;
	char		pbTtiOctetTransmitted[65];   
	int		pbTtiOctetExpected_len;
	char		pbTtiOctetExpected[65];   
	int		pbTtiOctetAccepted_len;
	char		pbTtiOctetAccepted[65];   
	pbSdMode_Tval pbSdMode;   
	TruthValue_Tval pbBurstyEnable;   
	int		pbBurstyPeriod;   
	int		pbBurstyPercent;   
	TruthValue_Tval pbDegEnable;   
	int		pbDegThreshold;   
	TruthValue_Tval pbExcEnable;   
	int		pbExcThreshold;   
	TruthValue_Tval pbAISEnable;   
	TruthValue_Tval pbRDIEnable;   
	PbPmMonitor_Tval pmNearEnd15minMonitored;
	PbPmMonitor_Tval pmFarEnd15minMonitored;
	PbPmMonitor_Tval pmNearEnd24hrMonitored;
	PbPmMonitor_Tval pmFarEnd24hrMonitored;
}MIBpbTPConfigTable_t;








































 



 
 
extern MIBDid_t pbOTUPortConfigTable_Did;

   
typedef enum {
	pbOTUPortMode_auto[TTT]=1,
	pbOTUPortMode_mon=2,
	pbOTUPortMode_nmon=3
} pbOTUPortMode_Tval;

typedef enum {
	pbOTUPortLoopback_none[TTT]=1,
	pbOTUPortLoopback_outward=2,
	pbOTUPortLoopback_inward=3
} pbOTUPortLoopback_Tval;

typedef enum {
	pbInsFecErrRate_errE3[TTT]=3,
	pbInsFecErrRate_errE4=4,
	pbInsFecErrRate_errE5=5
} pbInsFecErrRate_Tval;

typedef enum {
	pbOTUFecMode_rsfec[TTT]=0,
	pbOTUFecMode_ufec=1
} pbOTUFecMode_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                       
	PbPortType_Tval pbPortType;                                               
	int		pbPortNo;                                                            
	char		pbOTUPortLabel[65];   
	pbOTUPortMode_Tval pbOTUPortMode;   
	TruthValue_Tval pbOTUPortAlarmDisable;   
	pbOTUPortLoopback_Tval pbOTUPortLoopback;   
	TruthValue_Tval pbFecEnable;   
	TruthValue_Tval pbInsFecErrEnable;   
	pbInsFecErrRate_Tval pbInsFecErrRate;   
	int		pbWaveLengthId;   
	TruthValue_Tval pbSMTimAlmEnable;   
	TruthValue_Tval pbSMTimActEnable;   
	int		pbSMTxTti_len;
	char		pbSMTxTti[65];   
	int		pbSMExpTti_len;
	char		pbSMExpTti[65];   
	TruthValue_Tval pbPTAlmEnable;   
	int		pbTxPt;   
	int		pbExpPt;   
	TruthValue_Tval pbCIDAlmEnable;   
	int		pbTxChannelId;   
	TruthValue_Tval pbAutoAdjustManulStopEnable;   
	int		pbPortPathMapping_len;
	char		pbPortPathMapping[9];   
	pbOTUFecMode_Tval pbOTUFecMode;   
	PbPortStatus_Tval pbOTUPortAdminStatus;   
	PbUsageStatus_Tval pbOTUPortUsageStatus;   
}MIBpbOTUPortConfigTable_t;
































 



 
 
extern MIBDid_t pbPRBSPortHisTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                               
	int		pbPortNo;                                                    
	PbPortType_Tval pbPortType;                                       
	unsigned int	pbPRBSHisErrorSeconds;   
	int		pbPRBSHisMeanError;
	char		pbPRBSTrapTimeStamp[15];   
	PbActualPortType_Tval pbPRBSHisActualPortType;   
}MIBpbPRBSPortHisTable_t;














 



 
 
extern MIBDid_t pbPRBSPortCurTable_Did;

   
typedef enum {
	pbPRBSPattern_na[TTT]=0,
	pbPRBSPattern_power15=1,
	pbPRBSPattern_power20=2,
	pbPRBSPattern_power23=3
} pbPRBSPattern_Tval;

typedef enum {
	pbPRBSStatus_na[TTT]=0,
	pbPRBSStatus_syncing=1,
	pbPRBSStatus_syncSucc=2,
	pbPRBSStatus_syncFail=3,
	pbPRBSStatus_syncError=4
} pbPRBSStatus_Tval;

typedef enum {
	prbsMode_normal[TTT]=0,
	prbsMode_invert=1
} prbsMode_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                         
	int		pbPortNo;                                              
	PbPortType_Tval pbPortType;                                 
	TruthValue_Tval pbPRBSEnable;   
	pbPRBSPattern_Tval pbPRBSPattern;   
	unsigned int	pbPRBSErrorBlocks;   
	unsigned int	pbPRBSErrorSeconds;   
	pbPRBSStatus_Tval pbPRBSStatus;   
	PbActualPortType_Tval pbPRBSActualPortType;   
	prbsMode_Tval prbsMode;   
}MIBpbPRBSPortCurTable_t;

















 



 
 
extern MIBDid_t pbOTUPortStatusTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;           
	PbPortType_Tval pbPortType;                   
	int		pbPortNo;                                
	int		pbSMRxTti_len;
	char		pbSMRxTti[65];   
	int		pbRxPt;   
	int		pbRxChannelId;   
}MIBpbOTUPortStatusTable_t;













 



 
 
extern MIBDid_t pbOTUTPConfigTable_Did;

   
typedef enum {
	pbOTUTpType_none[TTT]=0,
	pbOTUTpType_otu1=1,
	pbOTUTpType_otu2=2,
	pbOTUTpType_odu21=3,
	pbOTUTpType_otu3=4,
	pbOTUTpType_odu31=5,
	pbOTUTpType_odu32=6,
	pbOTUTpType_odu321=7,
	pbOTUTpType_otu4=8,
	pbOTUTpType_odu41=9,
	pbOTUTpType_odu42=10,
	pbOTUTpType_odu421=11,
	pbOTUTpType_odu43=12,
	pbOTUTpType_odu431=13,
	pbOTUTpType_odu432=14,
	pbOTUTpType_odu4321=15
} pbOTUTpType_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                     
	PbPortType_Tval pbPortType;                                             
	int		pbPortNo;                                                          
	int		pbOTUTpChannelId;                                                     
	PbTpSegment_Tval pbOTUTpSegment;                                           
	pbOTUTpType_Tval pbOTUTpType;   
	TruthValue_Tval pbOTUMonitored;   
	TruthValue_Tval pbOTUTimAlmEnable;   
	TruthValue_Tval pbOTUTimActEnable;   
	int		pbOTUTxTti_len;
	char		pbOTUTxTti[65];   
	int		pbOTUExpTti_len;
	char		pbOTUExpTti[65];   
	int		pbOTURxTti_len;
	char		pbOTURxTti[65];   
	TruthValue_Tval pbOTUDegEnable;   
	int		pbOTUDegThreshold;   
	int		pbOTUDegIntervals;   
	PbTpMaintenanceType_Tval pbOTUSendMaintenanceType;   
	PbTpMaintenanceType_Tval pbOTURecvMaintenanceType;   
	TruthValue_Tval pbOTUPlmAlmEnable;   
	TruthValue_Tval pbOTUMsimAlmEnable;   
	TruthValue_Tval pbOTUPtAlmEnable;   
	int		pbOTUTxPt;   
	int		pbOTUExpPt;   
	int		pbOTURxPt;   
	PbPmMonitor_Tval pmOTUNearEnd15minMonitored;   
	PbPmMonitor_Tval pmOTUFarEnd15minMonitored;   
	PbPmMonitor_Tval pmOTUNearEnd24hrMonitored;   
	PbPmMonitor_Tval pmOTUFarEnd24hrMonitored;   
}MIBpbOTUTPConfigTable_t;


































 



 
extern MIBDid_t pbSonetModule_Did;

   
















 



typedef struct
{
        UINT32[TTT]  ulPortId;       
        PbPortType_Tval ulPortType;

         

        UINT32  ulTug3Num;
        
        UINT16 ausTug3Mapping[192 ];
}PORT_TUG3_MAPPING_T;  

 
typedef struct
{
        UINT32[TTT]  ulPortId;       
        PbPortType_Tval ulPortType;

        UINT32  ulTug3Num;

        UINT16 ausTug3Mapping[1];    
}MSG_PORT_TUG3_MAPPING_T;  

 






















 
















 














 





















typedef struct
{
        UINT32[TTT]  nPortId;     

         
        PbPortOperationStatus_Tval eLaserOn;    

 
        
        int         nLaserIBias;
        int         nLaserRecvPwr;
        int         nLaserTransPwr;
        int         nLaserTemp;

  

	TruthValue_Tval pbCompliance8472;   
	int		pbnNominalMBps;   
	int		pbnWavelength;   
	int		pbnLinkLength9125;   
	int		pbnLinkLength50125;   
	int		pbnLinkLength62125;   
	int		pbnLinkLengthCopper;   
	char		pbsVendorName[20];   
	char		pbsVendorPN[20];   
	char		pbsVendorSN[20];   
	char		pbsManuDate[16];   
	PbSFFTranscCode_Tval pbnTransCode;   
	char		pbsVendorOUI[16];   
	PbConnectorType_Tval pbnConnectorType;  
    int     pbnClLaserTemp;  
    int     pbnTECCurrent;   
    char    pbsSagPN[20];  
}__attribute__ ((packed))  PORT_STATUS_T;  

 


 



























typedef struct
{
    UINT8[TTT]  slotNo;
    UINT8  portType;
    UINT8  portNo;
    UINT16 mappingStrLen;
    UINT8  mappingStr[0];
}__attribute__ ((packed))  PORT_MAPPING_T;

typedef struct
{
    UINT8[TTT]  slotNo;
    UINT8  portType;
    UINT8  portNo;
    UINT16 mappingStrLen;    
}__attribute__ ((packed))  CTD_MAPPING_T;

 






 














typedef struct
{
    UINT32[TTT] SlotNo;
    UINT32 BoardStyle;
}__attribute__ ((packed))  SLOT_ATTRIB;

typedef struct
{
    UINT32[TTT] PortNo_Min;  
	UINT32 PortNo_Max;  
}__attribute__ ((packed))  PORT_RANGE;

typedef struct
{
    SLOT_ATTRIB[TTT] slotAttrib[13];  
}__attribute__ ((packed))  PdhCardFuncToIoSuit;

typedef struct
{
    SLOT_ATTRIB[TTT] slotAttrib[2]; 
    PORT_RANGE portRange;
}__attribute__ ((packed))  PdhCardIoToFuncSuit;

typedef struct
{
    UINT32[TTT] number;             
    SLOT_ATTRIB cardInfo[12];   
    PORT_RANGE portRange[12];   
}__attribute__ ((packed))  PdhCardRelation;

 


typedef struct
{    
    UINT8[TTT]  portType;
    UINT8  portNo;
    UINT8  actualPortType;
    UINT16 mappingStrLen;
     
}__attribute__ ((packed))  ONE_PORT_MAPPING_T;

typedef struct
{
    UINT8[TTT] ucSlotNo;
    UINT8 ucPortNum;
     
}__attribute__ ((packed))  ONE_SLOT_MAPPING_T;

typedef struct
{
    UINT8[TTT] ucSlotNum;
         
}__attribute__ ((packed))  NE_MAPPING_T;

 


 

 
typedef void (*funcDCCPortStateChangeNew[TTT])(UINT32 inst, int port, int state);

PB_ERROR_CODE_T CTD_GetPdhIoCardInfoFromFuncCard(UINT32 funcCardSlotNo, UINT32 funcCardBoardStlye, PdhCardRelation *pPdhRelatedCard);
PB_ERROR_CODE_T CTD_GetPdhFuncCardInfoFromIoCard(UINT32 ioCardSlotNo, UINT32 ioCardBoardStlye, PdhCardRelation *pPdhRelatedCard);


PB_ERROR_CODE_T CTD_ifm_clrNeMappingSeachFlag(NE_MAPPING_T* pNeMapping);
PB_ERROR_CODE_T CTD_ifm_GetNextMappingfromNe(NE_MAPPING_T* pNeMapping, UINT32* pSlotNo, UINT32* pPortType, UINT32* pPortNo, UINT32 *pMappingStrLen,
                                 UINT8 *pMappingStr);
PB_ERROR_CODE_T CTD_ifm_clrSlotMappingSeachFlag(ONE_SLOT_MAPPING_T* pSlotMapping);
PB_ERROR_CODE_T CTD_ifm_GetNextMappingfromSlot(ONE_SLOT_MAPPING_T* pSlotMapping, UINT32* pSlotNo, UINT32* pPortType, UINT32* pPortNo, UINT32 *pMappingStrLen,
                                 UINT8 *pMappingStr);
PB_ERROR_CODE_T CTD_ifm_GetSlotNumberFromNeMapping(NE_MAPPING_T *pNeMapping, UINT32 *pSlotNumber);
PB_ERROR_CODE_T CTD_ifm_GetPortNumberFromNeMapping(UINT32 slotNo, NE_MAPPING_T *pNeMapping, UINT32 *pPortNumber);
PB_ERROR_CODE_T CTD_ifm_GetPortMappingFromNeMapping(UINT32 slotNo, UINT32 portType, UINT32 portNo, NE_MAPPING_T *pNeMapping,  
                              UINT32 *pPortMappingLen, UINT8 *pMappingStr);
PB_ERROR_CODE_T CTD_ifm_GetPortNumberFromSlotMapping(ONE_SLOT_MAPPING_T *pSlotMapping,UINT32 *pSlotNo, UINT32 *pPortNumber);
PB_ERROR_CODE_T CTD_ifm_GetPortMappingFromSlotMapping(UINT32 slotNo, UINT32 portType, UINT32 portNo, ONE_SLOT_MAPPING_T *pSlotMapping,  
                              UINT32 *pPortMappingLen, UINT8 *pMappingStr);











 





























































































 
































typedef INT16[TTT] TEMPERATURE_T;

typedef enum {
  TEMPERATURE_STATE_NORMAL[TTT],
  TEMPERATURE_STATE_OVERHEAT,
  TEMPERATURE_STATE_UNDERHEAT
} TEMPERATURE_STATE_T;

typedef enum
{
  LED_TYPE_CRITICAL[TTT]=0,
  LED_TYPE_MAJOR=1,
  LED_TYPE_MINOR=2,
  LED_TYPE_ACTIVE=3,
  LED_TYPE_FAULTY=4,
  LED_TYPE_FAN=5,
  LED_TYPE_POWER=6,
  LED_TYPE_PORTLINK=7,
  LED_TYPE_PORTALARM=8,
  LED_TYPE_CARDMISMATCH=9,
  LED_TYPE_STANDBY=10,
  LED_TYPE_CFCARD=11,
  LED_TYPE_USRLINK=12
} LED_TYPE_T;

typedef enum
{
  LED_STATE_UNKNOWN[TTT] = -1,  
  LED_STATE_ON = 0,
  LED_STATE_OFF = 1,
  LED_STATE_BLINK = 2,
} LED_STATE_T;

typedef int BOARD_STYLE_T[TTT];

typedef enum {
  SDD_BOARD_ABSENT[TTT] = 0,
  SDD_BOARD_PRESENT = 1,
  SDD_BOARD_UNKNOWN = 2
} BOARD_PRESENCE_T;

typedef enum {
  SDD_REBOOT_STATE_START[TTT]    = 0,
  SDD_REBOOT_STATE_FINISH   = 1,
  SDD_REBOOT_STATE_UNKNOWN  = 2
} SDD_REBOOT_STATE_T;

typedef enum
{
  BOARD_EVENT_REMOVE[TTT] = 0,
  BOARD_EVENT_INSERT = 1,
  BOARD_EVENT_LATCH_ATTACH = 2,
  BOARD_EVENT_LATCH_DETATCH = 3
} BOARD_EVENT_T;

 
typedef enum
{
    SDD_RESET_UNKNOWN[TTT]       = 0,
    SDD_RESET_WARM   = 1,    
    SDD_RESET_COLD         = 2,    
    SDD_RESET_NE_WARM    = 3,    
    SDD_RESET_NE_COLD      = 4,     
    SDD_RESET_BOARD_PLUG	= 5		 
     
} SDD_RESET_REASON;

 
typedef enum
{
    SDD_BOARD_TYPE_EMPTY[TTT]        = 0,
    SDD_BOARD_TYPE_MC           = 1,
    SDD_BOARD_TYPE_CC           = 2,
    SDD_BOARD_TYPE_CHASSIS      = 3,
    SDD_BOARD_TYPE_8STM16       = 4,
    SDD_BOARD_TYPE_8STM14       = 5,
    SDD_BOARD_TYPE_2STM64       = 6,
    SDD_BOARD_TYPE_8GET         = 7,
    SDD_BOARD_TYPE_10GEA        = 8,
    SDD_BOARD_TYPE_10GET        = 9,
    SDD_BOARD_TYPE_RPR          = 10,
    SDD_BOARD_TYPE_8STM1E       = 11,
    SDD_BOARD_TYPE_8STM1EIO     = 12,
    SDD_BOARD_TYPE_12E3DS3      = 13,
    SDD_BOARD_TYPE_12E3DS3IO    = 14,
    SDD_BOARD_TYPE_126E1        = 15,
    SDD_BOARD_TYPE_126E1IO      = 16,
    SDD_BOARD_TYPE_SI           = 17,
    SDD_BOARD_TYPE_OA           = 18,
    SDD_BOARD_TYPE_PWR          = 19,
    SDD_BOARD_TYPE_FAN          = 20,
    SDD_BOARD_TYPE_1OTU         = 21,
    SDD_BOARD_TYPE_10GEL2       = 22,
    SDD_BOARD_TYPE_8STM16M      = 23,
    SDD_BOARD_TYPE_16STM14M     = 24,
    SDD_BOARD_TYPE_2STM64M      = 25,
    SDD_BOARD_TYPE_EOS          = 26,
    SDD_BOARD_TYPE_GMPLS        = 27,
    SDD_BOARD_TYPE_DATAFABRIC_CONTROLLER        = 28,
    SDD_BOARD_TYPE_DATAFABRIC   = 29,
    SDD_BOARD_TYPE_BACKPLANE    = 30,
    SDD_BOARD_TYPE_TENGE        = 31,

    SDD_BOARD_TYPE_10GEL2_46    = 32,    

    SDD_BOARD_TYPE_MAX
} SDD_BOARD_TYPE_T;

typedef enum
{
    SDD_BUTTON_EVENT_TYPE_LEDTEST[TTT],
    SDD_BUTTON_EVENT_TYPE_ALARMCUTOFF,
    SDD_BUTTON_EVENT_TYPE_ALARMSUPPRESS
}SDD_BUTTON_EVENT_TYPE;

typedef enum 
{
  BUTTON_STATE_DOWN[TTT],
  BUTTON_STATE_UP,
} BUTTON_STATE_T;

typedef enum
{
  POWER_FAIL[TTT],
  POWER_OK,
  POWER_PRESENT,
  POWER_ABSENT
} POWER_STATUS_T;

typedef enum{
    FAN_STATUS_OK[TTT],
    FAN_STATUS_FAIL,
    FAN_STATUS_ABSENT,
    FAN_STATUS_PRESENT
}FAN_STATUS_T;

typedef enum
{
    TIMING_LINE_NULL[TTT] = 0,
    TIMING_LINE_1    = 1,        
    TIMING_LINE_2    = 2            
        
}TIMING_LINE_T;

typedef enum 
{
    none[TTT]=0,
    manre=1,
    mantest=2
} ALS_MODE_STATUS_T;

typedef enum
{
    PORT_STATE_UNKNOWN[TTT] = -1,
    PORT_STATE_DIS,
    PORT_STATE_EN
} PORTADMIN_STATE_T;

typedef enum
{
    ALS_FUNC_UNKNOWN[TTT] = -1,
    ALS_FUNC_DIS,
    ALS_FUNC_EN
}ALS_FUNC_STATE_T;

typedef struct
{
    TIMING_LINE_T[TTT] port1_Line;
    TIMING_LINE_T port2_Line;
    TIMING_LINE_T port3_Line;
    TIMING_LINE_T port4_Line;
    TIMING_LINE_T port5_Line;
    TIMING_LINE_T port6_Line;
    TIMING_LINE_T port7_Line;
    TIMING_LINE_T port8_Line;
} TIMING_REF_T;


typedef enum
{
    LED_TEST_KNOWN[TTT] = -1,
    LED_TEST_BEGIN = 0,
    LED_TEST_PROC  = 1,
    LED_TEST_END   = 2
} SDD_LED_TEST_STATE_T;

 
typedef void (*SDD_BOARD_EVENT_CBACK[TTT])(BOARD_EVENT_T event,
                                    SLOT_NUMBER_T slot,
                                    BOARD_STYLE_T cardType);

typedef void (*SDD_LATCH_EVENT_CBACK[TTT])(BOARD_EVENT_T event,
                                    SLOT_NUMBER_T slot,
                                    BOARD_STYLE_T cardType);

typedef void (*SDD_ENTITY_UPDATE_CBACK[TTT])(INT16 entityNum,
                                       ENTITY_INFO_T *pInfo);


typedef void (*SDD_ONE_SECOND_TIMER_CBACK[TTT])(UINT32 counter);

typedef void (*SDD_BUTTON_EVENT_CBACK[TTT])(SDD_BUTTON_EVENT_TYPE buttonType,
                                      BUTTON_STATE_T oldState,
                                      BUTTON_STATE_T newState);                                      







 


































































 


typedef unsigned int  HW_PORT_TYPE[TTT];      
































 


typedef unsigned int  HW_ACT_PORT_TYPE[TTT];      













 


typedef UINT32[TTT] SDH_TP_TYPE;   











































 


typedef UINT8[TTT] MAGUS_TP_TYPE;







 
typedef enum 
{
    TTI_LEN_16BYTE[TTT]        = 0x1,
    TTI_LEN_64BYTE        = 0x2,
    TTI_LEN_FIXED1B       = 0x3,
    TTI_LEN_PROVISIONED1B = 0x4,
}TTI_LEN_T;




typedef int ePort_MAPPING_MODE[TTT];




typedef enum 
{
    PORT_LOOP_NONE[TTT]     = 0x1,       
    PORT_LOOP_INWARD   = 0x2,       
    PORT_LOOP_OUTWARD  = 0x3        
} PORT_LOOPBACK_T;

typedef enum
{
    TTI_TYPE_TRANSMIT[TTT]   = 0x0,
    TTI_TYPE_ACCEPTED   = 0x1,
    TTI_TYPE_CAPTURED   = 0x2,
    TTI_TYPE_EXPECTED   = 0x3
} TTI_TYPE_T;

typedef char TTI_STRING[TTT][64];

typedef enum
{
    TIM_DISABLED[TTT]    = 0x0,
    TIM_ENABLED     = 0x1
} eTIM_MODE;

typedef enum 
{
    PSL_TYPE_TRANSMIT[TTT]   = 0x0,
    PSL_TYPE_ACCEPTED   = 0x1,
    PSL_TYPE_CAPTURED   = 0x2,
    PSL_TYPE_EXPECTED   = 0x3
} PSL_TYPE_T;

typedef enum 
{
    PORT_MODE_INVALID[TTT]   = 0x0,   
    PORT_MODE_AUTO      = 0x1,   
    PORT_MODE_MON       = 0x2,   
    PORT_MODE_NMON      = 0x3    
} PORT_MODE_T;

 
typedef enum 
{
    ALARM_SOURCE[TTT]    = 0x0,
    ALARM_SINK      = 0x1
}ALARM_DIRECTION_T;

 
typedef struct
{
    UINT32[TTT]  bip;
    UINT32  fc;
    BOOL    b_lof;
    BOOL    b_ses;
} RS_PMPARA_T;

typedef struct
{
    UINT32[TTT]  bip;      
    UINT32  rei;      
    UINT32  fc;       
    UINT32  fefc;     
    BOOL    b_ses;    
    BOOL    b_fses;   
} MSHPLP_PMPARA_T;

typedef struct
{
    UINT32[TTT] npjc;
    UINT32 ppjc;
} AUTU_PMPARA_T;

typedef struct
{
    UINT32[TTT]  bip;      
    UINT32  bei;      
    UINT32  fc;       
    UINT32  fefc;     
} OTU_PMPARA_T;

typedef struct
{
    UINT32[TTT]  fec0;      
    UINT32  fec1;      
    UINT32  fecall;       
    UINT32  fecbyte;      
    UINT32  fecun;      
    UINT32  fc;     
} FEC_PMPARA_T;

typedef struct 
{
    int   nLaserIBias[TTT];
    float nVcc;                              
    int   nLaserTemp;
    int   nLaserTransPwr;
    int   nLaserRecvPwr;
    int   bCompliance8472;                    
    int   pbnNominalMBps;                     
    int   pbnWavelength;                      
    int   pbnLinkLength9125;                  
    int   pbnLinkLength50125;                 
    int   pbnLinkLength62125;                 
    int   pbnLinkLengthCopper;                
    char  pbsVendorName[20];                  
    char  pbsVendorPN[20];                    
    char  pbsVendorSN[20];                    
    char  pbsManuDate[16];                    
    PbSFFTranscCode_Tval pbnTransCode;        
    char  pbsVendorOUI[16];                   
    PbConnectorType_Tval pbnConnectorType;    
    int   pbnClLaserTemp;                    
    int   pbnTECCurrent;                     
    char  pbsSagPN[20];                      
} LASER_PARAMETER_T;

 
typedef enum 
{
    PDH_MAP_E1_VC12_TU12[TTT]    = 0x0,
    PDH_MAP_DS1_VC11_TU11   = 0x1,
    PDH_MAP_DS1_VC11_TU12   = 0x2,
    PDH_MAP_E3_LOVC3_TU3    = 0x3,
    PDH_MAP_E3_HOVC3_AU3    = 0x4,
    PDH_MAP_DS3_LOVC3_TU3   = 0x5,
    PDH_MAP_DS3_HOVC3_AU3   = 0x6
} PDH_MAPPING_T;

typedef enum
{
    LINE_CODING_HDB3[TTT]    = 0x0,
    LINE_CODING_CMI     = 0x1,
    LINE_CODING_AMI     = 0x2,
    LINE_CODING_B3ZS    = 0x3,
    LINE_CODING_B6ZS    = 0x4,
    LINE_CODING_B8ZS    = 0x5
}LINE_CODING_T;

typedef enum
{
    OHM_75_R[TTT]  = 0x0,
    OHM_120_R = 0x1,
    OHM_100_R = 0x2,
    OHM_110_R = 0x3,
}PDH_OHM_TYPE_T;

typedef enum 
{
    PDH_MAP_OPTION_ASYNC[TTT]    = 0x0,
    PDH_MAP_OPTION_BITSYNC  = 0x1,
    PDH_MAP_OPTION_BYTESYNC = 0x2
}PDH_MAP_OPTION_T;

 
typedef enum 
{
    E1_SA_BIT_4[TTT]     = 0x0,
    E1_SA_BIT_5     = 0x1,
    E1_SA_BIT_6     = 0x2,
    E1_SA_BIT_7     = 0x3,
    E1_SA_BIT_8     = 0x4
}E1_SA_BIT_T;

typedef enum 
{
    PORT_STATE_ABSENT[TTT]   = 0x0,
    PORT_STATE_UP       = 0x1,
    PORT_STATE_DOWN     = 0x2
} PORT_STATE_T;

typedef enum 
{
    LATCH_STATE_UNKNOWN[TTT]     = 0x0,
    LATCH_STATE_CLOSE       = 0x1,
    LATCH_STATE_OPEN        = 0x2,
    LATCH_STATE_CARDFAIL    = 0x3,
    LATCH_STATE_CARD_REMOVE = 0x4,
    LATCH_STATE_CARD_INSERT = 0x5
}LATCH_STATE_T;

typedef enum
{
    EOW_TYPE_NULL[TTT]   = 0x0,
    EOW_TYPE_E1     = 0x1,
    EOW_TYPE_E2     = 0x2,
    EOW_TYPE_F1     = 0x3
}EOW_TYPE_T;

typedef enum
{ 
    PDH_MODE_DS3[TTT]  = 0x0,
    PDH_MODE_E3   = 0x1,
    PDH_MODE_E1   = 0x2,
    PDH_MODE_DS1  = 0x3
}PDH_PORT_MODE_T;

typedef enum
{
    E1_STRUCTURE_INVALID[TTT]   = 0x0,
    E1_STRUCTURE_FRAMED    = 0x1,
    E1_STRUCTURE_UNFRAMED  = 0x2,
    E3_STRUCTURE_G751      = 0x3,
    E3_STRUCTURE_G832      = 0x4,
    E3_STRUCTURE_UNFRAMED  = 0x5,
    DS3_STRUCTURE_M13      = 0x6,
    DS3_STRUCTURE_CBIT     = 0x7,
    DS3_STRUCTURE_UNFRAMED = 0x8,
}PDH_FRAME_MODE_T;

 
typedef enum 
{
    PRBS_STATUS_NA[TTT]          = 0x0,
    PRBS_STATUS_SYNCING     = 0x1,
    PRBS_STATUS_SYNC_SUCC   = 0x2,
    PRBS_STATUS_SYNC_FAIL   = 0x3,
    PRBS_STATUS_SYNC_ERROR  = 0x4
} PRBS_STATUS_T;

typedef enum 
{
    PRBS_MODE_NA[TTT]      = 0x0,
    PRBS_MODE_POWER15 = 0x1,
    PRBS_MODE_POWER20 = 0x2,
    PRBS_MODE_POWER23 = 0x3,
} PRBS_MODE_T;

typedef enum 
{
    SIGNAL_TYPE_NORMAL[TTT]  = 0x1,      
    SIGNAL_TYPE_UNEQ    = 0x2,      
    SIGNAL_TYPE_AIS     = 0x3,      
    SIGNAL_TYPE_RDI     = 0x4,       
     
    SIGNAL_TYPE_PPIAIS  = 0x8
} SIGNAL_TYPE_T;

typedef enum 
{
    ALARM_INSERT_AUTO[TTT]   = 0x0,
    ALARM_INSERT_FORCE  = 0x1,
}ALARM_INSERT_WAY_T;

typedef enum
{
    DCC_TYPE_NONE[TTT]    = 0x0,
    DCC_TYPE_RS      = 0x1,
    DCC_TYPE_MS      = 0x2,
    DCC_TYPE_BOTH    = 0x3,
} DCC_TYPE_T;

typedef enum
{
    CTD_BOARD_EPGTYPE_ERROR[TTT]         = 0x0,
    CTD_BOARD_EPGTYPE_NONE          = 0x1,
    CTD_BOARD_EPGTYPE_1TON_WORK     = 0x2,
    CTD_BOARD_EPGTYPE_1TON_PROT     = 0x3,
    CTD_BOARD_EPGTYPE_1PLUS1_WORK   = 0x4,
    CTD_BOARD_EPGTYPE_1PLUS1_PROT   = 0x5,
    CTD_BOARD_EPGTYPE_1TO1_WORK     = 0x6,
    CTD_BOARD_EPGTYPE_1TO1_PROT     = 0x7
} CTD_BOARD_EPGTYPE;

 
typedef enum
{
    CTD_LOCC_NONE[TTT]    = 0x0,
    CTD_LOCC_20G     = 0x1,
    CTD_LOCC_40G     = 0x2,
}CTD_LOCC_MODE_T;

 
typedef enum
{
    CTD_CARD_UNKNOWN[TTT]    = 0x0,
    CTD_CARD_ACTIVE     = 0x1,
    CTD_CARD_STANDBY    = 0x2,
}CTD_CARD_STATE_T;

 
typedef enum
{
    CTD_FEC_ERR_NONE[TTT]    = 0x0,
    CTD_FEC_ERR_E3      = 0x3,
    CTD_FEC_ERR_E4      = 0x4,
    CTD_FEC_ERR_E5      = 0x5,
}CTD_FEC_INSERT_RATE_T;

 












 









 











typedef struct 
{
    char   *name[TTT];
    UINT32  style;           
    UINT32  option;          
    UINT32  totalPortNum;    
    UINT32  portIdRange[(29 ) ][2];   



    UINT32  dataPortNum[2];  
} CTD_BOARD_INFO_T;

 













































 
 






 


 













typedef UINT16[TTT] TU_TP_T;

 


 





























typedef UINT32[TTT] AU_TP_T;

 



 







typedef UINT32[TTT] COMPACT_TP_T;






 






 




 









 


typedef struct
{
     
    SDH_TP_TYPE[TTT] eTpType;

     
    UINT32 E: 4,
           D: 4,
           C: 4,
           B: 4,
           A: 4,
           K: 4,
           L: 4,
           M: 4;        
}__attribute__ ((packed))  TP_INDEX_T;  

 


 
















typedef UINT16[TTT] SDH_TUG3_MAPPING_T;



typedef UINT8[TTT] SDH_TUG2_MAPPING_T;




 


typedef UINT16[TTT] SDH_VC3H_MAPPING_T;

 







 









typedef struct
{
    



    BOOL[TTT] b_clr;
    SDH_TUG3_MAPPING_T tug3[3];
} SDH_VC4_MAPPING_T;

typedef struct
{
    



    BOOL[TTT] b_au4;

    union
    {
         
        SDH_VC4_MAPPING_T vc4;
 
         
        SDH_VC3H_MAPPING_T vc3h[3];
    } hovc;
} SDH_AUG1_MAPPING_T;

typedef struct
{
    



    BOOL[TTT] b_4c;
 
    SDH_AUG1_MAPPING_T aug1[4];
} SDH_AUG4_MAPPING_T;

typedef struct
{
    



    BOOL[TTT] b_16c;
 
    SDH_AUG4_MAPPING_T aug4[4];
} SDH_AUG16_MAPPING_T;

typedef struct
{
    



    BOOL[TTT] b_64c;

    SDH_AUG16_MAPPING_T aug16[4];
} SDH_AUG64_MAPPING_T;

typedef struct
{
    



    BOOL[TTT] b_256c;

    SDH_AUG64_MAPPING_T aug64[4];
} SDH_AUG256_MAPPING_T;

extern void CTD_InitModule();
extern UINT32 CTD_GetPortTotalNumber(SLOT_NUMBER_T slot);
extern UINT32 CTD_GetPortNumber(SLOT_NUMBER_T slot, HW_PORT_TYPE type);
extern UINT32 CTD_GetPortBegin(SLOT_NUMBER_T slot, HW_PORT_TYPE type);
extern UINT32 CTD_GetBoardStyle(SLOT_NUMBER_T slot);
extern UINT32 CTD_GetBoardOption(SLOT_NUMBER_T slot);
extern PB_ERROR_CODE_T CTD_SetBoardInfo(SLOT_NUMBER_T slot, UINT32 ulStyle, UINT32 ulOption);
extern PB_ERROR_CODE_T CTD_GetPortType(SLOT_NUMBER_T slot, UINT8 *pucTypeNum, HW_PORT_TYPE *pePortType);
extern SLOT_NUMBER_T CTD_InstanceToSlot(INSTANCE_T inst);
extern INSTANCE_T CTD_SlotToInstance(SLOT_NUMBER_T slot);
extern UINT32 CTD_GetRelativePortId(SLOT_NUMBER_T slot, UINT32 port);
extern UINT32 CTD_GetAbsolutePortId(SLOT_NUMBER_T slot, HW_PORT_TYPE pType, UINT32 port);
extern CTD_BOARD_EPGTYPE CTD_GetBoardEpgType(SLOT_NUMBER_T slot);
extern CARDTYPE_T CTD_BoardStyleToCardType(PbBoardStyle_Tval boardStyle);
extern PORT_LOOPBACK_T CTD_TransToCdhLoopType(pbPortLoopback_Tval  eLoopbackType);
extern PB_ERROR_CODE_T CTD_TransToCdhMap(PORT_MAPPING_T *pTug3Map, void *pCdhMap);
extern PB_ERROR_CODE_T CTD_TransToCdhTp(const TP_INDEX_T *pTpIndex, COMPACT_TP_T *pTpId);
extern SDH_TP_TYPE CTD_GetTpType(const TP_INDEX_T *pTpIndex);
extern TTI_LEN_T CTD_TransToCdhTtiMode(PbTIModeType_Tval mode);
extern SIGNAL_TYPE_T CTD_TransToCdhSigType(PbSignalType_Tval signalType);
extern LATCH_STATE_T CTD_TransToCdhLatchState(PbEpgFunctionCardStatus_Tval eState);
extern PbEpgFunctionCardStatus_Tval CTD_TransToExLatchState(LATCH_STATE_T eState);
extern PRBS_MODE_T CTD_TransToCdhPrbsMode(pbPRBSPattern_Tval prbsPattern);
extern PbPortOperationStatus_Tval CTD_TransToExPortState(PORT_STATE_T cdhPortState);
extern const char* CTD_GetLedStateName(LED_STATE_T state);
extern PDH_FRAME_MODE_T CTD_TransToCdhFrameMode(expectedFrameStructure_Tval eFrameMode);
extern UINT32 CTD_TransToCdhPortType(HW_ACT_PORT_TYPE ePortType);
extern PORT_LOOPBACK_T CTD_TransToOtuLoopType(pbOTUPortLoopback_Tval eLoopbackType);
extern CTD_FEC_INSERT_RATE_T CTD_TransToOtuFecErrRate(pbInsFecErrRate_Tval InsFecErrRate);
extern CTD_CARD_STATE_T CTD_GetXcState();
extern PB_ERROR_CODE_T CTD_SetXcState(BOOL bCardState);
extern const char* CTD_GetCardName(SLOT_NUMBER_T slot);

extern CTD_BOARD_INFO_T ctd_boardInfo[];








 














































































































 


















 

 
 

 



















































 

 

 

























 

 

 




































 

 

 







 
































 








































 



 

	 












	 


















 






 



 






 



 


 




 




extern int *	__errno(void);























 









 

typedef struct obj_core[TTT]  *OBJ_ID;		 


 

















 



extern STATUS 	objShow (OBJ_ID objId, int showType);















 

 

 






















































 







 



typedef struct mem_part[TTT] *PART_ID;

 

typedef struct
    {

    unsigned long numBytesFree[TTT],	    
		  numBlocksFree,    
		  maxBlockSizeFree, 
		  numBytesAlloc,    
		  numBlocksAlloc;   

    }  MEM_PART_STATS;


 

 



 




 




 






 









 

 

extern PART_ID memSysPartId;

 

extern FUNCPTR  smMemPartOptionsSetRtn;
extern FUNCPTR  smMemPartFindMaxRtn;
extern FUNCPTR  smMemPartReallocRtn;
extern FUNCPTR  smMemPartShowRtn;

 



extern STATUS 	memInit (char *pPool, unsigned poolSize);
extern STATUS 	memPartLibInit (char *pPool, unsigned poolSize);
extern PART_ID 	memPartCreate (char *pPool, unsigned poolSize);
extern void 	memPartInit (PART_ID partId, char *pPool, unsigned poolSize);
extern STATUS 	memPartAddToPool (PART_ID partId, char *pPool,
				  unsigned poolSize);
extern void 	memAddToPool (char *pPool, unsigned poolSize);
extern void *	memPartAlloc (PART_ID partId, unsigned nBytes);
extern void *   memPartAlignedAlloc (PART_ID partId, unsigned nBytes,
				     unsigned alignment);
extern void *	memalign (unsigned alignment, unsigned size);
extern void *   valloc (unsigned size);
extern STATUS 	memPartFree (PART_ID partId, char *pBlock);
extern STATUS 	memPartOptionsSet (PART_ID partId, unsigned options);
extern int 	memFindMax (void);
extern int 	memPartFindMax (PART_ID partId);
extern void *	memPartRealloc (PART_ID partId, char *pBlock, unsigned nBytes);
extern void 	memOptionsSet (unsigned options);
extern STATUS 	cfree (char *pBlock);
extern void 	memShowInit (void);
extern void 	memShow (int type);
extern STATUS 	memPartShow (PART_ID partId, int type);
extern STATUS   memPartInfoGet (PART_ID	partId, MEM_PART_STATS * ppartStats);












 






typedef struct obj_class[TTT] *CLASS_ID;		 

extern CLASS_ID classClassId;			 

 



extern STATUS 	classLibInit (void);
extern STATUS 	classMemPartIdSet (CLASS_ID classId, PART_ID memPartId);
extern void 	classShowInit (void);
extern STATUS 	classShow (CLASS_ID classId, int level);



















 

 

 


























typedef struct obj_core[TTT]		 
    {
    struct obj_class *pObjClass;	 
    } OBJ_CORE;






 



extern OBJ_ID 	objCreate (CLASS_ID classId, ...);
extern STATUS 	objInit (CLASS_ID classId, OBJ_ID objId, ...);
extern STATUS 	objDelete (OBJ_ID objId);
extern STATUS 	objDestroy (OBJ_ID objId, BOOL dealloc, int timeout);
extern STATUS 	objFree (CLASS_ID classId, char *pObject);
extern STATUS 	objTerminate (OBJ_ID objId);
extern void *	objAlloc (CLASS_ID classId);
extern void *	objAllocExtra (CLASS_ID classId, unsigned nExtraBytes,
			       void ** ppExtra);
extern void 	objCoreInit (OBJ_CORE *pObjCore, CLASS_ID pObjClass);
extern void 	objCoreTerminate (OBJ_CORE *pObjCore);











 

 
 























 









typedef struct obj_class[TTT]	 
    {
    OBJ_CORE		objCore;	 
    struct mem_part	*objPartId;	 
    unsigned		objSize;	 
    unsigned		objAllocCnt;	 
    unsigned		objFreeCnt;	 
    unsigned		objInitCnt;	 
    unsigned		objTerminateCnt; 
    int			coreOffset;	 
    FUNCPTR		createRtn;	 
    FUNCPTR		initRtn;	 
    FUNCPTR		destroyRtn;	 
    FUNCPTR		showRtn;	 
    FUNCPTR		instRtn;	 
    } OBJ_CLASS;


 



extern CLASS_ID	classCreate (unsigned objectSize, int coreOffset,
			     FUNCPTR createRtn, FUNCPTR initRtn,
			     FUNCPTR destroyRtn);
extern STATUS	classInit (OBJ_CLASS *pObjClass, unsigned objectSize,
			   int coreOffset, FUNCPTR createRtn, FUNCPTR initRtn,
			   FUNCPTR destroyRtn);
extern STATUS	classDestroy (CLASS_ID classId);
extern STATUS	classInstConnect (CLASS_ID classId, FUNCPTR instRtn);
extern STATUS	classShowConnect (CLASS_ID classId, FUNCPTR showRtn);
extern STATUS   classInstrument ( OBJ_CLASS * pObjClass, 
				  OBJ_CLASS * pObjInstClass );











   









 








































 



 
 







 



 

typedef struct __va_list_tag[TTT] {
  unsigned char gpr;		 


  unsigned char fpr;		 


  char *overflow_arg_area;	 

  char *reg_save_area;		 
} __va_list[1], __gnuc_va_list[1];









 



 


typedef struct {
  long   __gp_save[TTT][8];		 
  double __fp_save[8];		 
} __va_regsave_t;

 
 









 









 























 
















 





















 
 















 




 

 

 

typedef __gnuc_va_list[TTT] va_list;





























 

struct __sbuf 			 
    {
    uchar_t * _base;		 
    int	      _size;		 
    };

typedef	struct __sFILE[TTT]
    {
    OBJ_CORE		objCore;	 
    uchar_t *		_p;		 
    int			_r;		 
    int			_w;		 
    short		_flags;		 
    short		_file;		 
    struct __sbuf	_bf;		 
    int			_lbfsize;	 
    struct __sbuf	_ub;		 
    uchar_t *		_up;		 
    int			_ur;		 
    uchar_t		_ubuf[3];	 
    uchar_t		_nbuf[1];	 
    struct __sbuf	_lb;		 
    int			_blksize;	 
    int			_offset;	 
    int			taskId;		 
    } FILE;

 

extern CLASS_ID fpClassId;		 

 

























































extern void	clearerr (FILE *);
extern int	fclose (FILE *);
extern int	feof (FILE *);
extern int	ferror (FILE *);
extern int	fflush (FILE *);
extern int	fgetc (FILE *);
extern int	fgetpos (FILE *, fpos_t *);
extern char *	fgets (char *, size_t, FILE *);
extern FILE *	fopen (const char *, const char *);
extern int	fprintf (FILE *, const char *, ...);
extern int	fputc (int, FILE *);
extern int	fputs (const char *, FILE *);
extern int	fread (void *, size_t, size_t, FILE *);
extern FILE *	freopen (const char *, const char *, FILE *);
extern int	fscanf (FILE *, const char *, ...);
extern int	fseek (FILE *, long, int);
extern int	fsetpos (FILE *, const fpos_t *);
extern long	ftell (FILE *);
extern int	fwrite (const void *, size_t, size_t, FILE *);
extern int	getc (FILE *);
extern int	getchar (void);
extern char *	gets (char *);
extern void	perror (const char *);
extern int	printf (const char *, ...);
extern int	putc (int, FILE *);
extern int	putchar (int);
extern int	puts (const char *);
extern int	remove (const char *);
extern int	rename  (const char *, const char *);
extern void	rewind (FILE *);
extern int	scanf (const char *, ...);
extern void	setbuf (FILE *, char *);
extern int	setvbuf (FILE *, char *, int, size_t);
extern int	sprintf (char *, const char *, ...);
extern int	sscanf (const char *, const char *, ...);
extern FILE *	tmpfile (void);
extern char *	tmpnam (char *);
extern int	ungetc (int, FILE *);
extern int	vfprintf (FILE *, const char *, va_list);
extern int	vprintf (const char *, va_list);
extern int	vsprintf (char *, const char *, va_list);
extern int	__srget (FILE *);		 
extern int	__swbuf (int, FILE *);		 

 

extern FILE *	fdopen (int, const char *);
extern int	fileno (FILE *);

 

 



extern int	fdprintf (int fd, const char *fmt, ...);
extern int	vfdprintf (int fd, const char *fmt, va_list ap);
extern int	printErr (const char *fmt, ...);
extern int	getw (FILE *);
extern int	putw (int, FILE *);
extern void	setbuffer (FILE *, char *, int);
extern int	setlinebuf (FILE *);
extern FILE *   stdioFp (int std);
extern STATUS   stdioShow (FILE * fp, int level);
extern STATUS   stdioShowInit (void);
extern STATUS   stdioInit (void);






 


extern FILE **	__stdin(void);		 
extern FILE **	__stdout(void);		 
extern FILE **	__stderr(void);		 











 












































 


















 

























 












 






 






 












 















 






















 














 









    typedef void *ClientData[TTT];






 


















typedef struct Tcl_Interp[TTT] {
    char *result;		 

    void (*freeProc)  (char *blockPtr)  ;
				 






    int errorLine;               


} Tcl_Interp;

typedef struct Tcl_AsyncHandler_[TTT] *Tcl_AsyncHandler;
typedef struct Tcl_Channel_[TTT] *Tcl_Channel;
typedef struct Tcl_Command_[TTT] *Tcl_Command;
typedef struct Tcl_Event[TTT] Tcl_Event;
typedef struct Tcl_Pid_[TTT] *Tcl_Pid;
typedef struct Tcl_RegExp_[TTT] *Tcl_RegExp;
typedef struct Tcl_TimerToken_[TTT] *Tcl_TimerToken;
typedef struct Tcl_Trace_[TTT] *Tcl_Trace;
typedef struct Tcl_Var_[TTT] *Tcl_Var;

 




























 



typedef enum {TCL_INT[TTT], TCL_DOUBLE, TCL_EITHER} Tcl_ValueType;
typedef struct Tcl_Value[TTT] {
    Tcl_ValueType type;		 

    long intValue;		 
    double doubleValue;		 
} Tcl_Value;

 





struct Tcl_Obj;

 



typedef int (Tcl_AppInitProc[TTT])  (Tcl_Interp *interp)  ;
typedef int (Tcl_AsyncProc[TTT])  (ClientData clientData,
	Tcl_Interp *interp, int code)  ;
typedef void (Tcl_ChannelProc[TTT])  (ClientData clientData, int mask)  ;
typedef void (Tcl_CloseProc[TTT])  (ClientData data)  ;
typedef void (Tcl_CmdDeleteProc[TTT])  (ClientData clientData)  ;
typedef int (Tcl_CmdProc[TTT])  (ClientData clientData,
	Tcl_Interp *interp, int argc, char *argv[])  ;
typedef void (Tcl_CmdTraceProc[TTT])  (ClientData clientData,
	Tcl_Interp *interp, int level, char *command, Tcl_CmdProc *proc,
	ClientData cmdClientData, int argc, char *argv[])  ;
typedef void (Tcl_DupInternalRepProc[TTT])  (struct Tcl_Obj *srcPtr, 
        struct Tcl_Obj *dupPtr)  ;
typedef int (Tcl_EventProc[TTT])  (Tcl_Event *evPtr, int flags)  ;
typedef void (Tcl_EventCheckProc[TTT])  (ClientData clientData,
	int flags)  ;
typedef int (Tcl_EventDeleteProc[TTT])  (Tcl_Event *evPtr,
        ClientData clientData)  ;
typedef void (Tcl_EventSetupProc[TTT])  (ClientData clientData,
	int flags)  ;
typedef void (Tcl_ExitProc[TTT])  (ClientData clientData)  ;
typedef void (Tcl_FileProc[TTT])  (ClientData clientData, int mask)  ;
typedef void (Tcl_FileFreeProc[TTT])  (ClientData clientData)  ;
typedef void (Tcl_FreeInternalRepProc[TTT])  (struct Tcl_Obj *objPtr)  ;
typedef void (Tcl_FreeProc[TTT])  (char *blockPtr)  ;
typedef void (Tcl_IdleProc[TTT])  (ClientData clientData)  ;
typedef void (Tcl_InterpDeleteProc[TTT])  (ClientData clientData,
	Tcl_Interp *interp)  ;
typedef int (Tcl_MathProc[TTT])  (ClientData clientData,
	Tcl_Interp *interp, Tcl_Value *args, Tcl_Value *resultPtr)  ;
typedef void (Tcl_NamespaceDeleteProc[TTT])  (ClientData clientData)  ;
typedef int (Tcl_ObjCmdProc[TTT])  (ClientData clientData,
	Tcl_Interp *interp, int objc, struct Tcl_Obj * const  objv[])  ;
typedef int (Tcl_PackageInitProc[TTT])  (Tcl_Interp *interp)  ;
typedef void (Tcl_TcpAcceptProc[TTT])  (ClientData callbackData,
        Tcl_Channel chan, char *address, int port)  ;
typedef void (Tcl_TimerProc[TTT])  (ClientData clientData)  ;
typedef int (Tcl_SetFromAnyProc[TTT])  (Tcl_Interp *interp,
	struct Tcl_Obj *objPtr)  ;
typedef void (Tcl_UpdateStringProc[TTT])  (struct Tcl_Obj *objPtr)  ;
typedef char *(Tcl_VarTraceProc[TTT])  (ClientData clientData,
	Tcl_Interp *interp, char *part1, char *part2, int flags)  ;

 





typedef struct Tcl_ObjType[TTT] {
    char *name;			 
    Tcl_FreeInternalRepProc *freeIntRepProc;
				 


    Tcl_DupInternalRepProc *dupIntRepProc;
    				 

    Tcl_UpdateStringProc *updateStringProc;
    				 

    Tcl_SetFromAnyProc *setFromAnyProc;
    				 



} Tcl_ObjType;

 





typedef struct Tcl_Obj[TTT] {
    int refCount;		 
    char *bytes;		 










    int length;			 

    Tcl_ObjType *typePtr;	 



    union {			 
	long longValue;		 
	double doubleValue;	 
	void  *otherValuePtr;	 
	struct {		 
	    void  *ptr1;
	    void  *ptr2;
	} twoPtrValue;
    } internalRep;
} Tcl_Obj;

 










extern  void		Tcl_IncrRefCount  (Tcl_Obj *objPtr)  ;
extern  void		Tcl_DecrRefCount  (Tcl_Obj *objPtr)  ;
extern  int		Tcl_IsShared  (Tcl_Obj *objPtr)  ;

















 





extern  Tcl_Obj *	Tcl_NewBooleanObj  (int boolValue)  ;
extern  Tcl_Obj *	Tcl_NewDoubleObj  (double doubleValue)  ;
extern  Tcl_Obj *	Tcl_NewIntObj  (int intValue)  ;
extern  Tcl_Obj *	Tcl_NewListObj  (int objc,
			    Tcl_Obj * const  objv[])  ;
extern  Tcl_Obj *	Tcl_NewLongObj  (long longValue)  ;
extern  Tcl_Obj *	Tcl_NewObj  (void)  ;
extern  Tcl_Obj *	Tcl_NewStringObj  (char *bytes,
			    int length)  ;



 





typedef struct Tcl_Namespace[TTT] {
    char *name;                  



    char *fullName;              

    ClientData clientData;       

    Tcl_NamespaceDeleteProc* deleteProc;
                                 

    struct Tcl_Namespace* parentPtr;
                                 


} Tcl_Namespace;

 





















typedef struct Tcl_CallFrame[TTT] {
    Tcl_Namespace *nsPtr;
    int dummy1;
    int dummy2;
    char *dummy3;
    char *dummy4;
    char *dummy5;
    int dummy6;
    char *dummy7;
    char *dummy8;
    int dummy9;
    char* dummy10;
} Tcl_CallFrame;

 













     
typedef struct Tcl_CmdInfo[TTT] {
    int isNativeObjectProc;	  



    Tcl_ObjCmdProc *objProc;	  
    ClientData objClientData;	  
    Tcl_CmdProc *proc;		  
    ClientData clientData;	  
    Tcl_CmdDeleteProc *deleteProc;
                                  

    ClientData deleteData;	  

    Tcl_Namespace *namespacePtr;  




} Tcl_CmdInfo;

 






typedef struct Tcl_DString[TTT] {
    char *string;		 

    int length;			 

    int spaceAvl;		 

    char staticSpace[200 ];
				 

} Tcl_DString;





 




 



 







 






 








 








 















 









 





extern  char *		Tcl_Alloc  (unsigned int size)  ;
extern  void		Tcl_Free  (char *ptr)  ;
extern  char *		Tcl_Realloc  (char *ptr,
			    unsigned int size)  ;

















 









 





typedef struct Tcl_HashEntry[TTT] {
    struct Tcl_HashEntry *nextPtr;	 


    struct Tcl_HashTable *tablePtr;	 
    struct Tcl_HashEntry **bucketPtr;	 


    ClientData clientData;		 

    union {				 
	char *oneWordValue;		 
	int words[1];			 



	char string[4];			 


    } key;				 
} Tcl_HashEntry;

 






typedef struct Tcl_HashTable[TTT] {
    Tcl_HashEntry **buckets;		 


    Tcl_HashEntry *staticBuckets[4 ];
					 

    int numBuckets;			 

    int numEntries;			 

    int rebuildSize;			 

    int downShift;			 


    int mask;				 

    int keyType;			 





    Tcl_HashEntry *(*findProc)  (struct Tcl_HashTable *tablePtr, 
	    const  char *key)  ;
    Tcl_HashEntry *(*createProc)  (struct Tcl_HashTable *tablePtr,
	    const  char *key, int *newPtr)  ;
} Tcl_HashTable;

 




typedef struct Tcl_HashSearch[TTT] {
    Tcl_HashTable *tablePtr;		 
    int nextIndex;			 

    Tcl_HashEntry *nextEntryPtr;	 

} Tcl_HashSearch;

 






 









 









 











 









struct Tcl_Event {
    Tcl_EventProc *proc;	 
    struct Tcl_Event *nextPtr;	 
};

 



typedef enum {
    TCL_QUEUE_TAIL[TTT], TCL_QUEUE_HEAD, TCL_QUEUE_MARK
} Tcl_QueuePosition;

 







 






typedef struct Tcl_Time[TTT] {
    long sec;			 
    long usec;			 
} Tcl_Time;

 








 










 



typedef int	(Tcl_DriverBlockModeProc[TTT])  (
		    ClientData instanceData, int mode)  ;
typedef int	(Tcl_DriverCloseProc[TTT])  (ClientData instanceData,
		    Tcl_Interp *interp)  ;
typedef int	(Tcl_DriverInputProc[TTT])  (ClientData instanceData,
		    char *buf, int toRead, int *errorCodePtr)  ;
typedef int	(Tcl_DriverOutputProc[TTT])  (ClientData instanceData,
		    char *buf, int toWrite, int *errorCodePtr)  ;
typedef int	(Tcl_DriverSeekProc[TTT])  (ClientData instanceData,
		    long offset, int mode, int *errorCodePtr)  ;
typedef int	(Tcl_DriverSetOptionProc[TTT])  (
		    ClientData instanceData, Tcl_Interp *interp,
	            char *optionName, char *value)  ;
typedef int	(Tcl_DriverGetOptionProc[TTT])  (
		    ClientData instanceData, Tcl_Interp *interp,
		    char *optionName, Tcl_DString *dsPtr)  ;
typedef void	(Tcl_DriverWatchProc[TTT])  (
		    ClientData instanceData, int mask)  ;
typedef int	(Tcl_DriverGetHandleProc[TTT])  (
		    ClientData instanceData, int direction,
		    ClientData *handlePtr)  ;

 



typedef enum Tcl_EolTranslation[TTT] {
    TCL_TRANSLATE_AUTO,			 
    TCL_TRANSLATE_CR,			 
    TCL_TRANSLATE_LF,			 
    TCL_TRANSLATE_CRLF			 
} Tcl_EolTranslation;

 







typedef struct Tcl_ChannelType[TTT] {
    char *typeName;			 


    Tcl_DriverBlockModeProc *blockModeProc;
    					 

    Tcl_DriverCloseProc *closeProc;	 

    Tcl_DriverInputProc *inputProc;	 

    Tcl_DriverOutputProc *outputProc;	 

    Tcl_DriverSeekProc *seekProc;	 

    Tcl_DriverSetOptionProc *setOptionProc;
    					 
    Tcl_DriverGetOptionProc *getOptionProc;
    					 
    Tcl_DriverWatchProc *watchProc;	 

    Tcl_DriverGetHandleProc *getHandleProc;
					 

} Tcl_ChannelType;

 









 



typedef enum Tcl_PathType[TTT] {
    TCL_PATH_ABSOLUTE,
    TCL_PATH_RELATIVE,
    TCL_PATH_VOLUME_RELATIVE
} Tcl_PathType;

 



extern  void		Tcl_AddErrorInfo  (Tcl_Interp *interp,
			    char *message)  ;
extern  void		Tcl_AddObjErrorInfo  (Tcl_Interp *interp,
			    char *message, int length)  ;
extern  void		Tcl_AllowExceptions  (Tcl_Interp *interp)  ;
extern  int		Tcl_AppendAllObjTypes  (
			    Tcl_Interp *interp, Tcl_Obj *objPtr)  ;
extern  void		Tcl_AppendElement  (Tcl_Interp *interp,
			    char *string)  ;
extern  void		Tcl_AppendResult  
			    ( Tcl_Interp *   interp , ...)   ;
extern  void		Tcl_AppendToObj  (Tcl_Obj *objPtr,
			    char *bytes, int length)  ;
extern  void		Tcl_AppendStringsToObj  
			    ( Tcl_Obj *   interp , ...)   ;
extern  int		Tcl_AppInit  (Tcl_Interp *interp)  ;
extern  Tcl_AsyncHandler	Tcl_AsyncCreate  (Tcl_AsyncProc *proc,
			    ClientData clientData)  ;
extern  void		Tcl_AsyncDelete  (Tcl_AsyncHandler async)  ;
extern  int		Tcl_AsyncInvoke  (Tcl_Interp *interp,
			    int code)  ;
extern  void		Tcl_AsyncMark  (Tcl_AsyncHandler async)  ;
extern  int		Tcl_AsyncReady  (void)  ;
extern  void		Tcl_BackgroundError  (Tcl_Interp *interp)  ;
extern  char		Tcl_Backslash  (const  char *src,
			    int *readPtr)  ;
extern  int		Tcl_BadChannelOption  (Tcl_Interp *interp,
			    char *optionName, char *optionList)  ;
extern  void		Tcl_CallWhenDeleted  (Tcl_Interp *interp,
			    Tcl_InterpDeleteProc *proc,
			    ClientData clientData)  ;
extern  void		Tcl_CancelIdleCall  (Tcl_IdleProc *idleProc,
			    ClientData clientData)  ;



extern  int		Tcl_Close  (Tcl_Interp *interp,
        		    Tcl_Channel chan)  ;
extern  int		Tcl_CommandComplete  (char *cmd)  ;
extern  char *		Tcl_Concat  (int argc, char **argv)  ;
extern  Tcl_Obj *	Tcl_ConcatObj  (int objc,
			    Tcl_Obj * const  objv[])  ;
extern  int		Tcl_ConvertCountedElement  (const  char *src,
			    int length, char *dst, int flags)  ;
extern  int		Tcl_ConvertElement  (const  char *src,
			    char *dst, int flags)  ;
extern  int		Tcl_ConvertToType  (Tcl_Interp *interp,
			    Tcl_Obj *objPtr, Tcl_ObjType *typePtr)  ;
extern  int		Tcl_CreateAlias  (Tcl_Interp *slave,
			    char *slaveCmd, Tcl_Interp *target,
        		    char *targetCmd, int argc, char **argv)  ;
extern  int		Tcl_CreateAliasObj  (Tcl_Interp *slave,
			    char *slaveCmd, Tcl_Interp *target,
        		    char *targetCmd, int objc,
		            Tcl_Obj * const  objv[])  ;
extern  Tcl_Channel	Tcl_CreateChannel  (
    			    Tcl_ChannelType *typePtr, char *chanName,
                            ClientData instanceData, int mask)  ;
extern  void		Tcl_CreateChannelHandler  (
			    Tcl_Channel chan, int mask,
                            Tcl_ChannelProc *proc, ClientData clientData)  ;
extern  void		Tcl_CreateCloseHandler  (
			    Tcl_Channel chan, Tcl_CloseProc *proc,
                            ClientData clientData)  ;
extern  Tcl_Command	Tcl_CreateCommand  (Tcl_Interp *interp,
			    char *cmdName, Tcl_CmdProc *proc,
			    ClientData clientData,
			    Tcl_CmdDeleteProc *deleteProc)  ;
extern  void		Tcl_CreateEventSource  (
			    Tcl_EventSetupProc *setupProc,
			    Tcl_EventCheckProc *checkProc,
			    ClientData clientData)  ;
extern  void		Tcl_CreateExitHandler  (Tcl_ExitProc *proc,
			    ClientData clientData)  ;
extern  void		Tcl_CreateFileHandler  (
    			    int fd, int mask, Tcl_FileProc *proc,
			    ClientData clientData)  ;
extern  Tcl_Interp *	Tcl_CreateInterp  (void)  ;
extern  void		Tcl_CreateMathFunc  (Tcl_Interp *interp,
			    char *name, int numArgs, Tcl_ValueType *argTypes,
			    Tcl_MathProc *proc, ClientData clientData)  ;
extern  Tcl_Command	Tcl_CreateObjCommand  (
			    Tcl_Interp *interp, char *cmdName,
			    Tcl_ObjCmdProc *proc, ClientData clientData,
			    Tcl_CmdDeleteProc *deleteProc)  ;
extern  Tcl_Interp *	Tcl_CreateSlave  (Tcl_Interp *interp,
		            char *slaveName, int isSafe)  ;
extern  Tcl_TimerToken	Tcl_CreateTimerHandler  (int milliseconds,
			    Tcl_TimerProc *proc, ClientData clientData)  ;
extern  Tcl_Trace	Tcl_CreateTrace  (Tcl_Interp *interp,
			    int level, Tcl_CmdTraceProc *proc,
			    ClientData clientData)  ;
extern  char *		Tcl_DbCkalloc  (unsigned int size,
			    char *file, int line)  ;
extern  int		Tcl_DbCkfree  (char *ptr,
			    char *file, int line)  ;
extern  char *		Tcl_DbCkrealloc  (char *ptr,
			    unsigned int size, char *file, int line)  ;
extern  void		Tcl_DbDecrRefCount  (Tcl_Obj *objPtr,
			    char *file, int line)  ;
extern  void		Tcl_DbIncrRefCount  (Tcl_Obj *objPtr,
			    char *file, int line)  ;
extern  int		Tcl_DbIsShared  (Tcl_Obj *objPtr,
			    char *file, int line)  ;
extern  Tcl_Obj *	Tcl_DbNewBooleanObj  (int boolValue,
                            char *file, int line)  ;
extern  Tcl_Obj *	Tcl_DbNewDoubleObj  (double doubleValue,
                            char *file, int line)  ;
extern  Tcl_Obj *	Tcl_DbNewListObj  (int objc,
			    Tcl_Obj * const  objv[], char *file, int line)  ;
extern  Tcl_Obj *	Tcl_DbNewLongObj  (long longValue,
                            char *file, int line)  ;
extern  Tcl_Obj *	Tcl_DbNewObj  (char *file, int line)  ;
extern  Tcl_Obj *	Tcl_DbNewStringObj  (char *bytes,
			    int length, char *file, int line)  ;
extern  void		Tcl_DeleteAssocData  (Tcl_Interp *interp,
                            char *name)  ;
extern  int		Tcl_DeleteCommand  (Tcl_Interp *interp,
			    char *cmdName)  ;
extern  int		Tcl_DeleteCommandFromToken  (
			    Tcl_Interp *interp, Tcl_Command command)  ;
extern  void		Tcl_DeleteChannelHandler  (
    			    Tcl_Channel chan, Tcl_ChannelProc *proc,
                            ClientData clientData)  ;
extern  void		Tcl_DeleteCloseHandler  (
			    Tcl_Channel chan, Tcl_CloseProc *proc,
                            ClientData clientData)  ;
extern  void		Tcl_DeleteEvents  (
			    Tcl_EventDeleteProc *proc,
                            ClientData clientData)  ;
extern  void		Tcl_DeleteEventSource  (
			    Tcl_EventSetupProc *setupProc,
			    Tcl_EventCheckProc *checkProc,
			    ClientData clientData)  ;
extern  void		Tcl_DeleteExitHandler  (Tcl_ExitProc *proc,
			    ClientData clientData)  ;
extern  void		Tcl_DeleteFileHandler  (int fd)  ;
extern  void		Tcl_DeleteHashEntry  (
			    Tcl_HashEntry *entryPtr)  ;
extern  void		Tcl_DeleteHashTable  (
			    Tcl_HashTable *tablePtr)  ;
extern  void		Tcl_DeleteInterp  (Tcl_Interp *interp)  ;
extern  void		Tcl_DeleteTimerHandler  (
			    Tcl_TimerToken token)  ;
extern  void		Tcl_DeleteTrace  (Tcl_Interp *interp,
			    Tcl_Trace trace)  ;
extern  void		Tcl_DetachPids  (int numPids, Tcl_Pid *pidPtr)  ;
extern  void		Tcl_DontCallWhenDeleted  (
			    Tcl_Interp *interp, Tcl_InterpDeleteProc *proc,
			    ClientData clientData)  ;
extern  int		Tcl_DoOneEvent  (int flags)  ;
extern  void		Tcl_DoWhenIdle  (Tcl_IdleProc *proc,
			    ClientData clientData)  ;
extern  char *		Tcl_DStringAppend  (Tcl_DString *dsPtr,
			    const  char *string, int length)  ;
extern  char *		Tcl_DStringAppendElement  (
			    Tcl_DString *dsPtr, const  char *string)  ;
extern  void		Tcl_DStringEndSublist  (Tcl_DString *dsPtr)  ;
extern  void		Tcl_DStringFree  (Tcl_DString *dsPtr)  ;
extern  void		Tcl_DStringGetResult  (Tcl_Interp *interp,
			    Tcl_DString *dsPtr)  ;
extern  void		Tcl_DStringInit  (Tcl_DString *dsPtr)  ;
extern  void		Tcl_DStringResult  (Tcl_Interp *interp,
			    Tcl_DString *dsPtr)  ;
extern  void		Tcl_DStringSetLength  (Tcl_DString *dsPtr,
			    int length)  ;
extern  void		Tcl_DStringStartSublist  (
			    Tcl_DString *dsPtr)  ;
extern  Tcl_Obj *	Tcl_DuplicateObj  (Tcl_Obj *objPtr)  ;
extern  int		Tcl_Eof  (Tcl_Channel chan)  ;
extern  char *		Tcl_ErrnoId  (void)  ;
extern  char *		Tcl_ErrnoMsg  (int err)  ;
extern  int		Tcl_Eval  (Tcl_Interp *interp,
			    char *string)  ;
extern  int		Tcl_EvalFile  (Tcl_Interp *interp,
			    char *fileName)  ;
extern  void		Tcl_EventuallyFree  (ClientData clientData,
			    Tcl_FreeProc *freeProc)  ;
extern  int		Tcl_EvalObj  (Tcl_Interp *interp,
			    Tcl_Obj *objPtr)  ;
extern  void		Tcl_Exit  (int status)  ;
extern  int		Tcl_ExposeCommand  (Tcl_Interp *interp,
        		    char *hiddenCmdToken, char *cmdName)  ;
extern  int		Tcl_ExprBoolean  (Tcl_Interp *interp,
			    char *string, int *ptr)  ;
extern  int		Tcl_ExprBooleanObj  (Tcl_Interp *interp,
			    Tcl_Obj *objPtr, int *ptr)  ;
extern  int		Tcl_ExprDouble  (Tcl_Interp *interp,
			    char *string, double *ptr)  ;
extern  int		Tcl_ExprDoubleObj  (Tcl_Interp *interp,
			    Tcl_Obj *objPtr, double *ptr)  ;
extern  int		Tcl_ExprLong  (Tcl_Interp *interp,
			    char *string, long *ptr)  ;
extern  int		Tcl_ExprLongObj  (Tcl_Interp *interp,
			    Tcl_Obj *objPtr, long *ptr)  ;
extern  int		Tcl_ExprObj  (Tcl_Interp *interp,
			    Tcl_Obj *objPtr, Tcl_Obj **resultPtrPtr)  ;
extern  int		Tcl_ExprString  (Tcl_Interp *interp,
			    char *string)  ;
extern  void		Tcl_Finalize  (void)  ;
extern  void		Tcl_FindExecutable  (char *argv0)  ;
extern  Tcl_HashEntry *	Tcl_FirstHashEntry  (
			    Tcl_HashTable *tablePtr,
			    Tcl_HashSearch *searchPtr)  ;
extern  int		Tcl_Flush  (Tcl_Channel chan)  ;
extern  void		TclFreeObj  (Tcl_Obj *objPtr)  ;
extern  void		Tcl_FreeResult  (Tcl_Interp *interp)  ;
extern  int		Tcl_GetAlias  (Tcl_Interp *interp,
       			    char *slaveCmd, Tcl_Interp **targetInterpPtr,
                            char **targetCmdPtr, int *argcPtr,
			    char ***argvPtr)  ;
extern  int		Tcl_GetAliasObj  (Tcl_Interp *interp,
       			    char *slaveCmd, Tcl_Interp **targetInterpPtr,
                            char **targetCmdPtr, int *objcPtr,
			    Tcl_Obj ***objv)  ;
extern  ClientData	Tcl_GetAssocData  (Tcl_Interp *interp,
                            char *name, Tcl_InterpDeleteProc **procPtr)  ;
extern  int		Tcl_GetBoolean  (Tcl_Interp *interp,
			    char *string, int *boolPtr)  ;
extern  int		Tcl_GetBooleanFromObj  (
			    Tcl_Interp *interp, Tcl_Obj *objPtr,
			    int *boolPtr)  ;
extern  Tcl_Channel	Tcl_GetChannel  (Tcl_Interp *interp,
	        	    char *chanName, int *modePtr)  ;
extern  int		Tcl_GetChannelBufferSize  (
    			    Tcl_Channel chan)  ;
extern  int		Tcl_GetChannelHandle  (Tcl_Channel chan,
	        	    int direction, ClientData *handlePtr)  ;
extern  ClientData	Tcl_GetChannelInstanceData  (
    			    Tcl_Channel chan)  ;
extern  int		Tcl_GetChannelMode  (Tcl_Channel chan)  ;
extern  char *		Tcl_GetChannelName  (Tcl_Channel chan)  ;
extern  int		Tcl_GetChannelOption  (Tcl_Interp *interp,
			    Tcl_Channel chan, char *optionName,
			    Tcl_DString *dsPtr)  ;
extern  Tcl_ChannelType * Tcl_GetChannelType  (Tcl_Channel chan)  ;
extern  int		Tcl_GetCommandInfo  (Tcl_Interp *interp,
			    char *cmdName, Tcl_CmdInfo *infoPtr)  ;
extern  char *		Tcl_GetCommandName  (Tcl_Interp *interp,
			    Tcl_Command command)  ;
extern  char *		Tcl_GetCwd  (char *buf, int len)  ;
extern  int		Tcl_GetDouble  (Tcl_Interp *interp,
			    char *string, double *doublePtr)  ;
extern  int		Tcl_GetDoubleFromObj  (
			    Tcl_Interp *interp, Tcl_Obj *objPtr,
			    double *doublePtr)  ;
extern  int		Tcl_GetErrno  (void)  ;
extern  int		Tcl_GetErrorLine  (Tcl_Interp *interp)  ;
extern  char *		Tcl_GetHostName  (void)  ;
extern  int		Tcl_GetIndexFromObj  (Tcl_Interp *interp,
			    Tcl_Obj *objPtr, char **tablePtr, char *msg,
			    int flags, int *indexPtr)  ;
extern  int		Tcl_GetInt  (Tcl_Interp *interp,
			    char *string, int *intPtr)  ;
extern  int		Tcl_GetInterpPath  (Tcl_Interp *askInterp,
			    Tcl_Interp *slaveInterp)  ;
extern  int		Tcl_GetIntFromObj  (Tcl_Interp *interp,
			    Tcl_Obj *objPtr, int *intPtr)  ;
extern  int		Tcl_GetLongFromObj  (Tcl_Interp *interp,
			    Tcl_Obj *objPtr, long *longPtr)  ;
extern  Tcl_Interp *	Tcl_GetMaster  (Tcl_Interp *interp)  ;
extern  Tcl_Obj *	Tcl_GetObjResult  (Tcl_Interp *interp)  ;
extern  Tcl_ObjType *	Tcl_GetObjType  (char *typeName)  ;
extern  int		Tcl_GetOpenFile  (Tcl_Interp *interp,
			    char *string, int write, int checkUsage,
			    ClientData *filePtr)  ;
extern  Tcl_Command	Tcl_GetOriginalCommand  (
			    Tcl_Command command)  ;
extern  Tcl_PathType	Tcl_GetPathType  (char *path)  ;
extern  int		Tcl_Gets  (Tcl_Channel chan,
        		    Tcl_DString *dsPtr)  ;
extern  int		Tcl_GetsObj  (Tcl_Channel chan,
        		    Tcl_Obj *objPtr)  ;
extern  int		Tcl_GetServiceMode  (void)  ;
extern  Tcl_Interp *	Tcl_GetSlave  (Tcl_Interp *interp,
			    char *slaveName)  ;
extern  Tcl_Channel	Tcl_GetStdChannel  (int type)  ;
extern  char *		Tcl_GetStringFromObj  (Tcl_Obj *objPtr,
			    int *lengthPtr)  ;
extern  char *		Tcl_GetStringResult  (Tcl_Interp *interp)  ;
extern  char *		Tcl_GetVar  (Tcl_Interp *interp,
			    char *varName, int flags)  ;
extern  char *		Tcl_GetVar2  (Tcl_Interp *interp,
			    char *part1, char *part2, int flags)  ;
extern  int		Tcl_GlobalEval  (Tcl_Interp *interp,
			    char *command)  ;
extern  int		Tcl_GlobalEvalObj  (Tcl_Interp *interp,
			    Tcl_Obj *objPtr)  ;
extern  char *		Tcl_HashStats  (Tcl_HashTable *tablePtr)  ;
extern  int		Tcl_HideCommand  (Tcl_Interp *interp,
		            char *cmdName, char *hiddenCmdToken)  ;
extern  int		Tcl_Init  (Tcl_Interp *interp)  ;
extern  void		Tcl_InitHashTable  (Tcl_HashTable *tablePtr,
			    int keyType)  ;
extern  void		Tcl_InitMemory  (Tcl_Interp *interp)  ;
extern  int		Tcl_InputBlocked  (Tcl_Channel chan)  ;
extern  int		Tcl_InputBuffered  (Tcl_Channel chan)  ;
extern  int		Tcl_InterpDeleted  (Tcl_Interp *interp)  ;
extern  int		Tcl_IsSafe  (Tcl_Interp *interp)  ;
extern  void		Tcl_InvalidateStringRep  (
			    Tcl_Obj *objPtr)  ;
extern  char *		Tcl_JoinPath  (int argc, char **argv,
			    Tcl_DString *resultPtr)  ;
extern  int		Tcl_LinkVar  (Tcl_Interp *interp,
			    char *varName, char *addr, int type)  ;
extern  int		Tcl_ListObjAppendList  (
			    Tcl_Interp *interp, Tcl_Obj *listPtr, 
			    Tcl_Obj *elemListPtr)  ;
extern  int		Tcl_ListObjAppendElement  (
			    Tcl_Interp *interp, Tcl_Obj *listPtr,
			    Tcl_Obj *objPtr)  ;
extern  int		Tcl_ListObjGetElements  (
			    Tcl_Interp *interp, Tcl_Obj *listPtr,
			    int *objcPtr, Tcl_Obj ***objvPtr)  ;
extern  int		Tcl_ListObjIndex  (Tcl_Interp *interp,
			    Tcl_Obj *listPtr, int index, 
			    Tcl_Obj **objPtrPtr)  ;
extern  int		Tcl_ListObjLength  (Tcl_Interp *interp,
			    Tcl_Obj *listPtr, int *intPtr)  ;
extern  int		Tcl_ListObjReplace  (Tcl_Interp *interp,
			    Tcl_Obj *listPtr, int first, int count,
			    int objc, Tcl_Obj * const  objv[])  ;
extern  void		Tcl_Main  (int argc, char **argv, int fd,
			    Tcl_AppInitProc *appInitProc)  ;
 
extern  int		Tcl_MakeSafe  (Tcl_Interp *interp)  ;
extern  Tcl_Channel	Tcl_MakeTcpClientChannel  (
    			    ClientData tcpSocket)  ;
extern  char *		Tcl_Merge  (int argc, char **argv)  ;
extern  Tcl_HashEntry *	Tcl_NextHashEntry  (
			    Tcl_HashSearch *searchPtr)  ;
extern  void		Tcl_NotifyChannel  (Tcl_Channel channel,
			    int mask)  ;
extern  Tcl_Obj *	Tcl_ObjGetVar2  (Tcl_Interp *interp,
			    Tcl_Obj *part1Ptr, Tcl_Obj *part2Ptr,
			    int flags)  ;
extern  Tcl_Obj *	Tcl_ObjSetVar2  (Tcl_Interp *interp,
			    Tcl_Obj *part1Ptr, Tcl_Obj *part2Ptr,
			    Tcl_Obj *newValuePtr, int flags)  ;
extern  Tcl_Channel	Tcl_OpenCommandChannel  (
    			    Tcl_Interp *interp, int argc, char **argv,
			    int flags)  ;
extern  Tcl_Channel	Tcl_OpenFileChannel  (Tcl_Interp *interp,
        		    char *fileName, char *modeString,
                            int permissions)  ;
extern  Tcl_Channel	Tcl_OpenTcpClient  (Tcl_Interp *interp,
			    int port, char *address, char *myaddr,
		            int myport, int async)  ;
extern  Tcl_Channel	Tcl_OpenTcpServer  (Tcl_Interp *interp,
		            int port, char *host,
        		    Tcl_TcpAcceptProc *acceptProc,
			    ClientData callbackData)  ;
extern  char *		Tcl_ParseVar  (Tcl_Interp *interp,
			    char *string, char **termPtr)  ;
extern  int		Tcl_PkgProvide  (Tcl_Interp *interp,
			    char *name, char *version)  ;
extern  char *		Tcl_PkgRequire  (Tcl_Interp *interp,
			    char *name, char *version, int exact)  ;
extern  char *		Tcl_PosixError  (Tcl_Interp *interp)  ;
extern  void		Tcl_Preserve  (ClientData data)  ;
extern  void		Tcl_PrintDouble  (Tcl_Interp *interp,
			    double value, char *dst)  ;
extern  int		Tcl_PutEnv  (const  char *string)  ;
extern  void		Tcl_QueueEvent  (Tcl_Event *evPtr,
			    Tcl_QueuePosition position)  ;
extern  int		Tcl_Read  (Tcl_Channel chan,
	        	    char *bufPtr, int toRead)  ;
extern  void		Tcl_ReapDetachedProcs  (void)  ;
extern  int		Tcl_RecordAndEval  (Tcl_Interp *interp,
			    char *cmd, int flags)  ;
extern  int		Tcl_RecordAndEvalObj  (Tcl_Interp *interp,
			    Tcl_Obj *cmdPtr, int flags)  ;
extern  Tcl_RegExp	Tcl_RegExpCompile  (Tcl_Interp *interp,
			    char *string)  ;
extern  int		Tcl_RegExpExec  (Tcl_Interp *interp,
			    Tcl_RegExp regexp, char *string, char *start)  ;
extern  int		Tcl_RegExpMatch  (Tcl_Interp *interp,
			    char *string, char *pattern)  ;
extern  void		Tcl_RegExpRange  (Tcl_RegExp regexp,
			    int index, char **startPtr, char **endPtr)  ;
extern  void		Tcl_RegisterChannel  (Tcl_Interp *interp,
	        	    Tcl_Channel chan)  ;
extern  void		Tcl_RegisterObjType  (
			    Tcl_ObjType *typePtr)  ;
extern  void		Tcl_Release  (ClientData clientData)  ;
extern  void		Tcl_RestartIdleTimer  (void)  ;
extern  void		Tcl_ResetResult  (Tcl_Interp *interp)  ;

extern  int		Tcl_ScanCountedElement  (const  char *string,
			    int length, int *flagPtr)  ;
extern  int		Tcl_ScanElement  (const  char *string,
			    int *flagPtr)  ;
extern  int		Tcl_Seek  (Tcl_Channel chan,
        		    int offset, int mode)  ;
extern  int		Tcl_ServiceAll  (void)  ;
extern  int		Tcl_ServiceEvent  (int flags)  ;
extern  void		Tcl_SetAssocData  (Tcl_Interp *interp,
                            char *name, Tcl_InterpDeleteProc *proc,
                            ClientData clientData)  ;
extern  void		Tcl_SetBooleanObj  (Tcl_Obj *objPtr, 
			    int boolValue)  ;
extern  void		Tcl_SetChannelBufferSize  (
			    Tcl_Channel chan, int sz)  ;
extern  int		Tcl_SetChannelOption  (
			    Tcl_Interp *interp, Tcl_Channel chan,
	        	    char *optionName, char *newValue)  ;
extern  int		Tcl_SetCommandInfo  (Tcl_Interp *interp,
			    char *cmdName, Tcl_CmdInfo *infoPtr)  ;
extern  void		Tcl_SetDoubleObj  (Tcl_Obj *objPtr, 
			    double doubleValue)  ;
extern  void		Tcl_SetErrno  (int err)  ;
extern  void		Tcl_SetErrorCode  
    			    ( Tcl_Interp *   arg1 , ...)   ;
extern  void		Tcl_SetIntObj  (Tcl_Obj *objPtr, 
			    int intValue)  ;
extern  void		Tcl_SetListObj  (Tcl_Obj *objPtr, 
			    int objc, Tcl_Obj * const  objv[])  ;
extern  void		Tcl_SetLongObj  (Tcl_Obj *objPtr, 
			    long longValue)  ;
extern  void		Tcl_SetMaxBlockTime  (Tcl_Time *timePtr)  ;
extern  void		Tcl_SetObjErrorCode  (Tcl_Interp *interp,
			    Tcl_Obj *errorObjPtr)  ;
extern  void		Tcl_SetObjLength  (Tcl_Obj *objPtr,
			    int length)  ;
extern  void		Tcl_SetObjResult  (Tcl_Interp *interp,
			    Tcl_Obj *resultObjPtr)  ;
extern  void		Tcl_SetPanicProc  (void (*proc)
			     ( char *    format , ...)   )  ;
extern  int		Tcl_SetRecursionLimit  (Tcl_Interp *interp,
			    int depth)  ;
extern  void		Tcl_SetResult  (Tcl_Interp *interp,
			    char *string, Tcl_FreeProc *freeProc)  ;
extern  int		Tcl_SetServiceMode  (int mode)  ;
extern  void		Tcl_SetStdChannel  (Tcl_Channel channel,
			    int type)  ;
extern  void		Tcl_SetStringObj  (Tcl_Obj *objPtr, 
			    char *bytes, int length)  ;
extern  void		Tcl_SetTimer  (Tcl_Time *timePtr)  ;
extern  char *		Tcl_SetVar  (Tcl_Interp *interp,
			    char *varName, char *newValue, int flags)  ;
extern  char *		Tcl_SetVar2  (Tcl_Interp *interp,
			    char *part1, char *part2, char *newValue,
			    int flags)  ;
extern  char *		Tcl_SignalId  (int sig)  ;
extern  char *		Tcl_SignalMsg  (int sig)  ;
extern  void		Tcl_Sleep  (int ms)  ;
extern  void		Tcl_SourceRCFile  (Tcl_Interp *interp)  ;
extern  int		Tcl_SplitList  (Tcl_Interp *interp,
			    char *list, int *argcPtr, char ***argvPtr)  ;
extern  void		Tcl_SplitPath  (char *path,
			    int *argcPtr, char ***argvPtr)  ;
extern  void		Tcl_StaticPackage  (Tcl_Interp *interp,
			    char *pkgName, Tcl_PackageInitProc *initProc,
			    Tcl_PackageInitProc *safeInitProc)  ;
extern  int		Tcl_StringMatch  (char *string,
			    char *pattern)  ;
extern  int		Tcl_Tell  (Tcl_Channel chan)  ;

extern  int		Tcl_TraceVar  (Tcl_Interp *interp,
			    char *varName, int flags, Tcl_VarTraceProc *proc,
			    ClientData clientData)  ;
extern  int		Tcl_TraceVar2  (Tcl_Interp *interp,
			    char *part1, char *part2, int flags,
			    Tcl_VarTraceProc *proc, ClientData clientData)  ;
extern  char *		Tcl_TranslateFileName  (Tcl_Interp *interp,
			    char *name, Tcl_DString *bufferPtr)  ;
extern  int		Tcl_Ungets  (Tcl_Channel chan, char *str,
			    int len, int atHead)  ;
extern  void		Tcl_UnlinkVar  (Tcl_Interp *interp,
			    char *varName)  ;
extern  int		Tcl_UnregisterChannel  (Tcl_Interp *interp,
			    Tcl_Channel chan)  ;
extern  int		Tcl_UnsetVar  (Tcl_Interp *interp,
			    char *varName, int flags)  ;
extern  int		Tcl_UnsetVar2  (Tcl_Interp *interp,
			    char *part1, char *part2, int flags)  ;
extern  void		Tcl_UntraceVar  (Tcl_Interp *interp,
			    char *varName, int flags, Tcl_VarTraceProc *proc,
			    ClientData clientData)  ;
extern  void		Tcl_UntraceVar2  (Tcl_Interp *interp,
			    char *part1, char *part2, int flags,
			    Tcl_VarTraceProc *proc, ClientData clientData)  ;
extern  void		Tcl_UpdateLinkedVar  (Tcl_Interp *interp,
			    char *varName)  ;
extern  int		Tcl_UpVar  (Tcl_Interp *interp,
			    char *frameName, char *varName,
			    char *localName, int flags)  ;
extern  int		Tcl_UpVar2  (Tcl_Interp *interp,
			    char *frameName, char *part1, char *part2,
			    char *localName, int flags)  ;
extern  int		Tcl_VarEval  
    			    ( Tcl_Interp *   interp , ...)   ;
extern  ClientData	Tcl_VarTraceInfo  (Tcl_Interp *interp,
			    char *varName, int flags,
			    Tcl_VarTraceProc *procPtr,
			    ClientData prevClientData)  ;
extern  ClientData	Tcl_VarTraceInfo2  (Tcl_Interp *interp,
			    char *part1, char *part2, int flags,
			    Tcl_VarTraceProc *procPtr,
			    ClientData prevClientData)  ;
extern  int		Tcl_WaitForEvent  (Tcl_Time *timePtr)  ;
extern  Tcl_Pid		Tcl_WaitPid  (Tcl_Pid pid, int *statPtr, 
			    int options)  ;
extern  int		Tcl_Write  (Tcl_Channel chan,
			    char *s, int slen)  ;
extern  void		Tcl_WrongNumArgs  (Tcl_Interp *interp,
			    int objc, Tcl_Obj * const  objv[], char *message)  ;




 

 

 




















 



extern void 	tickAnnounce (void);
extern void 	tickSet (ULONG ticks);
extern ULONG 	tickGet (void);
















 





typedef INT2[TTT] DEBUG_LEVEL;

 




extern DEBUG_LEVEL DBG_SetDebugLevel(DEBUG_LEVEL level);

 




extern DEBUG_LEVEL DBG_GetDebugLevel();

 











extern STATUS DBG_debug(int argc, char **argv);

 

















 




















extern UINT4 DBG_ReadRegister(UINT1 * pAddress, INT4 num);
extern void DBG_WriteRegister(UINT1 * pAddress, UINT1 value);



 





 






typedef struct {
    char levelName[TTT][16 ];
    UINT8  initVal;          
    char levelDesc[256 ];
}DBG_LEVEL_INFO_T;

typedef struct {
    char module[TTT][16 ];
    DBG_LEVEL_INFO_T levels[32 ];
}DBG_INFO_T;

 
typedef struct {
    UINT32[TTT] level[253];
    UINT32 warmFlag;   
    UINT32 nvramMaxLen;
    UINT32 nvramLen;
    char nvram[1];   
}DBG_NVRAM_T;
extern DBG_NVRAM_T* gpDbgNvram;

typedef UINT16[TTT] DBG_MODULE_T;

 





void DBG_Init(void);

 









DBG_MODULE_T DBG_RegisterModule(DBG_INFO_T *pInfo);

 









void DBG_SetLevel(char* module, char* level, BOOL set);
 








void DBG_SetAllLevels(char* module, BOOL set);
 










void DBG_SetLevelByNum(DBG_MODULE_T module, UINT16 level, BOOL set);

 




void DBG_ShowModules(void);

 






void DBG_ShowModuleInfo(char* module, BOOL full);

 








BOOL DBG_GetLevelByName(char* module, char* level);
 









BOOL DBG_GetLevel(DBG_MODULE_T module, UINT16 level);
 











BOOL DBG_GetLevel2And(DBG_MODULE_T module, UINT16 level1, UINT16 level2);
 











BOOL DBG_GetLevel2Or(DBG_MODULE_T module, UINT16 level1, UINT16 level2);

 
void DBG_NvResetLevel(void);
 
int DBG_NvResetBuffer(UINT32 base, UINT32 bufLen);
 
void DBG_NvPrintBuffer(void);
 

void DBG_NvPrintBufferBack(void);
void DBG_NvSetLevel(char* module, char* level, BOOL set);
void DBG_NvSetAllLevels(char* module, BOOL set);
void DBG_NvSetLevelByNum(DBG_MODULE_T module, UINT16 level, BOOL set);
void DBG_NvShowModules(void);
void DBG_NvShowModuleInfo(char* module, BOOL full);
BOOL DBG_NvGetLevelByName(char* module, char* level);
BOOL DBG_NvGetLevel(DBG_MODULE_T module, UINT16 level);
BOOL DBG_NvGetLevel2And(DBG_MODULE_T module, UINT16 level1, UINT16 level2);
BOOL DBG_NvGetLevel2Or(DBG_MODULE_T module, UINT16 level1, UINT16 level2);






  














extern int DBG_TclAppInit(Tcl_Interp *interp);





 

















 
 
 
 
 
 
 
 
 
 
 
 







 











 












 



 

 







 


 


 



 



 








 



 

















































































































 


 








 




 


typedef struct {
    unsigned short slot[TTT];         
    unsigned short pslot;        
    unsigned int applNumber; 
    unsigned int instance;
} applId_tt;

typedef struct {
    unsigned char packet_type[TTT];   
    unsigned char packet_flags;  
    unsigned short packet_sequence;   
    applId_tt dest;   
    applId_tt src;  

    int command;      
    int length;                  
    unsigned short reSendSynMsgMax; 

    unsigned short  sendSynMsgTimerLen;   

    unsigned short  wCheckSum;   
    unsigned char aExt[2];
    void *handle;   
     
} command_tt;



 











 















































 














 




typedef struct _CM_PHYCARDPARA_T[TTT] {
    unsigned int style;
    unsigned int function;
    unsigned int hwVersion;
    unsigned int option;
    unsigned int slot;
    char   serialNum[18 ];
    char   manuDate[9 ];
    char   prodCode[11 ]; 
    char   oemCode[11 ];
    char   simCode[26 ];
    char   bootDate[41 ];
    char   bootVersion[17 ];
    char   hardVersion[17 ];
    char   softVersion[33 ];
    char   fusionVersion[17 ];
    char   fpgaVersion[(17  * 15) ];	
} CM_PHYCARDPARA_T;

typedef struct _CM_INFRA_BOOT_ACK_T[TTT]
{
    int    m_boot; 
}CM_INFRA_BOOT_ACK_T;

typedef struct _CM_LOAD_OBJ_T[TTT]
{
    unsigned int slot;
}CM_LOAD_OBJ_T;

typedef struct cmndFmtApplState[TTT] {
    command_tt head;
    int state;
    int applOptions;
} cmndFmtApplState_t;

 







































 






































typedef UINT16[TTT] DTL_MODULE_T;

typedef enum
{
    DTL_NOTHING_OPEN[TTT] = 0,       
    DTL_REALTIME_PRINT,         
    DTL_RAM_SAVE,               
    DTL_FLASH_SAVE,              
    DTL_FLASH_SAVE_DIRECTLY,    
                                
}DTL_LEVEL_MODE_T;

typedef struct
{
    char                 levelName[TTT][32 ];
    DTL_LEVEL_MODE_T     levelControl;         
    UINT16               levelCount;            
    char                 levelDesc[128 ];
}DTL_LEVEL_INFO_T;

typedef struct 
{
    char                module[TTT][32 ];
    DTL_LEVEL_INFO_T    levels[32 ];
}DTL_MOD_INFO_T;

















extern DTL_MODULE_T  DTL_RegisterModule(DTL_MOD_INFO_T *pInfo, BOOL timeStampEnable);
extern void          DTL_PrintProc(DTL_MODULE_T module, UINT8 level, char* fileName, int line,  char *fmt, ...);
extern void          DTL_LoadModule(void);










 
 
 
 
 
 
 
 










 
 
 
 
 
 
 
 
 



















































































































































































 
 

 

 

 


































 











































 



 








 















 














 






struct opthdr {
	long 	level;			 
	long	name;			 
	long	len;			 
};




 


struct	linger {
	int	l_onoff;		 
	int	l_linger;		 
};

 




 





































 



struct sockaddr {
	u_char	sa_len;			 
	u_char	sa_family;		 
	char	sa_data[14];		 
};

typedef struct sockaddr[TTT] SOCKADDR;

 



struct sockproto {
	u_short	sp_family;		 
	u_short	sp_protocol;		 
};

 

































 











 



















 




extern UINT32 somaxconn;

 



struct msghdr {
	caddr_t	msg_name;		 
	u_int	msg_namelen;		 
	struct	iovec *msg_iov;		 
	u_int	msg_iovlen;		 
	caddr_t	msg_control;		 
	u_int	msg_controllen;		 
 


	int	msg_flags;		 
};
















 





struct cmsghdr {
	u_int	cmsg_len;		 
	int	cmsg_level;		 
	int	cmsg_type;		 
 
};

 



 






 







 












 

 

 





























 




struct timeval
    {
    long tv_sec;	 
    long tv_usec;	 
    };

struct timezone
    {
    int	tz_minuteswest;	 
    int	tz_dsttime;	 
    };













 

 

 































 





 







 




 

typedef struct msg_q[TTT] *MSG_Q_ID;	 

typedef struct			 
    {
    int     numMsgs[TTT];		 
    int     numTasks;		 

    int     sendTimeouts;	 
    int     recvTimeouts;	 

    int     options;		 
    int     maxMsgs;		 
    int     maxMsgLength;	 

    int     taskIdListMax;	 
    int *   taskIdList;		 

    int     msgListMax;		 
    char ** msgPtrList;		 
    int *   msgLenList;		 

    } MSG_Q_INFO;

 

 










 



extern STATUS 	msgQLibInit (void);
extern MSG_Q_ID msgQCreate (int maxMsgs, int maxMsgLength, int options);
extern STATUS 	msgQDelete (MSG_Q_ID msgQId);
extern STATUS 	msgQSend (MSG_Q_ID msgQId, char *buffer, UINT nBytes,
			  int timeout, int priority);
extern int 	msgQReceive (MSG_Q_ID msgQId, char *buffer, UINT maxNBytes,
			     int timeout);
extern STATUS 	msgQInfoGet (MSG_Q_ID msgQId, MSG_Q_INFO *pInfo);
extern int 	msgQNumMsgs (MSG_Q_ID msgQId);
extern void 	msgQShowInit (void);
extern STATUS 	msgQShow (MSG_Q_ID msgQId, int level);














 
 
 
 
 
 
 
 
 






















































































































































































    typedef struct {
        int waiterCount[TTT];
        void *semaphore;
    } *PDQsema;



    extern char *Strerror(int error);
    extern STATUS *Strerror_r(int error, char *buffer);
    extern char *Strdup(const char *src);







    extern void *Int_Malloc(char *file, int line, size_t len);
    extern void Int_FFree(char *file, int line, void *ptr);
    extern void Int_Mem_Add_User(char *file, int line, void *mem);








    extern void *Calloc(size_t nmemb, size_t size);
    extern void *Realloc(void *ptr, size_t newSize);


    extern char *Strncpy(char *s1, const char *s2, size_t n);
    extern int StrEQ(const char *s1, const char *s2);
    extern int StrcaseEQ(const char *s1, const char *s2);
    extern int StrIsNumber(const char *str);

    extern PDQsema pdqSemCreate(void);
    extern void pdqSemTake(PDQsema sema);
    extern void pdqSemGive(PDQsema sema);














 

 

 




























 

 

 





















 











 



 



 




 





 



 












 

 




 



 








 



 













 




 








 















































 

struct dirent		 
    {
    char	d_name [99   + 1];	 
    };


 
 

typedef struct		 
    {
    int		  dd_fd[TTT];		 
    int		  dd_cookie;		 
    struct dirent dd_dirent;		 
    } DIR;

 





 



extern DIR *	opendir (char *dirName);
extern STATUS 	closedir (DIR *pDir);
extern struct 	dirent *readdir (DIR *pDir);
extern void 	rewinddir (DIR *pDir);





























 
 
void SFT_ApplSwRegister(void);
 
 













typedef PB_ERROR_CODE_T[TTT] (*AMM_AppNotifyRegister)(int flag);

typedef void (*auxClockHookFunc_t[TTT])(int user_para);


void tmd_ReportApplInitState(int status);
void  Amm_ApplNotifyRegister(AMM_AppNotifyRegister *fptr);
void Amm_SwRegister(void);
void  Amm_ApplInit(void);
void Amm_ApplWaitStatus(BOOL bSwFlag);
void Amm_FdrCycleChange(int dwCycleTime);
int AMM_Select(int width, fd_set *pReadFds, fd_set *pWriteFds,fd_set *pExceptFds, struct timeval *pTimeOut);


 
    int tmd_GetFDforAppl(int applNumber);
    int tmd_GetApplIDforAppl(char *taskName);

 
    int gettimeofday(struct timeval *tv, struct timezone *tz);
    int settimeofday(const struct timeval *tv, const struct timezone *tz);

 
 
    int AMM_SpawnAppl(char *name, int priority, int options, int stackSize, int (*entryPt) (void), int applNum,
                      char *applName, unsigned int logflags, int cfgOptions);

 
 
 
    int AMM_SpawnTask(char *name, int priority, int options, int stackSize, int (*entryPt) (void), int taskNum, int arg1,
                      int arg2, int arg3, int arg4, int arg5, int arg6, int arg7);

     
     
    int AMM_SpawnApplTask(char *name, int priority, int options, int stackSize, int (*entryPt) (void), int applNum, char *applName,
                  unsigned int logflags, int cfgOptions, int arg1, int arg2, int arg3, int arg4, int arg5, int arg6, int arg7);

 















 
    struct acb *tmd_RegisterApplication(int applNum, char *applName, unsigned int logflags, int cfgOptions);

 
    void tmd_TaskEnd(void);
    void tmd_RemoveRegistration(int applNumber);

 
    int tmd_GenerateAlarm(int alarm_interface_index, int slot_num, int port_num, int ifAlarmEnabled, int alarm_type_id,
                           int new_alarm_status, int interface_type, int instances[]);
    int tmd_GenerateEvent(int event_type_id, char *event_detail);



    int SIPADDR(int slot);
    int PSIPADDR(int slot);

 
    unsigned int FindBoardProperties(void);
    int BoardInit(int boardtype);

 



 















 









 
typedef enum{	
		SEND_OK[TTT] = 0,		
		QUEUE_FULL=1,
		LINK_BREAKDOWN=2,
		NET_CONGESTION =3,
		DEST_APP_NOTRESP=4,
		PROTO_ERROR=5,
		OTHER_ERROR=6,
                MS_STATE_UNKNOWN=7,
                DMM_CMND_NULL=8,
                DMM_SRC_INVALID=9,
                DMM_DEST_INVALID= 10,
                DMM_MSG_LEN_ERROR=11,
                DMM_NOT_READY=12,
                DMM_SLOT_TRANSFER_ERROR=13,
                DMM_SYN_INNER_DEST_NCK=14,
                DMM_SYN_NCK_BY_DMM =15,
                DMM_SYN_NCK_BY_APPL=16
}DMM_ERR_CODE_t;



 void *msg_q_Receive(int qid, int timeout);
 
 command_tt *DMM_ReadPipe(int fd);
 
 command_tt *DMM_ReadQueue(int qid, int timeout);


 command_tt *DMM_CreateMsgExt(char *file, int line,int length);
 
 void DMM_ReleaseMsgExt(char *file, int line,command_tt *pCommand);




 
 command_tt * DMM_ReadCommandForAppl ();
 int DMM_CreateApplQueue(int size);
 
 int DMM_CreateQueue(int size);
 int DMM_ReleaseQueue( int qid);
 
 int DMM_CreateApplPipe(int size);
 
 int DMM_ReleasePipe(int fd);


 DMM_ERR_CODE_t DMM_SendCommand (command_tt *command);
 DMM_ERR_CODE_t DMM_SendUnAckedCommand(command_tt *command);
 DMM_ERR_CODE_t DMM_SendWRes(command_tt *command, int retries, int timeout, command_tt **ppResMsg);
   DMM_ERR_CODE_t DMM_SendSynAck(command_tt  *pInCmd,command_tt *pAckCmd,BOOL bRecvSucc);
 DMM_ERR_CODE_t DMM_SendBcCmd(command_tt *pCommand);
 command_tt * DMM_Recv (int timeout);
 command_tt * DMM_ReadCommandForAppl ();
 int  DMM_GetPhysicalSlot(int iLogicSlot);
 int   DMM_GetLogicalSlot(int iPhysicalSlot);
 int DMM_GetMatePSlot(void );
DMM_ERR_CODE_t DmmGetLinkState(unsigned short wDestPslot);


 
 int DMM_GetMatePSlot(void );

 int DMM_GetLocalPSlot(void );
 int DMM_GetLocalLSlot(void );
BOOL DMM_SetSpcMsMap(UINT16  wActivePSlot,BOOL bStdbyIsOnline);
BOOL DMM_GetPSlotOnLine(UINT16 wPSlotNo);
BOOL DMM_GetLSlotOnLine(UINT16 wLSlotNo);

int DMM_CreateSpcApplQ(UINT32 dwHighQSize,UINT32 dwLowQSize,UINT32 dwExtQSize);
UINT32 DMM_GetMsgType(const command_tt *pCommand);

void  DMM_SetCmdUrgent(command_tt *pCommand);
BOOL DMM_IsSmartCard(int PhySlot);


BOOL msTimer_Start(auxClockHookFunc_t FuncPtr,int user_para,UINT32 MsLen);
BOOL taskDelayMs(UINT32 DelayLen);



 

extern FILE *NfsOpenFile(const char *pFileName, const char *pMode);
extern STATUS NfsRemoveFile(const char *pFileName);
extern STATUS NfsCreatePath(const char *pDirName);
extern STATUS NfsDelPath(const char *pDirName);
extern DIR *NfsOpenDir(const char *pDirName);

 



extern int RFileWrite(char *pFileName,char *pMem,int WriteLen,int WriteMode);
extern int RFileRead(char *pFileName,char *pMem,int ReadLen);



 
 int tmd_SendQueueCmnd(int qid, command_tt *command);
 
 int tmd_SendPipeCmnd(int fd, command_tt *command);

 
 int tmd_IsrSendQueueCmnd(int qid, command_tt *command);
 
 int tmd_IsrSendCommand(command_tt *command);
 STATUS tmd_PipeDrv (void);

 BOOL tmd_RemapSlot(int LSlotIndex,int PSlotIndex);
 int tmd_StackCheck(int taskNum);
 int tmd_GetQueueSize(int qid);
 int tmd_GetNumLowCmnds(int qid);
 int tmd_GetNumHiCmnds(int qid);
 int tmd_GetMaxLowCmnds(int qid);
 int tmd_GetMaxHiCmnds(int qid);
 int tmd_GetNumRxMsgs(int qid);

 int tmd_GetNumLowCmnds(int qid);
 int tmd_ClrQueueDbg(int qid);
 int tmd_GetSlotMac(int slot, char *mac);

 STATUS tmd_RemapProxeeSlot(int slot, int proxy);

 int tmd_MsgSlotCheck(int slot);


extern int tmd_GetSlotIfName(int slot, char *name_buffer);
extern int tmd_GetSlotTxMsgNum(int slot);
extern int tmd_GetSlotRxMsgNum(int slot);

 int tmd_GetSlotIfName(int slot, char *name_buffer);
 int tmd_GetSlotTxMsgNum(int slot);
 int tmd_GetSlotRxMsgNum(int slot);

 void tmd_ResetSlotMsgCnts(int slot);


 int Zip(char* pstSrcName, char* pszArchFileName);
 int Zip_PSM(char* pstSrcName, char* pszArchFileName);
 int unZip(char* pstSrcName, char* pszArchFileName);
 int Zip_Buffer(char* bufferData, unsigned int bufferLen, char* pszArchFileName);





 


    void SetUseEther(int i);

    void *tmd_CreatePrivateArea(unsigned int size);
    int tmd_EnablePrivateArea(unsigned int appl);
    int tmd_DisablePrivateArea(unsigned int appl);    
    
 
 
 
    void initializeMirroringServices(void);

 
    STATUS isMemLocMirrored(void *address);
    STATUS registerMirroredMemLoc(void *address, short numbytes, unsigned short initialValue);
    STATUS setMemLoc_16bit(void *address, short accessType, unsigned short bitMask, unsigned short bitPattern);
    STATUS setMemLoc_16bit_Isr(void *address, short accessType, unsigned short bitMask, unsigned short bitPattern);
    unsigned short getMemLoc_16bit(void *address);
    unsigned short getMemLoc_16bit_Isr(void *address);

 
    STATUS is_I2C_Register_Shared(int address);
    STATUS register_Shared_16bit_I2C_Register(int address, unsigned short initialValue, char setInitValNow);
    STATUS set_shared_16bit_I2C_register(int address, short accessType, unsigned short bitMask,
                                         unsigned short bitPattern);
    int get_shared_16bit_I2C_register(int address, unsigned short *data);

void AMM_SlotWdgTimeoutProc(int slot);
    
 


 


    void registerDynamicDumps(void *area, int len, char *name);

    void tmd_prepare_card_for_impending_shutdown(void);













unsigned int  CRC32(unsigned int crc, const unsigned char *buf, unsigned int len);












 

 

 





































































































































 

 

 
































 

 

 




























 

typedef struct q_class[TTT]		 
    {
    FUNCPTR createRtn;		 
    FUNCPTR initRtn;		 
    FUNCPTR deleteRtn;		 
    FUNCPTR terminateRtn;	 
    FUNCPTR putRtn;		 
    FUNCPTR getRtn;		 
    FUNCPTR removeRtn;		 
    FUNCPTR resortRtn;		 
    FUNCPTR advanceRtn;		 
    FUNCPTR getExpiredRtn;	 
    FUNCPTR keyRtn;		 
    FUNCPTR calibrateRtn;	 
    FUNCPTR infoRtn;		 
    FUNCPTR eachRtn;		 
    struct q_class *valid;	 
    } Q_CLASS;

typedef Q_CLASS[TTT] *Q_CLASS_ID;	 

 

 




























 





 

extern  Q_CLASS_ID		qFifoClassId;
extern  Q_CLASS_ID		qPriListClassId;
extern  Q_CLASS_ID		qPriListFromTailClassId;
extern  Q_CLASS_ID		qPriDeltaClassId;
extern  Q_CLASS_ID		qPriHeapClassId;
extern  Q_CLASS_ID		qPriBMapClassId;

 








 

 








typedef struct		 
    {
    UINT[TTT]     qPriv1;			 
    UINT     qPriv2;			 
    UINT     qPriv3;			 
    UINT     qPriv4;			 
    } Q_NODE;


 








typedef struct		 
    {
    Q_NODE[TTT]  *pFirstNode;		 
    UINT     qPriv1;			 
    UINT     qPriv2;			 
    Q_CLASS *pQClass;			 
    } Q_HEAD;





 


 
















 













 

















 












 













 














 




















 
















 













 



















 

























extern Q_HEAD *	qCreate (Q_CLASS *pQClass, ...);
extern Q_NODE *	qEach (Q_HEAD *pQHead, FUNCPTR routine, int routineArg);
extern Q_NODE *	qFirst (Q_HEAD *pQHead);
extern Q_NODE *	qGet (Q_HEAD *pQHead);
extern Q_NODE *	qGetExpired (Q_HEAD *pQHead);
extern STATUS 	qDelete (Q_HEAD *pQHead);
extern STATUS 	qInit (Q_HEAD *pQHead, Q_CLASS *pQClass, ...);
extern STATUS 	qTerminate (Q_HEAD *pQHead);
extern ULONG 	qKey (Q_HEAD *pQHead, Q_NODE *pQNode, int keyType);
extern int 	qInfo (Q_HEAD *pQHead, Q_NODE *nodeArray [ ], int maxNodes);
extern void 	qAdvance (Q_HEAD *pQHead);
extern void 	qCalibrate (Q_HEAD *pQHead, ULONG keyDelta);
extern void 	qPut (Q_HEAD *pQHead, Q_NODE *pQNode, ULONG key);
extern STATUS 	qRemove (Q_HEAD *pQHead, Q_NODE *pQNode);
extern void 	qResort (Q_HEAD *pQHead, Q_NODE *pQNode, ULONG newKey);











 

 

 




























































 

 
 





















typedef struct		 
    {
    _RType[TTT] gpr[32 ];	 
    _RType msr;			 
    _RType lr;			 
    _RType ctr;			 
    _RType pc;			 
    UINT32 cr;			 
    UINT32 xer;			 





    UINT32 pad;			 

    } REG_SET;

 


































































































































































typedef struct regindex[TTT]
    {
    char	*regName;	 
    int		regOff;		 







    } REG_INDEX;








 

 

 






































































 

 

 


































 



























typedef struct
    {
    UINT32[TTT]	valid;		 

    UINT32	vecOff;		 
    _RType	cia;		 

    _RType	msr;		 




    _RType	dar;		 


    UINT32      cr;		 
    UINT32	xer;		 


    UINT32	fpcsr;		 
    UINT32	dsisr;		 



    } EXC_INFO;











 


















						 






























 











 

extern FUNCPTR  excExcepHook;    

 



extern STATUS		excConnect (VOIDFUNCPTR *, VOIDFUNCPTR);
extern STATUS  		excIntConnect (VOIDFUNCPTR *, VOIDFUNCPTR);
extern void		excVecSet (FUNCPTR *, FUNCPTR);
extern FUNCPTR		excVecGet (FUNCPTR *);
extern void		excVecBaseSet (FUNCPTR *);
extern FUNCPTR *	excVecBaseGet (void);






























































typedef struct  excfaultTab[TTT]
    {
    int faultType;		 
    int subtype;		 
    int signal;			 
    int code;			 
    } EXC_FAULT_TAB;

 


extern STATUS 	excShowInit (void);
extern void 	excHookAdd (FUNCPTR excepHook);
extern STATUS 	excJobAdd (VOIDFUNCPTR func, int arg1, int arg2, int arg3,
			   int arg4, int arg5, int arg6);















 

 

 


















































































 

 







 





































 



typedef unsigned short event_t[TTT];



 

 

 

























































 

extern FUNCPTR     _func_ioTaskStdSet;
extern FUNCPTR     _func_bdall;
extern FUNCPTR     _func_dspTaskRegsShow;
extern  VOIDFUNCPTR _func_dspRegsListHook;	 
extern  FUNCPTR	   _func_dspMregsHook;		 
extern FUNCPTR     _func_excBaseHook;
extern FUNCPTR     _func_excInfoShow;
extern FUNCPTR     _func_excIntHook;
extern FUNCPTR     _func_excJobAdd;
extern FUNCPTR     _func_excPanicHook;
extern FUNCPTR     _func_fastUdpErrorNotify;
extern FUNCPTR     _func_fastUdpInput;
extern FUNCPTR     _func_fastUdpPortTest;
extern FUNCPTR     _func_fclose;
extern FUNCPTR     _func_fppTaskRegsShow;
extern FUNCPTR     _func_altivecProbe;
extern FUNCPTR     _func_altivecTaskRegsGet;
extern FUNCPTR     _func_altivecTaskRegsShow;
extern FUNCPTR     _func_speTaskRegsShow;
extern FUNCPTR     _func_ftpLs;
extern FUNCPTR     _func_netLsByName;
extern FUNCPTR     _func_printErr;
extern FUNCPTR     _func_logMsg;
extern FUNCPTR     _func_memalign;
extern FUNCPTR     _func_pthread_setcanceltype;
extern FUNCPTR     _func_selPtyAdd;
extern FUNCPTR     _func_selPtyDelete;
extern FUNCPTR     _func_selTyAdd;
extern FUNCPTR     _func_selTyDelete;
extern FUNCPTR     _func_selWakeupAll;
extern FUNCPTR     _func_selWakeupListInit;
extern FUNCPTR     _func_selWakeupListTerm;
extern VOIDFUNCPTR _func_sigExcKill;
extern FUNCPTR     _func_sigprocmask;
extern FUNCPTR     _func_sigTimeoutRecalc;
extern FUNCPTR     _func_smObjObjShow;
extern FUNCPTR     _func_spy;
extern FUNCPTR     _func_spyStop;
extern FUNCPTR     _func_spyClkStart;
extern FUNCPTR     _func_spyClkStop;
extern FUNCPTR     _func_spyReport;
extern FUNCPTR     _func_spyTask;
extern FUNCPTR     _func_sseTaskRegsShow;
extern FUNCPTR     _func_symFindByValueAndType;    
extern FUNCPTR     _func_symFindByValue;           
extern FUNCPTR     _func_symFindSymbol;
extern FUNCPTR     _func_symNameGet;
extern FUNCPTR     _func_symValueGet;
extern FUNCPTR     _func_symTypeGet;
extern FUNCPTR     _func_taskCreateHookAdd;
extern FUNCPTR     _func_taskDeleteHookAdd;
extern FUNCPTR     _func_valloc;
extern FUNCPTR     _func_remCurIdGet;
extern FUNCPTR     _func_remCurIdSet;

extern FUNCPTR	   _dbgDsmInstRtn;


extern BOOL        fastUdpInitialized;


extern BOOL	   ftpErrorSuppress;
extern BOOL	   _procNumWasSet;
extern int	   m2If64BitCounters;

extern VOIDFUNCPTR _func_evtLogO;
extern VOIDFUNCPTR _func_evtLogOIntLock;

extern VOIDFUNCPTR _func_evtLogM0;
extern VOIDFUNCPTR _func_evtLogM1;
extern VOIDFUNCPTR _func_evtLogM2;
extern VOIDFUNCPTR _func_evtLogM3;

extern VOIDFUNCPTR _func_evtLogT0;
extern VOIDFUNCPTR _func_evtLogT0_noInt;
extern VOIDFUNCPTR _func_evtLogT1;
extern VOIDFUNCPTR _func_evtLogT1_noTS;
extern VOIDFUNCPTR _func_evtLogTSched;

extern VOIDFUNCPTR _func_evtLogString;
extern FUNCPTR     _func_evtLogPoint;
extern FUNCPTR	   _func_evtLogReserveTaskName;



extern FUNCPTR     _func_tmrStamp;
extern FUNCPTR     _func_tmrStampLock;
extern FUNCPTR     _func_tmrFreq;
extern FUNCPTR     _func_tmrPeriod;
extern FUNCPTR     _func_tmrConnect;
extern FUNCPTR     _func_tmrEnable;
extern FUNCPTR     _func_tmrDisable;

extern VOIDFUNCPTR _func_trgCheck;
extern UINT32 evtAction;
extern UINT32 wvEvtClass;
extern UINT32 trgEvtClass;

extern BOOL   wvInstIsOn;              
extern BOOL   wvObjIsEnabled;          




















































 













 

 










 












 
















 

















 


















 













 













 











 

















 
















 










 
















 
















 









 









 









 









 









 









 
















 









 









 









 


























 














































 

 


     





     





     




 


     











     





     





     










     











     






     





      





     

 


     










     







     






     








     






     







     







     







     








     








     









     









     








     








     








     








     






     






     







     






     









     






     









     










     







     






     






     







     





     







     








     







     






     








     






     





     





 


     






     





     





     





     








     







     





     




     





     





     





     





     





     





     





     




     





     





     





     





     





     





     





     





     





     





     





     





     





     





     




     




 


     







     






     







     







     




     





     





     





     





     






     






 




     





     




     























 














	 


















 






























 

 

 





























 

 

 























extern VOIDFUNCPTR eventEvtRtn;  

 

typedef struct eventsCb[TTT]
    {
    UINT32 wanted;	 
    volatile UINT32 received;	 
    UINT8  options;	 
    UINT8  sysflags;	 
    UINT8  pad[2];	 
    } EVENTS;		 

 



 



					 


 

typedef struct eventsResourceCb[TTT]
    {
    UINT32 registered;	 
    int    taskId;	 
    UINT8  options;	 
    UINT8  pad[3];	 
    } EVENTS_RSRC;	 





 














extern void 	eventLibInit	(void);
extern void 	eventInit	(EVENTS_RSRC * pEvRsrc);
extern void 	eventTerminate 	(const EVENTS_RSRC * pEvRsrc);
extern void 	semEvLibInit	(void);
extern void 	msgQEvLibInit	(void);
extern STATUS 	eventStart	(OBJ_ID objId, EVENTS_RSRC * pEvRsrc,
				 FUNCPTR isRsrcFree, UINT32 events,
				 UINT8 options);
extern STATUS	eventRsrcSend	(int taskId, UINT32 events);
extern STATUS	eventRsrcShow	(EVENTS_RSRC * pEvRsrc);
extern STATUS   eventTaskShow	(EVENTS	* pEvents);























 













typedef struct semaphore[TTT]  
    {
    OBJ_CORE	objCore;	 
    UINT8	semType;	 
    UINT8	options;	 
    UINT16	recurse;	 
    Q_HEAD	qHead;		 
    union
	{
	UINT		 count;	 
	struct windTcb	*owner;	 
	} state;
    EVENTS_RSRC	events;		 

    } SEMAPHORE;




 












 
















 

extern OBJ_CLASS	semClass;		 
extern OBJ_CLASS	semInstClass;		 
extern CLASS_ID		semClassId;		 
extern CLASS_ID		semInstClassId;		 
extern FUNCPTR		semGiveTbl [];		 
extern FUNCPTR		semTakeTbl [];		 
extern FUNCPTR		semFlushTbl [];		 
extern FUNCPTR		semGiveDeferTbl [];	 
extern FUNCPTR		semFlushDeferTbl [];	 
extern int		semMGiveKernWork;	 

extern FUNCPTR  semSmShowRtn;	 
extern FUNCPTR  semSmInfoRtn;	 

 



extern STATUS	semLibInit (void);
extern STATUS	semTerminate (SEM_ID semId);
extern STATUS	semDestroy (SEM_ID semId, BOOL dealloc);
extern STATUS	semGiveDefer (SEM_ID semId);
extern STATUS	semFlushDefer (SEM_ID semId);
extern STATUS	semInvalid (SEM_ID semId);
extern STATUS	semIntRestrict (SEM_ID semId);
extern STATUS	semQInit (SEMAPHORE *pSemaphore, int options);
extern STATUS	semQFlush (SEM_ID semId);
extern void	semQFlushDefer (SEM_ID semId);
extern STATUS	semBInit (SEMAPHORE *pSem,int options,SEM_B_STATE initialState);
extern STATUS	semBCoreInit (SEMAPHORE *pSemaphore, int options,
			      SEM_B_STATE initialState);
extern STATUS	semBGive (SEM_ID semId);
extern STATUS	semBTake (SEM_ID semId, int timeout);
extern void	semBGiveDefer (SEM_ID semId);
extern STATUS	semMInit (SEMAPHORE *pSem, int options);
extern STATUS	semMCoreInit (SEMAPHORE *pSemaphore, int options);
extern STATUS	semMGive (SEM_ID semId);
extern STATUS	semMTake (SEM_ID semId, int timeout);
extern STATUS	semMGiveKern (SEM_ID semId);
extern STATUS	semMPendQPut (SEM_ID semId, int timeout);
extern STATUS	semCInit (SEMAPHORE *pSem,int options,int initialCount);
extern STATUS	semCCoreInit (SEMAPHORE *pSemaphore, int options,
			      int initialCount);
extern STATUS	semCGive (SEM_ID semId);
extern STATUS	semCTake (SEM_ID semId, int timeout);
extern void	semCGiveDefer (SEM_ID semId);
extern STATUS	semOTake (SEM_ID semId);


















 

 

 


















































 















typedef struct { int quot[TTT]; int rem; } div_t ;




typedef struct { long quot[TTT]; long rem; } ldiv_t ;



typedef struct {		 
	unsigned char __state[TTT];
	unsigned short __wchar;
	} _Mbsave;



extern void	abort (void);
extern int	abs (int __i);
extern int	atexit (void (*__func)(void));
extern double	atof (const char *__s);
extern int	atoi (const char *__s);
extern long	atol (const char *__s);
extern void *	bsearch (const void *__key, const void *__base,
		         size_t __nelem, size_t __size,
		         int  (*__cmp)(const void *__ck, const void *__ce));
extern div_t	div (int __numer, int __denom);
extern long	labs (long __i);
extern ldiv_t	ldiv (long __numer, long __denom);
extern int	mblen (const char *__s, size_t __n);
extern size_t	mbstowcs (wchar_t *__wcs, const char *__s, size_t __n);
extern int	mbtowc (wchar_t *__pwc, const char *__s, size_t __n);
extern void	qsort (void *__base, size_t __nelem, size_t __size,
		       int  (*__cmp)(const void *__e1, const void *__e2));
extern int	rand (void);
extern void *	srand (unsigned int __seed);
extern double	strtod (const char *__s, char **__endptr);
extern long	strtol (const char *__s, char **__endptr, int __base);
extern unsigned long strtoul (const char *__s, char **__endptr, int __base);
extern int	system (const char *__s);
extern size_t	wcstombs (char *__s, const wchar_t *__wcs, size_t __n);
extern int	wctomb (char *__s, wchar_t __wchar);

extern void *	calloc (size_t __nelem, size_t __size);
extern void	exit (int __status);
extern void	free (void *__ptr);
extern char *	getenv (const char *__name);
extern void *	malloc (size_t __size);
extern void *	realloc (void *__ptr, size_t __size);



extern void     div_r (int numer, int denom, div_t * divStructPtr);
extern void     ldiv_r (long numer, long denom, ldiv_t * divStructPtr);















 












 







 



















 







typedef struct wdb_info[TTT]		 
    {
    int			wdbState;	 
    REG_SET *		wdbRegisters;	 
    struct
        {
	void *	wdb1;
	void *	wdb2;
	} wdbEvtList;			 
    int			bpAddr;		 
					 
    int			taskBpAddr;	 
    int			taskPc;		 
    int			taskFp;		 
    int			taskSp;		 
    VOIDFUNCPTR		wdbExitHook;	 
  } WDB_INFO;

typedef struct windTcb[TTT]		 
    {
    Q_NODE		qNode;		 
    Q_NODE		tickNode;	 
    Q_NODE		activeNode;	 

    OBJ_CORE		objCore;	 
    char *		name;		 
    int			options;	 
    UINT		status;		 
    UINT		priority;	 
    UINT		priNormal;	 
    UINT		priMutexCnt;	 
    struct semaphore *	pPriMutex;	 

    UINT		lockCnt;	 
    UINT		tslice;		 

    UINT16		swapInMask;	 
    UINT16		swapOutMask;	 

    Q_HEAD *		pPendQ;		 

    UINT		safeCnt;	 
    Q_HEAD		safetyQHead;	 

    FUNCPTR		entry;		 

    char *		pStackBase;	 
    char *		pStackLimit;	 
    char *		pStackEnd;	 

    int			errorStatus;	 
    int			exitCode;	 

    struct sigtcb *	pSignalInfo;	 
    struct selContext *	pSelectContext;	 

    UINT		taskTicks;	 
    UINT		taskIncTicks;	 

    struct taskVar *	pTaskVar;	 
    struct rpcModList *	pRPCModList;	 
    struct fpContext *	pFpContext;	 

    struct __sFILE *	taskStdFp[3];	 
    int			taskStd[3];	 

    char **		ppEnviron;	 
    int                 envTblSize;      
    int                 nEnvVarEntries;  
    struct sm_obj_tcb *	pSmObjTcb;	 
    int			windxLock;	 
    void *		pComLocal;	 
    REG_SET *		pExcRegSet;	 
    EVENTS		events;		 
    WDB_INFO *		pWdbInfo;	 
    void *		pPthread;	 
    int			reserved1;	 
    int			compiler1;	 
    int			spare1;		 
    int			spare2;		 
    int			spare3;		 
    int			spare4;		 

    




     

















    EXC_INFO            excInfo;         
    UINT                pCoprocCtx;      

     

    REG_SET             regs;            

















































    struct dspContext *	pDspContext;	 
    WDB_INFO		wdbInfo;	 
    } WIND_TCB;

typedef struct 			 
    {
    int			td_id[TTT];		 
    char *		td_name;	 
    int			td_priority;	 
    int			td_status;	 
    int			td_options;	 
    FUNCPTR		td_entry;	 
    char *		td_sp;		 
    char *		td_pStackBase;	 
    char *		td_pStackLimit;	 
    char *		td_pStackEnd;	 
    int			td_stackSize;	 
    int			td_stackCurrent; 
    int			td_stackHigh;	 
    int			td_stackMargin;	 
    int			td_errorStatus;	 
    int			td_delay;	 
    EVENTS		td_events;	 
    } TASK_DESC;





 


















 


















 













 











 














 

extern CLASS_ID	taskClassId;		 
extern CLASS_ID taskInstClassId;  	 
extern WIND_TCB *taskIdCurrent;		 
extern BOOL     taskPriRangeCheck;       

 



extern STATUS 	taskLibInit (void);





extern int 	taskSpawn (char *name, int priority, int options, int stackSize,
		      	   FUNCPTR entryPt, int arg1, int arg2, int arg3,
		      	   int arg4, int arg5, int arg6, int arg7,
		      	   int arg8, int arg9, int arg10);


extern STATUS 	taskInit (WIND_TCB *pTcb, char *name, int priority, int options,
			  char *pStackBase, int stackSize, FUNCPTR entryPt,
			  int arg1, int arg2, int arg3, int arg4, int arg5,
			  int arg6, int arg7, int arg8, int arg9, int arg10);
extern STATUS 	taskActivate (int tid);
extern STATUS 	taskDelete (int tid);
extern STATUS 	taskDeleteForce (int tid);
extern STATUS 	taskSuspend (int tid);
extern STATUS 	taskResume (int tid);
extern STATUS 	taskRestart (int tid);
extern STATUS 	taskPrioritySet (int tid, int newPriority);
extern STATUS 	taskPriorityGet (int tid, int *pPriority);
extern STATUS 	taskLock (void);
extern STATUS 	taskUnlock (void);
extern STATUS 	taskSafe (void);
extern STATUS 	taskUnsafe (void);
extern STATUS 	taskDelay (int ticks);
extern STATUS 	taskOptionsSet (int tid, int mask, int newOptions);
extern STATUS 	taskOptionsGet (int tid, int *pOptions);
extern char *	taskName (int tid);
extern int 	taskNameToId (char *name);
extern STATUS 	taskIdVerify (int tid);
extern int 	taskIdSelf (void);
extern int 	taskIdDefault (int tid);
extern BOOL 	taskIsReady (int tid);
extern BOOL 	taskIsSuspended (int tid);
extern WIND_TCB *taskTcb (int tid);
extern int 	taskIdListGet (int idList [ ], int maxTasks);
extern STATUS 	taskInfoGet (int tid, TASK_DESC *pTaskDesc);
extern STATUS 	taskStatusString (int tid, char *pString);
extern STATUS 	taskOptionsString (int tid, char *pString);
extern STATUS 	taskRegsGet (int tid, REG_SET *pRegs);
extern STATUS 	taskRegsSet (int tid, REG_SET *pRegs);
extern void 	taskRegsShow (int tid);
extern void *	taskStackAllot (int tid, unsigned nBytes);
extern void 	taskShowInit (void);
extern STATUS 	taskShow (int tid, int level);












 

 

 


































 

typedef struct node[TTT]		 
    {
    struct node *next;		 
    struct node *previous;	 
    } NODE;


 

typedef struct			 
    {
    NODE[TTT] node;			 
    int count;			 
    } LIST;

 


 




extern void	lstLibInit (void);
extern NODE *	lstFirst (LIST *pList);
extern NODE *	lstGet (LIST *pList);
extern NODE *	lstLast (LIST *pList);
extern NODE *	lstNStep (NODE *pNode, int nStep);
extern NODE *	lstNext (NODE *pNode);
extern NODE *	lstNth (LIST *pList, int nodenum);
extern NODE *	lstPrevious (NODE *pNode);
extern int 	lstCount (LIST *pList);
extern int 	lstFind (LIST *pList, NODE *pNode);
extern void 	lstAdd (LIST *pList, NODE *pNode);
extern void 	lstConcat (LIST *pDstList, LIST *pAddList);
extern void 	lstDelete (LIST *pList, NODE *pNode);
extern void 	lstExtract (LIST *pSrcList, NODE *pStartNode, NODE *pEndNode,
	  		    LIST *pDstList);
extern void 	lstFree (LIST *pList);
extern void 	lstInit (LIST *pList);
extern void 	lstInsert (LIST *pList, NODE *pPrev, NODE *pNode);




















struct acb {
    applId_tt applId;
    char applname[23  + 1];
     

    int fd;                      
    int qid;                     

    int          fd_qid;  
    unsigned int logFlags;
    unsigned int cfg_options;
    unsigned int swping_counter;
    unsigned int swping_max;
    unsigned int waiting;
    unsigned int malloc_memory;  
    unsigned int malloc_buffs;   
    unsigned int Malloc_buffs;   
    unsigned int Malloc_memory;  
    int tid;                     
    void *applPrivate;           
    void *PrivateAreaAddr;       
    int   PrivateAreaSize;            
    int   PrivateAreaOpen;          
    int          tasksSpawned;      
};


struct taskMemStat
{ 
 int taskId;
 int AppNo;
 char taskName[12 ];
 unsigned int dynMemReqSum;  
 unsigned int dynMemUsingNow;  
 unsigned int dynMemTUsingNow;   
 unsigned int  fixedMemReqSum;  
 unsigned int fixedMemUsingNow;   
 unsigned int fixedMemTUsingNow;  
 
};

struct MemUsedInTaskInit
{ 
   char mod_or_app_Name[12 ];
  unsigned int malloc_size_used_in_load;  
  unsigned int malloc_size_used_in_active;  
};


struct taskCB {
    int taskNum;
    char taskname[10  + 1];
    void *taskPrivate;
    char            *mibAccessPtr;  
};


extern struct taskCB *taskCB;
extern struct acb *acb;
extern struct acb *applicationACBs[];

extern struct taskMemStat gTaskMemStat[];









 

 


































 




















 

 

 


































 






























 

 

 


































 



















 









struct	arphdr {
	u_short	ar_hrd;		 


	u_short	ar_pro;		 
	u_char	ar_hln;		 
	u_char	ar_pln;		 
	u_short	ar_op;		 






 









};

 


struct arpreq {
	struct	sockaddr arp_pa;		 
	struct	sockaddr arp_ha;		 
	int	arp_flags;			 
};
 

















 

 

 


































 




















 

 
 













 





































 

 

 





































 





typedef enum
    {
    SELREAD[TTT],
    SELWRITE
    } SELECT_TYPE;

 

 

 
















typedef struct selWkNode[TTT]
    {
    NODE		linkedListHooks; 
    BOOL		dontFree;	 
    int			taskId;		 
    int			fd;		 
    SELECT_TYPE		type;		 
    } SEL_WAKEUP_NODE;

typedef struct
    {
    SEMAPHORE[TTT]		listMutex;	 
    SEL_WAKEUP_NODE	firstNode;	 
    LIST		wakeupList;	 
    } SEL_WAKEUP_LIST;

typedef struct selContext[TTT]
    {
    SEMAPHORE	wakeupSem;		 
    BOOL     	pendedOnSelect;		 

    fd_set     *pReadFds;		 
    fd_set     *pWriteFds;		 

     

    fd_set     *pOrigReadFds;		 
    fd_set     *pOrigWriteFds;		 
    int		width;			 

     











    } SEL_CONTEXT;


 



extern void	selectInit		(int numFiles);
extern void	selTaskDeleteHookAdd 	(void);

















 



extern SELECT_TYPE  selWakeupType 	(SEL_WAKEUP_NODE *pWakeupNode);
extern STATUS 	    selNodeAdd 	      	(SEL_WAKEUP_LIST *pWakeupList,
			    		 SEL_WAKEUP_NODE *pWakeupNode);
extern STATUS 	    selNodeDelete 	(SEL_WAKEUP_LIST *pWakeupList,
			       		 SEL_WAKEUP_NODE *pWakeupNode);
extern int 	    selWakeupListLen 	(SEL_WAKEUP_LIST *pWakeupList);
extern void 	    selWakeup 		(SEL_WAKEUP_NODE *pWakeupNode);
extern void 	    selWakeupAll 	(SEL_WAKEUP_LIST *pWakeupList, 
					 SELECT_TYPE type);
extern void 	    selWakeupListInit 	(SEL_WAKEUP_LIST *pWakeupList);
extern void 	    selWakeupListTerm 	(SEL_WAKEUP_LIST *pWakeupList);
extern int	    select 		(int width, fd_set *pReadFds, 
					 fd_set *pWriteFds, fd_set *pExceptFds,
					 struct timeval *pTimeOut);









 

 

 


































 





















struct iovec {
	caddr_t	iov_base;
	int	iov_len;
};

enum	uio_rw { UIO_READ, UIO_WRITE };

 
enum uio_seg {
	UIO_USERSPACE,		 
	UIO_SYSSPACE,		 
	UIO_USERISPACE		 
};

struct uio {
	struct	iovec *uio_iov;
	int	uio_iovcnt;
	off_t	uio_offset;
	int	uio_resid;
	enum	uio_seg uio_segflg;
	enum	uio_rw uio_rw;



};
















 

 

 


































 































 

 
 
























 

















 































            
 



extern int 	splnet (void);
extern int 	splimp (void);
extern void 	splx (int x);
extern void 	panic (char *msg);
extern void 	wakeup (SEM_ID semId);
extern void 	ksleep (SEM_ID semId);
extern char *	_netMalloc (int bufSize, UCHAR type, int canWait); 
extern void	_netFree (char * pBuf); 
extern void * 	hashinit (int 	elements, int type, u_long * hashmask);












 

 

 



























extern void *	memchr (const void *__s, int __c, size_t __n);
extern int 	memcmp (const void *__s1, const void *__s2, size_t __n);
extern void *	memcpy (void *__s1, const void *__s2, size_t __n);
extern void *	memmove (void *__s1, const void *__s2, size_t __n);
extern void *	memset (void *__s, int __c, size_t __n);

extern char *	strcat (char *__s1, const char *__s2);
extern char *	strchr (const char *__s, int __c);
extern int 	strcmp (const char *__s1, const char *__s2);
extern int 	strcoll (const char *__s1, const char *__s2);
extern char *	strcpy (char *__s1, const char *__s2);
extern size_t 	strcspn (const char *__s1, const char *__s2);
extern size_t 	strlen (const char *__s);
extern char *	strncat (char *__s1, const char *__s2, size_t __n);
extern int 	strncmp (const char *__s1, const char *__s2, size_t __n);
extern char *	strncpy (char *__s1, const char *__s2, size_t __n);
extern char *	strpbrk (const char *__s1, const char *__s2);
extern char *	strrchr (const char *__s, int __c);
extern size_t 	strspn (const char *__s1, const char *__s2);
extern char *	strstr (const char *__s1, const char *__s2);
extern char *	strtok (char *__s, const char *__sep);
extern size_t 	strxfrm (char *__s1, const char *__s2, size_t __n);
extern char *	strerror(int __errcode);


extern char *	strtok_r (char *__s, const char *__sep, char **__ppLast);



extern int	strerror_r (int __errcode, char *__buf);
extern void 	bcopy (const char *source, char *dest, int nbytes);
extern void 	bcopyBytes (char *source, char *dest, int nbytes);
extern void 	bcopyWords (char *source, char *dest, int nwords);
extern void 	bcopyLongs (char *source, char *dest, int nlongs);
extern void 	bfill (char *buf, int nbytes, int ch);
extern void 	bfillBytes (char *buf, int nbytes, int ch);
extern void 	bzero (char *buffer, int nbytes);
extern int 	bcmp (char *buf1, char *buf2, int nbytes);
extern void 	binvert (char *buf, int nbytes);
extern void 	bswap (char *buf1, char *buf2, int nbytes);
extern void 	uswab (char *source, char *destination, int nbytes);
extern void 	swab (char *source, char *dest, int nbytes);
extern char *	index (const char *s, int c);
extern char *	rindex (const char *s, int c);










 

 

 

































 













	
	
	








 


































 













 
 
 

 



























 











 







































 























 






 




 

 









 




 



 








 



 



 



 





    











                    











                    



                    








 









typedef struct
    {
    int		mBlkNum[TTT];		 
    int		clBlkNum;		 
    char * 	memArea;		 
    int		memSize;		 
    } M_CL_CONFIG;

 







typedef struct clDesc[TTT]
    {
    int		clSize;			 
    int		clNum;			 
    char *	memArea;		 
    int		memSize;		 
    } CL_DESC; 

 

typedef struct clBuff[TTT]
    {
    struct clBuff *	pClNext; 	 
    } CL_BUF;

typedef CL_BUF[TTT] * CL_BUF_ID; 

 

typedef struct clPool[TTT]
    {
    int			clSize;		 
    int			clLg2;		 
    int			clNum; 		 
    int			clNumFree; 	 
    int			clUsage;	 
    CL_BUF_ID		pClHead;	 
    struct netPool *	pNetPool;	 
    } CL_POOL; 

typedef CL_POOL[TTT] * CL_POOL_ID; 

 

typedef struct mHdr[TTT]
    {
    struct mBlk *	mNext;		 
    struct mBlk *	mNextPkt;	 
    char *		mData;		 
    int			mLen;		 
    UCHAR		mType;		 
    UCHAR		mFlags;		 
    USHORT		reserved; 
    } M_BLK_HDR;

 

typedef struct	pktHdr[TTT]
    {
    struct ifnet *	rcvif;		 
    int			len;		 
    } M_PKT_HDR;

typedef union clBlkList[TTT]
    {
    struct clBlk * 	pClBlkNext;	 
    char * 		pClBuf;		 
    } CL_BLK_LIST;
    
 

typedef struct clBlk[TTT]
    {
    CL_BLK_LIST 	clNode;		 
    UINT		clSize;		 
    int			clRefCnt;	 
    FUNCPTR		pClFreeRtn;	 
    int			clFreeArg1;	 
    int			clFreeArg2;	 
    int			clFreeArg3;	 
    struct netPool *	pNetPool;	 
    } CL_BLK;

 

typedef struct mBlk[TTT]
    {
    M_BLK_HDR 	mBlkHdr; 		 
    M_PKT_HDR	mBlkPktHdr;		 
    CL_BLK *	pClBlk;			 
    } M_BLK;

 

typedef struct mbstat[TTT]
    {
    ULONG	mNum;			 
    ULONG	mDrops;			 
    ULONG	mWait;			 
    ULONG	mDrain;			 
    ULONG	mTypes[256];		 
    } M_STAT;

typedef M_BLK[TTT] * 	M_BLK_ID;
typedef CL_BLK[TTT] *	CL_BLK_ID;
typedef struct netPool[TTT] 	NET_POOL;
typedef struct poolFunc[TTT] POOL_FUNC;
typedef NET_POOL[TTT] * 	NET_POOL_ID;

struct	poolFunc			 
    {
     
    STATUS	(*pInitRtn) (NET_POOL_ID pNetPool, M_CL_CONFIG * pMclBlkConfig,
                             CL_DESC * pClDescTbl, int clDescTblNumEnt,
			     BOOL fromKheap);

     
    void	(*pMblkFreeRtn) (NET_POOL_ID pNetPool, M_BLK_ID pMblk);

     
    void	(*pClBlkFreeRtn) (CL_BLK_ID pClBlk);

     
    void	(*pClFreeRtn) (NET_POOL_ID pNetPool, char * pClBuf);

     
    M_BLK_ID 	(*pMblkClFreeRtn) (NET_POOL_ID pNetPool, M_BLK_ID pMblk);

     
    M_BLK_ID	(*pMblkGetRtn) (NET_POOL_ID pNetPool, int canWait, UCHAR type);

     
    CL_BLK_ID	(*pClBlkGetRtn) (NET_POOL_ID pNetPool, int canWait);
    
     
    char *	(*pClGetRtn) (NET_POOL_ID pNetPool, CL_POOL_ID pClPool);

     
    STATUS	(*pMblkClGetRtn) (NET_POOL_ID pNetPool, M_BLK_ID pMblk,
                                  int bufSize, int canWait, BOOL bestFit);

     
    CL_POOL_ID	(*pClPoolIdGetRtn) (NET_POOL_ID pNetPool, int	bufSize,
                                    BOOL bestFit);
    };

struct netPool				 
    {
    M_BLK_ID	pmBlkHead;		 
    CL_BLK_ID	pClBlkHead;		 
    int		mBlkCnt;		 
    int		mBlkFree;		 


    int		clMask;			 
    int		clLg2Max;		 
    int		clSizeMax;		 
    int		clLg2Min;		 
    int		clSizeMin;		 
    CL_POOL * 	clTbl [((16   - 6  )  + 1) ];	 
    M_STAT *	pPoolStat;		 
    POOL_FUNC *	pFuncTbl;		 
    };

                     
                    
extern  STATUS 		netBufLibInit (void);
extern  STATUS 		netPoolInit (NET_POOL_ID pNetPool,
                                     M_CL_CONFIG * pMclBlkConfig,
                                     CL_DESC * pClDescTbl, int clDescTblNumEnt,
                                     POOL_FUNC * pFuncTbl);
extern  STATUS		netPoolDelete (NET_POOL_ID);
extern  void		netMblkFree (NET_POOL_ID pNetPool, M_BLK_ID pMblk);
extern  void		netClBlkFree (NET_POOL_ID pNetPool, CL_BLK_ID pClBlk);
extern  void 		netClFree (NET_POOL_ID pNetPool, UCHAR * pClBuf);
extern  M_BLK_ID 	netMblkClFree (M_BLK_ID pMblk);
extern  void		netMblkClChainFree (M_BLK_ID pMblk);
extern  M_BLK_ID 	netMblkGet (NET_POOL_ID pNetPool, int canWait,
                                    UCHAR type);
extern  CL_BLK_ID	netClBlkGet (NET_POOL_ID pNetPool, int canWait);
extern  char *	 	netClusterGet (NET_POOL_ID pNetPool,
                                       CL_POOL_ID pClPool);
extern  STATUS 	 	netMblkClGet (NET_POOL_ID pNetPool, M_BLK_ID pMblk,
                                      int bufSize, int canWait, BOOL bestFit);
extern  M_BLK_ID 	netTupleGet (NET_POOL_ID pNetPool, int bufSize,
                                     int canWait, UCHAR type, BOOL bestFit);

extern  M_BLK_ID 	netTupleGet2 (NET_POOL_ID, int, int);

extern  CL_BLK_ID  	netClBlkJoin (CL_BLK_ID pClBlk, char * pClBuf,
                                      int size, FUNCPTR pFreeRtn, int arg1,
                                      int arg2, int arg3);
extern  M_BLK_ID  	netMblkClJoin (M_BLK_ID pMblk, CL_BLK_ID pClBlk);
extern  CL_POOL_ID 	netClPoolIdGet (NET_POOL_ID pNetPool, int bufSize,
                                        BOOL bestFit);

extern  int 		netMblkToBufCopy (M_BLK_ID pMblk, char * pBuf,
                                          FUNCPTR pCopyRtn);
extern  int		netMblkOffsetToBufCopy (M_BLK_ID pMblk, int offset,
                                                char * pBuf, int len,
                                                FUNCPTR	pCopyRtn);
extern  M_BLK_ID 	netMblkDup (M_BLK_ID pSrcMblk, M_BLK_ID	pDestMblk);
extern  M_BLK_ID 	netMblkChainDup (NET_POOL_ID pNetPool, M_BLK_ID	pMblk,
                                         int offset, int len, int canWait);

















 























 



 


 













 





 





 





 





 






 










 










 








 















 

 












 






















        




    
 















 

extern  struct mbstat 	mbstat;			 
extern  M_CL_CONFIG	mClBlkConfig;		 
extern  CL_DESC 		clDescTbl [];		 
extern  int		clDescTblNumEnt; 	 
extern  M_CL_CONFIG	sysMclBlkConfig;	 
extern  CL_DESC 		sysClDescTbl [];	 
extern  int		sysClDescTblNumEnt; 	 


extern  NET_POOL_ID	_pNetDpool;		 
extern  NET_POOL_ID	_pNetSysPool;		 


 

extern int max_linkhdr;		 
extern int max_protohdr;	 
extern int max_hdr;		 
extern int max_datalen;		 

extern struct	mBlk  * netMblkClFree( struct mBlk  * ) ;
extern struct	mBlk  *m_getclr (int, UCHAR, int, BOOL);
extern struct	mBlk  *m_prepend (struct mBlk  *, int, int);
extern struct	mBlk  *m_pullup (struct mBlk  *, int);
extern void	m_adj (struct mBlk  *, int);
extern void	netMblkClChainFree( struct mBlk  * ) ;
extern void 	m_cat (struct mBlk  *, struct mBlk  *);
extern struct 	mBlk  *m_devget (char *, int, int, struct ifnet *,
				void (*copy)());
struct mBlk  *	mBufClGet (int, UCHAR, register  int, BOOL); 
struct mBlk  * 	mHdrClGet (int, UCHAR, register  int, BOOL); 

extern  struct mBlk  * bcopy_to_mbufs (u_char * buf, int totlen, int off0,
                                     struct ifnet * ifp, int width);
extern  struct mBlk  * build_cluster (u_char * buf, int totlen,
                                    struct ifnet * ifp, u_char ctype,
                                    u_char * pRefcnt, FUNCPTR freeRtn,
                                    int arg1, int arg2, int arg3);
extern  int	copyFromMbufs (char * pIobuf, struct mBlk  * pMbuf, int width);












 






struct socket
    {
    short	so_type;		 
    short	so_options;		 
    short	so_linger;		 
    short	so_state;		 
    caddr_t	so_pcb;			 
    struct	protosw *so_proto;	 

     



    int		so_userArg;		 
    SEM_ID	so_timeoSem;		 
    int		so_fd;			 

     











    struct	socket *so_head;	 
    struct	socket *so_q0;		 
    struct	socket *so_q;		 
    short	so_q0len;		 
    short	so_qlen;		 
    short	so_qlimit;		 
    short	so_timeo;		 
    u_short	so_error;		 
    short	so_pgrp;		 
    u_long	so_oobmark;		 

     

    struct	sockbuf
	{
	u_long		sb_cc;		 
	u_long		sb_hiwat;	 
	u_long		sb_mbcnt;	 
	u_long		sb_mbmax;	 
	u_long		sb_lowat;	 
	struct		mBlk  *sb_mb;	 
	struct		proc *sb_sel;	 
	short		sb_timeo;	 
	short		sb_flags;	 

	SEM_ID		sb_Sem;		 
	int		sb_want;	 
	} so_rcv, so_snd;










    void	(*so_upcall) (struct socket *so, caddr_t arg, int waitf);
    caddr_t	so_upcallarg;		 
    BOOL 	selectFlag; 		 
    SEL_WAKEUP_LIST so_selWakeupList;  
    int         vsid;                  
    };






 















 



 









 



 





 







 







 







 








 















extern  VOIDFUNCPTR sowakeupHook;

extern u_long	sb_max;

 


 
extern	char netio[], netcon[], netcls[];

 


extern int soo_ioctl (struct socket * so, int cmd, caddr_t data);
extern int soo_select (struct socket *so, SEL_WAKEUP_NODE *wakeupNode);
extern int soo_unselect (struct socket *so, SEL_WAKEUP_NODE *wakeupNode); 

struct mBlk ;
struct sockaddr;

extern void	sbappend (struct sockbuf *sb, struct mBlk  *m);
extern int	sbappendaddr (struct sockbuf *sb, struct sockaddr *asa,
	    struct mBlk  *m0, struct mBlk  *control);
extern int	sbappendcontrol (struct sockbuf *sb, struct mBlk  *m0,
	    struct mBlk  *control);
extern void	sbappendrecord (struct sockbuf *sb, struct mBlk  *m0);
extern void	sbcheck (struct sockbuf *sb);
extern void	sbcompress (struct sockbuf *sb, struct mBlk  *m, struct mBlk  *n);
extern void	sbdrop (struct sockbuf *sb, int len);
extern void	sbdroprecord (struct sockbuf *sb);
extern void	sbflush (struct sockbuf *sb);
extern void	sbinsertoob (struct sockbuf *sb, struct mBlk  *m0);
extern void	sbrelease (struct sockbuf *sb);
extern int	sbreserve (struct sockbuf *sb, u_long cc);
extern void	sbwait (struct sockbuf *sb);
extern void	sbwakeup(struct socket *so, struct sockbuf *sb,
			 SELECT_TYPE wakeupType);
extern int	sb_lock (struct sockbuf *sb);
extern int	soabort (struct socket *so);
extern int	soaccept (struct socket *so, struct mBlk  *nam);
extern int	sobind (struct socket *so, struct mBlk  *nam);
extern void	socantrcvmore (struct socket *so);
extern void	socantsendmore (struct socket *so);
extern int	soclose (struct socket *so);
extern int	soconnect (struct socket *so, struct mBlk  *nam);
extern int	soconnect2 (struct socket *so1, struct socket *so2);
extern int	socreate (int dom, struct socket **aso, int type, int proto);
extern int	sodisconnect (struct socket *so);
extern void	sofree (struct socket *so);
extern int	sogetopt (struct socket *so, int level, int optname,
	    struct mBlk  **mp);
extern void	sohasoutofband (struct socket *so);
extern void	soisconnected (struct socket *so);
extern void	soisconnecting (struct socket *so);
extern void	soisdisconnected (struct socket *so);
extern void	soisdisconnecting (struct socket *so);
extern int	solisten (struct socket *so, int backlog);
extern struct socket *
	sonewconn1 (struct socket *head, int connstatus);
extern void	soqinsque (struct socket *head, struct socket *so, int q);
extern int	soqremque (struct socket *so, int q);
extern int	soreceive (struct socket *so, struct mBlk  **paddr, 
			   struct uio *pUio, struct mBlk  **mp0, struct mBlk  **
			   controlp, int *flagsp);
extern int	soreserve (struct socket *so, u_long sndcc, u_long rcvcc);
extern void	sorflush (struct socket *so);
extern int	sosend (struct socket *so, struct mBlk  *addr, struct uio *uio,
	    struct mBlk  *top, struct mBlk  *control, int flags);
extern int	sosetopt (struct socket *so, int level, int optname,
	    struct mBlk  *m0);
extern int	soshutdown (struct socket *so, int how);
extern void	sowakeup (struct socket *so, struct sockbuf *sb, 
			  SELECT_TYPE wakeupType);







 

 

 


































 






















 



struct radix_node {
	struct	radix_mask *rn_mklist;	 
	struct	radix_node *rn_p;	 
	short	rn_b;			 
	char	rn_bmask;		 
	u_char	rn_flags;		 




	union {
		struct {			 
			caddr_t	rn_Key;	 
			caddr_t	rn_Mask;	 
			struct	radix_node *rn_Dupedkey;
		} rn_leaf;
		struct {			 
			int	rn_Off;		 
			struct	radix_node *rn_L; 
			struct	radix_node *rn_R; 
		}rn_node;
	}		rn_u;





};








 



extern struct radix_mask {
	short	rm_b;			 
	char	rm_unused;		 
	u_char	rm_flags;		 
	struct	radix_mask *rm_mklist;	 
	union	{
		caddr_t	rmu_mask;		 
		struct	radix_node *rmu_leaf;	 
	}	rm_rmu;
	int	rm_refs;		 
} *rn_mkfreelist;













struct radix_node_head {
	struct	radix_node *rnh_treetop;
	int	rnh_addrsize;		 
	int	rnh_pktsize;		 
	struct	radix_node *(*rnh_addaddr)	 
		(void *v, void *mask,
		     struct radix_node_head *head, struct radix_node nodes[]);
	struct	radix_node *(*rnh_addpkt)	 
		(void *v, void *mask,
		     struct radix_node_head *head, struct radix_node nodes[]);
	struct	radix_node *(*rnh_deladdr)	 
		(void *v, void *mask, struct radix_node_head *head);
	struct	radix_node *(*rnh_delpkt)	 
		(void *v, void *mask, struct radix_node_head *head);
	struct	radix_node *(*rnh_matchaddr)	 
		(void *v, struct radix_node_head *head, int);
        struct  radix_node *(*rnh_lookup)        
                (void *v, void *mask, struct radix_node_head *head);
	struct	radix_node *(*rnh_matchpkt)	 
		(void *v, struct radix_node_head *head);
	int	(*rnh_walktree)			 
		(struct radix_node_head *head, int (*f)(), void *w);
	struct	radix_node rnh_nodes[3];	 
};















void	 rn_init (void);

int	 rn_inithead (struct radix_node_head **, int);
int	 rn_destroyhead (struct radix_node_head *);
int	 rn_refines (void *, void *);
int	 rn_walksubtree (struct radix_node_head *, void *, void *,
                         int (*)(), void *);
int	 rn_walktree (struct radix_node_head *, int (*)(), void *);
struct radix_node
	 *rn_addmask (void *, int, int),
	 *rn_addroute (void *, void *, struct radix_node_head *,
			struct radix_node [2]),
	 *rn_delete (void *, void *, struct radix_node_head *),
	 *rn_insert (void *, struct radix_node_head *, int *,
			struct radix_node [2]),
	 *rn_match (void *, struct radix_node_head *, int),
	 *rn_newpair (void *, int, struct radix_node[2]),
	 *rn_search (void *, struct radix_node *),
	 *rn_search_m (void *, struct radix_node *, void *);














 






 




struct route
    {
    struct	rtentry *ro_rt;
    struct	sockaddr ro_dst;
    };

 



struct rt_metrics {
	u_long	rmx_locks;	 
	u_long	rmx_mtu;	 
	u_long	rmx_expire;	 
	u_long	rmx_recvpipe;	 
	u_long	rmx_sendpipe;	 
	u_long	rmx_ssthresh;	 
	u_long	rmx_rtt;	 
	u_long	rmx_rttvar;	 
	u_short	rmx_hopcount;	 
        u_short rmx_mss; 	 

         

        long 	value1;
        long 	value2;
        long 	value3;
        long 	value4;
        long 	value5;
        long 	routeTag;
        u_char  weight;
};

 






struct sockaddr_gate
    {
    u_char         gate_len;
    u_char         gate_family;
    u_char         routeProto;
    u_char         weight;
    u_long         gate_addr;
    long           value1;
    long           value2;
    long           value3;
    long           value4;
    long           value5;
    long           routeTag;
    };

 







 










struct rtentry {
	struct	radix_node rt_nodes[2];	 


	struct	sockaddr *rt_gateway;	 
	short	rt_flags;		 
	short	rt_refcnt;		 
	u_long	rt_use;			 
	struct	ifnet *rt_ifp;		 
	struct	ifaddr *rt_ifa;		 
	struct	sockaddr *rt_genmask;	 
	caddr_t	rt_llinfo;		 
	struct	rtentry *rt_gwroute;	 
        int	rt_mod;			  
	struct	rt_metrics rt_rmx;	 
        struct  rtentry *rt_parent;      
};

 



struct ortentry {
	u_long	rt_hash;		 
	struct	sockaddr rt_dst;	 
	struct	sockaddr rt_gateway;	 
	short	rt_flags;		 
	short	rt_refcnt;		 
	u_long	rt_use;			 
	struct	ifnet *rt_ifp;		 
        int	rt_mod;			 
};
























 

struct	rtstat
    {
    short	rts_badredirect;	 
    short	rts_dynamic;		 
    short	rts_newgateway;		 
    short	rts_unreach;		 
    short	rts_wildcard;		 
    };

 


struct rt_msghdr {
	u_short	rtm_msglen;	 
	u_char	rtm_version;	 
	u_char	rtm_type;	 
	u_short	rtm_index;	 
	int	rtm_flags;	 
	int	rtm_addrs;	 
	pid_t	rtm_pid;	 
	int	rtm_seq;	 
	int	rtm_errno;	 
	int	rtm_use;	 
	u_long	rtm_inits;	 
	struct	rt_metrics rtm_rmx;  
};































 











 












 










struct rt_addrinfo {
	int	rti_addrs;
	struct	sockaddr *rti_info[8 ];
};

struct route_cb {
	int	ip_count;
	int	ns_count;
	int	iso_count;
	int	any_count;
};











extern	struct	rtstat	rtstat;
extern	struct	radix_node_head *rt_tables[];
extern  int	rtmodified; 




int	 route_init (void);

void	 rt_maskedcopy (struct sockaddr *,
	    struct sockaddr *, struct sockaddr *);
int	 rt_setgate (struct rtentry *,
	    struct sockaddr *, struct sockaddr *);
void	 rtable_init (void **);
void	 rtalloc (struct route *);
struct rtentry *
	 rtalloc1 (struct sockaddr *, int, int);
void	 rtfree (struct rtentry *);
int	 rtinit (struct ifaddr *, int, int);
int	 rtioctl (int, caddr_t);
int	 rtredirect (struct sockaddr *, struct sockaddr *,
	    struct sockaddr *, int, struct sockaddr *, struct rtentry **);
int	 rtrequest (int, struct sockaddr *,
	    struct sockaddr *, struct sockaddr *, int, struct rtentry **);
int	 rtrequest11 (int, struct sockaddr *,
	    struct sockaddr *, struct sockaddr *, int, struct rtentry **);







 

 

 




















 


extern STATUS   ifAddrAdd (char *interfaceName, char *interfaceAddress,
                           char *broadcastAddress, int subnetMask);
extern STATUS 	ifAddrSet (char *interfaceName, char *interfaceAddress);
extern STATUS 	ifAddrDelete (char *interfaceName, char *interfaceAddress);
extern STATUS 	ifAddrGet (char *interfaceName, char *interfaceAddress);
extern STATUS 	ifBroadcastSet (char *interfaceName, char *broadcastAddress);
extern STATUS 	ifBroadcastGet (char *interfaceName, char *broadcastAddress);
extern STATUS 	ifDstAddrSet (char *interfaceName, char *dstAddress);
extern STATUS 	ifDstAddrGet (char *interfaceName, char *dstAddress);
extern STATUS 	ifMaskSet (char *interfaceName, int netMask);
extern STATUS 	ifMaskGet (char *interfaceName, int *netMask);
extern STATUS 	ifFlagChange (char *interfaceName, int flags, BOOL on);
extern STATUS 	ifFlagSet (char *interfaceName, int flags);
extern STATUS 	ifFlagGet (char *interfaceName, int *flags);
extern STATUS 	ifMetricSet (char *interfaceName, int metric);
extern STATUS 	ifMetricGet (char *interfaceName, int *pMetric);
extern int 	ifRouteDelete (char *ifName, int unit);
extern struct 	ifnet *ifunit (char *ifname);
extern struct	ifnet *ifIndexToIfpNoLock (int ifIndex);
extern struct	ifnet *ifIndexToIfp (int ifIndex);
extern unsigned short	ifNameToIfIndex (char *ifname);
extern STATUS	ifIndexToIfName (unsigned short ifIndex, char *ifname);
extern STATUS	ifUnnumberedSet(char *, char *, char *, char *);
extern int 	ifAllRoutesDelete (char *, int);












 
























struct	ifqueue {
	struct	mBlk  *ifq_head;
	struct	mBlk  *ifq_tail;
	int	ifq_len;
	int	ifq_maxlen;
	int	ifq_drops;
};

struct mBlk ;
struct proc;
struct rtentry;
struct socket;
struct ether_header;

 



struct	if_data {
	 
	u_char	ifi_type;		 
	u_char	ifi_addrlen;		 
	u_char	ifi_hdrlen;		 
	u_long	ifi_mtu;		 
	u_long	ifi_metric;		 
	u_long	ifi_baudrate;		 
	 
	u_long	ifi_ipackets;		 
	u_long	ifi_ierrors;		 
	u_long	ifi_opackets;		 
	u_long	ifi_oerrors;		 
	u_long	ifi_collisions;		 
	u_long	ifi_ibytes;		 
	u_long	ifi_obytes;		 
	u_long	ifi_imcasts;		 
	u_long	ifi_omcasts;		 
	u_long	ifi_iqdrops;		 
	u_long	ifi_noproto;		 
	u_long  ifi_lastchange;		 
};

 





struct ifnet {
	char	*if_name;		 
	struct	ifnet *if_next;		 
	struct	ifaddr *if_addrlist;	 
	int	if_pcount;		 
	caddr_t	if_bpf;			 
	u_short	if_index;		 
	short	if_unit;		 
	short	if_timer;		 
	short	if_flags;		 
	struct	if_data if_data;	 
	struct	mBlk *	pInmMblk; 	 
	int	(*if_init) 
		(int unit);		 
	int	(*if_output)		 
		(struct ifnet *, struct mBlk  *, struct sockaddr *, 
		 struct rtentry *);	
	int	(*if_start) 		 
    		(struct ifnet *);
	int	(*if_ioctl)		 
		(struct ifnet *, int cmd, caddr_t data);
	int	(*if_reset)		 
		(int unit);	
	int	(*if_resolve)();	 
	void	(*if_watchdog)		 
		(int unit);
	struct	ifqueue if_snd;		 
        void * 	pCookie; 		 



};














































 







 
















 














 





struct ifaddr {
	struct	sockaddr *ifa_addr;	 
	struct	sockaddr *ifa_dstaddr;	 

	struct	sockaddr *ifa_netmask;	 
	struct	ifnet *ifa_ifp;		 
	struct	ifaddr *ifa_next;	 
	void	(*ifa_rtrequest)();	 
	u_short	ifa_flags;		 
	short	ifa_refcnt;		 
	int	ifa_metric;		 
};


 



struct if_msghdr {
	u_short	ifm_msglen;	 
	u_char	ifm_version;	 
	u_char	ifm_type;	 
	int	ifm_addrs;	 
	int	ifm_flags;	 
	u_short	ifm_index;	 
	struct	if_data ifm_data; 
};

 



struct ifa_msghdr {
	u_short	ifam_msglen;	 
	u_char	ifam_version;	 
	u_char	ifam_type;	 
	int	ifam_addrs;	 
	int	ifam_flags;	 
	u_short	ifam_index;	 
	int	ifam_metric;	 
};

 





struct	ifreq {

	char	ifr_name[16 ];		 
	union {
		struct	sockaddr ifru_addr;
		struct	sockaddr ifru_dstaddr;
		struct	sockaddr ifru_broadaddr;
		short	ifru_flags;
		int	ifru_metric;
		caddr_t	ifru_data;
	} ifr_ifru;






};

struct ifaliasreq {
	char	ifra_name[16 ];		 
	struct	sockaddr ifra_addr;
	struct	sockaddr ifra_broadaddr;
	struct	sockaddr ifra_mask;
};

 



struct	ifmreq {

	char	ifr_name[16 ];		 
	int	ifr_tableLen;
	char 	*ifr_table;
};

 





struct	ifconf {
	int	ifc_len;		 
	union {
		caddr_t	ifcu_buf;
		struct	ifreq *ifcu_req;
	} ifc_ifcu;


};

 




typedef struct mtuQuery_t[TTT] 
	{
	UCHAR family;
	UINT32 dstIpAddr;
	UINT32 mtu;
	} MTU_QUERY;











extern struct ifnet * 	ifnet;		 
extern struct ifqueue 	rawintrq;	 

extern STATUS		if_attach (struct ifnet *);
extern void		if_down (struct ifnet *);
extern void		if_qflush (struct ifqueue *);


extern void		if_slowtimo (void);




extern void		if_up (struct ifnet *);
extern int		ifconf (int, caddr_t);
extern void		ifinit (void);
extern int		ifioctl (struct socket *, u_long, caddr_t);
extern int		ifpromisc (struct ifnet *, int);
extern struct ifaddr *	ifa_ifwithaddr (struct sockaddr *);
extern struct ifaddr *	ifa_ifwithaf (int);
extern struct ifaddr *	ifa_ifwithdstaddr (struct sockaddr *);
extern struct ifaddr *	ifa_ifwithnet (struct sockaddr *);
extern struct ifaddr *	ifaof_ifpforaddr (struct sockaddr *, struct ifnet *);
extern struct ifaddr *	ifa_ifwithroute(int, struct sockaddr *, 
					struct sockaddr*);
extern void		ifafree (struct ifaddr *);
extern void		link_rtrequest (int, struct rtentry *,
                                        struct sockaddr *);

struct port_enable_info{
	int port;
	int disable;
	int protocol;	 
	char description[64];
	int hitcount;
	struct port_enable_info *pnext;
};

typedef struct portUsing_hash[TTT]{
	int count;
	struct port_enable_info *pnext;
}portUsing_Hash;	 













 




 





















 









 


struct in_addr {
	u_long s_addr;
};

 










































 


struct sockaddr_in {
	u_char	sin_len;
	u_char	sin_family;
	u_short	sin_port;
	struct	in_addr sin_addr;
	char	sin_zero[8];
};

 





struct sockaddr_rt {
	u_char	srt_len;
	u_char	srt_family;
        u_char  srt_proto;
        u_char  srt_tos;          
	struct	in_addr srt_addr;
	char	sin_zero[8];
        };












 






struct ip_opts {
	struct	in_addr ip_dst;		 
	char	opts[40];		 
};

 



















 






 









struct ip_mreq {
 struct in_addr imr_multiaddr;  
   union {
     struct in_addr u_imr_interface; 
     int       u_imr_index;       
 } imr_arg;
};







 









 



















 


















extern	struct domain inetdomain;
extern  BOOL inet_netmatch(struct sockaddr_in *sin1, struct sockaddr_in *sin2);
extern  void in_makeaddr_b(u_long net, u_long host, struct in_addr * pAddr);
extern 	u_long in_lnaof();
extern	void in_ifaddr_remove();
extern	int in_broadcast (struct in_addr, struct ifnet *);
extern	int in_canforward (struct in_addr);
extern	int in_cksum (struct mBlk  *, int);
extern	int in_localaddr (struct in_addr);
extern	u_long in_netof (struct in_addr);
extern	void in_socktrim (struct sockaddr_in *);
extern  struct in_ifaddr *in_iaonnetof(u_long net);
















 





 










 













 
 


 



























 










 
extern void tmd_init(void *bp);

 


struct sirocco_bootp_req_info {
    char serial_number[12];
    int slot_number;
    short int board_style;
    short int card_function;
};

 


struct sirocco_bootp_resp_info {
    struct in_addr scm_addr;
    struct in_addr scm_mask;
    struct in_addr sca_addr;
    struct in_addr sca_mask;
    struct in_addr gate_addr;
};

union sirocco_bootp_vend_info {
    struct sirocco_bootp_req_info req_info;
    struct sirocco_bootp_resp_info resp_info;
};





extern int Inital_load_complete;
extern unsigned int InitialTextLoadAddr;
extern unsigned int TextLoadAddr;


 
int getSlotNumber(void);









extern int sysShutdown;
extern int sysPoweroff;

typedef enum {
    INIT_ERROR_NONE[TTT],
    INIT_ERROR_MINOR,
    INIT_ERROR_MAJOR,
    INIT_ERROR_FATAL
} InitErrorEnum;

struct globals {
     



    char externalDevName[10 ];   
    unsigned long externalIPAddress;     
    unsigned long externalNetmask;   
    unsigned long externalBroadcast;     
    unsigned long gatewayIpAddress;  
    unsigned long nodeIPAddress;     
    unsigned long nodeIPNetmask;     
    char serialNumber[12 ];   
    unsigned long physicalSlot;  
    unsigned long logicalSlot;   

    int cardFunction;            
    int boardStyle;              
    int cardState;               
    int warmStart;               
    int coldStart;               
    
    struct acb **applicationACBs;

    InitErrorEnum ErrorLevel;    

    int activeInterface;         
    char actIfName[10 ];     
    unsigned long activeIpAddr;  
    char loadPath[100 ];  
    int chassisType;             

    void *moduleInfo;            
    void *logQueue;              
    unsigned int *sizes;         
    unsigned int *npool;         
    unsigned int *nused;         
    unsigned long memRatio;

    unsigned long externalIPAddressSec;
    unsigned long externalNetmaskSec;
    int ethernetEnable;

     



    unsigned long GmplsIPAddress; 
    unsigned long GmplsIPNetmask; 

};



 





 










 















extern struct globals globals;

extern short getPortNumber(void);






 









typedef unsigned char Uint8[TTT];
typedef signed char Int8[TTT];

typedef unsigned short Uint16[TTT];
typedef short Int16[TTT];

typedef unsigned int Uint32[TTT];
typedef int Int32[TTT];


typedef unsigned char Boolean[TTT];





 












 
 
 
 




   
typedef struct
{
    short proxy_slot_list[TTT][40 +1];      
} fdrProxyList_t;

 
 
 
 
 
 
 
 
struct cmndSlotUpdate
{
    command_tt head;
    int reg_flags;                       
    int physical_slot;                   
    int board_function;                  

    int card_function;                   
    int card_style;                      
    int card_state;                      
    int last_card_style;                 
    int isCardSmart;                     
    int proxy_slot;                      

    int response_required;               
    int logical_slot;                    
    unsigned int sparedslots_bitmask;    
};
typedef struct cmndSlotUpdate[TTT] cmndSlotUpdate_t;

 
 
 

 
 
 
 
 












 
 
 
 
 









extern STATUS fdrcoll_Register_Notification(UINT32 physical_slot, int reg_flags);
extern STATUS fdrcoll_UnRegister_Notification(UINT32 physical_slot,
                                              int reg_flags);
 
 
 
 
 
extern int fdr_poll_slot_state(UINT32 phys_slot);
extern int fdr_poll_slot_style(UINT32 phys_slot);
extern int fdr_poll_last_slot_style(UINT32 phys_slot);
extern int fdr_poll_slot_function(UINT32 phys_slot);
extern int fdr_poll_slot_operational_function(UINT32 phys_slot);
extern int fdr_poll_slot_running_function(UINT32 phys_slot);
extern int fdr_poll_proxy_slot(UINT32 phys_slot);
extern int fdr_poll_slot_is_card_smart(UINT32 phys_slot);
extern int fdr_get_logical_slot_of_physical_slot(UINT32 phys_slot);
extern int fdr_get_physical_slot_of_logical_slot(UINT32 logical_slot);
extern int fdr_fetch_proxy_slots_for_card(UINT32 phys_slot,
                                          fdrProxyList_t *proxylist);
extern int fdr_poll_all_info_for_slot(UINT32 pslot, cmndSlotUpdate_t *csu);

 
 
 
 
 
extern int fdrcoll_get_local_card_state(void);
extern STATUS fdrcoll_Register_Mapping_Notification(void);
extern void fdr_transmit_slot_notification_response(cmndSlotUpdate_t *msg);
extern unsigned int fdrcoll_what_was_last_Eval_broadcast_key(void);
extern int fdr_poll_slot_is_soft_synchronized(UINT32 phys_slot);


 

   

















 
 
 

 
    typedef struct {
        command_tt[TTT] head;
        applId_tt applId;
        unsigned int new_state;
        unsigned int failure_mode;
        unsigned int slot_event_key;
    } cmndFmtFDRcommand_t;

    typedef struct {
        command_tt[TTT] head;
        unsigned int card_state;
        unsigned int slot_event_key;

    } cmndFdrCardStateChange_t;

    typedef struct {
        command_tt[TTT] head;
        int board_type;
        int board_function;
        int card_state;
        int phys_slot;
        unsigned int slot_event_key;
    } cmndFdrQuery_t;

    typedef struct {
        command_tt[TTT] head;
        unsigned int slot_event_key;
        char i2cAddr[30];
        int phys_slot;
        unsigned int entity_id_number;
        short entity_index;
    } cmndFdrBackplaneQuery_t;

    typedef struct {
        command_tt[TTT] head;
        int physical_slot;
        int prior_card_type;
    } cmndFdrRemoveIntf_t;

    typedef struct {
        command_tt[TTT] head;
        int physical_slot;
        char i2cAddr[30];
        unsigned int slot_event_key;

    } cmndFdrDumbCardQuery_t;

 
    typedef struct {
        command_tt[TTT] head;
        int notified_card_state;
    } cmndFdrMapNotify_t;

    typedef struct {
        command_tt[TTT] head;
        int applnum;
        char applname[30];
        int notification;
        int status;
        int flag_fdr_reports;
        int options;
    } cmndFdrCollReg_t;

 







 
 
 




































 





 
 
 
 





 






 









 







enum
{
    CMM_LEVEL_ERR = 0,
    CMM_LEVEL_CMC,
    CMM_LEVEL_SLOT,
    CMM_LEVEL_STATE,
    CMM_LEVEL_ALMEVT
};

enum
{
    CMM_LEVEL_CAI = 0,
    CMM_LEVEL_CMI
};

enum
{
    CMM_LEVEL_CAD = 0,
    CAD_LEVEL_ALMEVT,
    CAD_LEVEL_ERR
};
enum
{
    CMND_CM_DATA_INIT_COMPLETE = 0x3800 ,
    CMND_CM_CARDPROV,
    CMND_CM_CARDSTATECHG,
    CMND_CM_READYTOINIT,
    CMND_CM_READYTOACT,
    CMND_CM_PREPARETOACT,
    CMND_CM_DEINIT,
    CMND_CM_DEACT,
    CMND_CM_INITDRV,
    CMND_CM_RESTOREAPP,
    CMND_CM_INITAPP,
    CMND_CM_ACTDRV,
    CMND_CM_ACTAPP,
    CMND_CM_INITDRVOK,
    CMND_CM_INITDRVFAIL,
    CMND_CM_INITAPPOK,
    CMND_CM_INITAPPFAIL,
    CMND_CM_ACTDRVOK,
    CMND_CM_ACTDRVFAIL,
    CMND_CM_ACTAPPOK,
    CMND_CM_ACTAPPFAIL,
    CMND_CM_CHECKSTATE,          
    CMND_CM_CHECKSTATE_ACK,          
    CMND_CM_DRVSTAE,             
    CMND_CM_INSERT,
    CMND_CM_REMOVE,
    CMND_CM_FAIL,
    CMND_CM_FAILCLR,
    CMND_CM_ACTIVECC,
    CMND_CM_PHYINSERT,
    CMND_CM_APP_QUERY_MIBCARD,
    CMND_CM_MIBCARD,
    CMND_CM_MIBCARD_ACK,
    CMND_CM_CARDSTATE,
    CMND_CM_CARDSTATE_ACK,
    CMND_CM_MIBCARD_INIT_FINISH,
    CMND_CM_CMI_STARTED,
    CMND_CM_MIBCARD_ACT_FINISH,
    CMND_CM_RESTORE_CARD,
    CMND_CM_ADD_CARD,
    CMND_CM_DEL_CARD,
    CMND_CM_CARD_DOWN,
    CMND_CM_CARD_UP,
    CMND_CM_DELCARD,
    CMND_CM_RESETCARD,
    CMND_CM_REBOOT,
    CMND_CM_HALT,
    CMND_CM_HALT_ACK,
    CMND_CM_LATCH_STATE,
    CMND_CM_ACTIVECCDOWN,
    CMND_CM_ACTIVECCUP,
    CMND_CM_REPORT_CARD_DEFECT,
    CMND_CM_REPORT_CARD_PRESENCE,
    CMND_CM_DISABLECARD,
    CMND_CM_ENABLECARD,
    CMND_CM_TASK_READY,
    CMND_CM_TASK_READY_ACK,
    CMND_CM_SLOT_UPDATE,
    CMND_CM_CC_CAPABILITY_QUERY,   
    CMND_CM_CC_CAPABILITY,         
    CMND_CM_CC_CAPABILITY_ACK,     
    CMND_CM_CPC_LOCC_CAPACITY,      
    CMND_CM_CPC_HOCC_PHYSTATE,     
    CMND_CM_CPC_HOCC_PHYSTATE_ACK,  
    CMND_CM_CC_QUERY_ACTIVECC,         
    CMND_CM_APP_QUERY_CARDSTATE,        
    CMND_CM_APP_QUERY_CARDSTATE_RESPD,        
    CMND_CM_CARD_REBOOT,
    CMND_CM_RESETCPU,                         
    CMND_CM_SET_TEMPTH,          
    CMND_CM_QUERY_LATCHSTATE,
    CMND_CM_POLLING_STATE,          
    CMND_CM_MIBCARD_CHECKSTATE_FINISHED,    
    CMND_CM_UNITFAIL,                     
    CMND_CM_PCM_NOVALIDMIBCC,         
    CMND_CM_SWFPGAVS,              
    CMND_CM_VCXOOCXOFAIL,         
    CMND_CM_CHECKMIBACTFINISH,     
    CMND_CM_SETSILED,     
    CMND_CM_SHUTDOWNLAMP,     
    CMND_CM_SETLAMP,     
    CMND_CM_STOPSLAVECCCHECK,     
    CMND_CM_HOCC_POWER_FAIL,       
    CMND_CM_QUERY_TEMP_THRESHOLD,  
    CMND_CM_TEMP_THRESHOLD_ACK,    
    CMND_CM_SET_CARDTYPE,     
    CMND_CM_SET_HOCC_AIS,
    CMND_CM_SET_PORT_STATUS,
    CMND_CM_ACTIVE_HOCC_COLD_REBOOT,
    CMND_CM_ALL_LCCARD_ACTIVE,
    CMND_CM_FAN_PWR_INFO_QUERY,
    CMND_CM_FAN_PWR_INFO_RESP,
    CMND_CM_FAN_FAILED
};

typedef enum _CM_CARDBASESTATE_T[TTT]
{
    CM_BASSTATE_NONE=0,          
    CM_BASSTATE_UP = 1,          
    CM_BASSTATE_DOWN = 2,        
    CM_BASSTATE_UNKNOWN = 3      
} CM_CARDBASESTATE_T;

typedef struct _CM_CARDINFO_T[TTT]
{
    UINT32 slot;     
    UINT32 style;    
    UINT32 option;   
    BOOL   warm;     
    BOOL   cancfg;   
    BOOL   suspended;  
} CM_CARDINFO_T;

struct CM_INFO_CC_QURY_CPC_T
{
    UINT32 slot;
};

struct CM_RESET_CPU_T
{
    UINT32 Pslot;
};

struct CM_POLL_STATE_T
{
    UINT32 Pslot;
};


typedef struct _CM_ACTIVECC_DATA_T[TTT]
{
    UINT32                ActiveCC;
} CM_ACTIVECC_DATA_T;

typedef struct _CM_HOCC_PHYSTATE_T[TTT]
{
    SLOT_NUMBER_T slot;
    BOOL ispresent;
}CM_HOCC_PHYSTATE_T;

typedef struct _CM_CPC_CCPHYSTATE_T[TTT]
{
    command_tt            head;   
    CM_HOCC_PHYSTATE_T    info;   
} CM_CPC_CCPHYSTATE_T;

typedef struct _CM_CCS_CPC_READY_T[TTT]
{
    command_tt            head;   
    UINT32                slot;   
} CM_CCS_CPC_READY_T;


typedef struct _CM_CARDSTATE_DATA_T[TTT]
{
    CM_CARDINFO_T         card;
    UINT32                cmd;
} CM_CARDSTATE_DATA_T;

typedef struct _CM_CARDSTATE_ACK_DATA_T[TTT]
{
    CM_CARDINFO_T         card;
    UINT32                cmd;
    PB_ERROR_CODE_T       result;
} CM_CARDSTATE_ACK_DATA_T;

typedef struct _CM_MIBCARD_DATA_T[TTT]
{
    CM_CARDINFO_T         card[SLOT_NUMBER_MAX ];
} CM_MIBCARD_DATA_T;


typedef struct _CM_CARDSTATE_ARRY_T[TTT]
{
    CM_CARDSTATE_DATA_T         state[SLOT_NUMBER_MAX ];
} CM_CARDSTATE_ARRY_T;

typedef struct _CM_REPORT_CARD_DEFECT_DATA_T[TTT]
{
    UINT32 slot;
    BOOL ur;
    BOOL miscard;
    BOOL uf;
    BOOL initing;
    BOOL misslot;
} CM_REPORT_CARD_DEFECT_DATA_T;

typedef struct _CM_HALT_DATA_T[TTT]
{
    BOOL       warm;
    UINT32      type;    
} CM_HALT_DATA_T;

typedef enum
{
    TMS_NO_FAULTY_ALARM[TTT] = 0,
    TMS_VCXO_FAIL,
    TMS_OCXO_FAIL,
    TMS_HOCC_POWER_FAIL
}CM_VCXOOCXO_FAULTY_TYPE;
 
typedef struct
{
    UINT8[TTT]                   slot;
    CM_VCXOOCXO_FAULTY_TYPE    faultyType;
    BOOL                       vcxofail;
}CM_RECV_VOCXO_MSG_T;


 
 
typedef struct
{
    command_tt[TTT]              head;
    UINT8                   slot;
    CM_VCXOOCXO_FAULTY_TYPE    faultyType;
    BOOL                       vcxofail;
} CM_VCXOOCXO_FAIL_IND_MSG_T;

typedef struct
{
    UINT8[TTT]           high;
    UINT8           low;
    UINT8           slot;
}CM_TEMP_THRESHOLD_T;


 
typedef struct
{
    command_tt[TTT]              head;
    UINT8           high;
    UINT8           low;
    UINT8           slot;
} CM_TEMP_THRESHOLD_MSG_T;

 
typedef struct _CM_ACTIVECC_T[TTT]
{
    command_tt            head;     
    UINT32                ActiveCC; 
                                    
} CM_ACTIVECC_T;

 
typedef struct _CM_CARDSTATE_T[TTT]
{
    command_tt            head;   

    CM_CARDINFO_T         card;   
    UINT32                cmd;    
                                  
                                  
                                  
                                  
                                  
} CM_CARDSTATE_T;

 
typedef struct _CM_CARDSTATE_ACK_T[TTT]
{
    command_tt            head;  
  
    CM_CARDINFO_T         card;  
    UINT32                cmd;   
    PB_ERROR_CODE_T       result; 
} CM_CARDSTATE_ACK_T;

 
typedef struct _CM_APP_QUERY_CARDSTATE_T[TTT]
{
    command_tt            head;
} CM_APP_QUERY_CARDSTATE_T;

 
typedef struct _CM_APP_QUERY_CARDSTATE_REPD_T[TTT]
{
    command_tt            head;
    CM_CARDSTATE_ARRY_T         state;  
}CM_APP_QUERY_CARDSTATE_REPD_T;

 
typedef struct _CM_MIBCARD_T[TTT]
{
    command_tt            head;
    CM_CARDINFO_T         card[SLOT_NUMBER_MAX ];  
} CM_MIBCARD_T;

 
typedef struct _CM_MIBCARD_ACK_T[TTT]
{
    command_tt            head;
} CM_MIBCARD_ACK_T;

 
typedef struct _CM_APP_QUERY_MIBCARD_T[TTT]
{
    command_tt            head;
} CM_APP_QUERY_MIBCARD_T;


typedef struct _CM_REPORT_CARD_DEFECT_T[TTT]
{
    command_tt head;

    UINT32 slot;
    BOOL ur;
    BOOL miscard;
    BOOL uf;
    BOOL initing;
    BOOL misslot;
} CM_REPORT_CARD_DEFECT_T;



typedef struct _CM_HALT_T[TTT]
{
    command_tt head;
    BOOL       warm;
    UINT32      type;  
} CM_HALT_T;

typedef struct _CM_LATCH_T[TTT]
{
    command_tt          head;
    UINT32                 slot;
    UINT32                 state;
} CM_LATCH_T;

typedef enum{
    NE_HOCC_CAPABILITY_UNKNOW[TTT] = 0,      
    NE_HOCC_CAPABILITY_340G   = 1,      
    NE_HOCC_CAPABILITY_680G  = 2       
}eNeHOCCCapability;

typedef enum{
    NE_LOCC_CAPABILITY_UNKNOW[TTT] = 0,      
    NE_LOCC_CAPABILITY_NONE     =1,     
    NE_LOCC_CAPABILITY_20G    = 2,      
    NE_LOCC_CAPABILITY_40G  = 3       
}eNeLOCCCapability;

typedef struct _CM_CC_CAPABILITY_T[TTT]
{
    command_tt            head;
    eNeHOCCCapability       eHOCCCapability;
    eNeLOCCCapability       eLOCCCapability;
} CM_CC_CAPABILITY_T;

typedef struct _CM_REBOOTCARD_T[TTT]
{
    command_tt          head;
    UINT32 slot;
    BOOL   warm;
} CM_REBOOTCARD_T;














 








 

 
 
 
 
 
 
 
 
 
 
 




 








 




 



 
extern MIBDid_t iso_Did;

   


 



 
extern MIBDid_t org_Did;

   


 



 
extern MIBDid_t dod_Did;

   


 



 
extern MIBDid_t internet_Did;

   


 



 
extern MIBDid_t mgmt_Did;

   


 



 
extern MIBDid_t private_Did;

   


 



 
extern MIBDid_t snmpV2_Did;

   


 



 
extern MIBDid_t snmpModules_Did;

   


 



 
extern MIBDid_t enterprises_Did;

   








 




 



 
extern MIBDid_t mib_2_Did;

   


 



 
extern MIBDid_t at_Did;

   


 



 
extern MIBDid_t ip_Did;

   
typedef enum {
	ipForwarding_forwarding[TTT]=1,
	ipForwarding_not_forwarding=2
} ipForwarding_Tval;

typedef struct
{
	ipForwarding_Tval[TTT] ipForwarding;
	int		ipDefaultTTL;
	unsigned int	ipInReceives;
	unsigned int	ipInHdrErrors;
	unsigned int	ipInAddrErrors;
	unsigned int	ipForwDatagrams;
	unsigned int	ipInUnknownProtos;
	unsigned int	ipInDiscards;
	unsigned int	ipInDelivers;
	unsigned int	ipOutRequests;
	unsigned int	ipOutDiscards;
	unsigned int	ipOutNoRoutes;
	int		ipReasmTimeout;
	unsigned int	ipReasmReqds;
	unsigned int	ipReasmOKs;
	unsigned int	ipReasmFails;
	unsigned int	ipFragOKs;
	unsigned int	ipFragFails;
	unsigned int	ipFragCreates;
	unsigned int	ipRoutingDiscards;
}MIBip_t;

























 



 
extern MIBDid_t icmp_Did;

   
typedef struct
{
	unsigned int	icmpInMsgs[TTT];
	unsigned int	icmpInErrors;
	unsigned int	icmpInDestUnreachs;
	unsigned int	icmpInTimeExcds;
	unsigned int	icmpInParmProbs;
	unsigned int	icmpInSrcQuenchs;
	unsigned int	icmpInRedirects;
	unsigned int	icmpInEchos;
	unsigned int	icmpInEchoReps;
	unsigned int	icmpInTimestamps;
	unsigned int	icmpInTimestampReps;
	unsigned int	icmpInAddrMasks;
	unsigned int	icmpInAddrMaskReps;
	unsigned int	icmpOutMsgs;
	unsigned int	icmpOutErrors;
	unsigned int	icmpOutDestUnreachs;
	unsigned int	icmpOutTimeExcds;
	unsigned int	icmpOutParmProbs;
	unsigned int	icmpOutSrcQuenchs;
	unsigned int	icmpOutRedirects;
	unsigned int	icmpOutEchos;
	unsigned int	icmpOutEchoReps;
	unsigned int	icmpOutTimestamps;
	unsigned int	icmpOutTimestampReps;
	unsigned int	icmpOutAddrMasks;
	unsigned int	icmpOutAddrMaskReps;
}MIBicmp_t;































 



 
extern MIBDid_t tcp_Did;

   
typedef enum {
	tcpRtoAlgorithm_other[TTT]=1,
	tcpRtoAlgorithm_constant=2,
	tcpRtoAlgorithm_rsre=3,
	tcpRtoAlgorithm_vanj=4
} tcpRtoAlgorithm_Tval;

typedef struct
{
	tcpRtoAlgorithm_Tval[TTT] tcpRtoAlgorithm;
	int		tcpRtoMin;
	int		tcpRtoMax;
	int		tcpMaxConn;
	unsigned int	tcpActiveOpens;
	unsigned int	tcpPassiveOpens;
	unsigned int	tcpAttemptFails;
	unsigned int	tcpEstabResets;
	unsigned int	tcpCurrEstab;
	unsigned int	tcpInSegs;
	unsigned int	tcpOutSegs;
	unsigned int	tcpRetransSegs;
	unsigned int	tcpInErrs;
	unsigned int	tcpOutRsts;
}MIBtcp_t;



















 



 
extern MIBDid_t udp_Did;

   
typedef struct
{
	unsigned int	udpInDatagrams[TTT];
	unsigned int	udpNoPorts;
	unsigned int	udpInErrors;
	unsigned int	udpOutDatagrams;
}MIBudp_t;









 



 
extern MIBDid_t egp_Did;

   
typedef struct
{
	unsigned int	egpInMsgs[TTT];
	unsigned int	egpInErrors;
	unsigned int	egpOutMsgs;
	unsigned int	egpOutErrors;
	int		egpAs;
}MIBegp_t;










 



 
extern MIBDid_t transmission_Did;

   


 



 
 
extern MIBDid_t egpNeighTable_Did;

   
typedef enum {
	egpNeighState_idle[TTT]=1,
	egpNeighState_acquisition=2,
	egpNeighState_down=3,
	egpNeighState_up=4,
	egpNeighState_cease=5
} egpNeighState_Tval;

typedef enum {
	egpNeighMode_active[TTT]=1,
	egpNeighMode_passive=2
} egpNeighMode_Tval;

typedef enum {
	egpNeighEventTrigger_start[TTT]=1,
	egpNeighEventTrigger_stop=2
} egpNeighEventTrigger_Tval;

typedef struct
{
	unsigned int	egpNeighAddr[TTT];                                    
	egpNeighState_Tval egpNeighState;
	int		egpNeighAs;
	unsigned int	egpNeighInMsgs;
	unsigned int	egpNeighInErrs;
	unsigned int	egpNeighOutMsgs;
	unsigned int	egpNeighOutErrs;
	unsigned int	egpNeighInErrMsgs;
	unsigned int	egpNeighOutErrMsgs;
	unsigned int	egpNeighStateUps;
	unsigned int	egpNeighStateDowns;
	int		egpNeighIntervalHello;
	int		egpNeighIntervalPoll;
	egpNeighMode_Tval egpNeighMode;
	egpNeighEventTrigger_Tval egpNeighEventTrigger;
}MIBegpNeighTable_t;






















 



 
 
extern MIBDid_t udpTable_Did;

   
typedef struct
{
	unsigned int	udpLocalAddress[TTT];                     
	int		udpLocalPort;                                
}MIBudpTable_t;









 



 
 
extern MIBDid_t tcpConnTable_Did;

   
typedef enum {
	tcpConnState_closed[TTT]=1,
	tcpConnState_listen=2,
	tcpConnState_synSent=3,
	tcpConnState_synReceived=4,
	tcpConnState_established=5,
	tcpConnState_finWait1=6,
	tcpConnState_finWait2=7,
	tcpConnState_closeWait=8,
	tcpConnState_lastAck=9,
	tcpConnState_closing=10,
	tcpConnState_timeWait=11,
	tcpConnState_deleteTCB=12
} tcpConnState_Tval;

typedef struct
{
	unsigned int	tcpConnLocalAddress[TTT];                         
	int		tcpConnLocalPort;                                    
	unsigned int	tcpConnRemAddress;                           
	int		tcpConnRemPort;                                      
	tcpConnState_Tval tcpConnState;
}MIBtcpConnTable_t;












 



 
 
extern MIBDid_t ipAddrTable_Did;

   
typedef struct
{
	unsigned int	ipAdEntAddr[TTT];                                 
	int		ipAdEntIfIndex;
	unsigned int	ipAdEntNetMask;
	unsigned int	ipAdEntBcastAddr;
	int		ipAdEntReasmMaxSize;
}MIBipAddrTable_t;












 



 
 
extern MIBDid_t ipRouteTable_Did;

   
typedef enum {
	ipRouteType_other[TTT]=1,
	ipRouteType_invalid=2,
	ipRouteType_direct=3,
	ipRouteType_indirect=4
} ipRouteType_Tval;

typedef enum {
	ipRouteProto_other[TTT]=1,
	ipRouteProto_local=2,
	ipRouteProto_netmgmt=3,
	ipRouteProto_icmp=4,
	ipRouteProto_egp=5,
	ipRouteProto_ggp=6,
	ipRouteProto_hello=7,
	ipRouteProto_rip=8,
	ipRouteProto_is_is=9,
	ipRouteProto_es_is=10,
	ipRouteProto_ciscoIgrp=11,
	ipRouteProto_bbnSpfIgp=12,
	ipRouteProto_ospf=13,
	ipRouteProto_bgp=14
} ipRouteProto_Tval;

typedef struct
{
	unsigned int	ipRouteDest[TTT];                       
	int		ipRouteIfIndex;
	int		ipRouteMetric1;
	int		ipRouteMetric2;
	int		ipRouteMetric3;
	int		ipRouteMetric4;
	unsigned int	ipRouteNextHop;
	ipRouteType_Tval ipRouteType;
	ipRouteProto_Tval ipRouteProto;
	int		ipRouteAge;
	unsigned int	ipRouteMask;
	int		ipRouteMetric5;
	OIDValue	ipRouteInfo;
}MIBipRouteTable_t;




















 



 
 
extern MIBDid_t ipNetToMediaTable_Did;

   
typedef enum {
	ipNetToMediaType_other[TTT]=1,
	ipNetToMediaType_invalid=2,
	ipNetToMediaType_dynamic=3,
	ipNetToMediaType_static=4
} ipNetToMediaType_Tval;

typedef struct
{
	int		ipNetToMediaIfIndex[TTT];                                         
	unsigned int	ipNetToMediaNetAddress;                              
	int		ipNetToMediaPhysAddress_len;
	char		ipNetToMediaPhysAddress[255];
	ipNetToMediaType_Tval ipNetToMediaType;
}MIBipNetToMediaTable_t;











 



 
 
extern MIBDid_t atTable_Did;

   
typedef struct
{
	int		atIfIndex[TTT];                               
	int		atNetAddress_len;
	char		atNetAddress[8];                        
	int		atPhysAddress_len;
	char		atPhysAddress[255];
}MIBatTable_t;















 




 



 
extern MIBDid_t snmpMIB_Did;

   


 



 
extern MIBDid_t snmpMIBObjects_Did;

   


 



 
extern MIBDid_t snmpMIBConformance_Did;

   


 



 
extern MIBDid_t snmpMIBCompliances_Did;

   


 



 
extern MIBDid_t snmpMIBGroups_Did;

   


 



 
extern MIBDid_t snmpTrap_Did;

   
typedef struct
{
	OIDValue[TTT]	snmpTrapOID;
	OIDValue	snmpTrapEnterprise;
}MIBsnmpTrap_t;







 



 
extern MIBDid_t snmpTraps_Did;

   


 



 
extern MIBDid_t snmpSet_Did;

   
typedef struct
{
	unsigned int	snmpSetSerialNo[TTT];
}MIBsnmpSet_t;






 



 
extern MIBDid_t system_Did;

   
typedef struct
{
	char		sysDescr[TTT][255];
	OIDValue	sysObjectID;
	unsigned int	sysUpTime;
	char		sysContact[255];
	char		sysName[255];
	char		sysLocation[255];
	int		sysServices;
	unsigned int	sysORLastChange;
}MIBsystem_t;













 



 
extern MIBDid_t snmp_Did;

   
typedef enum {
	snmpEnableAuthenTraps_enabled[TTT]=1,
	snmpEnableAuthenTraps_disabled=2
} snmpEnableAuthenTraps_Tval;

typedef struct
{
	unsigned int	snmpInPkts[TTT];
	unsigned int	snmpInBadVersions;
	unsigned int	snmpOutPkts;
	unsigned int	snmpInBadCommunityNames;
	unsigned int	snmpInBadCommunityUses;
	unsigned int	snmpInASNParseErrs;
	snmpEnableAuthenTraps_Tval snmpEnableAuthenTraps;
	unsigned int	snmpOutTraps;
	unsigned int	snmpOutGetResponses;
	unsigned int	snmpOutSetRequests;
	unsigned int	snmpOutGetNexts;
	unsigned int	snmpOutGetRequests;
	unsigned int	snmpOutGenErrs;
	unsigned int	snmpOutBadValues;
	unsigned int	snmpOutNoSuchNames;
	unsigned int	snmpOutTooBigs;
	unsigned int	snmpInTraps;
	unsigned int	snmpInGetResponses;
	unsigned int	snmpInSetRequests;
	unsigned int	snmpInGetNexts;
	unsigned int	snmpInGetRequests;
	unsigned int	snmpInTotalSetVars;
	unsigned int	snmpInTotalReqVars;
	unsigned int	snmpInGenErrs;
	unsigned int	snmpInReadOnlys;
	unsigned int	snmpInBadValues;
	unsigned int	snmpInNoSuchNames;
	unsigned int	snmpInTooBigs;
	unsigned int	snmpSilentDrops;
	unsigned int	snmpProxyDrops;
}MIBsnmp_t;



































 



 
 
extern MIBDid_t sysORTable_Did;

   
typedef struct
{
	int		sysORIndex[TTT];                          
	OIDValue	sysORID;
	char		sysORDescr[255];
	unsigned int	sysORUpTime;
}MIBsysORTable_t;
















 




 



 
extern MIBDid_t ianaifType_Did;

   







 




 



 
extern MIBDid_t interfaces_Did;

   
typedef struct
{
	int		ifNumber[TTT];
}MIBinterfaces_t;






 



 
extern MIBDid_t ifMIB_Did;

   


 



 
extern MIBDid_t ifMIBObjects_Did;

   
typedef struct
{
	unsigned int	ifTableLastChange[TTT];
	unsigned int	ifStackLastChange;
}MIBifMIBObjects_t;







 



 
extern MIBDid_t ifConformance_Did;

   


 



 
extern MIBDid_t ifGroups_Did;

   


 



 
extern MIBDid_t ifCompliances_Did;

   


 



 
 
extern MIBDid_t ifXTable_Did;

   
typedef enum {
	ifLinkUpDownTrapEnable_enabled[TTT]=1,
	ifLinkUpDownTrapEnable_disabled=2
} ifLinkUpDownTrapEnable_Tval;

typedef struct
{
	int		ifIndex[TTT];                                                           
	char		ifName[255];
	unsigned int	ifInMulticastPkts;
	unsigned int	ifInBroadcastPkts;
	unsigned int	ifOutMulticastPkts;
	unsigned int	ifOutBroadcastPkts;
	unsigned int	ifHCInOctets[2];
	unsigned int	ifHCInUcastPkts[2];
	unsigned int	ifHCInMulticastPkts[2];
	unsigned int	ifHCInBroadcastPkts[2];
	unsigned int	ifHCOutOctets[2];
	unsigned int	ifHCOutUcastPkts[2];
	unsigned int	ifHCOutMulticastPkts[2];
	unsigned int	ifHCOutBroadcastPkts[2];
	ifLinkUpDownTrapEnable_Tval ifLinkUpDownTrapEnable;
	unsigned int	ifHighSpeed;
	TruthValue_Tval ifPromiscuousMode;
	TruthValue_Tval ifConnectorPresent;
	char		ifAlias[64];
	unsigned int	ifCounterDiscontinuityTime;
}MIBifXTable_t;



























 



 
 
extern MIBDid_t ifTestTable_Did;

   
typedef enum {
	ifTestStatus_notInUse[TTT]=1,
	ifTestStatus_inUse=2
} ifTestStatus_Tval;

typedef enum {
	ifTestResult_none[TTT]=1,
	ifTestResult_success=2,
	ifTestResult_inProgress=3,
	ifTestResult_notSupported=4,
	ifTestResult_unAbleToRun=5,
	ifTestResult_aborted=6,
	ifTestResult_failed=7
} ifTestResult_Tval;

typedef struct
{
	int		ifIndex[TTT];                               
	unsigned int	ifTestId;
	ifTestStatus_Tval ifTestStatus;
	OIDValue	ifTestType;
	ifTestResult_Tval ifTestResult;
	OIDValue	ifTestCode;
	int		ifTestOwner_len;
	char		ifTestOwner[255];
}MIBifTestTable_t;














 



 
 
extern MIBDid_t ifRcvAddressTable_Did;

   
typedef enum {
	ifRcvAddressType_other[TTT]=1,
	ifRcvAddressType_volatile=2,
	ifRcvAddressType_nonVolatile=3
} ifRcvAddressType_Tval;

typedef struct
{
	int		ifIndex[TTT];                                             
	int		ifRcvAddressAddress_len;
	char		ifRcvAddressAddress[255];                           
	RowStatus_Tval ifRcvAddressStatus;
	ifRcvAddressType_Tval ifRcvAddressType;
}MIBifRcvAddressTable_t;











 



 
 
extern MIBDid_t ifStackTable_Did;

   
typedef struct
{
	int		ifStackHigherLayer[TTT];                                
	int		ifStackLowerLayer;                                 
	RowStatus_Tval ifStackStatus;
}MIBifStackTable_t;










 



 
 
extern MIBDid_t ifTable_Did;

   
typedef enum {
	ifAdminStatus_up[TTT]=1,
	ifAdminStatus_down=2,
	ifAdminStatus_testing=3
} ifAdminStatus_Tval;

typedef enum {
	ifOperStatus_up[TTT]=1,
	ifOperStatus_down=2,
	ifOperStatus_testing=3,
	ifOperStatus_unknown=4,
	ifOperStatus_dormant=5,
	ifOperStatus_notPresent=6,
	ifOperStatus_lowerLayerDown=7
} ifOperStatus_Tval;

typedef struct
{
	int		ifIndex[TTT];                                         
	char		ifDescr[255];
	IANAifType_Tval ifType;
	int		ifMtu;
	unsigned int	ifSpeed;
	int		ifPhysAddress_len;
	char		ifPhysAddress[255];
	ifAdminStatus_Tval ifAdminStatus;
	ifOperStatus_Tval ifOperStatus;
	unsigned int	ifLastChange;
	unsigned int	ifInOctets;
	unsigned int	ifInUcastPkts;
	unsigned int	ifInNUcastPkts;
	unsigned int	ifInDiscards;
	unsigned int	ifInErrors;
	unsigned int	ifInUnknownProtos;
	unsigned int	ifOutOctets;
	unsigned int	ifOutUcastPkts;
	unsigned int	ifOutNUcastPkts;
	unsigned int	ifOutDiscards;
	unsigned int	ifOutErrors;
	unsigned int	ifOutQLen;
	OIDValue	ifSpecific;
}MIBifTable_t;


































 




 



 
extern MIBDid_t snmpFrameworkMIB_Did;

   


 



 
extern MIBDid_t snmpFrameworkAdmin_Did;

   


 



 
extern MIBDid_t snmpFrameworkMIBObjects_Did;

   


 



 
extern MIBDid_t snmpFrameworkMIBConformance_Did;

   


 



 
extern MIBDid_t snmpFrameworkMIBCompliances_Did;

   


 



 
extern MIBDid_t snmpFrameworkMIBGroups_Did;

   


 



 
extern MIBDid_t snmpEngine_Did;

   
typedef struct
{
	int		snmpEngineID_len[TTT];
	char		snmpEngineID[32];
	int		snmpEngineBoots;
	int		snmpEngineTime;
	int		snmpEngineMaxMessageSize;
}MIBsnmpEngine_t;









 



 
extern MIBDid_t snmpAuthProtocols_Did;

   


 



 
extern MIBDid_t snmpPrivProtocols_Did;

   







 




 



 
extern MIBDid_t snmpMPDMIB_Did;

   


 



 
extern MIBDid_t snmpMPDAdmin_Did;

   


 



 
extern MIBDid_t snmpMPDMIBObjects_Did;

   


 



 
extern MIBDid_t snmpMPDMIBConformance_Did;

   


 



 
extern MIBDid_t snmpMPDMIBCompliances_Did;

   


 



 
extern MIBDid_t snmpMPDMIBGroups_Did;

   


 



 
extern MIBDid_t snmpMPDStats_Did;

   
typedef struct
{
	unsigned int	snmpUnknownSecurityModels[TTT];
	unsigned int	snmpInvalidMsgs;
	unsigned int	snmpUnknownPDUHandlers;
}MIBsnmpMPDStats_t;













 




 



 
extern MIBDid_t snmpTargetMIB_Did;

   


 



 
extern MIBDid_t snmpTargetObjects_Did;

   
typedef struct
{
	unsigned int	snmpTargetSpinLock[TTT];
	unsigned int	snmpUnavailableContexts;
	unsigned int	snmpUnknownContexts;
}MIBsnmpTargetObjects_t;








 



 
extern MIBDid_t snmpTargetConformance_Did;

   


 



 
extern MIBDid_t snmpTargetCompliances_Did;

   


 



 
extern MIBDid_t snmpTargetGroups_Did;

   


 



 
 
extern MIBDid_t snmpTargetAddrTable_Did;

   
typedef struct
{
	char		snmpTargetAddrName[TTT][32];                                         
	OIDValue	snmpTargetAddrTDomain;
	int		snmpTargetAddrTAddress_len;
	char		snmpTargetAddrTAddress[255];
	int		snmpTargetAddrTimeout;
	int		snmpTargetAddrRetryCount;
	int		snmpTargetAddrTagList_len;
	char		snmpTargetAddrTagList[255];
	char		snmpTargetAddrParams[32];
	StorageType_Tval snmpTargetAddrStorageType;
	RowStatus_Tval snmpTargetAddrRowStatus;
}MIBsnmpTargetAddrTable_t;
















 



 
 
extern MIBDid_t snmpTargetParamsTable_Did;

   
typedef struct
{
	char		snmpTargetParamsName[TTT][32];                                               
	int		snmpTargetParamsMPModel;
	int		snmpTargetParamsSecurityModel;
	char		snmpTargetParamsSecurityName[255];
	SnmpSecurityLevel_Tval snmpTargetParamsSecurityLevel;
	StorageType_Tval snmpTargetParamsStorageType;
	RowStatus_Tval snmpTargetParamsRowStatus;
}MIBsnmpTargetParamsTable_t;



















 




 



 
extern MIBDid_t snmpNotificationMIB_Did;

   


 



 
extern MIBDid_t snmpNotifyObjects_Did;

   


 



 
extern MIBDid_t snmpNotifyConformance_Did;

   


 



 
extern MIBDid_t snmpNotifyCompliances_Did;

   


 



 
extern MIBDid_t snmpNotifyGroups_Did;

   


 



 
 
extern MIBDid_t snmpNotifyTable_Did;

   
typedef enum {
	snmpNotifyType_trap[TTT]=1,
	snmpNotifyType_inform=2
} snmpNotifyType_Tval;

typedef struct
{
	char		snmpNotifyName[TTT][32];                                     
	int		snmpNotifyTag_len;
	char		snmpNotifyTag[255];
	snmpNotifyType_Tval snmpNotifyType;
	StorageType_Tval snmpNotifyStorageType;
	RowStatus_Tval snmpNotifyRowStatus;
}MIBsnmpNotifyTable_t;












 



 
 
extern MIBDid_t snmpNotifyFilterProfileTable_Did;

   
typedef struct
{
	char		snmpTargetParamsName[TTT][32];                                                     
	char		snmpNotifyFilterProfileName[32];
	StorageType_Tval snmpNotifyFilterProfileStorType;
	RowStatus_Tval snmpNotifyFilterProfileRowStatus;
}MIBsnmpNotifyFilterProfileTable_t;











 



 
 
extern MIBDid_t snmpNotifyFilterTable_Did;

   
typedef enum {
	snmpNotifyFilterType_included[TTT]=1,
	snmpNotifyFilterType_excluded=2
} snmpNotifyFilterType_Tval;

typedef struct
{
	char		snmpNotifyFilterProfileName[TTT][32];                                    
	OIDValue	snmpNotifyFilterSubtree;                                         
	int		snmpNotifyFilterMask_len;
	char		snmpNotifyFilterMask[16];
	snmpNotifyFilterType_Tval snmpNotifyFilterType;
	StorageType_Tval snmpNotifyFilterStorageType;
	RowStatus_Tval snmpNotifyFilterRowStatus;
}MIBsnmpNotifyFilterTable_t;


















 




 



 
extern MIBDid_t snmpUsmMIB_Did;

   


 



 
extern MIBDid_t usmMIBObjects_Did;

   


 



 
extern MIBDid_t usmMIBConformance_Did;

   


 



 
extern MIBDid_t usmMIBCompliances_Did;

   


 



 
extern MIBDid_t usmMIBGroups_Did;

   


 



 
extern MIBDid_t usmStats_Did;

   
typedef struct
{
	unsigned int	usmStatsUnsupportedSecLevels[TTT];
	unsigned int	usmStatsNotInTimeWindows;
	unsigned int	usmStatsUnknownUserNames;
	unsigned int	usmStatsUnknownEngineIDs;
	unsigned int	usmStatsWrongDigests;
	unsigned int	usmStatsDecryptionErrors;
}MIBusmStats_t;











 



 
extern MIBDid_t usmUser_Did;

   
typedef struct
{
	unsigned int	usmUserSpinLock[TTT];
}MIBusmUser_t;






 



 
 
extern MIBDid_t usmUserTable_Did;

   
typedef struct
{
	int		usmUserEngineID_len[TTT];
	char		usmUserEngineID[32];                                        
	char		usmUserName[32];                                            
	char		usmUserSecurityName[255];
	OIDValue	usmUserCloneFrom;
	OIDValue	usmUserAuthProtocol;
	int		usmUserAuthKeyChange_len;
	char		usmUserAuthKeyChange[255];
	int		usmUserOwnAuthKeyChange_len;
	char		usmUserOwnAuthKeyChange[255];
	OIDValue	usmUserPrivProtocol;
	int		usmUserPrivKeyChange_len;
	char		usmUserPrivKeyChange[255];
	int		usmUserOwnPrivKeyChange_len;
	char		usmUserOwnPrivKeyChange[255];
	int		usmUserPublic_len;
	char		usmUserPublic[32];
	StorageType_Tval usmUserStorageType;
	RowStatus_Tval usmUserStatus;
}MIBusmUserTable_t;




















 



 
extern MIBDid_t usmNoPrivProtocol_Did;

   


 



 
extern MIBDid_t usmDESPrivProtocol_Did;

   


 



 
extern MIBDid_t usmNoAuthProtocol_Did;

   


 



 
extern MIBDid_t usmHMACMD5AuthProtocol_Did;

   


 



 
extern MIBDid_t usmHMACSHAAuthProtocol_Did;

   







 




 



 
extern MIBDid_t snmpVacmMIB_Did;

   


 



 
extern MIBDid_t vacmMIBObjects_Did;

   


 



 
extern MIBDid_t vacmMIBConformance_Did;

   


 



 
extern MIBDid_t vacmMIBCompliances_Did;

   


 



 
extern MIBDid_t vacmMIBGroups_Did;

   


 



 
 
extern MIBDid_t vacmContextTable_Did;

   
typedef struct
{
	char		vacmContextName[TTT][32];                        
}MIBvacmContextTable_t;








 



 
 
extern MIBDid_t vacmSecurityToGroupTable_Did;

   
typedef struct
{
	int		vacmSecurityModel[TTT];                                                         
	char		vacmSecurityName[32];                                                     
	char		vacmGroupName[32];
	StorageType_Tval vacmSecurityToGroupStorageType;
	RowStatus_Tval vacmSecurityToGroupStatus;
}MIBvacmSecurityToGroupTable_t;












 



 
 
extern MIBDid_t vacmAccessTable_Did;

   
typedef enum {
	vacmAccessContextMatch_exact[TTT]=1,
	vacmAccessContextMatch_prefix=2
} vacmAccessContextMatch_Tval;

typedef struct
{
	char		vacmGroupName[TTT][32];                                            
	char		vacmAccessContextPrefix[32];                                  
	int		vacmAccessSecurityModel;                                       
	SnmpSecurityLevel_Tval vacmAccessSecurityLevel;                     
	vacmAccessContextMatch_Tval vacmAccessContextMatch;
	char		vacmAccessReadViewName[32];
	char		vacmAccessWriteViewName[32];
	char		vacmAccessNotifyViewName[32];
	StorageType_Tval vacmAccessStorageType;
	RowStatus_Tval vacmAccessStatus;
}MIBvacmAccessTable_t;

















 



 
extern MIBDid_t vacmMIBViews_Did;

   
typedef struct
{
	unsigned int	vacmViewSpinLock[TTT];
}MIBvacmMIBViews_t;






 



 
 
extern MIBDid_t vacmViewTreeFamilyTable_Did;

   
typedef enum {
	vacmViewTreeFamilyType_included[TTT]=1,
	vacmViewTreeFamilyType_excluded=2
} vacmViewTreeFamilyType_Tval;

typedef struct
{
	char		vacmViewTreeFamilyViewName[TTT][32];                                         
	OIDValue	vacmViewTreeFamilySubtree;                                           
	int		vacmViewTreeFamilyMask_len;
	char		vacmViewTreeFamilyMask[16];
	vacmViewTreeFamilyType_Tval vacmViewTreeFamilyType;
	StorageType_Tval vacmViewTreeFamilyStorageType;
	RowStatus_Tval vacmViewTreeFamilyStatus;
}MIBvacmViewTreeFamilyTable_t;


















 




 



 
extern MIBDid_t snmpCommunityMIB_Did;

   


 



 
extern MIBDid_t snmpCommunityMIBObjects_Did;

   
typedef struct
{
	unsigned int	snmpTrapAddress[TTT];
	int		snmpTrapCommunity_len;
	char		snmpTrapCommunity[255];
}MIBsnmpCommunityMIBObjects_t;







 



 
extern MIBDid_t snmpCommunityMIBConformance_Did;

   


 



 
extern MIBDid_t snmpCommunityMIBCompliances_Did;

   


 



 
extern MIBDid_t snmpCommunityMIBGroups_Did;

   


 



 
 
extern MIBDid_t snmpCommunityTable_Did;

   
typedef struct
{
	char		snmpCommunityIndex[TTT][32];                                               
	int		snmpCommunityName_len;
	char		snmpCommunityName[255];
	char		snmpCommunitySecurityName[32];
	int		snmpCommunityContextEngineID_len;
	char		snmpCommunityContextEngineID[32];
	char		snmpCommunityContextName[32];
	int		snmpCommunityTransportTag_len;
	char		snmpCommunityTransportTag[255];
	StorageType_Tval snmpCommunityStorageType;
	RowStatus_Tval snmpCommunityStatus;
}MIBsnmpCommunityTable_t;















 



 
 
extern MIBDid_t snmpTargetAddrExtTable_Did;

   
typedef struct
{
	char		snmpTargetAddrName[TTT][32];                             
	int		snmpTargetAddrTMask_len;
	char		snmpTargetAddrTMask[255];
	int		snmpTargetAddrMMS;
}MIBsnmpTargetAddrExtTable_t;















 




 



 
extern MIBDid_t agentxMIB_Did;

   


 



 
extern MIBDid_t agentxObjects_Did;

   


 



 
extern MIBDid_t agentxConformance_Did;

   


 



 
extern MIBDid_t agentxMIBGroups_Did;

   


 



 
extern MIBDid_t agentxMIBCompliances_Did;

   


 



 
extern MIBDid_t agentxGeneral_Did;

   
typedef struct
{
	int		agentxDefaultTimeout[TTT];
	int		agentxMasterAgentXVer;
}MIBagentxGeneral_t;







 



 
extern MIBDid_t agentxConnection_Did;

   
typedef struct
{
	unsigned int	agentxConnTableLastChange[TTT];
}MIBagentxConnection_t;






 



 
extern MIBDid_t agentxSession_Did;

   
typedef struct
{
	unsigned int	agentxSessionTableLastChange[TTT];
}MIBagentxSession_t;






 



 
extern MIBDid_t agentxRegistration_Did;

   
typedef struct
{
	unsigned int	agentxRegistrationTableLastChange[TTT];
}MIBagentxRegistration_t;






 



 
 
extern MIBDid_t agentxRegistrationTable_Did;

   
typedef struct
{
	unsigned int	agentxConnIndex[TTT];                             
	unsigned int	agentxSessionIndex;                          
	unsigned int	agentxRegIndex;                              
	int		agentxRegContext_len;
	char		agentxRegContext[255];
	OIDValue	agentxRegStart;
	unsigned int	agentxRegRangeSubId;
	unsigned int	agentxRegUpperBound;
	unsigned int	agentxRegPriority;
	int		agentxRegTimeout;
	TruthValue_Tval agentxRegInstance;
}MIBagentxRegistrationTable_t;

















 



 
 
extern MIBDid_t agentxSessionTable_Did;

   
typedef enum {
	agentxSessionAdminStatus_up[TTT]=1,
	agentxSessionAdminStatus_down=2
} agentxSessionAdminStatus_Tval;

typedef struct
{
	unsigned int	agentxConnIndex[TTT];                                       
	unsigned int	agentxSessionIndex;                                    
	OIDValue	agentxSessionObjectID;
	char		agentxSessionDescr[255];
	agentxSessionAdminStatus_Tval agentxSessionAdminStatus;
	unsigned int	agentxSessionOpenTime;
	int		agentxSessionAgentXVer;
	int		agentxSessionTimeout;
}MIBagentxSessionTable_t;















 



 
 
extern MIBDid_t agentxConnectionTable_Did;

   
typedef struct
{
	unsigned int	agentxConnIndex[TTT];                                           
	unsigned int	agentxConnOpenTime;
	OIDValue	agentxConnTransportDomain;
	int		agentxConnTransportAddress_len;
	char		agentxConnTransportAddress[255];
}MIBagentxConnectionTable_t;
















 




 



 
extern MIBDid_t enterpriseRoot_Did;

   


 



 
extern MIBDid_t enterpriseCommonRoot_Did;

   


 



 
extern MIBDid_t enterpriseReg_Did;

   


 



 
extern MIBDid_t enterpriseGeneric_Did;

   


 



 
extern MIBDid_t enterpriseProducts_Did;

   


 



 
extern MIBDid_t enterpriseCaps_Did;

   


 



 
extern MIBDid_t enterpriseReqs_Did;

   


 



 
extern MIBDid_t enterpriseExpr_Did;

   


 



 
extern MIBDid_t productSeries1Products_Did;

   


 



 
extern MIBDid_t productSeries1Common_Did;

   


 



 
extern MIBDid_t enterpriseModules_Did;

   


 



 
extern MIBDid_t enterpriseNetworkingProducts_Did;

   


 



 
extern MIBDid_t product1Reg_Did;

   


 



 
extern MIBDid_t enterpriseGlobalRegModule_Did;

   







 




 



 
extern MIBDid_t productSeries1CmnConf_Did;

   


 



 
extern MIBDid_t productSeries1CmnObjs_Did;

   


 



 
extern MIBDid_t productSeries1CmnEvents_Did;

   
typedef struct
{
	unsigned int	pbTrapTimeStamp[TTT];
}MIBproductSeries1CmnEvents_t;






 



 
extern MIBDid_t productSeries1CmnTCs_Did;

   


 



 
extern MIBDid_t productSeries1TrapGroup_Did;

   


 



 
extern MIBDid_t pbNode_Did;

   


 



 
extern MIBDid_t pbEvents_Did;

   


 



 
extern MIBDid_t pbCircuitBasedTransport_Did;

   


 



 
extern MIBDid_t pbTMS_Did;

   


 



 
extern MIBDid_t pbOspf_Did;

   


 



 
extern MIBDid_t pbMoln_Did;

   


 



 
extern MIBDid_t pbDcc_Did;

   


 



 
extern MIBDid_t pbEthernet_Did;

   


 



 
extern MIBDid_t pbDiagnostics_Did;

   


 



 
extern MIBDid_t pbOpticsMonitor_Did;

   


 



 
extern MIBDid_t pbPowerCircuitMonitor_Did;

   


 



 
extern MIBDid_t pbOr_Did;

   


 



 
extern MIBDid_t pbTrunk_Did;

   


 



 
extern MIBDid_t pbXcExtend_Did;

   


 



 
extern MIBDid_t pbRpr_Did;

   


 



 
extern MIBDid_t pbOAObjects_Did;

   


 



 
extern MIBDid_t pbOsi_Did;

   


 



 
extern MIBDid_t pbIpTunnel_Did;

   


 



 
extern MIBDid_t pbProtection_Did;

   


 



 
extern MIBDid_t pbSecurity_Did;

   


 



 
extern MIBDid_t pbDigitalTransport_Did;

   


 



 
extern MIBDid_t productSeries1MibModule_Did;

   







 




 



 
extern MIBDid_t enterpriseGlobalTCModule_Did;

   







 




 



 
 
extern MIBDid_t pbOATable_Did;

   
typedef enum {
	pbOAModuleConfiguration_singlePump[TTT]=0,
	pbOAModuleConfiguration_dualPump=1
} pbOAModuleConfiguration_Tval;

typedef enum {
	pbOAModuleType_amplet[TTT]=0,
	pbOAModuleType_boosterAmplifier=1,
	pbOAModuleType_lineAmplifier=2,
	pbOAModuleType_preAmplifier=3
} pbOAModuleType_Tval;

typedef enum {
	pbOAOperationMode_constantCurrent[TTT]=0,
	pbOAOperationMode_constantGain=1,
	pbOAOperationMode_constantPower=2
} pbOAOperationMode_Tval;

typedef enum {
	pbOAAutoShutdown_disable[TTT]=0,
	pbOAAutoShutdown_enable=1
} pbOAAutoShutdown_Tval;

typedef enum {
	pbOARealOperationMode_constantCurrent[TTT]=0,
	pbOARealOperationMode_constantGain=1,
	pbOARealOperationMode_constantPower=2
} pbOARealOperationMode_Tval;

typedef enum {
	pbOARealAutoShutdown_disable[TTT]=0,
	pbOARealAutoShutdown_enable=1
} pbOARealAutoShutdown_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbOASlotNo;                                            
	int		pbOAPortNo;                                                             
	pbOAModuleConfiguration_Tval pbOAModuleConfiguration;   
	pbOAModuleType_Tval pbOAModuleType;   
	char		pbOAHWVersion[10];   
	char		pbOASWVersion[10];   
	char		pbOASerialNumber[10];   
	int		pbOAInputPower;   
	int		pbOACurrentOutputPower;   
	int		pbOACurrentModuleGain;   
	int		pbOAPump1Power;   
	int		pbOAPump2Power;   
	int		pbOATemperature;   
	int		pbOAPump1DriveCurrent;   
	int		pbOAPump2DriveCurrent;   
	int		pbOAPowerSupplyVoltage;   
	pbOAOperationMode_Tval pbOAOperationMode;   
	int		pbOAExpectedOutputPower;   
	int		pbOAExpectedModuleGain;   
	int		pbOAInputThreshold;   
	int		pbOAOutputThreshold;   
	int		pbOAShutdownThreshold;   
	int		pbOALowTThreshold;   
	int		pbOAHighTThreshold;   
	pbOAAutoShutdown_Tval pbOAAutoShutdown;   
	int		pbOAMaxoutputpower;   
	int		pbOAMaxPump1Current;   
	int		pbOAMaxPump2Current;   
	pbOARealOperationMode_Tval pbOARealOperationMode;   
	int		pbOARealExpectedOutputPower;   
	int		pbOARealExpectedModuleGain;   
	int		pbOARealInputThreshold;   
	int		pbOARealOutputThreshold;   
	int		pbOARealShutdownThreshold;   
	int		pbOARealLowTThreshold;   
	int		pbOARealHighTThreshold;   
	pbOARealAutoShutdown_Tval pbOARealAutoShutdown;   
	int		pbOARealCoolPumpTemp;   
}MIBpbOATable_t;













































 



 
extern MIBDid_t enterpriseOAModule_Did;

   







 




 



 
extern MIBDid_t addressGroup_Did;

   
typedef enum {
	pbEthernetEnable_disable[TTT]=1,
	pbEthernetEnable_enable=2
} pbEthernetEnable_Tval;

typedef enum {
	pbMgmtPort1Status_down[TTT]=0,
	pbMgmtPort1Status_up=1
} pbMgmtPort1Status_Tval;

typedef enum {
	pbMgmtPort2Status_down[TTT]=0,
	pbMgmtPort2Status_up=1
} pbMgmtPort2Status_Tval;

typedef struct
{
	unsigned int	pbIpAddress[TTT];   
	unsigned int	pbIpMask;   
	unsigned int	pbGatewayAddress;   
	unsigned int	pbEthernetAddress;   
	unsigned int	pbEthernetMask;   
	int		pbSystemMacAddress_len;
	char		pbSystemMacAddress[6];   
	unsigned int	pbSlaveEthernetAddress;   
	unsigned int	pbEthernetAddressSecondary;   
	unsigned int	pbEthernetMaskSecondary;   
	pbEthernetEnable_Tval pbEthernetEnable;   
	unsigned int	pbGMPLSIPAddress;   
	unsigned int	pbGMPLSIPMask;
	pbMgmtPort1Status_Tval pbMgmtPort1Status;
	pbMgmtPort2Status_Tval pbMgmtPort2Status;
}MIBaddressGroup_t;



















 



 
extern MIBDid_t systemGroup_Did;

   
typedef struct
{
	PbNodeMode_Tval[TTT] pbMode;   
	char		pbLabel[255];   
	char		pbLocation[255];   
	char		pbDescription[255];   
	char		pbContact[255];   
	char		pbSerialNumber[255];   
	char		pbRelease[20];   
	char		pbBootImageVersion[20];   
	char		pbBackplaneHwVersion[17];   
	char		pbBackplaneCode[64];   
}MIBsystemGroup_t;















 



 
extern MIBDid_t ledGroup_Did;

   
typedef struct
{
	TruthValue_Tval[TTT] pbLedTest;   
}MIBledGroup_t;






 



 
 
extern MIBDid_t pbSlotTable_Did;

   
typedef enum {
	pbCardState_none[TTT]=0,
	pbCardState_provisioning=1,
	pbCardState_initializing=2,
	pbCardState_faulty=3,
	pbCardState_operational=4,
	pbCardState_absent=5,
	pbCardState_disabled=6,
	pbCardState_mismatch=7,
	pbCardState_available=8,
	pbCardState_active=9,
	pbCardState_standby=10,
	pbCardState_mirroring=11,
	pbCardState_tracking=12,
	pbCardState_reset=13,
	pbCardState_max=14
} pbCardState_Tval;

typedef enum {
	pbCardDesiredState_auto[TTT]=1,
	pbCardDesiredState_active=2,
	pbCardDesiredState_standby=3
} pbCardDesiredState_Tval;

typedef enum {
	pbSlotResetDuration_permanent[TTT]=1,
	pbSlotResetDuration_transient=2
} pbSlotResetDuration_Tval;

typedef enum {
	pbDiagMode_none[TTT]=1,
	pbDiagMode_once=2,
	pbDiagMode_always=3,
	pbDiagMode_ess=4,
	pbDiagMode_burnIn=5
} pbDiagMode_Tval;

typedef enum {
	pbForceResetSlot_none[TTT]=1,
	pbForceResetSlot_warm=2,
	pbForceResetSlot_cold=3
} pbForceResetSlot_Tval;

typedef enum {
	pbLatchState_na[TTT]=0,
	pbLatchState_off=1,
	pbLatchState_on=2
} pbLatchState_Tval;

typedef enum {
	slotMaxDCCNumber_ports_8[TTT]=0,
	slotMaxDCCNumber_ports_16=1
} slotMaxDCCNumber_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                                  
	PbSlotType_Tval pbSlotType;   
	PbBoardStyle_Tval pbBoardType;   
	PbBoardFunction_Tval pbBoardFunction;   
	pbCardState_Tval pbCardState;   
	pbCardDesiredState_Tval pbCardDesiredState;   
	char		pbSlotNumberDisplay[10];   
	TruthValue_Tval pbSlotReset;   
	int		pbSlotNoFailuresTotal;   
	TruthValue_Tval pbSlotResetNoFailures;   
	pbSlotResetDuration_Tval pbSlotResetDuration;   
	char		pbSlotName[255];   
	char		pbSlotDescr[255];   
	TruthValue_Tval pbSlotIfCardDumb;   
	TruthValue_Tval pbSlotCrashDumpAvail;   
	PbBoardStyle_Tval pbSlotLastBoardType;   
	TruthValue_Tval pbSlotBoardTypeDifference;   
	TruthValue_Tval pbSlotExplicitDeletion;   
	PbBoardStyle_Tval pbProvisionedCardType;   
	char		pbSlotCardSpecificInfo[255];   
	int		pbSlotTemperatureThreshold;   
	int		pbSlotTemperatureHysteresis;   
	int		pbSlotTemperatureCleanThreshold;   
	PbBoardFunction_Tval pbSlotLastBoardFunction;   
	pbDiagMode_Tval pbDiagMode;   
	TruthValue_Tval pbDiagActive;   
	PbSlotNumberType_Tval pbLogicalSlotNumber;   
	TruthValue_Tval pbSlotDisable;   
	pbForceResetSlot_Tval pbForceResetSlot;   
	PbLedColor_Tval pbSlotFailureLedColor;   
	PbLedColor_Tval pbSlotActiveLedColor;   
	char		pbBoardSerialNumber[255];   
	int		pbBoardOption;   
	char		pbCode[64];   
	pbLatchState_Tval pbLatchState;   
	TruthValue_Tval pbSlotAlarmDisable;   
	PbBoardFunction_Tval provisionedCardFunction;
	int		slotConfigOption;   
	char		cardSoftwareVersion[33];   
	char		cardBootVersion[21];   
	char		cardBootDatetime[255];   
	char		cardHardwareVersion[17];   
	char		cardFusionVersion[17];   
	char		cardFpgaVersion[255];   
	int		macAddress_len;
	char		macAddress[6];
	slotMaxDCCNumber_Tval slotMaxDCCNumber;
	int		slotMapValue;
}MIBpbSlotTable_t;






















































 



 
extern MIBDid_t pbMibSaveRestoreGroup_Did;

   
typedef enum {
	pbConfigType_ascii[TTT]=1,
	pbConfigType_binary=2
} pbConfigType_Tval;

typedef struct
{
	PbOnOff_Tval[TTT] pbAutoSaver;   
	int		pbAutoSaverFirstTimer;   
	int		pbAutoSaverLastTimer;   
	pbConfigType_Tval pbConfigType;   
	TruthValue_Tval pbSaveMib;   
	TruthValue_Tval pbClearMibSet;   
}MIBpbMibSaveRestoreGroup_t;











 



 
extern MIBDid_t pbInterfaceGroup_Did;

   
typedef struct
{
	TruthValue_Tval[TTT] pbAutoLinkStarted;   
}MIBpbInterfaceGroup_t;






 



 
extern MIBDid_t pbUpgradeGroup_Did;

   
typedef struct
{
	char		pbUpgradeCurrRelease[TTT][30];   
	char		pbUpgradeBackupRelease[30];   
	unsigned int	pbUpgradeHostIP;   
	char		pbUpgradeHostUsername[20];   
	char		pbUpgradeHostPassword[20];   
	char		pbUpgradeHostFileName[255];   
	TypeUpgradeCmnd_Tval pbUpgradeCommand;   
	PbCmndState_Tval pbUpgradeCmndState;   
	char		pbUpgradeStateDescr[255];   
	TruthValue_Tval pbUpgradeLoadCancel;   
	TypeUpgradeCmnd_Tval nodeUpgradeLastCommand;   
	TypeSoftUpgFailedIndex_Tval nodeUpgradeFailedIndex;   
	int		nodeUpgradeSwitchPhySlot;   
}MIBpbUpgradeGroup_t;


















 



 
extern MIBDid_t pbConfigCmndGroup_Did;

   
typedef enum {
	nodeMibNmsOperateArea_none[TTT]=0,
	nodeMibNmsOperateArea_flash=1,
	nodeMibNmsOperateArea_cf=2,
	nodeMibNmsOperateArea_ramdisc=3
} nodeMibNmsOperateArea_Tval;

typedef enum {
	pbBackupMIBState_invalid[TTT]=0,
	pbBackupMIBState_valid=1
} pbBackupMIBState_Tval;

typedef struct
{
	TypeMibCmnd_Tval[TTT] nodeMibCmnd;   
	PbCmndState_Tval nodeMibCmndState;   
	TruthValue_Tval nodeMibCmndCancel;   
	nodeMibNmsOperateArea_Tval nodeMibNmsOperateArea;   
	TypeMibUpDownLoadStatus_Tval nodeMibUpDownLoadStatus;   
	TypeMibCmnd_Tval nodeMibLastCommand;   
	TypeMibUpgFailedIndex_Tval nodeMibFailedIndex;   
	pbBackupMIBState_Tval pbBackupMIBState;   
	DateTime	pbMIBOperationDateTimeStamp;   
	TruthValue_Tval nodeMIBFilesNoCheck;   
}MIBpbConfigCmndGroup_t;















 



 
extern MIBDid_t pbStatsGroup_Did;

   
typedef struct
{
	int		pbNumberOfReboots[TTT];   
	DateTime	pbNodeDownDTS;   
}MIBpbStatsGroup_t;







 



 
extern MIBDid_t alarmGroup_Did;

   
typedef struct
{
	PbEnableDisable_Tval[TTT] pbNodeAlarmEnabling;   
	TruthValue_Tval pbAISEnabled;   
	TruthValue_Tval pbRDIEnabled;   
	TruthValue_Tval pbAlarmSuppress;   
	TruthValue_Tval pbAlarmCutOff;   
	int		pbDataExcDegTpNum;   
	TruthValue_Tval pbSEFEnabled;
}MIBalarmGroup_t;












 



 
extern MIBDid_t pbNodeGroup_Did;

   
typedef enum {
	pbNodeType_hiT7065[TTT]=11
} pbNodeType_Tval;

typedef struct
{
	pbNodeType_Tval[TTT] pbNodeType;   
	char		pbNodeSoftwareVersion[255];   
	int		pbNodeIntSoftwareVersion;   
	int		pbDatabaseVersion;   
}MIBpbNodeGroup_t;









 



 
extern MIBDid_t nodeControlGroup_Did;

   
typedef struct
{
	TruthValue_Tval[TTT] pbWarmRebootNode;   
	PbColdRebootNodeState_Tval pbColdRebootNode;   
	TruthValue_Tval pbResetNode;   
	TruthValue_Tval pbNodeShutDown;   
	TruthValue_Tval pbNodePowerOff;   
}MIBnodeControlGroup_t;










 



 
extern MIBDid_t ntpGroup_Did;

   
typedef struct
{
	TruthValue_Tval[TTT] pbNTPEnabled;   
	unsigned int	pbNTPIpAddress;   
	int		pbNTPRequestPeriods;   
}MIBntpGroup_t;








 



 
extern MIBDid_t pbDateTimeStampGroup_Did;

   
typedef struct
{
	DateTime[TTT]	pbDateTimeStampSet;   
	DateTime	pbDateTimeStampGet;   
	PbTimeZone_Tval pbTimeZone;   
}MIBpbDateTimeStampGroup_t;








 



 
extern MIBDid_t pbCFCardGroup_Did;

   
typedef enum {
	pbCFCardMIBValidity_cfcf[TTT]=1,
	pbCFCardMIBValidity_cfmc=2,
	pbCFCardMIBValidity_mccf=3,
	pbCFCardMIBValidity_mcmc=4,
	pbCFCardMIBValidity_cffailed=5
} pbCFCardMIBValidity_Tval;

typedef struct
{
	PbCFCardState_Tval[TTT] pbCFCardStatus;   
	pbCFCardMIBValidity_Tval pbCFCardMIBValidity;   
	PbCFCardState_Tval pbStandbyCFCardStatus;   
}MIBpbCFCardGroup_t;








 



 
extern MIBDid_t flashSpaceGroup_Did;

   
typedef struct
{
	int		boardFlashFreeSpace[TTT];   
	int		cfCardFreeSpace;   
}MIBflashSpaceGroup_t;







 



 
 
extern MIBDid_t pbExtensionShelfTable_Did;

   
typedef struct
{
	int		pbExtensionShelfID[TTT];                                                   
	unsigned int	pbMainShelfIP;   
	char		pbMainShelfReadString[255];   
	char		pbMainShelfWriteString[255];   
	int		pbMainShelfSlot;   
	int		pbMainShelfPort;   
	unsigned int	pbExtesionShelfIP;   
	char		pbExtesionShelfReadString[255];   
	char		pbExtesionShelfWriteString[255];   
	int		pbExtesionShelfSlot;   
	int		pbExtesionShelfPort;   
	char		pbExtesionShelfLabel[255];   
	char		pbExtesionShelfDesc[255];   
	RowStatus_Tval pbExtesionShelfRowStatus;   
}MIBpbExtensionShelfTable_t;





















 



 
extern MIBDid_t nodePropertyGroup_Did;

   
typedef enum {
	nodeHoccCapability_capability_340g[TTT]=1,
	nodeHoccCapability_capability_680g=2
} nodeHoccCapability_Tval;

typedef enum {
	nodeLoccCapability_capability_none[TTT]=1,
	nodeLoccCapability_capability_20g=2,
	nodeLoccCapability_capability_40g=3
} nodeLoccCapability_Tval;

typedef struct
{
	nodeHoccCapability_Tval[TTT] nodeHoccCapability;   
	nodeLoccCapability_Tval nodeLoccCapability;   
}MIBnodePropertyGroup_t;







 



 
extern MIBDid_t eowFunctionGroup_Did;

   


 



 
extern MIBDid_t gmplsLicenseGroup_Did;

   
typedef enum {
	gmplsLicenseStatus_unknown[TTT]=1,
	gmplsLicenseStatus_license_not_exist=2,
	gmplsLicenseStatus_license_invalid=3,
	gmplsLicenseStatus_ospf_only=4,
	gmplsLicenseStatus_gmpls=5
} gmplsLicenseStatus_Tval;

typedef struct
{
	gmplsLicenseStatus_Tval[TTT] gmplsLicenseStatus;
	TruthValue_Tval gmplsLicenseSyncFlag;
}MIBgmplsLicenseGroup_t;







 



 
extern MIBDid_t e2romConfigGroup_Did;

   


 



 
extern MIBDid_t systemMonitorGroup_Did;

   


 



 
extern MIBDid_t cpuUtilEventGroup_Did;

   
typedef struct
{
	int		cpuUtilThreshold[TTT];   
	TruthValue_Tval cpuUtilEventEnable;   
}MIBcpuUtilEventGroup_t;







 



 
extern MIBDid_t memUtilEventGroup_Did;

   
typedef struct
{
	int		memUtilThreshold[TTT];   
	TruthValue_Tval memUtilEventEnable;   
}MIBmemUtilEventGroup_t;







 



 
extern MIBDid_t cfCardUtilEventGroup_Did;

   
typedef struct
{
	int		cfCardUtilThreshold[TTT];   
	TruthValue_Tval cfCardUtilEventEnable;   
}MIBcfCardUtilEventGroup_t;







 



 
extern MIBDid_t flashUtilEventGroup_Did;

   
typedef struct
{
	int		flashUtilThreshold[TTT];   
	TruthValue_Tval flashUtilEventEnable;   
}MIBflashUtilEventGroup_t;







 



 
 
extern MIBDid_t pbE2RomConfigTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;             
	int		pbE2RomPageNo;                             
	int		pbE2RomTlvData_len;
	char		pbE2RomTlvData[253];
}MIBpbE2RomConfigTable_t;










 



 
 
extern MIBDid_t eowOhccTable_Did;

   
typedef struct
{
	int		eowOhccDestination[TTT];                                   
	int		eowOhccSource;   
	TruthValue_Tval eowOhccRingManaged;   
}MIBeowOhccTable_t;










 



 
 
extern MIBDid_t siGlobalTable_Did;

   
typedef enum {
	siClipper_clip0[TTT]=0,
	siClipper_clip4=4,
	siClipper_clip8=8,
	siClipper_clip16=16,
	siClipper_clip32=32
} siClipper_Tval;

typedef enum {
	siEnsThreshold_thresh0[TTT]=0,
	siEnsThreshold_thresh1=1,
	siEnsThreshold_thresh3=3,
	siEnsThreshold_thresh5=5,
	siEnsThreshold_thresh7=7,
	siEnsThreshold_thresh255=255
} siEnsThreshold_Tval;

typedef enum {
	siErmAtt_is6dB[TTT]=0,
	siErmAtt_is9dB=1
} siErmAtt_Tval;

typedef enum {
	siWorkingMode_normalMode[TTT]=1,
	siWorkingMode_boxMode=2
} siWorkingMode_Tval;

typedef enum {
	siUpdateDsp_inactive[TTT]=0,
	siUpdateDsp_update=1,
	siUpdateDsp_cancel=2
} siUpdateDsp_Tval;

typedef enum {
	siUpdateDspState_successfully[TTT]=0,
	siUpdateDspState_failed=1,
	siUpdateDspState_updating=2,
	siUpdateDspState_unknown=3
} siUpdateDspState_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                 
	int		ifIdx;                                            
	char		siName[33];   
	char		siPhoneNum[4];   
	siClipper_Tval siClipper;   
	siEnsThreshold_Tval siEnsThreshold;   
	int		siErmThreshold;   
	siErmAtt_Tval siErmAtt;   
	int		siErmStep;   
	siWorkingMode_Tval siWorkingMode;   
	siUpdateDsp_Tval siUpdateDsp;   
	siUpdateDspState_Tval siUpdateDspState;   
}MIBsiGlobalTable_t;



















 



 
 
extern MIBDid_t siChannelManageTable_Did;

   
typedef enum {
	siChannelRingManageDelta_greaterThan12dB[TTT]=0,
	siChannelRingManageDelta_lessThan6dB=1
} siChannelRingManageDelta_Tval;

typedef enum {
	siChannelRingManageSwitch_dBMode[TTT]=0,
	siChannelRingManageSwitch_ooMode=1
} siChannelRingManageSwitch_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                   
	int		ifIdx;                                                           
	int		siChannelID;                                                        
	int		siChannelGroup;                                                     
	char		siChannelName[16];   
	TruthValue_Tval siChannelEnable;   
	TruthValue_Tval siChannelNoiseDetect;   
	TruthValue_Tval siChannelNoiseState;   
	TruthValue_Tval siChannelRingManage;   
	TruthValue_Tval siChannelRingManageState;   
	siChannelRingManageDelta_Tval siChannelRingManageDelta;   
	siChannelRingManageSwitch_Tval siChannelRingManageSwitch;   
	int		siChannelGroupSetting;   
}MIBsiChannelManageTable_t;




















 



 
extern MIBDid_t pbACOGroup_Did;

   
typedef struct
{
	PbOnOff_Tval[TTT] pbAudibleACO;   
	PbOnOff_Tval pbVisualACO;   
	PbEnableDisable_Tval pbExtAudible;   
	PbEnableDisable_Tval pbExtVisual;   
}MIBpbACOGroup_t;









 



 
 
extern MIBDid_t pbIoaTable_Did;

   
typedef struct
{
	int		pbIoaIndexNo[TTT];                                       
	char		pbIoaLabel[32];   
	TruthValue_Tval pbIoaEnableStatus;   
	TruthValue_Tval pbIoaStatus;   
}MIBpbIoaTable_t;











 



 
extern MIBDid_t alarmRuleSwitchGroup_Did;

   
typedef struct
{
	PbEnableDisable_Tval[TTT] lofMonitoringSwitch;
	PbEnableDisable_Tval lomMonitoringSwitch;
	PbEnableDisable_Tval lopMonitoringSwitch;
}MIBalarmRuleSwitchGroup_t;








 



 
 
extern MIBDid_t upgradeSoftwareInfoTable_Did;

   
typedef enum {
	upgradeSoftwareIndication_boardfirst[TTT]=1,
	upgradeSoftwareIndication_boardsecond=2,
	upgradeSoftwareIndication_cffirst=3,
	upgradeSoftwareIndication_cfsecond=4
} upgradeSoftwareIndication_Tval;

typedef enum {
	upgradeSoftwareRole_active[TTT]=1,
	upgradeSoftwareRole_backup=2
} upgradeSoftwareRole_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] upgradeSoftwareSlotNumber;                         
	upgradeSoftwareIndication_Tval upgradeSoftwareIndication;                
	upgradeSoftwareRole_Tval upgradeSoftwareRole;   
	char		upgradeSoftwareName[33];   
	DateTime	upgradeSoftwareDatetime;   
}MIBupgradeSoftwareInfoTable_t;












 



 
 
extern MIBDid_t pbPhysicalAdjacencyTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbLocalSlotNumber;                                             
	int		pbLocalPortNumber;                                                              
	PbUpDown_Tval pbRemoteNodeMolnAdjacencyStatus;   
	unsigned int	pbRemoteNodeIPAddress;   
	int		pbRemoteSlotNumber;   
	int		pbRemotePortNumber;   
	PbUpDown_Tval pbLinkOperationalStatus;   
	char		pbInterfaceDescr[64];   
	PbLinkGeneralType_Tval pbLinkGeneralType;   
	RowStatus_Tval pbLinkRowStatus;   
}MIBpbPhysicalAdjacencyTable_t;

















 



 
 
extern MIBDid_t pbAutoLinkTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbLocalSlot;                       
	int		pbLocalPort;                                        
	unsigned int	pbRemoteIPAddress;   
	int		pbRemoteSlot;   
	int		pbRemotePort;   
}MIBpbAutoLinkTable_t;












 



 
 
extern MIBDid_t pbLedTable_Did;

   
typedef enum {
	pbLedColor_off[TTT]=0,
	pbLedColor_green=1,
	pbLedColor_yellow=2,
	pbLedColor_red=3,
	pbLedColor_orange=4,
	pbLedColor_blinkingGreen=5,
	pbLedColor_blinkingYellow=6,
	pbLedColor_blinkingRed=7,
	pbLedColor_blinkingOrange=8
} pbLedColor_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbLedSlotNo;             
	int		pbLedIndexNo;                             
	char		pbLedLabel[32];   
	pbLedColor_Tval pbLedColor;   
}MIBpbLedTable_t;











 



 
extern MIBDid_t pbNodeModule_Did;

   








 




 



 
extern MIBDid_t rprGeneral_Did;

   


 



 
extern MIBDid_t rprProtocols_Did;

   


 



 
extern MIBDid_t rprService_Did;

   


 



 
extern MIBDid_t rprWan_Did;

   


 



 
extern MIBDid_t rprHwPassThrough_Did;

   


 



 
 
extern MIBDid_t rprHwpXcTable_Did;

   
typedef enum {
	rprHwpXcCircuitDirection_bidirection[TTT]=1,
	rprHwpXcCircuitDirection_unidirection=2,
	rprHwpXcCircuitDirection_multicast=3
} rprHwpXcCircuitDirection_Tval;

typedef enum {
	rprHwpXcCcsRpmMsgType_client[TTT]=1,
	rprHwpXcCcsRpmMsgType_ems=2,
	rprHwpXcCcsRpmMsgType_snm=3,
	rprHwpXcCcsRpmMsgType_gmpls=4,
	rprHwpXcCcsRpmMsgType_rpr=5
} rprHwpXcCcsRpmMsgType_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                   
	RprXcCapacity_Tval rprHwpXcCapacity;                                     
	PbSlotNumberType_Tval rprHwpXcSrcSlot;                                   
	int		rprHwpXcSrcPort;                                                    
	RprTpNumberType_Tval rprHwpXcSource;                                     
	PbSlotNumberType_Tval rprHwpXcDstSlot;                                   
	int		rprHwpXcDstPort;                                                    
	RprTpNumberType_Tval rprHwpXcDestination;                                
	PbPortType_Tval rprHwpXcSrcPortType;   
	PbPortType_Tval rprHwpXcDstPortType;   
	int		rprHwpXcConnectId;   
	rprHwpXcCircuitDirection_Tval rprHwpXcCircuitDirection;   
	rprHwpXcCcsRpmMsgType_Tval rprHwpXcCcsRpmMsgType;   
	RprXcMsgStatus_Tval rprHwpXcCcsRpmMsgState;   
	int		rprHwpXcCcsRpmMsgPriority;   
	PbBoardStyle_Tval rprHwpXcSrcSlotCard;   
	PbBoardStyle_Tval rprHwpXcDstSlotCard;   
	RprXcFailReason_Tval rprHwpXcReason;   
	RprXcRowStatus_Tval rprHwpXcRowStatus;   
	RprXcTableClass_Tval rprHwpXcTableClass;   
}MIBrprHwpXcTable_t;



























 



 
 
extern MIBDid_t pbRprWanConfigTable_Did;

   
typedef enum {
	pbRprWanPortXVType_vc4[TTT]=0,
	pbRprWanPortXVType_vc12=1
} pbRprWanPortXVType_Tval;

typedef enum {
	pbRprWanGFPFCS_disable[TTT]=0,
	pbRprWanGFPFCS_enable=1
} pbRprWanGFPFCS_Tval;

typedef enum {
	pbRprWanGFPFCSAutoDetect_disable[TTT]=0,
	pbRprWanGFPFCSAutoDetect_enable=1
} pbRprWanGFPFCSAutoDetect_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                       
	int		pbPortNo;                                                            
	char		pbRprWanPortLabel[255];   
	int		pbRprWanPortCapacity;   
	TruthValue_Tval pbRprWanPortMonitored;   
	pbRprWanPortXVType_Tval pbRprWanPortXVType;   
	TruthValue_Tval pbRprWanLCASSupport;   
	TruthValue_Tval pbRprWanPortCapacityTrigger;   
	pbRprWanGFPFCS_Tval pbRprWanGFPFCS;   
	pbRprWanGFPFCSAutoDetect_Tval pbRprWanGFPFCSAutoDetect;   
	TruthValue_Tval pbRprWanFlowControl;   
}MIBpbRprWanConfigTable_t;


















 



 
extern MIBDid_t pbRprLCASBase_Did;

   


 



 
 
extern MIBDid_t pbRprSOLCASConfigTable_Did;

   
typedef enum {
	pbRprSOLCASActive_none[TTT]=0,
	pbRprSOLCASActive_active=1,
	pbRprSOLCASActive_deactive=2
} pbRprSOLCASActive_Tval;

typedef enum {
	pbRprSOLCASState_fixed[TTT]=0,
	pbRprSOLCASState_add=1,
	pbRprSOLCASState_normal=2,
	pbRprSOLCASState_eos=3,
	pbRprSOLCASState_idle=5,
	pbRprSOLCASState_dnu=15
} pbRprSOLCASState_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                     
	int		pbPortNo;                                          
	PbTPType_Tval pbTpType;                                 
	int		pbTpIndex;                                         
	pbRprSOLCASActive_Tval pbRprSOLCASActive;   
	int		pbRprSOLCASWanPort;   
	pbRprSOLCASState_Tval pbRprSOLCASState;   
}MIBpbRprSOLCASConfigTable_t;














 



 
 
extern MIBDid_t pbRprSKLCASConfigTable_Did;

   
typedef enum {
	pbRprSKLCASState_fixed[TTT]=0,
	pbRprSKLCASState_idle=1,
	pbRprSKLCASState_ok=2,
	pbRprSKLCASState_fail=3
} pbRprSKLCASState_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                     
	int		pbPortNo;                                          
	PbTPType_Tval pbTpType;                                 
	int		pbTpIndex;                                         
	int		pbRprSKLCASWanPort;   
	pbRprSKLCASState_Tval pbRprSKLCASState;   
}MIBpbRprSKLCASConfigTable_t;













 



 
 
extern MIBDid_t rprServiceTable_Did;

   
typedef enum {
	rprSvcClassifyType_port[TTT]=0,
	rprSvcClassifyType_portVlan=1,
	rprSvcClassifyType_portVlanVpri=2
} rprSvcClassifyType_Tval;

typedef enum {
	rprSvcMode_basic[TTT]=1,
	rprSvcMode_share=2,
	rprSvcMode_cross=3
} rprSvcMode_Tval;

typedef enum {
	rprSvcTtlMode_auto[TTT]=1,
	rprSvcTtlMode_autoAdvanced=2,
	rprSvcTtlMode_manualCloseRing=3,
	rprSvcTtlMode_manualAll=4,
	rprSvcTtlMode_manualMac=5,
	rprSvcTtlMode_manualMacAdv=6
} rprSvcTtlMode_Tval;

typedef enum {
	rprGmiiSel_gmii0[TTT]=0,
	rprGmiiSel_gmii1=1
} rprGmiiSel_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                             
	int		rprIfIndex;                                                
	int		rprServiceId;                                                 
	int		rprLocalEthPortNo;                                            
	int		rprLocalVID;                                                  
	int		rprLocalVPrio;                                                
	rprSvcClassifyType_Tval rprSvcClassifyType;                        
	RprServiceType_Tval rprServiceType;   
	rprSvcMode_Tval rprSvcMode;   
	char		rprRmtStationMac[20];   
	RprRingletID_Tval rprSvcRingletSel;   
	RprRingletID_Tval rprSvcRealRingletSel;   
	TruthValue_Tval rprSvcAutoRingletSelEn;   
	RprServiceCos_Tval rprSvcCos;   
	rprSvcTtlMode_Tval rprSvcTtlMode;   
	int		rprSvcTtl0;   
	int		rprSvcTtl1;   
	int		rprSvcRealTtl0;   
	int		rprSvcRealTtl1;   
	TruthValue_Tval rprSvcWe;   
	TruthValue_Tval rprSvcSteered;   
	int		rprSvcRateProfIndex;   
	int		rprSvcTokenRate;   
	int		rprSvcBurstSize;   
	int		rprSvcMaxDelay;   
	int		rprSvcMaxJitter;   
	int		rprSvcWeight;   
	rprGmiiSel_Tval rprGmiiSel;   
	TruthValue_Tval rprDoubleVlanEn;   
	int		rprDoubleVID;   
	int		rprDoubleVPrio;   
	TruthValue_Tval rprSvcLoop;   
	TruthValue_Tval rprSvcActive;   
	RprSvcStatus_Tval rprSvcCurStatus;   
	RprSvcFailReason_Tval rprSvcReason;   
	char		rprSvcLabel[32];   
	int		rprFlowRuleID;   
	int		rprSvcMulBrdCastID;
	TruthValue_Tval rprSvcMulBrdCastEn;
	RowStatus_Tval rprSvcRowStatus;   
}MIBrprServiceTable_t;















































 



 
 
extern MIBDid_t rprRateProfileTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                     
	int		rprIfIndex;                                        
	int		rprRateProfNo;                                        
	int		rprTokenRate;   
	int		rprBurstSize;   
	int		rprExcessBurstSize;   
}MIBrprRateProfileTable_t;













 



 
 
extern MIBDid_t pbRprMultiCastTable_Did;

   
typedef enum {
	rprMultiCastGMRP_yes[TTT]=0,
	rprMultiCastGMRP_no=1
} rprMultiCastGMRP_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                 
	int		rprIfIndex;                                                    
	int		rprServiceId;                                                  
	char		rprMultiCastMacAddress[20];                                      
	int		rprMultiCastDoubleVlanId;   
	char		rprMultiCastPortsList[64];   
	rprMultiCastGMRP_Tval rprMultiCastGMRP;   
	RowStatus_Tval rprMultiCastRowStatus;   
}MIBpbRprMultiCastTable_t;















 



 
 
extern MIBDid_t pbRprAclTable_Did;

   
typedef enum {
	rprAclMacType_destinationMac[TTT]=1,
	rprAclMacType_sourceMac=2
} rprAclMacType_Tval;

typedef enum {
	rprAclMode_filter[TTT]=1,
	rprAclMode_forward=2
} rprAclMode_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                     
	int		rprIfIndex;                                        
	int		rprServiceId;                                      
	char		rprAclMacAddress[20];                                
	rprAclMacType_Tval rprAclMacType;   
	int		rprAclDoubleVlanId;   
	char		rprAclPortsList[64];   
	rprAclMode_Tval rprAclMode;   
	RowStatus_Tval rprAclRowStatus;   
	int		rprAclTblIdx;   
}MIBpbRprAclTable_t;

















 



 
 
extern MIBDid_t pbRprMultiBroadCastTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                                 
	int		rprIfIndex;                                                                    
	int		rprMultiBroadCastId;                                                              
	int		rprMultiBroadCastTimeInterval;   
	int		rprMultiBroadCastPacketsInterval;   
}MIBpbRprMultiBroadCastTable_t;












 



 
 
extern MIBDid_t rprTopoImageTable_Did;

   
typedef enum {
	rprTopoImageCapability_default[TTT]=0,
	rprTopoImageCapability_jbStrNspconsfair=1,
	rprTopoImageCapability_regWrpNspconsfair=2,
	rprTopoImageCapability_jbWrpNspconsfair=3,
	rprTopoImageCapability_regStrSpconsfair=4,
	rprTopoImageCapability_jbStrSpconsfair=5,
	rprTopoImageCapability_regWrpSpconsfair=6,
	rprTopoImageCapability_jbWrpSpconsfair=7
} rprTopoImageCapability_Tval;

typedef enum {
	rprTopoImageStatus_reachableRinglet0[TTT]=1,
	rprTopoImageStatus_reachableRinglet1=2,
	rprTopoImageStatus_reachableRinglet0Ringlet1=3,
	rprTopoImageStatus_wrapActiveWest=4,
	rprTopoImageStatus_wrapActiveEast=8,
	rprTopoImageStatus_receivedBadFcs=16,
	rprTopoImageStatus_receivBadFcsReachableR0R1=19,
	rprTopoImageStatus_receivedMultichokeFairness=32
} rprTopoImageStatus_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                                 
	int		rprIfIndex;                                                                    
	char		rprTopoImageMacAddress[20];                                                      
	char		rprTopoImageSecMacAddress1[20];   
	char		rprTopoImageSecMacAddress2[20];   
	int		rprTopoImageStationIfIndex;   
	char		rprTopoImageStationName[255];   
	rprTopoImageCapability_Tval rprTopoImageCapability;   
	int		rprTopoImageRinglet0Hops;   
	int		rprTopoImageRinglet0ReservedRate;   
	int		rprTopoImageRinglet1Hops;   
	int		rprTopoImageRinglet1ReservedRate;   
	RprProtectionStatus_Tval rprTopoImageWestProtectionStatus;   
	int		rprTopoImageWestWeight;   
	RprProtectionStatus_Tval rprTopoImageEastProtectionStatus;   
	int		rprTopoImageEastWeight;   
	rprTopoImageStatus_Tval rprTopoImageStatus;   
	char		rprTopoImageRemoteNEAddress[20];   
	int		rprTopoImageRemoteSlotNumber;   
}MIBrprTopoImageTable_t;


























 



 
 
extern MIBDid_t rprFairnessTable_Did;

   
typedef enum {
	rprFairnessRinglet_ringlet0[TTT]=1,
	rprFairnessRinglet_ringlet1=2
} rprFairnessRinglet_Tval;

typedef enum {
	rprFairnessResetWaterMarks_idle[TTT]=1,
	rprFairnessResetWaterMarks_resetWaterMarks=2
} rprFairnessResetWaterMarks_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                           
	int		rprIfIndex;                                                              
	rprFairnessRinglet_Tval rprFairnessRinglet;                                      
	int		rprFairnessRingletWeight;   
	int		rprFairnessReservedRate;   
	int		rprFairnessMaxAllowed;   
	int		rprFairnessAgeCoef;   
	int		rprFairnessLpCoef;   
	int		rprFairnessAdvertisementRatio;   
	int		rprFairnessMcffReportCoef;   
	int		rprFairnessActiveWeightsCoef;   
	int		rprFairnessSTQHighThreshold;   
	int		rprFairnessSTQMedThreshold;   
	int		rprFairnessSTQLowThreshold;   
	int		rprFairnessRateHighThreshold;   
	int		rprFairnessRateLowThreshold;   
	rprFairnessResetWaterMarks_Tval rprFairnessResetWaterMarks;   
	int		rprFairnessSTQHighWaterMark;   
	int		rprFairnessSTQLowWaterMark;   
	int		rprFairnessRampUpCoef;   
	int		rprFairnessRampDnCoef;   
}MIBrprFairnessTable_t;




























 



 
 
extern MIBDid_t rprOamTable_Did;

   
typedef enum {
	rprOamActionType_echo[TTT]=1,
	rprOamActionType_flush=2
} rprOamActionType_Tval;

typedef enum {
	rprOamClassOfService_classA[TTT]=1,
	rprOamClassOfService_classB=2,
	rprOamClassOfService_classC=3
} rprOamClassOfService_Tval;

typedef enum {
	rprOamControl_idle[TTT]=1,
	rprOamControl_active=2,
	rprOamControl_abort=3
} rprOamControl_Tval;

typedef enum {
	rprOamResponseStatus_unknown[TTT]=1,
	rprOamResponseStatus_inProcess=2,
	rprOamResponseStatus_error=3,
	rprOamResponseStatus_success=4
} rprOamResponseStatus_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                           
	int		rprIfIndex;                                              
	rprOamActionType_Tval rprOamActionType;   
	char		rprOamDestAddress[20];   
	RprOamRinglet_Tval rprOamRequestRinglet;   
	RprOamRinglet_Tval rprOamResponseRinglet;   
	rprOamClassOfService_Tval rprOamClassOfService;   
	char		rprOamUserData[20];   
	TruthValue_Tval rprOamProtected;   
	int		rprOamRequestCount;   
	int		rprOamTimeout;   
	rprOamControl_Tval rprOamControl;   
	int		rprOamResponseCount;   
	int		rprOamAvResponseTime;   
	rprOamResponseStatus_Tval rprOamResponseStatus;   
}MIBrprOamTable_t;






















 



 
 
extern MIBDid_t rprTopoRingInfoTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                 
	int		rprIfIndex;                                                    
	TruthValue_Tval rprRingMultiChoke0;   
	TruthValue_Tval rprRingMultiChoke1;   
	int		rprRingMtuSize;   
	int		rprRingTotalHopsTx0;   
	int		rprRingTotalHopsTx1;   
	char		rprRingLastNeighborMac0[20];   
	char		rprRingLastNeighborMac1[20];   
	int		rprRingCheckSum;   
	int		rprRingNeighborCheckSum0;   
	int		rprRingNeighborCheckSum1;   
	TruthValue_Tval rprRingCheckSumValid;   
	TruthValue_Tval rprRingNeighborCksValid0;   
	TruthValue_Tval rprRingNeighborCksValid1;   
}MIBrprTopoRingInfoTable_t;






















 



 
 
extern MIBDid_t rprIfTable_Did;

   
typedef enum {
	rprIfFairnessMode_aggressive[TTT]=1,
	rprIfFairnessMode_conservative=2,
	rprIfFairnessMode_others=3
} rprIfFairnessMode_Tval;

typedef enum {
	rprIfMacOperModes_default[TTT]=0,
	rprIfMacOperModes_strctorderNdrpbadfcs=1,
	rprIfMacOperModes_regorderDrpbadfcs=2,
	rprIfMacOperModes_strctorderDrpbadfcs=3
} rprIfMacOperModes_Tval;

typedef enum {
	rprIfRingOperModes_default[TTT]=0,
	rprIfRingOperModes_jbStrClsring=1,
	rprIfRingOperModes_regWrpClsring=2,
	rprIfRingOperModes_jbWrpClsring=3,
	rprIfRingOperModes_regStrOpenring=4,
	rprIfRingOperModes_jbStrOpenring=5,
	rprIfRingOperModes_regWrpOpenring=6,
	rprIfRingOperModes_jbWrpOpenring=7
} rprIfRingOperModes_Tval;

typedef enum {
	rprIfCurrentStatus_ok[TTT]=0,
	rprIfCurrentStatus_neighborInconsistency=1,
	rprIfCurrentStatus_duplicateMac=2,
	rprIfCurrentStatus_neiborInconsistDMAC=3,
	rprIfCurrentStatus_exceedMaxStations=4
} rprIfCurrentStatus_Tval;

typedef enum {
	rprIfMplsMode_mpls[TTT]=0,
	rprIfMplsMode_qinQ=1,
	rprIfMplsMode_transparent=2
} rprIfMplsMode_Tval;

typedef enum {
	rprIfHwPassThrough_disable[TTT]=1,
	rprIfHwPassThrough_enable=2,
	rprIfHwPassThrough_force=3
} rprIfHwPassThrough_Tval;

typedef enum {
	rprIfBandMode_auto[TTT]=1,
	rprIfBandMode_manual=2
} rprIfBandMode_Tval;

typedef enum {
	rprIfCardProtection_disable[TTT]=1,
	rprIfCardProtection_enable=2,
	rprIfCardProtection_force=3
} rprIfCardProtection_Tval;

typedef enum {
	rprIfL2RateLimitMode_advanced[TTT]=1,
	rprIfL2RateLimitMode_basic=2
} rprIfL2RateLimitMode_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                 
	int		rprIfIndex;                                                    
	int		rprIfStationsOnRing;   
	TruthValue_Tval rprIfReversionMode;   
	int		rprIfProtectionWTR;   
	int		rprIfProtectionFastTimer;   
	int		rprIfProtectionSlowTimer;   
	int		rprIfAtdTimer;   
	int		rprIfKeepaliveTimeout;   
	rprIfFairnessMode_Tval rprIfFairnessMode;   
	int		rprIfPtqSize;   
	int		rprIfStqSize;   
	int		rprIfSTQFullThreshold;   
	int		rprIfIdleThreshold;   
	int		rprIfSesThreshold;   
	RprProtectionType_Tval rprIfProtectionMode;   
	TruthValue_Tval rprIfJumboFramePreferred;   
	rprIfMacOperModes_Tval rprIfMacOperModes;   
	rprIfRingOperModes_Tval rprIfRingOperModes;   
	rprIfCurrentStatus_Tval rprIfCurrentStatus;   
	int		rprIfLinkRate;   
	rprIfMplsMode_Tval rprIfMplsMode;   
	int		rprIfMplsTypeTag;   
	TruthValue_Tval rprIfVlanPrioEn;   
	char		rprIfMyMacAddress[20];   
	TruthValue_Tval rprIfPassThroughEn;   
	rprIfHwPassThrough_Tval rprIfHwPassThrough;   
	TruthValue_Tval rprIfHwPassThroughStatus;   
	int		rprIfResRateR0;   
	int		rprIfResRateR1;   
	int		rprIfA0RateR0;   
	int		rprIfA0RateR1;   
	int		rprIfA1RateR0;   
	int		rprIfA1RateR1;   
	int		rprIfBcirRateR0;   
	int		rprIfBcirRateR1;   
	int		rprIfRealA0RateR0;   
	int		rprIfRealA0RateR1;   
	int		rprIfRealA1RateR0;   
	int		rprIfRealA1RateR1;   
	int		rprIfRealBcirRateR0;   
	int		rprIfRealBcirRateR1;   
	TruthValue_Tval rprIfAlarmMon;   
	char		rprIfStationName[128];   
	TruthValue_Tval rprIfInterWorking;   
	rprIfBandMode_Tval rprIfBandMode;   
	TruthValue_Tval rprIfMulBrdCastEn;
	rprIfCardProtection_Tval rprIfCardProtection;   
	TruthValue_Tval rprIfCardProtectionState;   
	rprIfL2RateLimitMode_Tval rprIfL2RateLimitMode;   
	char		rprIfCrossPortsList[64];   
	TruthValue_Tval rprIfLogSave;   
	TruthValue_Tval rprIfL2CosFlowControl;   
}MIBrprIfTable_t;




























































 



 
 
extern MIBDid_t rprSpanTable_Did;

   
typedef enum {
	rprSpanCurrentStatus_ok[TTT]=0,
	rprSpanCurrentStatus_kaNmcNsdNsf=1,
	rprSpanCurrentStatus_nkaMcNsdNsf=2,
	rprSpanCurrentStatus_kaMcNsdNsf=3,
	rprSpanCurrentStatus_nkaNmcSdNsf=4,
	rprSpanCurrentStatus_kaNmcSdNsf=5,
	rprSpanCurrentStatus_nkaMcSdNsf=6,
	rprSpanCurrentStatus_kaMcSdNsf=7,
	rprSpanCurrentStatus_nkaNmcNsdSf=8,
	rprSpanCurrentStatus_kaNmcNsdSf=9,
	rprSpanCurrentStatus_nkaMcNsdSf=10,
	rprSpanCurrentStatus_kaMcNsdSf=11,
	rprSpanCurrentStatus_nkaNmcSdSf=12,
	rprSpanCurrentStatus_kaNmcSdSf=13,
	rprSpanCurrentStatus_nkaMcSdSf=14,
	rprSpanCurrentStatus_kaMcSdSf=15
} rprSpanCurrentStatus_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                               
	int		rprIfIndex;                                                                  
	RprSpan_Tval rprSpanId;                                                           
	int		rprSpanTotalRingletReservedRate;   
	rprSpanCurrentStatus_Tval rprSpanCurrentStatus;   
	int		rprSpanWanPortNo;   
	int		rprSpanHopsToWrap;   
}MIBrprSpanTable_t;














 



 
 
extern MIBDid_t rprSpanProtectionTable_Did;

   
typedef enum {
	rprSpanProtectionCommand_idle[TTT]=1,
	rprSpanProtectionCommand_manualSwitch=2,
	rprSpanProtectionCommand_forcedSwitch=3
} rprSpanProtectionCommand_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                                       
	int		rprIfIndex;                                                                          
	RprSpan_Tval rprSpanId;                                                                   
	TruthValue_Tval rprSpanProtectionNeighborValid;   
	int		rprSpanProtectionHoldOffTimer;   
	rprSpanProtectionCommand_Tval rprSpanProtectionCommand;   
	unsigned int	rprSpanProtectionCount;   
	unsigned int	rprSpanProtectionDuration;   
	unsigned int	rprSpanProtectionLastActivationTime;   
	TruthValue_Tval rprSpanProtectionCountReset;   
}MIBrprSpanProtectionTable_t;

















 



 
 
extern MIBDid_t rprCardProtectionTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                         
	int		rprIfIndex;                                            
	int		rprCardProtectionId;                                      
	int		rprCpfWorkSlot;   
	int		rprCpfProtSlot;   
	int		rprCpfActiveSlot;   
	int		rprCpfCoordSlot;   
	int		rprCpfCoordProtGroup;   
	TruthValue_Tval rprCpfEnable;   
}MIBrprCardProtectionTable_t;
















 



 
extern MIBDid_t pbRprModule_Did;

   







 




 



 
extern MIBDid_t pbSdhPmUpLoadInfo_Did;

   


 



 
extern MIBDid_t pbSdhMostRecentIndex_Did;

   


 



 
extern MIBDid_t pbSdhRecentUapPerfMon_Did;

   


 



 
extern MIBDid_t pbSdhUapPerfMon_Did;

   


 



 
extern MIBDid_t pbSdhRecentPerfMon_Did;

   


 



 
extern MIBDid_t pbSdhCurPerfMon_Did;

   
typedef struct
{
	int		pbEthPmMonTimeIntervalSet[TTT];   
	PbEnableDisable_Tval pbPdhPmSlipEventEnable;   
}MIBpbSdhCurPerfMon_t;







 



 
extern MIBDid_t pbPMFilterConfigGroup_Did;

   
typedef struct
{
	TruthValue_Tval[TTT] pbPmDeleteAllFilter;
	PbSlotNumberType_Tval pbPmDeleteSlotNumber;
	TruthValue_Tval pbPmDeleteSlotFilter;
	unsigned int	pbPmDeleteFilterTypeId;
	TruthValue_Tval pbPmDeleteFilterType;
}MIBpbPMFilterConfigGroup_t;










 



 
 
extern MIBDid_t pbPMFilterTable_Did;

   
typedef struct
{
	unsigned int	pbPmFilterType[TTT];                    
	PbSlotNumberType_Tval pbSlotNumber;             
	PbPortType_Tval pbPortType;                     
	int		pbPortNo;                                  
	PbTPType_Tval pbTpType;                         
	int		pbTpIndex;                                 
	PbPmTableType_Tval pbTableType;                 
	unsigned int	pbPmEthId;                         
	unsigned int	pbPmReserved;
}MIBpbPMFilterTable_t;
















 



 
 
extern MIBDid_t pbSdhCurPMTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                               
	PbPortType_Tval pbPortType;                                       
	int		pbPortNo;                                                    
	PbTPType_Tval pbTpType;                                           
	int		pbTpIndex;                                                   
	PbPmTableType_Tval pbTableType;                                      
	PbActualPortType_Tval pbPmActualPortType;   
	PbPmMonitor_Tval pbSdhPmMonitor;   
	unsigned int	pbEsPmCounter;   
	TruthValue_Tval pbEsPmThresholdEnable;   
	int		pbEsPmThresholdLow;   
	int		pbEsPmThresholdHigh;   
	unsigned int	pbBbePmCounter;   
	TruthValue_Tval pbBbePmThresholdEnable;   
	int		pbBbePmThresholdLow;   
	int		pbBbePmThresholdHigh;   
	unsigned int	pbSesPmCounter;   
	TruthValue_Tval pbSesPmThresholdEnable;   
	int		pbSesPmThresholdLow;   
	int		pbSesPmThresholdHigh;   
	unsigned int	pbUasPmCounter;   
	TruthValue_Tval pbUasPmThresholdEnable;   
	int		pbUasPmThresholdLow;   
	int		pbUasPmThresholdHigh;   
	unsigned int	pbCsesPmCounter;   
	TruthValue_Tval pbCsesPmThresholdEnable;   
	int		pbCsesPmThresholdLow;   
	int		pbCsesPmThresholdHigh;   
	unsigned int	pbFcPmCounter;   
	TruthValue_Tval pbFcPmThresholdEnable;   
	int		pbFcPmThresholdLow;   
	int		pbFcPmThresholdHigh;   
	unsigned int	pbOfsPmCounter;
	TruthValue_Tval pbOfsPmThresholdEnable;   
	int		pbOfsPmThresholdLow;   
	int		pbOfsPmThresholdHigh;   
	unsigned int	pbPpjcPmCounter;   
	TruthValue_Tval pbPpjcPmThresholdEnable;   
	int		pbPpjcPmThresholdLow;   
	int		pbPpjcPmThresholdHigh;   
	unsigned int	pbNpjcPmCounter;   
	TruthValue_Tval pbNpjcPmThresholdEnable;   
	int		pbNpjcPmThresholdLow;   
	int		pbNpjcPmThresholdHigh;   
	TruthValue_Tval pbPmTableReset;   
	char		pbPmTimeStart[16];   
	unsigned int	pbPmTimeElapse;   
	PbPmPortStatusType_Tval pbPmProtStatus;   
	PbPmTpStatusType_Tval pbPmTpStatus;   
	TruthValue_Tval pbPmSuspect;   
}MIBpbSdhCurPMTable_t;

























































 



 
 
extern MIBDid_t pbEthCurPMTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                                                   
	int		pbPortNo;                                                                                        
	PbPmTableType_Tval pbEthTableType;                                                                       
	EthPortClass_Tval pbEthPmPortType;                                                                    
	PbPmMonitor_Tval pbEthPmMonitor;   
	char		pbEthPmTimeStart[16];   
	unsigned int	pbEthPmTimeElapse;   
	TruthValue_Tval pbEthPmTimeSuspect;   
	TruthValue_Tval pbEthPmTableReset;   
	unsigned int	pbEthInUnicastPktsHigh;   
	unsigned int	pbEthInUnicastPktsLow;   
	unsigned int	pbEthInMulcastPktsHigh;   
	unsigned int	pbEthInMulcastPktsLow;   
	unsigned int	pbEthInBrdcastPktsHigh;   
	unsigned int	pbEthInBrdcastPktsLow;   
	unsigned int	pbEthInAllBadPktsHigh;   
	unsigned int	pbEthInAllBadPktsLow;   
	unsigned int	pbEthInAllBadBytesHigh;   
	unsigned int	pbEthInAllBadBytesLow;   
	unsigned int	pbEthInAllGoodPktsHigh;   
	unsigned int	pbEthInAllGoodPktsLow;   
	unsigned int	pbEthInAllGoodBytesHigh;   
	unsigned int	pbEthInAllGoodBytesLow;   
	unsigned int	pbEthInOverSizePktsHigh;   
	unsigned int	pbEthInOverSizePktsLow;   
	unsigned int	pbEthInUnderSizePktsHigh;   
	unsigned int	pbEthInUnderSizePktsLow;   
	unsigned int	pbEthInCRCErrPktsHigh;   
	unsigned int	pbEthInCRCErrPktsLow;   
	unsigned int	pbEthOutUnicastPktsHigh;   
	unsigned int	pbEthOutUnicastPktsLow;   
	unsigned int	pbEthOutMulcastPktsHigh;   
	unsigned int	pbEthOutMulcastPktsLow;   
	unsigned int	pbEthOutBrdcastPktsHigh;   
	unsigned int	pbEthOutBrdcastPktsLow;   
	unsigned int	pbEthOutAllGoodPktsHigh;   
	unsigned int	pbEthOutAllGoodPktsLow;   
	unsigned int	pbEthOutAllGoodBytesHigh;   
	unsigned int	pbEthOutAllGoodBytesLow;   
	TruthValue_Tval pbEthBbrEnable;   
	int		pbEthBbrThresholdValue;   
	TruthValue_Tval pbEthBprEnable;   
	int		pbEthBprThresholdValue;   
	unsigned int	pbEthCurInAllBytesHigh;   
	unsigned int	pbEthCurInAllBytesLow;   
	unsigned int	pbEthCurInAllPktsHigh;   
	unsigned int	pbEthCurInAllPktsLow;   
	unsigned int	pbEthCurInAllGoodPktsHigh;   
	unsigned int	pbEthCurInAllGoodPktsLow;   
	unsigned int	pbEthCurInAllBadPktsHigh;   
	unsigned int	pbEthCurInAllBadPktsLow;   
	unsigned int	pbEthCurInUnicastPktsHigh;   
	unsigned int	pbEthCurInUnicastPktsLow;   
	unsigned int	pbEthCurInMulcastPktsHigh;   
	unsigned int	pbEthCurInMulcastPktsLow;   
	unsigned int	pbEthCurInBrdcastPktsHigh;   
	unsigned int	pbEthCurInBrdcastPktsLow;   
	unsigned int	pbEthCurInDropPktsHigh;   
	unsigned int	pbEthCurInDropPktsLow;   
	unsigned int	pbEthCurInUndersizeGoodPktsHigh;   
	unsigned int	pbEthCurInUndersizeGoodPktsLow;   
	unsigned int	pbEthCurInOversizeGoodPktsHigh;   
	unsigned int	pbEthCurInOversizeGoodPktsLow;   
	unsigned int	pbEthCurIn64PktsHigh;   
	unsigned int	pbEthCurIn64PktsLow;   
	unsigned int	pbEthCurIn65To127PktsHigh;   
	unsigned int	pbEthCurIn65To127PktsLow;   
	unsigned int	pbEthCurIn128To255PktsHigh;   
	unsigned int	pbEthCurIn128To255PktsLow;   
	unsigned int	pbEthCurIn256To511PktsHigh;   
	unsigned int	pbEthCurIn256To511PktsLow;   
	unsigned int	pbEthCurIn512To1023PktsHigh;   
	unsigned int	pbEthCurIn512To1023PktsLow;   
	unsigned int	pbEthCurIn1024To1518PktsHigh;   
	unsigned int	pbEthCurIn1024To1518PktsLow;   
	unsigned int	pbEthCurInPausePktsHigh;   
	unsigned int	pbEthCurInPausePktsLow;   
	unsigned int	pbEthCurInFragmentPktsHigh;   
	unsigned int	pbEthCurInFragmentPktsLow;   
	unsigned int	pbEthCurInJabberPktsHigh;   
	unsigned int	pbEthCurInJabberPktsLow;   
	unsigned int	pbEthCurInAlignmentErrorPktsHigh;   
	unsigned int	pbEthCurInAlignmentErrorPktsLow;   
	unsigned int	pbEthCurOutAllBytesHigh;   
	unsigned int	pbEthCurOutAllBytesLow;   
	unsigned int	pbEthCurOutAllPktsHigh;   
	unsigned int	pbEthCurOutAllPktsLow;   
	unsigned int	pbEthCurOutUnicastPktsHigh;   
	unsigned int	pbEthCurOutUnicastPktsLow;   
	unsigned int	pbEthCurOutMulcastPktsHigh;   
	unsigned int	pbEthCurOutMulcastPktsLow;   
	unsigned int	pbEthCurOutBrdcastPktsHigh;   
	unsigned int	pbEthCurOutBrdcastPktsLow;   
	unsigned int	pbEthCurOutGoodPausePktsHigh;   
	unsigned int	pbEthCurOutGoodPausePktsLow;   
	unsigned int	pbEthCurOutCollisionPktsHigh;   
	unsigned int	pbEthCurOutCollisionPktsLow;   
	unsigned int	pbCurOutInvalidSymbolsHigh;
	unsigned int	pbCurOutInvalidSymbolsLow;
	unsigned int	pbCurOutSuperblockCrcErrorHigh;
	unsigned int	pbCurOutSuperblockCrcErrorLow;
	unsigned int	pbCurOutSuperblockCorrectableCrcErrorHigh;
	unsigned int	pbCurOutSuperblockCorrectableCrcErrorLow;
}MIBpbEthCurPMTable_t;














































































































 



 
 
extern MIBDid_t pbxSecEthPmMonTable_Did;

   
typedef enum {
	pbxSecEthPmReportStatus_notReport[TTT]=1,
	pbxSecEthPmReportStatus_reportOnce=2
} pbxSecEthPmReportStatus_Tval;

typedef enum {
	pbxSecEthPmMonitorStatus_notMonitor[TTT]=1,
	pbxSecEthPmMonitorStatus_monitor=2
} pbxSecEthPmMonitorStatus_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                 
	int		pbPortNo;                                                      
	EthPortClass_Tval pbxSecEthPmPortType;                                 
	pbxSecEthPmReportStatus_Tval pbxSecEthPmReportStatus;   
	pbxSecEthPmMonitorStatus_Tval pbxSecEthPmMonitorStatus;   
	unsigned int	pbxSecEthPmFtpHostIP;   
	char		pbxSecEthPmFtpPath[64];   
	char		pbxSecEthPmFtpFileName[13];   
	char		pbxSecEthPmFtpUsername[32];   
	char		pbxSecEthPmFtpPassword[32];   
	char		pbxSecEthPmRequestId[40];   
	PbPmReportResp_Tval pbxSecEthPmRespMsg;   
}MIBpbxSecEthPmMonTable_t;



















 



 
 
extern MIBDid_t pbRprClientCurPMTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                                             
	int		rprIfIndex;                                                                                
	PbPmTableType_Tval pbRprClientTableType;                                                           
	PbPmMonitor_Tval pbRprClientPmMonitor;   
	char		pbRprClientPmTimeStart[16];   
	unsigned int	pbRprClientPmTimeElapse;   
	TruthValue_Tval pbRprClientPmTimeSuspect;   
	TruthValue_Tval pbRprClientPmTableReset;   
	unsigned int	pbRprClientInAllFramesHigh;   
	unsigned int	pbRprClientInAllFramesLow;   
	unsigned int	pbRprClientOutAllFramesHigh;   
	unsigned int	pbRprClientOutAllFramesLow;   
	unsigned int	pbRprClientOutPassFramesHigh;   
	unsigned int	pbRprClientOutPassFramesLow;   
	unsigned int	pbRprClientOutDropFramesHigh;   
	unsigned int	pbRprClientOutDropFramesLow;   
	unsigned int	pbRprClientOutErrLenFramesHigh;   
	unsigned int	pbRprClientOutErrLenFramesLow;   
	unsigned int	pbRprClientOutErrCrcFramesHigh;   
	unsigned int	pbRprClientOutErrCrcFramesLow;   
	unsigned int	pbRprClientInUcastClassAFramesHigh;   
	unsigned int	pbRprClientInUcastClassAFramesLow;   
	unsigned int	pbRprClientInUcastClassAOctetsHigh;   
	unsigned int	pbRprClientInUcastClassAOctetsLow;   
	unsigned int	pbRprClientInUcastClassBCirFramesHigh;   
	unsigned int	pbRprClientInUcastClassBCirFramesLow;   
	unsigned int	pbRprClientInUcastClassBCirOctetsHigh;   
	unsigned int	pbRprClientInUcastClassBCirOctetsLow;   
	unsigned int	pbRprClientInUcastClassBEirFramesHigh;   
	unsigned int	pbRprClientInUcastClassBEirFramesLow;   
	unsigned int	pbRprClientInUcastClassBEirOctetsHigh;   
	unsigned int	pbRprClientInUcastClassBEirOctetsLow;   
	unsigned int	pbRprClientInUcastClassCFramesHigh;   
	unsigned int	pbRprClientInUcastClassCFramesLow;   
	unsigned int	pbRprClientInUcastClassCOctetsHigh;   
	unsigned int	pbRprClientInUcastClassCOctetsLow;   
	unsigned int	pbRprClientInMcastClassAFramesHigh;   
	unsigned int	pbRprClientInMcastClassAFramesLow;   
	unsigned int	pbRprClientInMcastClassAOctetsHigh;   
	unsigned int	pbRprClientInMcastClassAOctetsLow;   
	unsigned int	pbRprClientInMcastClassBCirFramesHigh;   
	unsigned int	pbRprClientInMcastClassBCirFramesLow;   
	unsigned int	pbRprClientInMcastClassBCirOctetsHigh;   
	unsigned int	pbRprClientInMcastClassBCirOctetsLow;   
	unsigned int	pbRprClientInMcastClassBEirFramesHigh;   
	unsigned int	pbRprClientInMcastClassBEirFramesLow;   
	unsigned int	pbRprClientInMcastClassBEirOctetsHigh;   
	unsigned int	pbRprClientInMcastClassBEirOctetsLow;   
	unsigned int	pbRprClientInMcastClassCFramesHigh;   
	unsigned int	pbRprClientInMcastClassCFramesLow;   
	unsigned int	pbRprClientInMcastClassCOctetsHigh;   
	unsigned int	pbRprClientInMcastClassCOctetsLow;   
	unsigned int	pbRprClientOutUcastClassAFramesHigh;   
	unsigned int	pbRprClientOutUcastClassAFramesLow;   
	unsigned int	pbRprClientOutUcastClassAOctetsHigh;   
	unsigned int	pbRprClientOutUcastClassAOctetsLow;   
	unsigned int	pbRprClientOutUcastClassBCirFramesHigh;   
	unsigned int	pbRprClientOutUcastClassBCirFramesLow;   
	unsigned int	pbRprClientOutUcastClassBCirOctetsHigh;   
	unsigned int	pbRprClientOutUcastClassBCirOctetsLow;   
	unsigned int	pbRprClientOutUcastClassBEirFramesHigh;   
	unsigned int	pbRprClientOutUcastClassBEirFramesLow;   
	unsigned int	pbRprClientOutUcastClassBEirOctetsHigh;   
	unsigned int	pbRprClientOutUcastClassBEirOctetsLow;   
	unsigned int	pbRprClientOutUcastClassCFramesHigh;   
	unsigned int	pbRprClientOutUcastClassCFramesLow;   
	unsigned int	pbRprClientOutUcastClassCOctetsHigh;   
	unsigned int	pbRprClientOutUcastClassCOctetsLow;   
	unsigned int	pbRprClientOutMcastClassAFramesHigh;   
	unsigned int	pbRprClientOutMcastClassAFramesLow;   
	unsigned int	pbRprClientOutMcastClassAOctetsHigh;   
	unsigned int	pbRprClientOutMcastClassAOctetsLow;   
	unsigned int	pbRprClientOutMcastClassBCirFramesHigh;   
	unsigned int	pbRprClientOutMcastClassBCirFramesLow;   
	unsigned int	pbRprClientOutMcastClassBCirOctetsHigh;   
	unsigned int	pbRprClientOutMcastClassBCirOctetsLow;   
	unsigned int	pbRprClientOutMcastClassBEirFramesHigh;   
	unsigned int	pbRprClientOutMcastClassBEirFramesLow;   
	unsigned int	pbRprClientOutMcastClassBEirOctetsHigh;   
	unsigned int	pbRprClientOutMcastClassBEirOctetsLow;   
	unsigned int	pbRprClientOutMcastClassCFramesHigh;   
	unsigned int	pbRprClientOutMcastClassCFramesLow;   
	unsigned int	pbRprClientOutMcastClassCOctetsHigh;   
	unsigned int	pbRprClientOutMcastClassCOctetsLow;   
}MIBpbRprClientCurPMTable_t;



























































































 



 
 
extern MIBDid_t pbRprSpanCurPMTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                                         
	int		rprIfIndex;                                                                            
	RprSpan_Tval rprSpanId;                                                                     
	PbPmTableType_Tval pbRprSpanTableType;                                                         
	PbPmMonitor_Tval pbRprSpanPmMonitor;   
	char		pbRprSpanPmTimeStart[16];   
	unsigned int	pbRprSpanPmTimeElapse;   
	TruthValue_Tval pbRprSpanPmTimeSuspect;   
	TruthValue_Tval pbRprSpanPmTableReset;   
	unsigned int	pbRprSpanInAllFramesHigh;   
	unsigned int	pbRprSpanInAllFramesLow;   
	unsigned int	pbRprSpanInWrapFramesHigh;   
	unsigned int	pbRprSpanInWrapFramesLow;   
	unsigned int	pbRprSpanInDataFramesHigh;   
	unsigned int	pbRprSpanInDataFramesLow;   
	unsigned int	pbRprSpanInCtrlFramesHigh;   
	unsigned int	pbRprSpanInCtrlFramesLow;   
	unsigned int	pbRprSpanInFaFramesHigh;   
	unsigned int	pbRprSpanInFaFramesLow;   
	unsigned int	pbRprSpanOutAllFramesHigh;   
	unsigned int	pbRprSpanOutAllFramesLow;   
	unsigned int	pbRprSpanOutAddFramesHigh;   
	unsigned int	pbRprSpanOutAddFramesLow;   
	unsigned int	pbRprSpanOutTransitFramesHigh;   
	unsigned int	pbRprSpanOutTransitFramesLow;   
	unsigned int	pbRprSpanOutWrapFramesHigh;   
	unsigned int	pbRprSpanOutWrapFramesLow;   
	unsigned int	pbRprSpanOutTpFramesHigh;   
	unsigned int	pbRprSpanOutTpFramesLow;   
	unsigned int	pbRprSpanOutFaFramesHigh;   
	unsigned int	pbRprSpanOutFaFramesLow;   
	unsigned int	pbRprSpanOutOamFramesHigh;   
	unsigned int	pbRprSpanOutOamFramesLow;   
	unsigned int	pbRprSpanErrHecFramesHigh;   
	unsigned int	pbRprSpanErrHecFramesLow;   
	unsigned int	pbRprSpanErrParityFramesHigh;   
	unsigned int	pbRprSpanErrParityFramesLow;   
	unsigned int	pbRprSpanErrFcsFramesHigh;   
	unsigned int	pbRprSpanErrFcsFramesLow;   
	unsigned int	pbRprSpanErrEdgeFramesHigh;   
	unsigned int	pbRprSpanErrEdgeFramesLow;   
	unsigned int	pbRprSpanErrSelfSourceFramesHigh;   
	unsigned int	pbRprSpanErrSelfSourceFramesLow;   
	unsigned int	pbRprSpanInUcastClassAFramesHigh;   
	unsigned int	pbRprSpanInUcastClassAFramesLow;   
	unsigned int	pbRprSpanInUcastClassAOctetsHigh;   
	unsigned int	pbRprSpanInUcastClassAOctetsLow;   
	unsigned int	pbRprSpanInUcastClassBCirFramesHigh;   
	unsigned int	pbRprSpanInUcastClassBCirFramesLow;   
	unsigned int	pbRprSpanInUcastClassBCirOctetsHigh;   
	unsigned int	pbRprSpanInUcastClassBCirOctetsLow;   
	unsigned int	pbRprSpanInUcastClassBEirFramesHigh;   
	unsigned int	pbRprSpanInUcastClassBEirFramesLow;   
	unsigned int	pbRprSpanInUcastClassBEirOctetsHigh;   
	unsigned int	pbRprSpanInUcastClassBEirOctetsLow;   
	unsigned int	pbRprSpanInUcastClassCFramesHigh;   
	unsigned int	pbRprSpanInUcastClassCFramesLow;   
	unsigned int	pbRprSpanInUcastClassCOctetsHigh;   
	unsigned int	pbRprSpanInUcastClassCOctetsLow;   
	unsigned int	pbRprSpanInMcastClassAFramesHigh;   
	unsigned int	pbRprSpanInMcastClassAFramesLow;   
	unsigned int	pbRprSpanInMcastClassAOctetsHigh;   
	unsigned int	pbRprSpanInMcastClassAOctetsLow;   
	unsigned int	pbRprSpanInMcastClassBCirFramesHigh;   
	unsigned int	pbRprSpanInMcastClassBCirFramesLow;   
	unsigned int	pbRprSpanInMcastClassBCirOctetsHigh;   
	unsigned int	pbRprSpanInMcastClassBCirOctetsLow;   
	unsigned int	pbRprSpanInMcastClassBEirFramesHigh;   
	unsigned int	pbRprSpanInMcastClassBEirFramesLow;   
	unsigned int	pbRprSpanInMcastClassBEirOctetsHigh;   
	unsigned int	pbRprSpanInMcastClassBEirOctetsLow;   
	unsigned int	pbRprSpanInMcastClassCFramesHigh;   
	unsigned int	pbRprSpanInMcastClassCFramesLow;   
	unsigned int	pbRprSpanInMcastClassCOctetsHigh;   
	unsigned int	pbRprSpanInMcastClassCOctetsLow;   
	unsigned int	pbRprSpanOutUcastClassAFramesHigh;   
	unsigned int	pbRprSpanOutUcastClassAFramesLow;   
	unsigned int	pbRprSpanOutUcastClassAOctetsHigh;   
	unsigned int	pbRprSpanOutUcastClassAOctetsLow;   
	unsigned int	pbRprSpanOutUcastClassBCirFramesHigh;   
	unsigned int	pbRprSpanOutUcastClassBCirFramesLow;   
	unsigned int	pbRprSpanOutUcastClassBCirOctetsHigh;   
	unsigned int	pbRprSpanOutUcastClassBCirOctetsLow;   
	unsigned int	pbRprSpanOutUcastClassBEirFramesHigh;   
	unsigned int	pbRprSpanOutUcastClassBEirFramesLow;   
	unsigned int	pbRprSpanOutUcastClassBEirOctetsHigh;   
	unsigned int	pbRprSpanOutUcastClassBEirOctetsLow;   
	unsigned int	pbRprSpanOutUcastClassCFramesHigh;   
	unsigned int	pbRprSpanOutUcastClassCFramesLow;   
	unsigned int	pbRprSpanOutUcastClassCOctetsHigh;   
	unsigned int	pbRprSpanOutUcastClassCOctetsLow;   
	unsigned int	pbRprSpanOutMcastClassAFramesHigh;   
	unsigned int	pbRprSpanOutMcastClassAFramesLow;   
	unsigned int	pbRprSpanOutMcastClassAOctetsHigh;   
	unsigned int	pbRprSpanOutMcastClassAOctetsLow;   
	unsigned int	pbRprSpanOutMcastClassBCirFramesHigh;   
	unsigned int	pbRprSpanOutMcastClassBCirFramesLow;   
	unsigned int	pbRprSpanOutMcastClassBCirOctetsHigh;   
	unsigned int	pbRprSpanOutMcastClassBCirOctetsLow;   
	unsigned int	pbRprSpanOutMcastClassBEirFramesHigh;   
	unsigned int	pbRprSpanOutMcastClassBEirFramesLow;   
	unsigned int	pbRprSpanOutMcastClassBEirOctetsHigh;   
	unsigned int	pbRprSpanOutMcastClassBEirOctetsLow;   
	unsigned int	pbRprSpanOutMcastClassCFramesHigh;   
	unsigned int	pbRprSpanOutMcastClassCFramesLow;   
	unsigned int	pbRprSpanOutMcastClassCOctetsHigh;   
	unsigned int	pbRprSpanOutMcastClassCOctetsLow;   
}MIBpbRprSpanCurPMTable_t;


















































































































 



 
 
extern MIBDid_t pbPdhCurSlipTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                             
	PbPortType_Tval pbPortType;                                     
	int		pbPortNo;                                                  
	PbPmTableType_Tval pbSlipTableType;                                
	PbPmMonitor_Tval pbSlipMonitor;   
	unsigned int	pbPSlipCounter;   
	TruthValue_Tval pbPSlipThresholdEnable;   
	int		pbPSlipThreshold;   
	unsigned int	pbNSlipCounter;   
	TruthValue_Tval pbNSlipThresholdEnable;   
	int		pbNSlipThreshold;   
	TruthValue_Tval pbSlipTableReset;   
	char		pbSlipTimeStart[16];   
	unsigned int	pbSlipTimeElapse;   
	TruthValue_Tval pbSlipSuspect;   
}MIBpbPdhCurSlipTable_t;






















 



 
 
extern MIBDid_t pbPmMonitoredNumberTable_Did;

   
typedef struct
{
	unsigned int	pbSdhFtpCmndHostIP[TTT];                                
	int		pbPmMonitoredAll;   
	int		pbPmMonitoredCtp;   
	int		pbPmMonitoredTtp;   
	int		pbPmMonitoredEth;   
	int		pbPmMonitoredRprClient;   
	int		pbPmMonitoredRprSpan;   
	int		pbPmMonitoredAtm;   
	int		pbPmMonitoredPdhSlip;   
	int		pbPmMonitoredPdhCrc;   
	int		pbPmMonitoredFec;   
	int		pbPmMonitoredOtu;
}MIBpbPmMonitoredNumberTable_t;



















 



 
 
extern MIBDid_t pbxSecEthPMTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                               
	int		pbPortNo;                                                    
	EthPortClass_Tval pbxSecEthCurPmPortType;                         
	RowStatus_Tval pbxSecEthPmEnableStatus;   
	char		pbxSecEthPmTimeStart[16];   
	TruthValue_Tval pbxSecEthPmStartFlag;   
}MIBpbxSecEthPMTable_t;













 



 
 
extern MIBDid_t pbPdhCurPMTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                     
	PbPortType_Tval pbPortType;                                             
	int		pbPortNo;                                                          
	PbPmTableType_Tval pbPdhTableType;                                         
	PbPmMonitor_Tval pbPdhPmMonitor;   
	unsigned int	pbPdhEsPmCounter;   
	TruthValue_Tval pbPdhEsPmThresholdEnable;   
	int		pbPdhEsPmThresholdLow;   
	int		pbPdhEsPmThresholdHigh;   
	unsigned int	pbPdhBbePmCounter;   
	TruthValue_Tval pbPdhBbePmThresholdEnable;   
	int		pbPdhBbePmThresholdLow;   
	int		pbPdhBbePmThresholdHigh;   
	unsigned int	pbPdhSesPmCounter;   
	TruthValue_Tval pbPdhSesPmThresholdEnable;   
	int		pbPdhSesPmThresholdLow;   
	int		pbPdhSesPmThresholdHigh;   
	unsigned int	pbPdhUasPmCounter;   
	TruthValue_Tval pbPdhUasPmThresholdEnable;   
	int		pbPdhUasPmThresholdLow;   
	int		pbPdhUasPmThresholdHigh;   
	unsigned int	pbPdhCsesPmCounter;   
	TruthValue_Tval pbPdhCsesPmThresholdEnable;   
	int		pbPdhCsesPmThresholdLow;   
	int		pbPdhCsesPmThresholdHigh;   
	unsigned int	pbPdhFcPmCounter;   
	TruthValue_Tval pbPdhFcPmThresholdEnable;   
	int		pbPdhFcPmThresholdLow;   
	int		pbPdhFcPmThresholdHigh;   
	TruthValue_Tval pbPdhPmTableReset;   
	char		pbPdhPmTimeStart[16];   
	unsigned int	pbPdhPmTimeElapse;   
	TruthValue_Tval pbPdhPmSuspect;   
}MIBpbPdhCurPMTable_t;








































 



 
 
extern MIBDid_t pbEthVlanPMTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                           
	int		pbPortNo;                                                                
	PbPmTableType_Tval pbEthVlanTableType;                                           
	EthPortClass_Tval pbEthPmPortType;                                            
	int		pbEthVlanNo;                                                             
	PbPmMonitor_Tval pbEthVlanPmMonitor;   
	char		pbEthVlanPmTimeStart[16];   
	unsigned int	pbEthVlanPmTimeElapse;   
	TruthValue_Tval pbEthVlanPmTimeSuspect;   
	TruthValue_Tval pbEthVlanPmTableReset;   
	unsigned int	pbEthVlanInPktsHigh;   
	unsigned int	pbEthVlanInPktsLow;   
	unsigned int	pbEthVlanInBytesHigh;   
	unsigned int	pbEthVlanInBytesLow;   
	unsigned int	pbEthVlanDropPktsHigh;   
	unsigned int	pbEthVlanDropPktsLow;   
	unsigned int	pbEthVlanRcvUnicastFramesHigh;   
	unsigned int	pbEthVlanRcvUnicastFramesLow;   
	unsigned int	pbEthVlanRcvTotalFramesHigh;   
	unsigned int	pbEthVlanRcvTotalFramesLow;   
	unsigned int	pbEthVlanRcvUnicastBytesHigh;   
	unsigned int	pbEthVlanRcvUnicastBytesLow;   
	unsigned int	pbEthVlanRcvTotalBytesHigh;   
	unsigned int	pbEthVlanRcvTotalBytesLow;   
	RowStatus_Tval pbEthVlanPmEnableStatus;   
}MIBpbEthVlanPMTable_t;
































 



 
 
extern MIBDid_t pbxSecEthVlanPMTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                       
	int		pbPortNo;                                                            
	EthPortClass_Tval pbEthPmPortType;                                        
	int		pbEthVlanNo;                                                         
	RowStatus_Tval pbxSecEthVlanPmEnableStatus;   
	char		pbxSecEthVlanPmTimeStart[16];   
	TruthValue_Tval pbxSecEthVlanPmStartFlag;   
}MIBpbxSecEthVlanPMTable_t;














 



 
 
extern MIBDid_t pbEthTcaPMTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                 
	int		pbPortNo;                                                      
	EthPortClass_Tval pbEthPmPortType;                                  
	TruthValue_Tval pbEthPmBbrEnable;   
	int		pbEthPmBbrThresholdValue;   
	TruthValue_Tval pbEthPmBprEnable;   
	int		pbEthPmBprThresholdValue;   
}MIBpbEthTcaPMTable_t;














 



 
 
extern MIBDid_t pbFecCurPMTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                               
	PbPortType_Tval pbPortType;                                       
	int		pbPortNo;                                                    
	PbPmTableType_Tval pbFecTableType;                                   
	PbPmMonitor_Tval pbFecPmMonitor;   
	unsigned int	pbFecTecPmCounterHigh;   
	unsigned int	pbFecTecPmCounterLow;   
	unsigned int	pbFecZecPmCounterHigh;   
	unsigned int	pbFecZecPmCounterLow;   
	unsigned int	pbFecOecPmCounterHigh;   
	unsigned int	pbFecOecPmCounterLow;   
	unsigned int	pbFecFcPmCounter;
	TruthValue_Tval pbFecPmTableReset;   
	char		pbFecPmTimeStart[16];   
	unsigned int	pbFecPmTimeElapse;   
	TruthValue_Tval pbFecPmSuspect;   
	unsigned int	pbFecUncorrectedBlkHigh;
	unsigned int	pbFecUncorrectedBlkLow;
}MIBpbFecCurPMTable_t;

























 



 
 
extern MIBDid_t pbOtuCurPMTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                       
	PbPortType_Tval pbPortType;                               
	int		pbPortNo;                                            
	PbPmTableType_Tval pbOtuTableType;                        
	unsigned int	pbChannelID;                                 
	unsigned int	pbSegmentNum;                                
	PbPmMonitor_Tval pbOtuPmMonitor;
	unsigned int	pbOtuEsPmCounter;
	unsigned int	pbOtuBbePmCounter;
	unsigned int	pbOtuSesPmCounter;
	unsigned int	pbOtuUasPmCounter;
	unsigned int	pbOtuCsesPmCounter;
	unsigned int	pbOtuFcPmCounter;
	unsigned int	pbOtuOfsPmCounter;
	unsigned int	pbOtuIaesPmCounter;
	unsigned int	pbOtuBiaesPmCounter;
	TruthValue_Tval pbOtuPmTableReset;
	char		pbOtuPmTimeStart[16];
	unsigned int	pbOtuPmTimeElapse;
	TruthValue_Tval pbOtuPmSuspect;
}MIBpbOtuCurPMTable_t;



























 



 
 
extern MIBDid_t pbSdhRecentPMTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                           
	PbPortType_Tval pbPortType;                                   
	int		pbPortNo;                                                
	PbTPType_Tval pbTpType;                                       
	int		pbTpIndex;                                               
	PbPmTableType_Tval pbRecentTableType;                            
	int		pbRecentTimesIndex;                                         
	unsigned int	pbRecentEsPmCounter;   
	unsigned int	pbRecentBbePmCounter;   
	unsigned int	pbRecentSesPmCounter;   
	unsigned int	pbRecentUasPmCounter;   
	unsigned int	pbRecentCsesPmCounter;   
	unsigned int	pbRecentFcPmCounter;   
	unsigned int	pbRecentOfsPmCounter;   
	unsigned int	pbRecentPpjcPmCounter;   
	unsigned int	pbRecentNpjcPmCounter;   
	char		pbRecentPmTimeEnd[16];   
	TruthValue_Tval pbSuspect;   
	TruthValue_Tval pbComplete;   
}MIBpbSdhRecentPMTable_t;


























 



 
 
extern MIBDid_t pbEthRecentPMTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                                   
	int		pbPortNo;                                                                        
	PbPmTableType_Tval pbEthRecentTableType;                                                 
	EthPortClass_Tval pbEthRecentPmPortType;                                                 
	int		pbEthRecentTimesIndex;                                                              
	char		pbEthRecentPmTimeEnd[16];   
	TruthValue_Tval pbEthRecentPmTimeSuspect;   
	unsigned int	pbEthRecentInUnicastPktsHigh;   
	unsigned int	pbEthRecentInUnicastPktsLow;   
	unsigned int	pbEthRecentInMulcastPktsHigh;   
	unsigned int	pbEthRecentInMulcastPktsLow;   
	unsigned int	pbEthRecentInBrdcastPktsHigh;   
	unsigned int	pbEthRecentInBrdcastPktsLow;   
	unsigned int	pbEthRecentInAllBadPktsHigh;   
	unsigned int	pbEthRecentInAllBadPktsLow;   
	unsigned int	pbEthRecentInAllBadBytesHigh;   
	unsigned int	pbEthRecentInAllBadBytesLow;   
	unsigned int	pbEthRecentInAllGoodPktsHigh;   
	unsigned int	pbEthRecentInAllGoodPktsLow;   
	unsigned int	pbEthRecentInAllGoodBytesHigh;   
	unsigned int	pbEthRecentInAllGoodBytesLow;   
	unsigned int	pbEthRecentInOverSizePktsHigh;   
	unsigned int	pbEthRecentInOverSizePktsLow;   
	unsigned int	pbEthRecentInUnderSizePktsHigh;   
	unsigned int	pbEthRecentInUnderSizePktsLow;   
	unsigned int	pbEthRecentInCRCErrPktsHigh;   
	unsigned int	pbEthRecentInCRCErrPktsLow;   
	unsigned int	pbEthRecentOutUnicastPktsHigh;   
	unsigned int	pbEthRecentOutUnicastPktsLow;   
	unsigned int	pbEthRecentOutMulcastPktsHigh;   
	unsigned int	pbEthRecentOutMulcastPktsLow;   
	unsigned int	pbEthRecentOutBrdcastPktsHigh;   
	unsigned int	pbEthRecentOutBrdcastPktsLow;   
	unsigned int	pbEthRecentOutAllGoodPktsHigh;   
	unsigned int	pbEthRecentOutAllGoodPktsLow;   
	unsigned int	pbEthRecentOutAllGoodBytesHigh;   
	unsigned int	pbEthRecentOutAllGoodBytesLow;   
	unsigned int	pbEthRcntInAllBytesHigh;   
	unsigned int	pbEthRcntInAllBytesLow;   
	unsigned int	pbEthRcntInAllPktsHigh;   
	unsigned int	pbEthRcntInAllPktsLow;   
	unsigned int	pbEthRcntInAllGoodPktsHigh;   
	unsigned int	pbEthRcntInAllGoodPktsLow;   
	unsigned int	pbEthRcntInAllBadPktsHigh;   
	unsigned int	pbEthRcntInAllBadPktsLow;   
	unsigned int	pbEthRcntInUnicastPktsHigh;   
	unsigned int	pbEthRcntInUnicastPktsLow;   
	unsigned int	pbEthRcntInMulcastPktsHigh;   
	unsigned int	pbEthRcntInMulcastPktsLow;   
	unsigned int	pbEthRcntInBrdcastPktsHigh;   
	unsigned int	pbEthRcntInBrdcastPktsLow;   
	unsigned int	pbEthRcntInDropPktsHigh;   
	unsigned int	pbEthRcntInDropPktsLow;   
	unsigned int	pbEthRcntInUndersizeGoodPktsHigh;   
	unsigned int	pbEthRcntInUndersizeGoodPktsLow;   
	unsigned int	pbEthRcntInOversizeGoodPktsHigh;   
	unsigned int	pbEthRcntInOversizeGoodPktsLow;   
	unsigned int	pbEthRcntIn64PktsHigh;   
	unsigned int	pbEthRcntIn64PktsLow;   
	unsigned int	pbEthRcntIn65To127PktsHigh;   
	unsigned int	pbEthRcntIn65To127PktsLow;   
	unsigned int	pbEthRcntIn128To255PktsHigh;   
	unsigned int	pbEthRcntIn128To255PktsLow;   
	unsigned int	pbEthRcntIn256To511PktsHigh;   
	unsigned int	pbEthRcntIn256To511PktsLow;   
	unsigned int	pbEthRcntIn512To1023PktsHigh;   
	unsigned int	pbEthRcntIn512To1023PktsLow;   
	unsigned int	pbEthRcntIn1024To1518PktsHigh;   
	unsigned int	pbEthRcntIn1024To1518PktsLow;   
	unsigned int	pbEthRcntInPausePktsHigh;   
	unsigned int	pbEthRcntInPausePktsLow;   
	unsigned int	pbEthRcntInFragmentPktsHigh;   
	unsigned int	pbEthRcntInFragmentPktsLow;   
	unsigned int	pbEthRcntInJabberPktsHigh;   
	unsigned int	pbEthRcntInJabberPktsLow;   
	unsigned int	pbEthRcntInAlignmentErrorPktsHigh;   
	unsigned int	pbEthRcntInAlignmentErrorPktsLow;   
	unsigned int	pbEthRcntOutAllBytesHigh;   
	unsigned int	pbEthRcntOutAllBytesLow;   
	unsigned int	pbEthRcntOutAllPktsHigh;   
	unsigned int	pbEthRcntOutAllPktsLow;   
	unsigned int	pbEthRcntOutUnicastPktsHigh;   
	unsigned int	pbEthRcntOutUnicastPktsLow;   
	unsigned int	pbEthRcntOutMulcastPktsHigh;   
	unsigned int	pbEthRcntOutMulcastPktsLow;   
	unsigned int	pbEthRcntOutBrdcastPktsHigh;   
	unsigned int	pbEthRcntOutBrdcastPktsLow;   
	unsigned int	pbEthRcntOutGoodPausePktsHigh;   
	unsigned int	pbEthRcntOutGoodPausePktsLow;   
	unsigned int	pbEthRcntOutCollisionPktsHigh;   
	unsigned int	pbEthRcntOutCollisionPktsLow;   
}MIBpbEthRecentPMTable_t;


































































































 



 
 
extern MIBDid_t pbRprClientRecentPMTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                                                         
	int		rprIfIndex;                                                                                            
	PbPmTableType_Tval pbRprClientRecentTableType;                                                                 
	int		pbRprClientTableRecentTimesIndex;                                                                         
	char		pbRprClientRecentPmTimeEnd[16];   
	TruthValue_Tval pbRprClientRecentPmTimeSuspect;   
	unsigned int	pbRprClientRecentInAllFramesHigh;   
	unsigned int	pbRprClientRecentInAllFramesLow;   
	unsigned int	pbRprClientRecentOutAllFramesHigh;   
	unsigned int	pbRprClientRecentOutAllFramesLow;   
	unsigned int	pbRprClientRecentOutPassFramesHigh;   
	unsigned int	pbRprClientRecentOutPassFramesLow;   
	unsigned int	pbRprClientRecentOutDropFramesHigh;   
	unsigned int	pbRprClientRecentOutDropFramesLow;   
	unsigned int	pbRprClientRecentOutErrLenFramesHigh;   
	unsigned int	pbRprClientRecentOutErrLenFramesLow;   
	unsigned int	pbRprClientRecentOutErrCrcFramesHigh;   
	unsigned int	pbRprClientRecentOutErrCrcFramesLow;   
	unsigned int	pbRprClientRecentInUcastClassAFramesHigh;   
	unsigned int	pbRprClientRecentInUcastClassAFramesLow;   
	unsigned int	pbRprClientRecentInUcastClassAOctetsHigh;   
	unsigned int	pbRprClientRecentInUcastClassAOctetsLow;   
	unsigned int	pbRprClientRecentInUcastClassBCirFramesHigh;   
	unsigned int	pbRprClientRecentInUcastClassBCirFramesLow;   
	unsigned int	pbRprClientRecentInUcastClassBCirOctetsHigh;   
	unsigned int	pbRprClientRecentInUcastClassBCirOctetsLow;   
	unsigned int	pbRprClientRecentInUcastClassBEirFramesHigh;   
	unsigned int	pbRprClientRecentInUcastClassBEirFramesLow;   
	unsigned int	pbRprClientRecentInUcastClassBEirOctetsHigh;   
	unsigned int	pbRprClientRecentInUcastClassBEirOctetsLow;   
	unsigned int	pbRprClientRecentInUcastClassCFramesHigh;   
	unsigned int	pbRprClientRecentInUcastClassCFramesLow;   
	unsigned int	pbRprClientRecentInUcastClassCOctetsHigh;   
	unsigned int	pbRprClientRecentInUcastClassCOctetsLow;   
	unsigned int	pbRprClientRecentInMcastClassAFramesHigh;   
	unsigned int	pbRprClientRecentInMcastClassAFramesLow;   
	unsigned int	pbRprClientRecentInMcastClassAOctetsHigh;   
	unsigned int	pbRprClientRecentInMcastClassAOctetsLow;   
	unsigned int	pbRprClientRecentInMcastClassBCirFramesHigh;   
	unsigned int	pbRprClientRecentInMcastClassBCirFramesLow;   
	unsigned int	pbRprClientRecentInMcastClassBCirOctetsHigh;   
	unsigned int	pbRprClientRecentInMcastClassBCirOctetsLow;   
	unsigned int	pbRprClientRecentInMcastClassBEirFramesHigh;   
	unsigned int	pbRprClientRecentInMcastClassBEirFramesLow;   
	unsigned int	pbRprClientRecentInMcastClassBEirOctetsHigh;   
	unsigned int	pbRprClientRecentInMcastClassBEirOctetsLow;   
	unsigned int	pbRprClientRecentInMcastClassCFramesHigh;   
	unsigned int	pbRprClientRecentInMcastClassCFramesLow;   
	unsigned int	pbRprClientRecentInMcastClassCOctetsHigh;   
	unsigned int	pbRprClientRecentInMcastClassCOctetsLow;   
	unsigned int	pbRprClientRecentOutUcastClassAFramesHigh;   
	unsigned int	pbRprClientRecentOutUcastClassAFramesLow;   
	unsigned int	pbRprClientRecentOutUcastClassAOctetsHigh;   
	unsigned int	pbRprClientRecentOutUcastClassAOctetsLow;   
	unsigned int	pbRprClientRecentOutUcastClassBCirFramesHigh;   
	unsigned int	pbRprClientRecentOutUcastClassBCirFramesLow;   
	unsigned int	pbRprClientRecentOutUcastClassBCirOctetsHigh;   
	unsigned int	pbRprClientRecentOutUcastClassBCirOctetsLow;   
	unsigned int	pbRprClientRecentOutUcastClassBEirFramesHigh;   
	unsigned int	pbRprClientRecentOutUcastClassBEirFramesLow;   
	unsigned int	pbRprClientRecentOutUcastClassBEirOctetsHigh;   
	unsigned int	pbRprClientRecentOutUcastClassBEirOctetsLow;   
	unsigned int	pbRprClientRecentOutUcastClassCFramesHigh;   
	unsigned int	pbRprClientRecentOutUcastClassCFramesLow;   
	unsigned int	pbRprClientRecentOutUcastClassCOctetsHigh;   
	unsigned int	pbRprClientRecentOutUcastClassCOctetsLow;   
	unsigned int	pbRprClientRecentOutMcastClassAFramesHigh;   
	unsigned int	pbRprClientRecentOutMcastClassAFramesLow;   
	unsigned int	pbRprClientRecentOutMcastClassAOctetsHigh;   
	unsigned int	pbRprClientRecentOutMcastClassAOctetsLow;   
	unsigned int	pbRprClientRecentOutMcastClassBCirFramesHigh;   
	unsigned int	pbRprClientRecentOutMcastClassBCirFramesLow;   
	unsigned int	pbRprClientRecentOutMcastClassBCirOctetsHigh;   
	unsigned int	pbRprClientRecentOutMcastClassBCirOctetsLow;   
	unsigned int	pbRprClientRecentOutMcastClassBEirFramesHigh;   
	unsigned int	pbRprClientRecentOutMcastClassBEirFramesLow;   
	unsigned int	pbRprClientRecentOutMcastClassBEirOctetsHigh;   
	unsigned int	pbRprClientRecentOutMcastClassBEirOctetsLow;   
	unsigned int	pbRprClientRecentOutMcastClassCFramesHigh;   
	unsigned int	pbRprClientRecentOutMcastClassCFramesLow;   
	unsigned int	pbRprClientRecentOutMcastClassCOctetsHigh;   
	unsigned int	pbRprClientRecentOutMcastClassCOctetsLow;   
}MIBpbRprClientRecentPMTable_t;

























































































 



 
 
extern MIBDid_t pbRprSpanRecentPMTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                                                     
	int		rprIfIndex;                                                                                        
	RprSpan_Tval rprSpanId;                                                                                 
	PbPmTableType_Tval pbRprSpanRecentTableType;                                                               
	int		pbRprSpanTableRecentTimesIndex;                                                                       
	char		pbRprSpanRecentPmTimeEnd[16];   
	TruthValue_Tval pbRprSpanRecentPmTimeSuspect;   
	unsigned int	pbRprSpanRecentInAllFramesHigh;   
	unsigned int	pbRprSpanRecentInAllFramesLow;   
	unsigned int	pbRprSpanRecentInWrapFramesHigh;   
	unsigned int	pbRprSpanRecentInWrapFramesLow;   
	unsigned int	pbRprSpanRecentInDataFramesHigh;   
	unsigned int	pbRprSpanRecentInDataFramesLow;   
	unsigned int	pbRprSpanRecentInCtrlFramesHigh;   
	unsigned int	pbRprSpanRecentInCtrlFramesLow;   
	unsigned int	pbRprSpanRecentInFaFramesHigh;   
	unsigned int	pbRprSpanRecentInFaFramesLow;   
	unsigned int	pbRprSpanRecentOutAllFramesHigh;   
	unsigned int	pbRprSpanRecentOutAllFramesLow;   
	unsigned int	pbRprSpanRecentOutAddFramesHigh;   
	unsigned int	pbRprSpanRecentOutAddFramesLow;   
	unsigned int	pbRprSpanRecentOutTransitFramesHigh;   
	unsigned int	pbRprSpanRecentOutTransitFramesLow;   
	unsigned int	pbRprSpanRecentOutWrapFramesHigh;   
	unsigned int	pbRprSpanRecentOutWrapFramesLow;   
	unsigned int	pbRprSpanRecentOutTpFramesHigh;   
	unsigned int	pbRprSpanRecentOutTpFramesLow;   
	unsigned int	pbRprSpanRecentOutFaFramesHigh;   
	unsigned int	pbRprSpanRecentOutFaFramesLow;   
	unsigned int	pbRprSpanRecentOutOamFramesHigh;   
	unsigned int	pbRprSpanRecentOutOamFramesLow;   
	unsigned int	pbRprSpanRecentErrHecFramesHigh;   
	unsigned int	pbRprSpanRecentErrHecFramesLow;   
	unsigned int	pbRprSpanRecentErrParityFramesHigh;   
	unsigned int	pbRprSpanRecentErrParityFramesLow;   
	unsigned int	pbRprSpanRecentErrFcsFramesHigh;   
	unsigned int	pbRprSpanRecentErrFcsFramesLow;   
	unsigned int	pbRprSpanRecentErrEdgeFramesHigh;   
	unsigned int	pbRprSpanRecentErrEdgeFramesLow;   
	unsigned int	pbRprSpanRecentErrSelfSourceFramesHigh;   
	unsigned int	pbRprSpanRecentErrSelfSourceFramesLow;   
	unsigned int	pbRprSpanRecentInUcastClassAFramesHigh;   
	unsigned int	pbRprSpanRecentInUcastClassAFramesLow;   
	unsigned int	pbRprSpanRecentInUcastClassAOctetsHigh;   
	unsigned int	pbRprSpanRecentInUcastClassAOctetsLow;   
	unsigned int	pbRprSpanRecentInUcastClassBCirFramesHigh;   
	unsigned int	pbRprSpanRecentInUcastClassBCirFramesLow;   
	unsigned int	pbRprSpanRecentInUcastClassBCirOctetsHigh;   
	unsigned int	pbRprSpanRecentInUcastClassBCirOctetsLow;   
	unsigned int	pbRprSpanRecentInUcastClassBEirFramesHigh;   
	unsigned int	pbRprSpanRecentInUcastClassBEirFramesLow;   
	unsigned int	pbRprSpanRecentInUcastClassBEirOctetsHigh;   
	unsigned int	pbRprSpanRecentInUcastClassBEirOctetsLow;   
	unsigned int	pbRprSpanRecentInUcastClassCFramesHigh;   
	unsigned int	pbRprSpanRecentInUcastClassCFramesLow;   
	unsigned int	pbRprSpanRecentInUcastClassCOctetsHigh;   
	unsigned int	pbRprSpanRecentInUcastClassCOctetsLow;   
	unsigned int	pbRprSpanRecentInMcastClassAFramesHigh;   
	unsigned int	pbRprSpanRecentInMcastClassAFramesLow;   
	unsigned int	pbRprSpanRecentInMcastClassAOctetsHigh;   
	unsigned int	pbRprSpanRecentInMcastClassAOctetsLow;   
	unsigned int	pbRprSpanRecentInMcastClassBCirFramesHigh;   
	unsigned int	pbRprSpanRecentInMcastClassBCirFramesLow;   
	unsigned int	pbRprSpanRecentInMcastClassBCirOctetsHigh;   
	unsigned int	pbRprSpanRecentInMcastClassBCirOctetsLow;   
	unsigned int	pbRprSpanRecentInMcastClassBEirFramesHigh;   
	unsigned int	pbRprSpanRecentInMcastClassBEirFramesLow;   
	unsigned int	pbRprSpanRecentInMcastClassBEirOctetsHigh;   
	unsigned int	pbRprSpanRecentInMcastClassBEirOctetsLow;   
	unsigned int	pbRprSpanRecentInMcastClassCFramesHigh;   
	unsigned int	pbRprSpanRecentInMcastClassCFramesLow;   
	unsigned int	pbRprSpanRecentInMcastClassCOctetsHigh;   
	unsigned int	pbRprSpanRecentInMcastClassCOctetsLow;   
	unsigned int	pbRprSpanRecentOutUcastClassAFramesHigh;   
	unsigned int	pbRprSpanRecentOutUcastClassAFramesLow;   
	unsigned int	pbRprSpanRecentOutUcastClassAOctetsHigh;   
	unsigned int	pbRprSpanRecentOutUcastClassAOctetsLow;   
	unsigned int	pbRprSpanRecentOutUcastClassBCirFramesHigh;   
	unsigned int	pbRprSpanRecentOutUcastClassBCirFramesLow;   
	unsigned int	pbRprSpanRecentOutUcastClassBCirOctetsHigh;   
	unsigned int	pbRprSpanRecentOutUcastClassBCirOctetsLow;   
	unsigned int	pbRprSpanRecentOutUcastClassBEirFramesHigh;   
	unsigned int	pbRprSpanRecentOutUcastClassBEirFramesLow;   
	unsigned int	pbRprSpanRecentOutUcastClassBEirOctetsHigh;   
	unsigned int	pbRprSpanRecentOutUcastClassBEirOctetsLow;   
	unsigned int	pbRprSpanRecentOutUcastClassCFramesHigh;   
	unsigned int	pbRprSpanRecentOutUcastClassCFramesLow;   
	unsigned int	pbRprSpanRecentOutUcastClassCOctetsHigh;   
	unsigned int	pbRprSpanRecentOutUcastClassCOctetsLow;   
	unsigned int	pbRprSpanRecentOutMcastClassAFramesHigh;   
	unsigned int	pbRprSpanRecentOutMcastClassAFramesLow;   
	unsigned int	pbRprSpanRecentOutMcastClassAOctetsHigh;   
	unsigned int	pbRprSpanRecentOutMcastClassAOctetsLow;   
	unsigned int	pbRprSpanRecentOutMcastClassBCirFramesHigh;   
	unsigned int	pbRprSpanRecentOutMcastClassBCirFramesLow;   
	unsigned int	pbRprSpanRecentOutMcastClassBCirOctetsHigh;   
	unsigned int	pbRprSpanRecentOutMcastClassBCirOctetsLow;   
	unsigned int	pbRprSpanRecentOutMcastClassBEirFramesHigh;   
	unsigned int	pbRprSpanRecentOutMcastClassBEirFramesLow;   
	unsigned int	pbRprSpanRecentOutMcastClassBEirOctetsHigh;   
	unsigned int	pbRprSpanRecentOutMcastClassBEirOctetsLow;   
	unsigned int	pbRprSpanRecentOutMcastClassCFramesHigh;   
	unsigned int	pbRprSpanRecentOutMcastClassCFramesLow;   
	unsigned int	pbRprSpanRecentOutMcastClassCOctetsHigh;   
	unsigned int	pbRprSpanRecentOutMcastClassCOctetsLow;   
}MIBpbRprSpanRecentPMTable_t;
















































































































 



 
 
extern MIBDid_t pbPdhRecentSlipTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                             
	PbPortType_Tval pbPortType;                                     
	int		pbPortNo;                                                  
	PbPmTableType_Tval pbRecentSlipTableType;                          
	int		pbRecentSlipTimesIndex;                                       
	unsigned int	pbRecentPSlipCounter;   
	unsigned int	pbRecentNSlipCounter;   
	char		pbSlipTimeEnd[16];   
	TruthValue_Tval pbRecentSlipSuspect;   
}MIBpbPdhRecentSlipTable_t;
















 



 
 
extern MIBDid_t pbxSecEthRecentPMTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                                   
	int		pbPortNo;                                                                        
	EthPortClass_Tval pbxSecEthRecentPmPortType;                                             
	int		pbxSecEthTimesIndex;                                                                
	TruthValue_Tval pbxSecEthRecentPmStartFlag;   
	unsigned int	pbxSecEthRecentInUnicastPkts;   
	unsigned int	pbxSecEthRecentInMulcastPkts;   
	unsigned int	pbxSecEthRecentInBrdcastPkts;   
	unsigned int	pbxSecEthRecentInAllBadPkts;   
	unsigned int	pbxSecEthRecentInAllBadBytes;   
	unsigned int	pbxSecEthRecentInAllGoodPkts;   
	unsigned int	pbxSecEthRecentInAllGoodBytes;   
	unsigned int	pbxSecEthRecentInOverSizePkts;   
	unsigned int	pbxSecEthRecentInUnderSizePkts;   
	unsigned int	pbxSecEthRecentInCRCErrPkts;   
	unsigned int	pbxSecEthRecentOutUnicastPkts;   
	unsigned int	pbxSecEthRecentOutMulcastPkts;   
	unsigned int	pbxSecEthRecentOutBrdcastPkts;   
	unsigned int	pbxSecEthRecentOutAllGoodPkts;   
	unsigned int	pbxSecEthRecentOutAllGoodBytes;   
	int		pbxSecEthFrmStartIndex;   
	unsigned int	pbxSecEthRcntInAllBytes;   
	unsigned int	pbxSecEthRcntInAllPkts;   
	unsigned int	pbxSecEthRcntInAllGoodPkts;   
	unsigned int	pbxSecEthRcntInAllBadPkts;   
	unsigned int	pbxSecEthRcntInUnicastPkts;   
	unsigned int	pbxSecEthRcntInMulcastPkts;   
	unsigned int	pbxSecEthRcntInBrdcastPkts;   
	unsigned int	pbxSecEthRcntInDropPkts;   
	unsigned int	pbxSecEthRcntInUndersizeGoodPkts;   
	unsigned int	pbxSecEthRcntInOversizeGoodPkts;   
	unsigned int	pbxSecEthRcntIn64Pkts;   
	unsigned int	pbxSecEthRcntIn65To127Pkts;   
	unsigned int	pbxSecEthRcntIn128To255Pkts;   
	unsigned int	pbxSecEthRcntIn256To511Pkts;   
	unsigned int	pbxSecEthRcntIn512To1023Pkts;   
	unsigned int	pbxSecEthRcntIn1024To1518Pkts;   
	unsigned int	pbxSecEthRcntInPausePkts;   
	unsigned int	pbxSecEthRcntInFragmentPkts;   
	unsigned int	pbxSecEthRcntInJabberPkts;   
	unsigned int	pbxSecEthRcntInAlignmentErrorPkts;   
	unsigned int	pbxSecEthRcntOutAllBytes;   
	unsigned int	pbxSecEthRcntOutAllPkts;   
	unsigned int	pbxSecEthRcntOutUnicastPkts;   
	unsigned int	pbxSecEthRcntOutMulcastPkts;   
	unsigned int	pbxSecEthRcntOutBrdcastPkts;   
	unsigned int	pbxSecEthRcntOutGoodPausePkts;   
	unsigned int	pbxSecEthRcntOutCollisionPkts;   
}MIBpbxSecEthRecentPMTable_t;























































 



 
 
extern MIBDid_t pbPdhRecentPMTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                 
	PbPortType_Tval pbPortType;                                         
	int		pbPortNo;                                                      
	PbPmTableType_Tval pbPdhRecentTableType;                               
	int		pbPdhRecentTimesIndex;                                            
	unsigned int	pbPdhRecentEsPmCounter;   
	unsigned int	pbPdhRecentBbePmCounter;   
	unsigned int	pbPdhRecentSesPmCounter;   
	unsigned int	pbPdhRecentUasPmCounter;   
	unsigned int	pbPdhRecentCsesPmCounter;   
	unsigned int	pbPdhRecentFcPmCounter;   
	char		pbPdhRecentPmTimeEnd[16];   
	TruthValue_Tval pbPdhSuspect;   
	TruthValue_Tval pbPdhComplete;   
}MIBpbPdhRecentPMTable_t;





















 



 
 
extern MIBDid_t pbEthVlanRecentPMTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                                       
	int		pbPortNo;                                                                            
	PbPmTableType_Tval pbEthVlanRecentTableType;                                                 
	EthPortClass_Tval pbEthPmPortType;                                                        
	int		pbEthVlanNo;                                                                         
	int		pbEthVlanRecentTimesIndex;                                                              
	char		pbEthVlanRecentPmTimeEnd[16];   
	TruthValue_Tval pbEthVlanRecentPmTimeSuspect;   
	unsigned int	pbEthVlanRecentInPktsHigh;   
	unsigned int	pbEthVlanRecentInPktsLow;   
	unsigned int	pbEthVlanRecentInBytesHigh;   
	unsigned int	pbEthVlanRecentInBytesLow;   
	unsigned int	pbEthVlanRecentDropPktsHigh;   
	unsigned int	pbEthVlanRecentDropPktsLow;   
	unsigned int	pbEthVlanRecentRcvUnicastFramesHigh;   
	unsigned int	pbEthVlanRecentRcvUnicastFramesLow;   
	unsigned int	pbEthVlanRecentRcvTotalFramesHigh;   
	unsigned int	pbEthVlanRecentRcvTotalFramesLow;   
	unsigned int	pbEthVlanRecentRcvUnicastBytesHigh;   
	unsigned int	pbEthVlanRecentRcvUnicastBytesLow;   
	unsigned int	pbEthVlanRecentRcvTotalBytesHigh;   
	unsigned int	pbEthVlanRecentRcvTotalBytesLow;   
}MIBpbEthVlanRecentPMTable_t;





























 



 
 
extern MIBDid_t pbxSecEthVlanRecentPMTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                                       
	int		pbPortNo;                                                                            
	EthPortClass_Tval pbEthPmPortType;                                                        
	int		pbEthVlanNo;                                                                         
	int		pbxSecEthVlanTimesIndex;                                                                
	TruthValue_Tval pbxSecEthVlanRecentPmStartFlag;   
	unsigned int	pbxSecEthVlanRecentInPkts;   
	unsigned int	pbxSecEthVlanRecentInBytes;   
	unsigned int	pbxSecEthVlanRecentDropPkts;   
	unsigned int	pbxSecEthVlanRecentRcvUnicastFrames;   
	unsigned int	pbxSecEthVlanRecentRcvTotalFrames;   
	unsigned int	pbxSecEthVlanRecentRcvUnicastBytes;   
	unsigned int	pbxSecEthVlanRecentRcvTotalBytes;   
	int		pbxSecEthVlanFrmStartIndex;   
}MIBpbxSecEthVlanRecentPMTable_t;





















 



 
 
extern MIBDid_t pbFecRecentPMTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                       
	PbPortType_Tval pbPortType;                                               
	int		pbPortNo;                                                            
	PbPmTableType_Tval pbFecRecentTableType;                                     
	int		pbFecRecentTimesIndex;                                                  
	unsigned int	pbFecRecentTecPmCounterHigh;   
	unsigned int	pbFecRecentTecPmCounterLow;   
	unsigned int	pbFecRecentZecPmCounterHigh;   
	unsigned int	pbFecRecentZecPmCounterLow;   
	unsigned int	pbFecRecentOecPmCounterHigh;   
	unsigned int	pbFecRecentOecPmCounterLow;   
	unsigned int	pbFecRecentFcPmCounter;   
	char		pbFecRecentPmTimeEnd[16];   
	TruthValue_Tval pbFecSuspect;   
	TruthValue_Tval pbFecComplete;   
	unsigned int	pbFecRecUncorrectedBlkHigh;
	unsigned int	pbFecRecUncorrectedBlkLow;
}MIBpbFecRecentPMTable_t;
























 



 
 
extern MIBDid_t pbOtuRecentPMTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                   
	PbPortType_Tval pbPortType;                                           
	int		pbPortNo;                                                        
	unsigned int	pbOtuRecentChannelID;                                    
	unsigned int	pbOtuRecentSegmentNum;                                   
	PbPmTableType_Tval pbOtuRecentTableType;                              
	int		pbOtuRecentTimesIndex;                                           
	unsigned int	pbOtuRecentEsPmCounter;
	unsigned int	pbOtuRecentBbePmCounter;
	unsigned int	pbOtuRecentSesPmCounter;
	unsigned int	pbOtuRecentUasPmCounter;
	unsigned int	pbOtuRecentCsesPmCounter;
	unsigned int	pbOtuRecentFcPmCounter;
	unsigned int	pbOtuRecentOfsPmCounter;
	unsigned int	pbOtuRecentIaesPmCounter;
	unsigned int	pbOtuRecentBiaesPmCounter;
	char		pbOtuRecentPmTimeEnd[16];
	TruthValue_Tval pbOtuSuspect;
	TruthValue_Tval pbOtuComplete;
}MIBpbOtuRecentPMTable_t;


























 



 
 
extern MIBDid_t pbSdhUapPMTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;               
	PbPortType_Tval pbPortType;                       
	int		pbPortNo;                                    
	PbTPType_Tval pbTpType;                           
	int		pbTpIndex;                                   
	PbPmUapType_Tval pbPmUapType;                        
	TruthValue_Tval pbIsAtUap;   
	unsigned int	pbUAPCounter;   
	char		pbUapTimeStart[16];   
	unsigned int	pbUapTimeElapse;   
	TruthValue_Tval pbUAPReset;   
}MIBpbSdhUapPMTable_t;


















 



 
 
extern MIBDid_t pbPdhUapPMTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                     
	PbPortType_Tval pbPortType;                             
	int		pbPortNo;                                          
	PbPmUapType_Tval pbPdhUapType;                             
	TruthValue_Tval pbPdhIsAtUap;   
	unsigned int	pbPdhUAPCounter;   
	char		pbPdhUapTimeStart[16];   
	unsigned int	pbPdhUapTimeElapse;   
	TruthValue_Tval pbPdhUAPReset;   
}MIBpbPdhUapPMTable_t;
















 



 
 
extern MIBDid_t pbOtuUapPMTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                     
	PbPortType_Tval pbPortType;                             
	int		pbPortNo;                                          
	unsigned int	pbUapChannelID;                            
	unsigned int	pbUapSegmentNum;                           
	PbPmUapType_Tval pbOtuUapType;                          
	TruthValue_Tval pbOtuIsAtUap;
	unsigned int	pbOtuUAPCounter;
	char		pbOtuUapTimeStart[16];
	unsigned int	pbOtuUapTimeElapse;
	TruthValue_Tval pbOtuUAPReset;
}MIBpbOtuUapPMTable_t;


















 



 
 
extern MIBDid_t pbSdhRecentUapPMTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                         
	PbPortType_Tval pbPortType;                                 
	int		pbPortNo;                                              
	PbTPType_Tval pbTpType;                                     
	int		pbTpIndex;                                             
	PbPmUapType_Tval pbPmRecUapType;                               
	int		pbUapTimesIndex;                                          
	char		pbRecentUapTimeStart[16];   
	char		pbRecentUapTimeEnd[16];   
}MIBpbSdhRecentUapPMTable_t;
















 



 
 
extern MIBDid_t pbPdhRecentUapPMTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                               
	PbPortType_Tval pbPortType;                                       
	int		pbPortNo;                                                    
	PbPmUapType_Tval pbPdhRecUapType;                                    
	int		pbPdhUapTimesIndex;                                             
	char		pbPdhRecentUapTimeStart[16];   
	char		pbPdhRecentUapTimeEnd[16];   
}MIBpbPdhRecentUapPMTable_t;














 



 
 
extern MIBDid_t pbOtuRecentUapPMTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                               
	PbPortType_Tval pbPortType;                                       
	int		pbPortNo;                                                    
	unsigned int	pbOtuRecUapChannelID;                                
	unsigned int	pbOtuRecUapSegmentNum;                               
	PbPmUapType_Tval pbOtuRecUapType;                                 
	int		pbOtuUapTimesIndex;                                          
	char		pbOtuRecentUapTimeStart[16];
	char		pbOtuRecentUapTimeEnd[16];
}MIBpbOtuRecentUapPMTable_t;
















 



 
 
extern MIBDid_t pbSdhMostRecentIndexTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                     
	PbPortType_Tval pbPortType;                                             
	int		pbPortNo;                                                          
	PbTPType_Tval pbTpType;                                                 
	int		pbTpIndex;                                                         
	PbPmUapType_Tval pbPmRecIntervalTblType;                                   
	int		pbRecentIntervalTblMRI;   
	TruthValue_Tval pbRecentIntervalUpMaxIndex;   
	int		pbRecentUapTblMRI;   
	TruthValue_Tval pbRecentUapUpMaxIndex;   
}MIBpbSdhMostRecentIndexTable_t;

















 



 
 
extern MIBDid_t pbEthMostRecentIndexTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                           
	int		pbPortNo;                                                                
	PbPmTableType_Tval pbEthIndexTableType;                                          
	EthPortClass_Tval pbEthIndexPmPortType;                                          
	int		pbEthRecentIntervalTblMRI;   
	TruthValue_Tval pbEthRecentIntervalUpMaxIndex;   
}MIBpbEthMostRecentIndexTable_t;













 



 
 
extern MIBDid_t pbRprClientMostRecentIndexTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                                       
	int		rprIfIndex;                                                                             
	PbPmTableType_Tval pbRprClientIndexTableType;                                                
	int		pbRprClientRecentIntervalTblMRI;   
	TruthValue_Tval pbRprClientRecentIntervalUpMaxIndex;   
}MIBpbRprClientMostRecentIndexTable_t;












 



 
 
extern MIBDid_t pbRprSpanMostRecentIndexTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                                   
	int		rprIfIndex;                                                                      
	RprSpan_Tval rprSpanId;                                                                  
	PbPmTableType_Tval pbRprSpanIndexTableType;                                              
	int		pbRprSpanRecentIntervalTblMRI;   
	TruthValue_Tval pbRprSpanRecentIntervalUpMaxIndex;   
}MIBpbRprSpanMostRecentIndexTable_t;













 



 
 
extern MIBDid_t pbSlipMostRecentIndexTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                     
	PbPortType_Tval pbPortType;                             
	int		pbPortNo;                                          
	int		pbSlipRecentTblMRI;   
}MIBpbSlipMostRecentIndexTable_t;











 



 
 
extern MIBDid_t pbxSecEthIndexTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                                   
	int		pbPortNo;                                                                        
	EthPortClass_Tval pbxSecEthIndexPortType;                                                
	int		pbxSecEthRecentIntervalTblMRI;   
	TruthValue_Tval pbxSecEthRecentIntervalUpMaxIndex;   
	int		pbxSecEthRecentIndex;   
}MIBpbxSecEthIndexTable_t;













 



 
 
extern MIBDid_t pbPdhMostRecentIndexTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                           
	PbPortType_Tval pbPortType;                                                   
	int		pbPortNo;                                                                
	PbPmUapType_Tval pbPdhRecIntervalTblType;                                        
	int		pbPdhRecentIntervalTblMRI;   
	TruthValue_Tval pbPdhRecentIntervalUpMaxIndex;   
	int		pbPdhRecentUapTblMRI;   
	TruthValue_Tval pbPdhRecentUapUpMaxIndex;   
}MIBpbPdhMostRecentIndexTable_t;















 



 
 
extern MIBDid_t pbEthVlanMostRecentIndexTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                                   
	int		pbPortNo;                                                                        
	PbPmTableType_Tval pbEthVlanIndexTableType;                                              
	EthPortClass_Tval pbEthPmPortType;                                                       
	int		pbEthVlanNo;                                                                        
	int		pbEthVlanRecentIntervalTblMRI;   
	TruthValue_Tval pbEthVlanRecentIntervalUpMaxIndex;   
}MIBpbEthVlanMostRecentIndexTable_t;














 



 
 
extern MIBDid_t pbxSecEthVlanIndexTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                                           
	int		pbPortNo;                                                                                
	EthPortClass_Tval pbEthPmPortType;                                                            
	int		pbEthVlanNo;                                                                             
	int		pbxSecEthVlanRecentIntervalTblMRI;   
	TruthValue_Tval pbxSecEthVlanRecentIntervalUpMaxIndex;   
	int		pbxSecEthVlanRecentIndex;   
}MIBpbxSecEthVlanIndexTable_t;














 



 
 
extern MIBDid_t pbFecMostRecentIndexTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                           
	PbPortType_Tval pbPortType;                                                   
	int		pbPortNo;                                                                
	PbPmUapType_Tval pbFecRecIntervalTblType;                                        
	int		pbFecRecentIntervalTblMRI;   
	TruthValue_Tval pbFecRecentIntervalUpMaxIndex;   
}MIBpbFecMostRecentIndexTable_t;













 



 
 
extern MIBDid_t pbOtuMostRecentIndexTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                           
	PbPortType_Tval pbPortType;                                                   
	int		pbPortNo;                                                                
	unsigned int	pbOtuRecChannelID;                                               
	unsigned int	pbOtuRecSegmentNum;                                              
	PbPmUapType_Tval pbOtuRecIntervalTblType;                                     
	int		pbOtuRecentIntervalTblMRI;
	TruthValue_Tval pbOtuRecentIntervalUpMaxIndex;
	int		pbOtuRecentUapTblMRI;
	TruthValue_Tval pbOtuRecentUapUpMaxIndex;
}MIBpbOtuMostRecentIndexTable_t;

















 



 
 
extern MIBDid_t pbSdhPMUpLoadTable_Did;

   
typedef struct
{
	unsigned int	pbSdhFtpCmndHostIP[TTT];                                 
	char		pbSdhFtpCmndPath[64];   
	char		pbSdhFtpFileName[13];   
	char		pbSdhFtpCmndUsername[32];   
	char		pbSdhFtpCmndPassword[32];   
	SdhFtpCmndLastState_Tval pbSdhFtpCmndLastState;   
	unsigned int	pbAdjustTimeDircetion;   
	unsigned int	pbAdjustTimeDays;   
	unsigned int	pbAdjustTimeHours;   
	unsigned int	pbAdjustTimeMins;   
	unsigned int	pbAdjustTimeSecs;   
	RowStatus_Tval pbUpLoadStatus;   
}MIBpbSdhPMUpLoadTable_t;



















 



 
 
extern MIBDid_t pbxSecEthUploadTable_Did;

   
typedef struct
{
	unsigned int	pbxSecEthFtpHostIP[TTT];                               
	char		pbxSecEthFtpFileName[20];   
	char		pbxSecEthFtpUsername[32];   
	char		pbxSecEthFtpPassword[32];   
}MIBpbxSecEthUploadTable_t;











 



 
extern MIBDid_t pbSonetSDHPMModule_Did;

   







 




 



 
 
extern MIBDid_t pbActiveAlarmTable_Did;

   
typedef struct
{
	unsigned int	pbActiveAlarmIndex[TTT];                                             
	char		pbActiveAlarmCode[255];   
	AlarmSeverity_Tval pbActiveAlarmSeverity;   
	char		pbActiveAlarmSource[255];   
	DateTime	pbActiveAlarmDTS;   
	DateTime	pbActiveAlarmClearDTS;   
	PbSlotNumberType_Tval pbActiveAlarmSlotNum;   
	int		pbActiveAlarmPortNum;   
	PbPortType_Tval pbActiveAlarmPortType;   
	char		pbActiveAlarmDesc[255];   
	AlarmTypeID_Tval pbActiveAlarmTypeID;   
	AlarmCategory_Tval pbActiveAlarmCategory;   
	PbTPType_Tval pbActiveAlarmPathType;   
	int		pbActiveAlarmSeqNum;   
	PbYesNo_Tval pbActiveAlarmAcknowledge;   
	AlarmState_Tval pbActiveAlarmState;   
	PbBoardStyle_Tval pbActiveAlarmBoardStyle;   
	PbPortType_Tval pbActiveAlarmActualPortType;   
}MIBpbActiveAlarmTable_t;

























 



 
 
extern MIBDid_t pbAlarmTypeCfgTable_Did;

   
typedef struct
{
	AlarmTypeID_Tval[TTT] pbAlarmTypeID;                              
	char		pbAlarmTypeCode[255];   
	char		pbAlarmTypeDesc[255];   
	AlarmCategory_Tval pbAlarmTypeCategory;   
	AlarmSeverity_Tval pbAlarmTypeSeverity;   
	TruthValue_Tval pbAlarmTypeInhibit;
	TruthValue_Tval pbAlarmTypeMDO1;   
	TruthValue_Tval pbAlarmTypeMDO2;   
	int		pbAlarmTypeTrapID;   
	TruthValue_Tval pbAlarmTypeMDO3;   
	TruthValue_Tval pbAlarmTypeMDO4;   
	PbAlmClassType_Tval pbAlmClassID;   
	TruthValue_Tval pbAlarmTypeMDO5;
	TruthValue_Tval pbAlarmTypeMDO6;
	TruthValue_Tval pbAlarmTypeMDO7;
	TruthValue_Tval pbAlarmTypeMDO8;
}MIBpbAlarmTypeCfgTable_t;























 



 
 
extern MIBDid_t pbCurrentEventsTable_Did;

   
typedef struct
{
	int		pbCurrentEventIndex[TTT];                                          
	EventTypeID_Tval pbCurrentEventID;   
	DateTime	pbCurrentEventDTS;   
	char		pbCurrentEventName[255];   
	EventCategory_Tval pbCurrentEventCategory;   
	char		pbCurrentEventDetails[255];   
}MIBpbCurrentEventsTable_t;













 



 
 
extern MIBDid_t pbEventTypeCfgTable_Did;

   
typedef struct
{
	EventTypeID_Tval[TTT] pbEventTypeID;                              
	EventCategory_Tval pbEventTypeCategory;   
	char		pbEventTypeName[255];   
	TruthValue_Tval pbEventTypeSendTrap;   
}MIBpbEventTypeCfgTable_t;











 



 
extern MIBDid_t pbLogSizeGroup_Did;

   
typedef struct
{
	int		pbAlarmLogSize[TTT];
	int		pbEventLogSize;
}MIBpbLogSizeGroup_t;







 



 
extern MIBDid_t alarmPersistentTime_Did;

   
typedef struct
{
	int		alarmDetectionPersistentTime[TTT];   
	int		alarmClearingPersistentTime;   
}MIBalarmPersistentTime_t;







 



 
extern MIBDid_t logPolicyGroup_Did;

   
typedef enum {
	eventLogPolicy_fifo[TTT]=1,
	eventLogPolicy_rejectNewEvent=2
} eventLogPolicy_Tval;

typedef struct
{
	eventLogPolicy_Tval[TTT] eventLogPolicy;   
}MIBlogPolicyGroup_t;






 



 
extern MIBDid_t pbAlarmStatGroup_Did;

   
typedef struct
{
	int		pbNumberOfCriticalAlarms[TTT];   
	int		pbNumberOfMajorAlarms;   
	int		pbNumberOfMinorAlarms;   
	int		pbNumberOfWarningAlarms;   
	int		pbNumberOfIndeterminateAlarms;   
	int		pbNumberOfEvents;   
}MIBpbAlarmStatGroup_t;











 



 
extern MIBDid_t pbLogClearGroup_Did;

   
typedef struct
{
	TruthValue_Tval[TTT] pbClearAlarmLog;   
	TruthValue_Tval pbClearEventsLog;   
}MIBpbLogClearGroup_t;







 



 
extern MIBDid_t pbEventsModule_Did;

   







 




 



 
 
extern MIBDid_t pbSdhXcTable_Did;

   
typedef struct
{
	PbXcCapacity_Tval[TTT] pbXConConnectCapacity;                                         
	PbSlotNumberType_Tval pbXConConnectSrcSlot;                                      
	int		pbXConConnectSrcPort;                                                       
	PbPortType_Tval pbXConConnectSrcPortType;                                     
	int		pbXConConnectSource;                                                        
	PbSlotNumberType_Tval pbXConConnectDstSlot;                                      
	int		pbXConConnectDstPort;                                                       
	PbPortType_Tval pbXConConnectDstPortType;                                     
	int		pbXConConnectDestination;                                                   
	int		pbXConConnectId;   
	char		pbXConConnectCircuitId[64];   
	PbXcStatus_Tval pbXConConnectStatus;   
	PbXcFailReason_Tval pbXConConnectReason;   
	PbXcType_Tval pbXConConnectType;   
	PbCircuitDirection_Tval pbXConConnectCircuitDirection;   
	PbXcAction_Tval pbXConConnectAction;   
	PbXcFrom_Tval pbXConFrom;   
	RowStatus_Tval pbXConRowStatus;   
	char		pbXConConnectReqNo[40];   
	int		pbXCGmplsVcNumber;   
	char		pbXCGmplsCallName[255];   
	PbGmplsCcDirection_Tval pbGmplsCcDirection;   
}MIBpbSdhXcTable_t;





























 



 
extern MIBDid_t pbXCModule_Did;

   







 




 



 
extern MIBDid_t pbXCExtendObjects_Did;

   


 



 
 
extern MIBDid_t pbSdhXcNewContextTable_Did;

   
typedef enum {
	pbXConContextHOCCAu3Num_none[TTT]=0,
	pbXConContextHOCCAu3Num_init=1,
	pbXConContextHOCCAu3Num_sys=2,
	pbXConContextHOCCAu3Num_card=4,
	pbXConContextHOCCAu3Num_map=8,
	pbXConContextHOCCAu3Num_poh=16,
	pbXConContextHOCCAu3Num_connect=32,
	pbXConContextHOCCAu3Num_context=64,
	pbXConContextHOCCAu3Num_device=128,
	pbXConContextHOCCAu3Num_ccprot=256,
	pbXConContextHOCCAu3Num_sncp=512,
	pbXConContextHOCCAu3Num_msp=1024,
	pbXConContextHOCCAu3Num_msspr=2048,
	pbXConContextHOCCAu3Num_ep=4096,
	pbXConContextHOCCAu3Num_loccprot=8192,
	pbXConContextHOCCAu3Num_pco=16384,
	pbXConContextHOCCAu3Num_ccs=32768,
	pbXConContextHOCCAu3Num_cca=65536,
	pbXConContextHOCCAu3Num_gmpls=131072,
	pbXConContextHOCCAu3Num_all=1048575
} pbXConContextHOCCAu3Num_Tval;

typedef enum {
	pbXConContextHOCCAu3Step_none[TTT]=0,
	pbXConContextHOCCAu3Step_message=1,
	pbXConContextHOCCAu3Step_module=2,
	pbXConContextHOCCAu3Step_manager=3,
	pbXConContextHOCCAu3Step_ucsl=4,
	pbXConContextHOCCAu3Step_ldsl=5,
	pbXConContextHOCCAu3Step_pdsl=6,
	pbXConContextHOCCAu3Step_driver=7,
	pbXConContextHOCCAu3Step_system=8,
	pbXConContextHOCCAu3Step_simulator=9
} pbXConContextHOCCAu3Step_Tval;

typedef struct
{
	int		pbXConContextLOCCBusNum[TTT];                                         
	int		pbXConContextLOCCAuNum;                                          
	pbXConContextHOCCAu3Num_Tval pbXConContextHOCCAu3Num;
	pbXConContextHOCCAu3Step_Tval pbXConContextHOCCAu3Step;
	int		pbXConContextHOCCAu3Count;
}MIBpbSdhXcNewContextTable_t;












 



 
 
extern MIBDid_t pbSdhXcNewLoMapTable_Did;

   
typedef enum {
	gmplsReservationStatus_unreserved[TTT]=0,
	gmplsReservationStatus_reserved=1
} gmplsReservationStatus_Tval;

typedef enum {
	gmplsReservationOperate_unreserve[TTT]=0,
	gmplsReservationOperate_reserve=1
} gmplsReservationOperate_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbXConLoMapLOCCSlot;                        
	PbPortType_Tval pbXConLoMapLOCCPortType;                          
	int		pbXConLoMapLOCCPort;                                         
	int		pbXConLoMapHOCCIndex;
	PbSlotNumberType_Tval pbXConLoMapLCSlot;
	PbPortType_Tval pbXConLoMapLCPortType;
	int		pbXConLoMapLCPort;
	int		pbXConLoMapLCTP;
	gmplsReservationStatus_Tval gmplsReservationStatus;
	gmplsReservationOperate_Tval gmplsReservationOperate;
}MIBpbSdhXcNewLoMapTable_t;

















 



 
extern MIBDid_t pbXcMigrationGroup_Did;

   
typedef enum {
	pbXcMigrationCommand_none[TTT]=0,
	pbXcMigrationCommand_movePathToGmpls=1,
	pbXcMigrationCommand_confirmPathToGmpls=2,
	pbXcMigrationCommand_abortPathToGmpls=3
} pbXcMigrationCommand_Tval;

typedef enum {
	pbXcMigrationStatus_unknown[TTT]=0,
	pbXcMigrationStatus_successful=1,
	pbXcMigrationStatus_failed=2
} pbXcMigrationStatus_Tval;

typedef struct
{
	int		pbForwardXcId[TTT];
	int		pbReverseXcId;
	pbXcMigrationCommand_Tval pbXcMigrationCommand;
	pbXcMigrationStatus_Tval pbXcMigrationStatus;
}MIBpbXcMigrationGroup_t;









 



 
extern MIBDid_t pbXCContextModule_Did;

   







 




 



 
 
extern MIBDid_t pbTMSRefSourceTable_Did;

   
typedef struct
{
	int		pbTMSRefSourceIndex[TTT];                                            
	PbSlotNumberType_Tval pbTMSRefSourceSlot;   
	int		pbTMSRefSourcePort;   
	PbYesNo_Tval pbTMSRefSourceMonitored;   
	PbTMSSignalStatus_Tval pbTMSSignalStatus;   
	int		pbTMSRefSourcePriority;   
	PbYesNo_Tval pbTMSRefSourceLockOut;   
	PbTMSQl_Tval pbTMSRefSourceQlIn;   
	PbTMSQl_Tval pbTMSRefSourceQl;   
	PbTMSQLMode_Tval pbTMSQlProvionedMode;   
	PbTMSQl_Tval pbTMSQlProvioned;   
	PbYesNo_Tval pbTMSRefSourceValid;   
	int		pbTMSRefSourceWTR;   
	TMSIfSdhQlType_Tval tMSIfSdhQLType;   
	PbTMSQl_Tval tMSRefSourceQLOut;   
	PbYesNo_Tval tMSForceDnu;   
	PbYesNo_Tval tMSSupportQlOut;   
	PbPortType_Tval tMSPortType;   
	int		tmsRefSourceFDUpband;   
	int		tmsRefSourceFDLowband;   
	int		tmsRefSourceFDValue;   
	int		tmsStoredDrvClkNum;   
}MIBpbTMSRefSourceTable_t;





























 



 
extern MIBDid_t pbTMSSysTimingGroup_Did;

   
typedef enum {
	pbTMSTimingState_locked[TTT]=1,
	pbTMSTimingState_freerunning=2,
	pbTMSTimingState_holdover=3
} pbTMSTimingState_Tval;

typedef enum {
	pbTMSSysTimingMode_autoselection[TTT]=1,
	pbTMSSysTimingMode_freerunning=2,
	pbTMSSysTimingMode_holdover=3
} pbTMSSysTimingMode_Tval;

typedef enum {
	pbTMSSwitchRequestStatus_inactive[TTT]=0,
	pbTMSSwitchRequestStatus_ok=1,
	pbTMSSwitchRequestStatus_other_fail=2,
	pbTMSSwitchRequestStatus_dis_fail=3,
	pbTMSSwitchRequestStatus_lock_fail=4,
	pbTMSSwitchRequestStatus_fs_fail=5,
	pbTMSSwitchRequestStatus_sf_fail=6,
	pbTMSSwitchRequestStatus_ql_dnu=7,
	pbTMSSwitchRequestStatus_ql_low=8
} pbTMSSwitchRequestStatus_Tval;

typedef struct
{
	int		pbTMSSwitchRequest[TTT];   
	int		pbTMSActiveTimingSource;   
	pbTMSTimingState_Tval pbTMSTimingState;   
	pbTMSSysTimingMode_Tval pbTMSSysTimingMode;   
	pbTMSSwitchRequestStatus_Tval pbTMSSwitchRequestStatus;   
	DateTime	pbTMSHoldoverDTS;   
	int		pbTMSStaClkOutSource;   
	PbYesNo_Tval pbTMSQlEnabled;   
	PbTMSQl_Tval pbTMSExpectedSMMB;   
	PbYesNo_Tval pbTMSStClkAutoLoopPrevention;   
	int		tmsSysSrcFDThreshold;   
	int		tmsSysFDValue;   
}MIBpbTMSSysTimingGroup_t;

















 



 
 
extern MIBDid_t pbTMSStClkInTable_Did;

   
typedef struct
{
	TmsRefSourceNum_Tval[TTT] pbTMSStClkInIndex;                          
	PbTMSStClkType_Tval pbTMSStClkInType;   
	PbTMSMonitorMode_Tval pbTMSStClkInMonitored;   
	PbTMSSetSa_Tval pbTMSStClkInSaBit;   
	TMSStClkOhm_Tval tMSStClkInOhm;   
}MIBpbTMSStClkInTable_t;












 



 
 
extern MIBDid_t pbTMSStClkOutTable_Did;

   
typedef struct
{
	TmsRefSourceNum_Tval[TTT] pbTMSStClkOutIndex;                               
	PbTMSStClkType_Tval pbTMSStClkOutType;   
	PbYesNo_Tval pbTMSStClkOutMonitored;   
	PbTMSSetSa_Tval pbTMSStClkOutSaBit;   
	PbTMSQl_Tval pbTMSStClkOutQlThreshold;   
	PbTMSSquelchMode_Tval pbTMSStClkOutSquelchMode;   
	TMSStClkOhm_Tval tMSStClkOutOhm;   
	PbTMSQl_Tval pbTMSStClkOutQlIn;   
	PbTMSQl_Tval pbTMSStClkOutQl;   
	PbTMSOutActType_Tval tmsStClkOutputMode;   
	PbTMSOutState_Tval pbTMSStClkOutState;   
}MIBpbTMSStClkOutTable_t;


















 



 
extern MIBDid_t pbTMSModule_Did;

   







 




 



 
 
extern MIBDid_t pbEthGlobalPortTable_Did;

   
typedef enum {
	pbPortTagProtocol_iEEE802[TTT]=0,
	pbPortTagProtocol_doubleTag=1,
	pbPortTagProtocol_tunneling=2
} pbPortTagProtocol_Tval;

typedef enum {
	pbEthACLType_filter[TTT]=1,
	pbEthACLType_forward=2
} pbEthACLType_Tval;

typedef enum {
	pbEthBroadcastEnableHol_disable[TTT]=0,
	pbEthBroadcastEnableHol_enable=1
} pbEthBroadcastEnableHol_Tval;

typedef enum {
	pbEthQoSIEEE802Version_version2004[TTT]=0,
	pbEthQoSIEEE802Version_version2005=1
} pbEthQoSIEEE802Version_Tval;

typedef enum {
	pbEthChangeCoSMode_onlyCos[TTT]=0,
	pbEthChangeCoSMode_cosAndPriority=1
} pbEthChangeCoSMode_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                 
	pbPortTagProtocol_Tval pbPortTagProtocol;   
	int		pbAgingTime;   
	int		pbIPGConfig;   
	int		pbVlanTagProtocolType_len;
	char		pbVlanTagProtocolType[2];   
	int		pbMTUSize;   
	pbEthACLType_Tval pbEthACLType;   
	pbEthBroadcastEnableHol_Tval pbEthBroadcastEnableHol;   
	int		pbEthTunnelingRxTPID_len;
	char		pbEthTunnelingRxTPID[2];   
	pbEthQoSIEEE802Version_Tval pbEthQoSIEEE802Version;   
	pbEthChangeCoSMode_Tval pbEthChangeCoSMode;
	unsigned int	pbEthLabelBase;   
	int		pbEthWredDropProbability;   
}MIBpbEthGlobalPortTable_t;




















 



 
 
extern MIBDid_t pbEthConfigTable_Did;

   
typedef enum {
	pbEthPortType_ge[TTT]=8,
	pbEthPortType_fe=7,
	pbEthPortType_tenge=25,
	pbEthPortType_fiber_channel=26
} pbEthPortType_Tval;

typedef enum {
	pbEthPortAdminStatus_up[TTT]=1,
	pbEthPortAdminStatus_down=0
} pbEthPortAdminStatus_Tval;

typedef enum {
	pbPortLinkStatus_up[TTT]=1,
	pbPortLinkStatus_down=0
} pbPortLinkStatus_Tval;

typedef enum {
	pbEthPortAutoNego_enable[TTT]=1,
	pbEthPortAutoNego_disable=0
} pbEthPortAutoNego_Tval;

typedef enum {
	pbEthPortFlowControl_enable[TTT]=1,
	pbEthPortFlowControl_disable=0
} pbEthPortFlowControl_Tval;

typedef enum {
	pbEthPortSpeed_s10M[TTT]=1,
	pbEthPortSpeed_s100M=2,
	pbEthPortSpeed_s1G=3,
	pbEthPortSpeed_s10G=4,
	pbEthPortSpeed_fc1G=5,
	pbEthPortSpeed_fc2G=6,
	pbEthPortSpeed_fc4G=7
} pbEthPortSpeed_Tval;

typedef enum {
	pbEthPortDuplex_full[TTT]=1,
	pbEthPortDuplex_half=0
} pbEthPortDuplex_Tval;

typedef enum {
	pbUnTagMode_untag[TTT]=0,
	pbUnTagMode_tag=1
} pbUnTagMode_Tval;

typedef enum {
	pbEthPortMode_auto[TTT]=1,
	pbEthPortMode_mon=2,
	pbEthPortMode_nmon=3
} pbEthPortMode_Tval;

typedef enum {
	pbPortDefaultVlanPriority_be[TTT]=0,
	pbPortDefaultVlanPriority_bk=1,
	pbPortDefaultVlanPriority_sp=2,
	pbPortDefaultVlanPriority_ee=3,
	pbPortDefaultVlanPriority_cl=4,
	pbPortDefaultVlanPriority_vi=5,
	pbPortDefaultVlanPriority_vo=6,
	pbPortDefaultVlanPriority_nc=7
} pbPortDefaultVlanPriority_Tval;

typedef enum {
	pbLanTxPriAlg_wRR[TTT]=0,
	pbLanTxPriAlg_sP1_WRR3=1,
	pbLanTxPriAlg_sP2_WRR2=2,
	pbLanTxPriAlg_sP=3,
	pbLanTxPriAlg_wFQ=4
} pbLanTxPriAlg_Tval;

typedef enum {
	pbEthPortLoopback_none[TTT]=0,
	pbEthPortLoopback_incoming=1,
	pbEthPortLoopback_outgoing=2
} pbEthPortLoopback_Tval;

typedef enum {
	pbEthTxEnableHol_disable[TTT]=0,
	pbEthTxEnableHol_enable=1
} pbEthTxEnableHol_Tval;

typedef enum {
	pbEthAlsMode_no_command[TTT]=0,
	pbEthAlsMode_manual_restart=1,
	pbEthAlsMode_manual_test=2
} pbEthAlsMode_Tval;

typedef enum {
	ethMDIorMDIX_autoCrossover[TTT]=0,
	ethMDIorMDIX_mdix=1,
	ethMDIorMDIX_mdi=2
} ethMDIorMDIX_Tval;

typedef enum {
	pbLanChangeCoS_be[TTT]=0,
	pbLanChangeCoS_bk=1,
	pbLanChangeCoS_sp=2,
	pbLanChangeCoS_ee=3,
	pbLanChangeCoS_cl=4,
	pbLanChangeCoS_vi=5,
	pbLanChangeCoS_vo=6,
	pbLanChangeCoS_nc=7,
	pbLanChangeCoS_not_change=8
} pbLanChangeCoS_Tval;

typedef enum {
	pbLanQinQStatus_disable[TTT]=0,
	pbLanQinQStatus_enable=1
} pbLanQinQStatus_Tval;

typedef enum {
	pbLanQinQNewVlanPriority_be[TTT]=0,
	pbLanQinQNewVlanPriority_bk=1,
	pbLanQinQNewVlanPriority_sp=2,
	pbLanQinQNewVlanPriority_ee=3,
	pbLanQinQNewVlanPriority_cl=4,
	pbLanQinQNewVlanPriority_vi=5,
	pbLanQinQNewVlanPriority_vo=6,
	pbLanQinQNewVlanPriority_nc=7
} pbLanQinQNewVlanPriority_Tval;

typedef enum {
	pbEthPortClassifier_non_gmpls[TTT]=0,
	pbEthPortClassifier_i_nni=1,
	pbEthPortClassifier_e_nni=2,
	pbEthPortClassifier_uni10=3,
	pbEthPortClassifier_uni20=4
} pbEthPortClassifier_Tval;

typedef enum {
	pbEthPortWorkMode_ethernetMode[TTT]=0,
	pbEthPortWorkMode_mplsMode=1
} pbEthPortWorkMode_Tval;

typedef enum {
	pbSFPWorkMode_fx[TTT]=0,
	pbSFPWorkMode_t=1,
	pbSFPWorkMode_fx100=2,
	pbSFPWorkMode_xfp10G=3
} pbSFPWorkMode_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                       
	int		pbPortNo;                                                            
	pbEthPortType_Tval pbEthPortType;   
	pbEthPortAdminStatus_Tval pbEthPortAdminStatus;   
	pbPortLinkStatus_Tval pbPortLinkStatus;   
	pbEthPortAutoNego_Tval pbEthPortAutoNego;   
	pbEthPortFlowControl_Tval pbEthPortFlowControl;   
	pbEthPortSpeed_Tval pbEthPortSpeed;   
	pbEthPortDuplex_Tval pbEthPortDuplex;   
	char		pbEthPortVlan[255];   
	int		pbEthPortPvid;   
	pbUnTagMode_Tval pbUnTagMode;   
	int		pbPortInputRateLimit;   
	pbEthPortMode_Tval pbEthPortMode;   
	int		pbEthPortBroadCastRateLimit;   
	pbPortDefaultVlanPriority_Tval pbPortDefaultVlanPriority;   
	char		pbEthPortLabel[20];   
	pbLanTxPriAlg_Tval pbLanTxPriAlg;   
	char		pbLanTaggedVlan[255];   
	pbEthPortLoopback_Tval pbEthPortLoopback;   
	pbEthTxEnableHol_Tval pbEthTxEnableHol;   
	TruthValue_Tval pbEthAutoLaserShutdown;   
	pbEthAlsMode_Tval pbEthAlsMode;   
	TruthValue_Tval pbEthPortAlarmDisable;   
	TruthValue_Tval ethPortOnCSF;   
	ethMDIorMDIX_Tval ethMDIorMDIX;   
	pbLanChangeCoS_Tval pbLanChangeCoS;   
	pbLanQinQStatus_Tval pbLanQinQStatus;   
	int		pbLanQinQNewVlan;   
	pbLanQinQNewVlanPriority_Tval pbLanQinQNewVlanPriority;   
	int		pbLanTPID_len;
	char		pbLanTPID[2];   
	char		pbLanMirrorPort[8];   
	pbEthPortClassifier_Tval pbEthPortClassifier;
	pbEthPortWorkMode_Tval pbEthPortWorkMode;   
	TruthValue_Tval pbEthEnableWred;   
	pbSFPWorkMode_Tval pbSFPWorkMode;   
}MIBpbEthConfigTable_t;











































 



 
 
extern MIBDid_t pbEthWanConfigTable_Did;

   
typedef enum {
	pbWanDefaultVlanPriority_be[TTT]=0,
	pbWanDefaultVlanPriority_bk=1,
	pbWanDefaultVlanPriority_sp=2,
	pbWanDefaultVlanPriority_ee=3,
	pbWanDefaultVlanPriority_cl=4,
	pbWanDefaultVlanPriority_vi=5,
	pbWanDefaultVlanPriority_vo=6,
	pbWanDefaultVlanPriority_nc=7
} pbWanDefaultVlanPriority_Tval;

typedef enum {
	pbWanChangeCoS_be[TTT]=0,
	pbWanChangeCoS_bk=1,
	pbWanChangeCoS_sp=2,
	pbWanChangeCoS_ee=3,
	pbWanChangeCoS_cl=4,
	pbWanChangeCoS_vi=5,
	pbWanChangeCoS_vo=6,
	pbWanChangeCoS_nc=7,
	pbWanChangeCoS_not_change=8
} pbWanChangeCoS_Tval;

typedef enum {
	pbWanTagMode_untag[TTT]=0,
	pbWanTagMode_tag=1
} pbWanTagMode_Tval;

typedef enum {
	pbWanFlowControl_enable[TTT]=1,
	pbWanFlowControl_disable=0
} pbWanFlowControl_Tval;

typedef enum {
	pbWanTxPriAlg_wRR[TTT]=0,
	pbWanTxPriAlg_sP1_WRR3=1,
	pbWanTxPriAlg_sP2_WRR2=2,
	pbWanTxPriAlg_sP=3,
	pbWanTxPriAlg_wFQ=4
} pbWanTxPriAlg_Tval;

typedef enum {
	pbWanTxEnableHol_disable[TTT]=0,
	pbWanTxEnableHol_enable=1
} pbWanTxEnableHol_Tval;

typedef enum {
	pbWanQinQStatus_disable[TTT]=0,
	pbWanQinQStatus_enable=1
} pbWanQinQStatus_Tval;

typedef enum {
	pbWanQinQNewVlanPriority_be[TTT]=0,
	pbWanQinQNewVlanPriority_bk=1,
	pbWanQinQNewVlanPriority_sp=2,
	pbWanQinQNewVlanPriority_ee=3,
	pbWanQinQNewVlanPriority_cl=4,
	pbWanQinQNewVlanPriority_vi=5,
	pbWanQinQNewVlanPriority_vo=6,
	pbWanQinQNewVlanPriority_nc=7
} pbWanQinQNewVlanPriority_Tval;

typedef enum {
	pbWanLinkStatus_down[TTT]=0,
	pbWanLinkStatus_up=1
} pbWanLinkStatus_Tval;

typedef enum {
	pbWanPortWorkMode_ethernetMode[TTT]=0,
	pbWanPortWorkMode_mplsMode=1
} pbWanPortWorkMode_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                 
	int		pbPortNo;                                                      
	char		pbWanLabel[20];   
	char		pbWanVlanList[255];   
	char		pbWanTaggedVlanList[255];   
	pbWanDefaultVlanPriority_Tval pbWanDefaultVlanPriority;   
	pbWanChangeCoS_Tval pbWanChangeCoS;   
	int		pbWanPvid;   
	pbWanTagMode_Tval pbWanTagMode;   
	pbWanFlowControl_Tval pbWanFlowControl;   
	pbWanTxPriAlg_Tval pbWanTxPriAlg;   
	pbWanTxEnableHol_Tval pbWanTxEnableHol;   
	pbWanQinQStatus_Tval pbWanQinQStatus;   
	int		pbWanQinQNewVlan;   
	pbWanQinQNewVlanPriority_Tval pbWanQinQNewVlanPriority;   
	int		pbWanTPID_len;
	char		pbWanTPID[2];   
	char		pbWanMirrorPort[8];   
	pbWanLinkStatus_Tval pbWanLinkStatus;   
	pbWanPortWorkMode_Tval pbWanPortWorkMode;   
	TruthValue_Tval pbWanEnableWred;   
}MIBpbEthWanConfigTable_t;



























 



 
 
extern MIBDid_t pbEthStaticMACTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                       
	char		pbMACEntryMacAddr[20];                                 
	int		pbMACEntryVid;                                          
	char		pbMACEntryPort[8];   
	TruthValue_Tval pbMACEntryTagged;   
	int		pbMACEntryIndex;   
	RowStatus_Tval pbMACEntryRowStatus;   
}MIBpbEthStaticMACTable_t;














 



 
 
extern MIBDid_t pbEthStaticMulticastTable_Did;

   
typedef enum {
	pbStaticMulticastForGmrp_notForGmrp[TTT]=0,
	pbStaticMulticastForGmrp_forGmrp=1
} pbStaticMulticastForGmrp_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                     
	char		pbStaticMulticastMacAddr[20];                                        
	int		pbStaticMulticastVlan;                                                
	char		pbStaticMulticastPortList[64];   
	int		pbStaticMulticastIndex;   
	RowStatus_Tval pbStaticMulticastRowStatus;   
	pbStaticMulticastForGmrp_Tval pbStaticMulticastForGmrp;   
}MIBpbEthStaticMulticastTable_t;














 



 
 
extern MIBDid_t pbVlanPortCoSTable_Did;

   
typedef enum {
	pbEthVlanCoS_be[TTT]=0,
	pbEthVlanCoS_bk=1,
	pbEthVlanCoS_sp=2,
	pbEthVlanCoS_ee=3,
	pbEthVlanCoS_cl=4,
	pbEthVlanCoS_vi=5,
	pbEthVlanCoS_vo=6,
	pbEthVlanCoS_nc=7,
	pbEthVlanCoS_none=8
} pbEthVlanCoS_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                   
	int		pbPortNo;                                                        
	PbEthPortClass_Tval pbEthPortCls;                                        
	int		pbEthVlan;                                                          
	int		pbEthRateLimitValue;   
	pbEthVlanCoS_Tval pbEthVlanCoS;   
	TruthValue_Tval pbEthVlanDisable;   
	char		pbEthRedirectionPort[8];   
	int		pbVlanPortCoSIndex;   
	RowStatus_Tval pbEthVlanPortCoSRowStatus;   
	int		pbEthVlanPolicingID;   
	int		pbEthVlanColorID;   
}MIBpbVlanPortCoSTable_t;



















 



 
 
extern MIBDid_t pbEthVlanNameTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                     
	int		pbEthNamedVlan;                                                       
	char		pbEthVlanName[30];   
	RowStatus_Tval pbEthVlanRowStatus;   
	TruthValue_Tval pbEthVlanEnableMacLearning;   
}MIBpbEthVlanNameTable_t;












 



 
 
extern MIBDid_t pbPortQueueTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                         
	int		pbPortNo;                                              
	PbEthInterfaceType_Tval pbEthPortStyle;                        
	int		pbEthTxQueNo;                                             
	int		pbEthPortQueueWeight;   
	int		pbEthQueueWredID;   
}MIBpbPortQueueTable_t;













 



 
 
extern MIBDid_t pbEthACLTable_Did;

   
typedef enum {
	pbEthACLItemType_filter[TTT]=1,
	pbEthACLItemType_forward=2
} pbEthACLItemType_Tval;

typedef enum {
	pbEthACLCoS_be[TTT]=0,
	pbEthACLCoS_bk=1,
	pbEthACLCoS_sp=2,
	pbEthACLCoS_ee=3,
	pbEthACLCoS_cl=4,
	pbEthACLCoS_vi=5,
	pbEthACLCoS_vo=6,
	pbEthACLCoS_nc=7,
	pbEthACLCoS_none=8
} pbEthACLCoS_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                             
	char		pbEthACLMacAddr[20];                                         
	int		pbEthACLVid;                                                  
	pbEthACLItemType_Tval pbEthACLItemType;   
	int		pbEthACLRateLimit;   
	pbEthACLCoS_Tval pbEthACLCoS;   
	int		pbEthACLIndex;   
	RowStatus_Tval pbEthACLEntryRowStatus;   
}MIBpbEthACLTable_t;















 



 
 
extern MIBDid_t pbEthStatusTable_Did;

   
typedef enum {
	pbEthStatusPortStyle_lan[TTT]=1,
	pbEthStatusPortStyle_wan=2
} pbEthStatusPortStyle_Tval;

typedef enum {
	pbEthStatusPortType_ge[TTT]=8,
	pbEthStatusPortType_fe=7,
	pbEthStatusPortType_tenge=25,
	pbEthStatusPortType_fiber_channel=26
} pbEthStatusPortType_Tval;

typedef enum {
	pbEthStatusPortOperStatus_pbPortOperationStatus_up[TTT]=1,
	pbEthStatusPortOperStatus_pbPortOperationStatus_down=2,
	pbEthStatusPortOperStatus_pbPortOperationStatus_absent=3,
	pbEthStatusPortOperStatus_pbPortOperationStatus_na=4
} pbEthStatusPortOperStatus_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                       
	int		pbPortNo;                                                            
	pbEthStatusPortStyle_Tval pbEthStatusPortStyle;   
	pbEthStatusPortType_Tval pbEthStatusPortType;   
	pbEthStatusPortOperStatus_Tval pbEthStatusPortOperStatus;   
	int		pbEthStatusLaserIBias;   
	int		pbEthStatusLaserRecvPwr;   
	int		pbEthStatusLaserTransPwr;   
	int		pbEthStatusLaserTemp;   
	TruthValue_Tval pbEthStatusCompliance8472;   
	int		pbEthStatusNominalMBps;   
	int		pbEthStatusWavelength;   
	int		pbEthStatusLinkLength9125;   
	int		pbEthStatusLinkLength50125;   
	int		pbEthStatusLinkLength62125;   
	int		pbEthStatusLinkLengthCopper;   
	char		pbEthStatusVendorName[20];   
	char		pbEthStatusVendorPN[20];   
	char		pbEthStatusVendorSN[20];   
	char		pbEthStatusManuDate[16];   
	int		pbEthStatusTransCode;   
	char		pbEthStatusVendorOUI[16];   
	PbConnectorType_Tval pbEthStatusConnectorType;   
	char		pbEthsSAGPartNumber[20];   
	int		pbEthnClLaserTemp;   
	int		pbEthnTECCurrent;   
}MIBpbEthStatusTable_t;

































 



 
 
extern MIBDid_t pbVlanPortQinQTable_Did;

   
typedef enum {
	pbEthQinQNewVlanPriority_be[TTT]=0,
	pbEthQinQNewVlanPriority_bk=1,
	pbEthQinQNewVlanPriority_sp=2,
	pbEthQinQNewVlanPriority_ee=3,
	pbEthQinQNewVlanPriority_cl=4,
	pbEthQinQNewVlanPriority_vi=5,
	pbEthQinQNewVlanPriority_vo=6,
	pbEthQinQNewVlanPriority_nc=7
} pbEthQinQNewVlanPriority_Tval;

typedef enum {
	pbEthQinQNewVlanPriMode_userDefined[TTT]=0,
	pbEthQinQNewVlanPriMode_innerTag=1,
	pbEthQinQNewVlanPriMode_ipds=2
} pbEthQinQNewVlanPriMode_Tval;

typedef enum {
	pbEthQinQVlanSwapMode_vlanId[TTT]=0,
	pbEthQinQVlanSwapMode_tpid=1,
	pbEthQinQVlanSwapMode_both=2
} pbEthQinQVlanSwapMode_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                     
	int		pbPortNo;                                                          
	PbEthPortClass_Tval pbEthPortCls;                                       
	int		pbEthVlan;                                                         
	int		pbEthQinQNewVlanId;   
	pbEthQinQNewVlanPriority_Tval pbEthQinQNewVlanPriority;   
	int		pbVlanPortQinQIndex;   
	RowStatus_Tval pbEthVlanPortQinQRowStatus;   
	pbEthQinQNewVlanPriMode_Tval pbEthQinQNewVlanPriMode;   
	TruthValue_Tval pbEthQinQVlanSwapEnable;   
	int		pbEthQinQVlanSwapVid;   
	pbEthQinQVlanSwapMode_Tval pbEthQinQVlanSwapMode;   
}MIBpbVlanPortQinQTable_t;



















 



 
 
extern MIBDid_t pbEthProtPktACLTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                 
	char		pbEthACLMacAddr[20];                                          
	char		pbEthProtPktACLPort[64];
	int		pbEthProtPktACLIndex;
	RowStatus_Tval pbEthProtPktACLRowStatus;
}MIBpbEthProtPktACLTable_t;












 



 
 
extern MIBDid_t pbEthReservedTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                             
	int		pbEthReserveIndex;                                         
	char		pbEthReservedCfg[255];
	RowStatus_Tval pbEthReservedRowStatus;
}MIBpbEthReservedTable_t;











 



 
extern MIBDid_t pbIGMPSnooping_Did;

   


 



 
 
extern MIBDid_t pbLagConfigTable_Did;

   
typedef enum {
	pbLagType_lan[TTT]=0,
	pbLagType_wan=1
} pbLagType_Tval;

typedef enum {
	pbLagFlowControl_disable[TTT]=0,
	pbLagFlowControl_enable=1
} pbLagFlowControl_Tval;

typedef enum {
	pbLagTagMode_untag[TTT]=0,
	pbLagTagMode_tag=1
} pbLagTagMode_Tval;

typedef enum {
	pbLagDefaultVlanPriority_be[TTT]=0,
	pbLagDefaultVlanPriority_bk=1,
	pbLagDefaultVlanPriority_sp=2,
	pbLagDefaultVlanPriority_ee=3,
	pbLagDefaultVlanPriority_cl=4,
	pbLagDefaultVlanPriority_vi=5,
	pbLagDefaultVlanPriority_vo=6,
	pbLagDefaultVlanPriority_nc=7
} pbLagDefaultVlanPriority_Tval;

typedef enum {
	pbLagTxPriAlg_wRR[TTT]=0,
	pbLagTxPriAlg_sP1_WRR3=1,
	pbLagTxPriAlg_sP2_WRR2=2,
	pbLagTxPriAlg_sP=3,
	pbLagTxPriAlg_wFQ=4
} pbLagTxPriAlg_Tval;

typedef enum {
	pbLagTxEnableHol_disable[TTT]=0,
	pbLagTxEnableHol_enable=1
} pbLagTxEnableHol_Tval;

typedef enum {
	pbLagChangeCoS_be[TTT]=0,
	pbLagChangeCoS_bk=1,
	pbLagChangeCoS_sp=2,
	pbLagChangeCoS_ee=3,
	pbLagChangeCoS_cl=4,
	pbLagChangeCoS_vi=5,
	pbLagChangeCoS_vo=6,
	pbLagChangeCoS_nc=7,
	pbLagChangeCoS_not_change=8
} pbLagChangeCoS_Tval;

typedef enum {
	pbLagQinQStatus_disable[TTT]=0,
	pbLagQinQStatus_enable=1
} pbLagQinQStatus_Tval;

typedef enum {
	pbLagQinQNewVlanPriority_be[TTT]=0,
	pbLagQinQNewVlanPriority_bk=1,
	pbLagQinQNewVlanPriority_sp=2,
	pbLagQinQNewVlanPriority_ee=3,
	pbLagQinQNewVlanPriority_cl=4,
	pbLagQinQNewVlanPriority_vi=5,
	pbLagQinQNewVlanPriority_vo=6,
	pbLagQinQNewVlanPriority_nc=7
} pbLagQinQNewVlanPriority_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                 
	int		pbLagId;                                                          
	pbLagType_Tval pbLagType;   
	pbLagFlowControl_Tval pbLagFlowControl;   
	int		pbLagPvid;   
	char		pbLagVlan[255];   
	pbLagTagMode_Tval pbLagTagMode;   
	int		pbLagInputRateLimit;   
	int		pbLagBroadCastRateLimit;   
	pbLagDefaultVlanPriority_Tval pbLagDefaultVlanPriority;   
	pbLagTxPriAlg_Tval pbLagTxPriAlg;   
	pbLagTxEnableHol_Tval pbLagTxEnableHol;   
	pbLagChangeCoS_Tval pbLagChangeCoS;   
	pbLagQinQStatus_Tval pbLagQinQStatus;   
	int		pbLagQinQNewVlan;   
	pbLagQinQNewVlanPriority_Tval pbLagQinQNewVlanPriority;   
	char		pbLagPortList[255];   
	TruthValue_Tval pbLagEnableWred;   
}MIBpbLagConfigTable_t;

























 



 
extern MIBDid_t pbLacpConfig_Did;

   


 



 
 
extern MIBDid_t pbEthStaticMplsTable_Did;

   
typedef enum {
	pbEthInPortType_lan[TTT]=0,
	pbEthInPortType_wan=1
} pbEthInPortType_Tval;

typedef enum {
	pbEthOutPortType_lan[TTT]=0,
	pbEthOutPortType_wan=1
} pbEthOutPortType_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                   
	unsigned int	pbEthLspLabel;                                              
	char		pbEthInPort[8];   
	pbEthInPortType_Tval pbEthInPortType;   
	char		pbEthPort[8];   
	pbEthOutPortType_Tval pbEthOutPortType;   
	int		pbEthStaticMplsPolicingID;   
	int		pbEthStaticMplsColorID;   
	RowStatus_Tval pbEthStaticMplsStatus;   
	char		pbEthLspName[64];   
}MIBpbEthStaticMplsTable_t;

















 



 
 
extern MIBDid_t pbEthPolicingTable_Did;

   
typedef enum {
	pbEthPolicingMode_rfc2698[TTT]=0,
	pbEthPolicingMode_mef10_cf0=1,
	pbEthPolicingMode_mef10_cf1=2
} pbEthPolicingMode_Tval;

typedef enum {
	pbEthPolicingColorAware_unaware[TTT]=0,
	pbEthPolicingColorAware_aware=1
} pbEthPolicingColorAware_Tval;

typedef enum {
	pbEthPolicingDiscardColor_noColor[TTT]=0,
	pbEthPolicingDiscardColor_red=1,
	pbEthPolicingDiscardColor_yellow=2,
	pbEthPolicingDiscardColor_all=3
} pbEthPolicingDiscardColor_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                   
	int		pbEthPolicingIndex;                                                 
	char		pbEthPolicingName[32];   
	pbEthPolicingMode_Tval pbEthPolicingMode;   
	unsigned int	pbEthPolicingEIRPIR;   
	unsigned int	pbEthPolicingCIR;   
	unsigned int	pbEthPolicingEBSPBS;   
	unsigned int	pbEthPolicingCBS;   
	pbEthPolicingColorAware_Tval pbEthPolicingColorAware;   
	pbEthPolicingDiscardColor_Tval pbEthPolicingDiscardColor;   
	RowStatus_Tval pbEthPolicingRowStatus;   
	int		pbEthPolicingCount;   
}MIBpbEthPolicingTable_t;



















 



 
 
extern MIBDid_t pbEthColorTable_Did;

   
typedef enum {
	pbEthPrio0Color_green[TTT]=0,
	pbEthPrio0Color_yellow=1,
	pbEthPrio0Color_red=2
} pbEthPrio0Color_Tval;

typedef enum {
	pbEthPrio1Color_green[TTT]=0,
	pbEthPrio1Color_yellow=1,
	pbEthPrio1Color_red=2
} pbEthPrio1Color_Tval;

typedef enum {
	pbEthPrio2Color_green[TTT]=0,
	pbEthPrio2Color_yellow=1,
	pbEthPrio2Color_red=2
} pbEthPrio2Color_Tval;

typedef enum {
	pbEthPrio3Color_green[TTT]=0,
	pbEthPrio3Color_yellow=1,
	pbEthPrio3Color_red=2
} pbEthPrio3Color_Tval;

typedef enum {
	pbEthPrio4Color_green[TTT]=0,
	pbEthPrio4Color_yellow=1,
	pbEthPrio4Color_red=2
} pbEthPrio4Color_Tval;

typedef enum {
	pbEthPrio5Color_green[TTT]=0,
	pbEthPrio5Color_yellow=1,
	pbEthPrio5Color_red=2
} pbEthPrio5Color_Tval;

typedef enum {
	pbEthPrio6Color_green[TTT]=0,
	pbEthPrio6Color_yellow=1,
	pbEthPrio6Color_red=2
} pbEthPrio6Color_Tval;

typedef enum {
	pbEthPrio7Color_green[TTT]=0,
	pbEthPrio7Color_yellow=1,
	pbEthPrio7Color_red=2
} pbEthPrio7Color_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                       
	int		pbEthColorIndex;                                        
	pbEthPrio0Color_Tval pbEthPrio0Color;   
	pbEthPrio1Color_Tval pbEthPrio1Color;   
	pbEthPrio2Color_Tval pbEthPrio2Color;   
	pbEthPrio3Color_Tval pbEthPrio3Color;   
	pbEthPrio4Color_Tval pbEthPrio4Color;   
	pbEthPrio5Color_Tval pbEthPrio5Color;   
	pbEthPrio6Color_Tval pbEthPrio6Color;   
	pbEthPrio7Color_Tval pbEthPrio7Color;   
	RowStatus_Tval pbEthColorRowStatus;   
	int		pbEthColorCount;   
}MIBpbEthColorTable_t;



















 



 
 
extern MIBDid_t pbEthWredTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                     
	int		pbEthWredIndex;                                       
	int		pbEthWredLowThr0;   
	int		pbEthWredUpThr0;   
	int		pbEthWredLowThr1;   
	int		pbEthWredUpThr1;   
	int		pbEthWredLowThr2;   
	int		pbEthWredUpThr2;   
	RowStatus_Tval pbEthWredRowStatus;   
	int		pbEthWredCount;   
}MIBpbEthWredTable_t;

















 



 
 
extern MIBDid_t pbEthPortBasedACLTable_Did;

   
typedef enum {
	pbEthPortBasedACLItemType_filter[TTT]=1,
	pbEthPortBasedACLItemType_forward=2
} pbEthPortBasedACLItemType_Tval;

typedef enum {
	pbEthPortBasedACLCoS_be[TTT]=0,
	pbEthPortBasedACLCoS_bk=1,
	pbEthPortBasedACLCoS_sp=2,
	pbEthPortBasedACLCoS_ee=3,
	pbEthPortBasedACLCoS_cl=4,
	pbEthPortBasedACLCoS_vi=5,
	pbEthPortBasedACLCoS_vo=6,
	pbEthPortBasedACLCoS_nc=7,
	pbEthPortBasedACLCoS_none=8
} pbEthPortBasedACLCoS_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                               
	int		pbPortNo;                                                                    
	PbEthPortClass_Tval pbEthPortCls;                                                 
	char		pbEthPortBasedACLMacAddr[20];                                                  
	int		pbEthPortBasedACLVid;                                                           
	pbEthPortBasedACLItemType_Tval pbEthPortBasedACLItemType;   
	int		pbEthPortBasedACLRateLimit;   
	pbEthPortBasedACLCoS_Tval pbEthPortBasedACLCoS;   
	int		pbEthPortBasedACLIndex;   
	RowStatus_Tval pbEthPortBasedACLEntryRowStatus;   
}MIBpbEthPortBasedACLTable_t;

















 



 
 
extern MIBDid_t pbLacpGlobalCfgTable_Did;

   
typedef enum {
	pbLacpEnable_enable[TTT]=1,
	pbLacpEnable_disable=2
} pbLacpEnable_Tval;

typedef enum {
	pbLacpHashMode_macipport[TTT]=1,
	pbLacpHashMode_mac=2,
	pbLacpHashMode_ipport=3
} pbLacpHashMode_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;               
	pbLacpEnable_Tval pbLacpEnable;   
	char		pbLacpSystemID[255];   
	int		pbLacpSystemPri;   
	pbLacpHashMode_Tval pbLacpHashMode;   
}MIBpbLacpGlobalCfgTable_t;












 



 
 
extern MIBDid_t pbLacpAgConfigTable_Did;

   
typedef enum {
	pbLacpAgMode_dynamic[TTT]=1,
	pbLacpAgMode_static=0
} pbLacpAgMode_Tval;

typedef enum {
	pbLacpAgRowState_active[TTT]=1,
	pbLacpAgRowState_inactive=0
} pbLacpAgRowState_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                 
	int		pbLacpAgNo;                                       
	char		pbLacpAgName[32];   
	char		pbLacpAgMac[32];   
	pbLacpAgMode_Tval pbLacpAgMode;   
	pbLacpAgRowState_Tval pbLacpAgRowState;   
}MIBpbLacpAgConfigTable_t;













 



 
 
extern MIBDid_t pbLacpAgInformTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                             
	int		pbLacpAgNo;                                                
	int		pbLacpAgOperKey;   
	char		pbLacpPortList[128];   
	char		pbLacpPartnerMac[128];   
	int		pbLacpPartnerSysPri;   
	int		pbLacpPartnerAgOperKey;   
	int		pbLacpPortTypeInAg;   
	int		pbLacpPortSpeedInAg;   
}MIBpbLacpAgInformTable_t;
















 



 
 
extern MIBDid_t pbLacpApConfigTable_Did;

   
typedef enum {
	pbLacpTimeoutMode_fast[TTT]=1,
	pbLacpTimeoutMode_slow=0
} pbLacpTimeoutMode_Tval;

typedef enum {
	pbLacpPortIndiv_individual[TTT]=1,
	pbLacpPortIndiv_aggregable=2
} pbLacpPortIndiv_Tval;

typedef enum {
	pbLacpActiveMode_active[TTT]=1,
	pbLacpActiveMode_passive=0
} pbLacpActiveMode_Tval;

typedef enum {
	pbLacpPortBpduMode_standardMode[TTT]=0,
	pbLacpPortBpduMode_tagMode=1
} pbLacpPortBpduMode_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                     
	PbLacpPortClass_Tval pbLacpPortType;                       
	int		pbPortNo;                                          
	pbLacpTimeoutMode_Tval pbLacpTimeoutMode;   
	pbLacpPortIndiv_Tval pbLacpPortIndiv;   
	pbLacpActiveMode_Tval pbLacpActiveMode;   
	int		pbLacpDesigAggor;   
	int		pbLacpPortPri;   
	pbLacpPortBpduMode_Tval pbLacpPortBpduMode;   
}MIBpbLacpApConfigTable_t;
















 



 
 
extern MIBDid_t pbLacpApInformTable_Did;

   
typedef enum {
	pbLacpPortLinkState_up[TTT]=1,
	pbLacpPortLinkState_down=2
} pbLacpPortLinkState_Tval;

typedef enum {
	pbLacpPartnerPortMode_active[TTT]=1,
	pbLacpPartnerPortMode_passive=0
} pbLacpPartnerPortMode_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                             
	PbLacpPortClass_Tval pbLacpPortType;                            
	int		pbPortNo;                                                  
	pbLacpPortLinkState_Tval pbLacpPortLinkState;   
	int		pbLacpPortBelongAg;   
	char		pbLacpPortSync[32];   
	int		pbLacpPortOperKey;   
	int		pbLacpPartnerPortNo;   
	pbLacpPartnerPortMode_Tval pbLacpPartnerPortMode;   
	int		pbLacpPartnerPortPri;   
	int		pbLacpPartnerOperKey;   
	char		pbLacpPartnerPortState[32];   
}MIBpbLacpApInformTable_t;



















 



 
 
extern MIBDid_t pbIgmpSnoopingGlobalTable_Did;

   
typedef enum {
	pbIgmpSnoopingEnable_enable[TTT]=1,
	pbIgmpSnoopingEnable_disable=2
} pbIgmpSnoopingEnable_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                               
	pbIgmpSnoopingEnable_Tval pbIgmpSnoopingEnable;   
	int		pbIgmpSnoopingAgingTime;   
}MIBpbIgmpSnoopingGlobalTable_t;










 



 
 
extern MIBDid_t pbVlanIgmpSnoopingTable_Did;

   
typedef enum {
	pbVlanIgmpSnoopingEnable_enable[TTT]=1,
	pbVlanIgmpSnoopingEnable_disable=2
} pbVlanIgmpSnoopingEnable_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                       
	int		pbIgmpVlanNumber;                                                       
	pbVlanIgmpSnoopingEnable_Tval pbVlanIgmpSnoopingEnable;   
	RowStatus_Tval pbVlanIgmpSnoopingRowStatus;   
}MIBpbVlanIgmpSnoopingTable_t;











 



 
 
extern MIBDid_t pbIgmpSnoopingIpGroupTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                     
	int		pbIgmpVlanNumber;                                  
	unsigned int	pbGroupIp;                                    
	char		pbIgmpMacAddr[20];   
	char		pbIgmpIpMemberPort[128];   
}MIBpbIgmpSnoopingIpGroupTable_t;












 



 
 
extern MIBDid_t pbIgmpSnoopingMacGroupTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                       
	int		pbIgmpVlanNumber;                                    
	char		pbIgmpMacAddr[20];                                  
	char		pbIgmpMacMemberPort[128];   
}MIBpbIgmpSnoopingMacGroupTable_t;











 



 
 
extern MIBDid_t pbIgmpSnoopingMulRouterTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                       
	int		pbIgmpVlanNumber;                                    
	char		pbIgmpMulRouterPort[128];   
}MIBpbIgmpSnoopingMulRouterTable_t;










 



 
extern MIBDid_t pbEthernetModule_Did;

   







 




 



 
extern MIBDid_t pbGvrpBase_Did;

   


 



 
 
extern MIBDid_t pbGvrpBridgeTable_Did;

   
typedef enum {
	pbGvrpEnable_disabled[TTT]=0,
	pbGvrpEnable_enabled=1
} pbGvrpEnable_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                       
	char		pbGvrpBridgeAddress[32];   
	pbGvrpEnable_Tval pbGvrpEnable;   
	int		pbGvrpJoinTimer;   
	int		pbGvrpLeaveTimer;   
	int		pbGvrpLeaveallTimer;   
	char		pbGvrpVlanList[255];
	int		pbGvrpMaxDVlanNum;
}MIBpbGvrpBridgeTable_t;















 



 
 
extern MIBDid_t pbGvrpPortTable_Did;

   
typedef enum {
	pbGvrpPortType_lan[TTT]=1,
	pbGvrpPortType_wan=2,
	pbGvrpPortType_trunk=3
} pbGvrpPortType_Tval;

typedef enum {
	pbGvrpPortEnable_disabled[TTT]=0,
	pbGvrpPortEnable_enabled=1
} pbGvrpPortEnable_Tval;

typedef enum {
	pbGvrpPortRegAdminCtrl_normal[TTT]=0,
	pbGvrpPortRegAdminCtrl_fixed=1,
	pbGvrpPortRegAdminCtrl_forbidden=2
} pbGvrpPortRegAdminCtrl_Tval;

typedef enum {
	pbGvrpPortApplAdminCtrl_normal[TTT]=0,
	pbGvrpPortApplAdminCtrl_nonparticipant=1
} pbGvrpPortApplAdminCtrl_Tval;

typedef enum {
	pbGvrpBlockPortEnable_disabled[TTT]=0,
	pbGvrpBlockPortEnable_enabled=1
} pbGvrpBlockPortEnable_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                               
	pbGvrpPortType_Tval pbGvrpPortType;                                  
	int		pbGvrpPortNo;                                                   
	pbGvrpPortEnable_Tval pbGvrpPortEnable;   
	pbGvrpPortRegAdminCtrl_Tval pbGvrpPortRegAdminCtrl;   
	pbGvrpPortApplAdminCtrl_Tval pbGvrpPortApplAdminCtrl;   
	pbGvrpBlockPortEnable_Tval pbGvrpBlockPortEnable;   
}MIBpbGvrpPortTable_t;














 



 
 
extern MIBDid_t pbGvrpDVlanTable_Did;

   
typedef enum {
	pbGvrpDPortType_lan[TTT]=1,
	pbGvrpDPortType_wan=2,
	pbGvrpDPortType_trunk=3
} pbGvrpDPortType_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;               
	pbGvrpDPortType_Tval pbGvrpDPortType;                
	int		pbGvrpDPortNo;                                  
	char		pbGvrpDVlanList[255];   
}MIBpbGvrpDVlanTable_t;











 



 
extern MIBDid_t pbGvrpModule_Did;

   







 




 



 
extern MIBDid_t pbGmrpBase_Did;

   


 



 
 
extern MIBDid_t pbGmrpBridgeTable_Did;

   
typedef enum {
	pbGmrpEnable_disabled[TTT]=0,
	pbGmrpEnable_enabled=1
} pbGmrpEnable_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                       
	char		pbGmrpBridgeAddress[32];   
	pbGmrpEnable_Tval pbGmrpEnable;   
	int		pbGmrpJoinTimer;   
	int		pbGmrpLeaveTimer;   
	int		pbGmrpLeaveallTimer;   
	int		pbGmrpMaxDMacNum;   
}MIBpbGmrpBridgeTable_t;














 



 
 
extern MIBDid_t pbGmrpPortTable_Did;

   
typedef enum {
	pbGmrpPortType_lan[TTT]=1,
	pbGmrpPortType_wan=2,
	pbGmrpPortType_trunk=3
} pbGmrpPortType_Tval;

typedef enum {
	pbGmrpPortEnable_disabled[TTT]=0,
	pbGmrpPortEnable_enabled=1
} pbGmrpPortEnable_Tval;

typedef enum {
	pbGmrpPortRegAdminCtrl_normal[TTT]=0,
	pbGmrpPortRegAdminCtrl_fixed=1,
	pbGmrpPortRegAdminCtrl_forbidden=2
} pbGmrpPortRegAdminCtrl_Tval;

typedef enum {
	pbGmrpPortApplAdminCtrl_normal[TTT]=0,
	pbGmrpPortApplAdminCtrl_nonparticipant=1
} pbGmrpPortApplAdminCtrl_Tval;

typedef enum {
	pbGmrpForwardAllEnable_disabled[TTT]=0,
	pbGmrpForwardAllEnable_enabled=1
} pbGmrpForwardAllEnable_Tval;

typedef enum {
	pbGmrpBlockPortEnable_disabled[TTT]=0,
	pbGmrpBlockPortEnable_enabled=1
} pbGmrpBlockPortEnable_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                               
	pbGmrpPortType_Tval pbGmrpPortType;                                  
	int		pbGmrpPortNo;                                                   
	pbGmrpPortEnable_Tval pbGmrpPortEnable;   
	pbGmrpPortRegAdminCtrl_Tval pbGmrpPortRegAdminCtrl;   
	pbGmrpPortApplAdminCtrl_Tval pbGmrpPortApplAdminCtrl;   
	pbGmrpForwardAllEnable_Tval pbGmrpForwardAllEnable;   
	pbGmrpBlockPortEnable_Tval pbGmrpBlockPortEnable;   
}MIBpbGmrpPortTable_t;















 



 
 
extern MIBDid_t pbVlanGmrpTable_Did;

   
typedef enum {
	pbVlanGmrpEnable_disable[TTT]=0,
	pbVlanGmrpEnable_enable=1
} pbVlanGmrpEnable_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                       
	int		pbGmrpVlanNumber;                                       
	pbVlanGmrpEnable_Tval pbVlanGmrpEnable;   
	RowStatus_Tval pbVlanGmrpRowStatus;   
}MIBpbVlanGmrpTable_t;











 



 
 
extern MIBDid_t pbGmrpDMacTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                         
	int		pbGmrpVlanId;                                             
	char		pbGmrpMacAddr[20];                                       
	char		pbGmrpMacMemberPort1[255];   
	char		pbGmrpMacMemberPort2[255];   
}MIBpbGmrpDMacTable_t;












 



 
extern MIBDid_t pbGmrpModule_Did;

   







 




 



 
extern MIBDid_t eosMapper_Did;

   


 



 
 
extern MIBDid_t vcgConfigTable_Did;

   
typedef enum {
	vcgXVType_vc4[TTT]=0,
	vcgXVType_vc3=1,
	vcgXVType_vc12=2
} vcgXVType_Tval;

typedef enum {
	vcgPauseTransparent_disable[TTT]=0,
	vcgPauseTransparent_enable=1
} vcgPauseTransparent_Tval;

typedef enum {
	vcgGfpMode_gfp_f[TTT]=0,
	vcgGfpMode_gfp_t=1
} vcgGfpMode_Tval;

typedef enum {
	vcgGfpType_gfp_NullExternsion[TTT]=0,
	vcgGfpType_gfp_LinearFrames=1
} vcgGfpType_Tval;

typedef enum {
	vcgGfpFCS_disable[TTT]=0,
	vcgGfpFCS_enable=1
} vcgGfpFCS_Tval;

typedef enum {
	vcgGfpFcsAutoDetect_disable[TTT]=0,
	vcgGfpFcsAutoDetect_enable=1
} vcgGfpFcsAutoDetect_Tval;

typedef enum {
	vcgPortMonMode_auto[TTT]=1,
	vcgPortMonMode_mon=2,
	vcgPortMonMode_nmon=3
} vcgPortMonMode_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                       
	int		vcgNo;                                                  
	char		vcgLabel[100];   
	vcgXVType_Tval vcgXVType;   
	char		vcgChannelId[50];   
	TruthValue_Tval vcgLCASSupport;   
	TruthValue_Tval vcgCapacityTrigger;   
	vcgPauseTransparent_Tval vcgPauseTransparent;   
	int		vcgLcasHoldOffTime;   
	vcgGfpMode_Tval vcgGfpMode;   
	vcgGfpType_Tval vcgGfpType;   
	vcgGfpFCS_Tval vcgGfpFCS;   
	vcgGfpFcsAutoDetect_Tval vcgGfpFcsAutoDetect;   
	TruthValue_Tval vcgGfpCsfAutoMode;   
	vcgPortMonMode_Tval vcgPortMonMode;
	TruthValue_Tval vcgPortAlarmDisable;
	int		vcgPLCTThreshold;   
	int		vcgPLCRThreshold;   
}MIBvcgConfigTable_t;

























 



 
 
extern MIBDid_t eosGlobalConfigTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;         
	int		eosIPGConfig;   
	int		eosMTUSize;   
	int		eosEslConfig;   
}MIBeosGlobalConfigTable_t;











 



 
 
extern MIBDid_t pbSOLCASConfigTable_Did;

   
typedef enum {
	pbSOLCASActive_none[TTT]=0,
	pbSOLCASActive_active=1,
	pbSOLCASActive_deactive=2
} pbSOLCASActive_Tval;

typedef enum {
	pbSOLCASState_fixed[TTT]=0,
	pbSOLCASState_add=1,
	pbSOLCASState_normal=2,
	pbSOLCASState_eos=3,
	pbSOLCASState_idle=5,
	pbSOLCASState_dnu=15
} pbSOLCASState_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;               
	int		pbPortNo;                                    
	PbTPType_Tval pbTpType;                           
	int		pbTpIndex;                                   
	pbSOLCASActive_Tval pbSOLCASActive;   
	int		pbSOLCASVCGPort;   
	pbSOLCASState_Tval pbSOLCASState;   
}MIBpbSOLCASConfigTable_t;














 



 
 
extern MIBDid_t pbSKLCASConfigTable_Did;

   
typedef enum {
	pbSKLCASState_ok[TTT]=0,
	pbSKLCASState_fail=1
} pbSKLCASState_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;               
	int		pbPortNo;                                    
	PbTPType_Tval pbTpType;                           
	int		pbTpIndex;                                   
	int		pbSKLCASVCGPort;   
	pbSKLCASState_Tval pbSKLCASState;   
}MIBpbSKLCASConfigTable_t;













 



 
extern MIBDid_t enterpriseEOSModule_Did;

   







 




 



 
extern MIBDid_t pbRstpBase_Did;

   


 



 
 
extern MIBDid_t pbRstpBridgeTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                 
	int		pbRstpBridgeAddress_len;
	char		pbRstpBridgeAddress[6];   
	int		pbRstpBridgePriority;   
	int		pbRstpBridgeMaxAge;   
	int		pbRstpBridgeHelloTime;   
	int		pbRstpBridgeForwardDelay;   
	int		pbRstpTxHoldCount;   
	TruthValue_Tval pbRstpBEGIN;   
	TruthValue_Tval pbRstpEventSwitch;   
}MIBpbRstpBridgeTable_t;
















 



 
 
extern MIBDid_t pbRstpPortTable_Did;

   
typedef enum {
	pbRstpPortType_lan[TTT]=1,
	pbRstpPortType_wan=2,
	pbRstpPortType_trunk=3
} pbRstpPortType_Tval;

typedef enum {
	pbRstpPortEnable_enabled[TTT]=1,
	pbRstpPortEnable_disabled=2
} pbRstpPortEnable_Tval;

typedef enum {
	pbRstpPortAdminPointToPoint_forceTrue[TTT]=0,
	pbRstpPortAdminPointToPoint_forceFalse=1,
	pbRstpPortAdminPointToPoint_auto=2
} pbRstpPortAdminPointToPoint_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                       
	pbRstpPortType_Tval pbRstpPortType;                                          
	int		pbRstpPortNo;                                                           
	int		pbRstpPortPriority;   
	pbRstpPortEnable_Tval pbRstpPortEnable;   
	int		pbRstpPortPathCost;   
	TruthValue_Tval pbRstpPortAdminEdgePort;   
	pbRstpPortAdminPointToPoint_Tval pbRstpPortAdminPointToPoint;   
}MIBpbRstpPortTable_t;















 



 
 
extern MIBDid_t pbRstpBridgeStateTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                             
	char		pbRstpRPVector1[75];   
	char		pbRstpRPVector2[75];   
	int		pbRstpRootMaxAge;   
	int		pbRstpRootHelloTime;   
	int		pbRstpRootForwardDelay;   
	int		pbRstpRootPortId;   
}MIBpbRstpBridgeStateTable_t;














 



 
 
extern MIBDid_t pbRstpPortStateTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                       
	int		pbRstpPortType;                                      
	int		pbRstpPortNo;                                        
	int		pbRstpPEnable;   
	char		pbRstpPPVector1[75];   
	char		pbRstpPPVector2[75];   
	char		pbRstpDsgPVector1[75];   
	char		pbRstpDsgPVector2[75];   
	char		pbRstpMsgPVector1[75];   
	char		pbRstpMsgPVector2[75];   
	char		pbRstpPTimes[30];   
	char		pbRstpDsgTimes[30];   
	char		pbRstpMsgTimes[30];   
	int		pbRstpPForward;   
	int		pbRstpPLearn;   
	int		pbRstpPInfoIs;   
	int		pbRstpPRole;   
	int		pbRstpPSelectedRole;   
}MIBpbRstpPortStateTable_t;

























 



 
extern MIBDid_t enterpriseRstpMIB_Did;

   







 




 



 
extern MIBDid_t pbMstpBase_Did;

   


 



 
extern MIBDid_t pbMstpBridgeBase_Did;

   


 



 
extern MIBDid_t pbMstpPortBase_Did;

   


 



 
extern MIBDid_t pbMstpBridgeStateBase_Did;

   


 



 
extern MIBDid_t pbMstpPortStateBase_Did;

   


 



 
 
extern MIBDid_t pbCistPortStateTable_Did;

   
typedef enum {
	pbCistPState_psDisable[TTT]=0,
	pbCistPState_psBlocking=1,
	pbCistPState_psLearning=2,
	pbCistPState_psForwarding=3
} pbCistPState_Tval;

typedef enum {
	pbCistPRole_prDisable[TTT]=0,
	pbCistPRole_prRoot=1,
	pbCistPRole_prDesignated=2,
	pbCistPRole_prAlternate=3,
	pbCistPRole_prBackup=4,
	pbCistPRole_prMaster=5
} pbCistPRole_Tval;

typedef enum {
	pbCistPPState_forceTrue[TTT]=0,
	pbCistPPState_forceFalse=1
} pbCistPPState_Tval;

typedef enum {
	pbPortBpduRule_stp[TTT]=0,
	pbPortBpduRule_rstp_mstp=1
} pbPortBpduRule_Tval;

typedef enum {
	pbPortOperEdge_normalPort[TTT]=0,
	pbPortOperEdge_edgePort=1
} pbPortOperEdge_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                   
	PbEthInterfaceType_Tval pbMstPortType;                
	int		pbPortNo;                                        
	PbEnableDisable_Tval pbCistPortEnable;   
	char		pbCistPPVector1[75];   
	char		pbCistPPVector2[75];   
	char		pbCistPPVector3[75];   
	char		pbCistDPVector1[75];   
	char		pbCistDPVector2[75];   
	char		pbCistDPVector3[75];   
	char		pbCistMPVector1[75];   
	char		pbCistMPVector2[75];   
	char		pbCistMPVector3[75];   
	char		pbCistPTimes[30];   
	char		pbCistDTimes[30];   
	char		pbCistMTimes[30];   
	pbCistPState_Tval pbCistPState;   
	int		pbCistPInfoIs;   
	pbCistPRole_Tval pbCistPRole;   
	pbCistPPState_Tval pbCistPPState;
	int		pbMstRcvdInternal;   
	pbPortBpduRule_Tval pbPortBpduRule;
	pbPortOperEdge_Tval pbPortOperEdge;
}MIBpbCistPortStateTable_t;






























 



 
 
extern MIBDid_t pbMstiPortStateTable_Did;

   
typedef enum {
	pbMstiPState_psDisable[TTT]=0,
	pbMstiPState_psBlocking=1,
	pbMstiPState_psLearning=2,
	pbMstiPState_psForwarding=3
} pbMstiPState_Tval;

typedef enum {
	pbMstiPRole_prDisable[TTT]=0,
	pbMstiPRole_prRoot=1,
	pbMstiPRole_prDesignated=2,
	pbMstiPRole_prAlternate=3,
	pbMstiPRole_prBackup=4,
	pbMstiPRole_prMaster=5
} pbMstiPRole_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                       
	PbEthInterfaceType_Tval pbMstPortType;                    
	int		pbPortNo;                                            
	int		pbMstiNumber;                                        
	char		pbMstiPPVector1[75];   
	char		pbMstiPPVector2[75];   
	char		pbMstiDPVector1[75];   
	char		pbMstiDPVector2[75];   
	char		pbMstiMPVector1[75];   
	char		pbMstiMPVector2[75];   
	char		pbMstiPTimes[30];   
	char		pbMstiDTimes[30];   
	char		pbMstiMTimes[30];   
	pbMstiPState_Tval pbMstiPState;   
	int		pbMstiPInfoIs;   
	pbMstiPRole_Tval pbMstiPRole;   
	int		pbMstiPSelectedRole;   
}MIBpbMstiPortStateTable_t;
























 



 
 
extern MIBDid_t pbCistBridgeStateTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                               
	int		pbMstBaseNumPorts;   
	char		pbCistRPVector1[75];   
	char		pbCistRPVector2[75];   
	char		pbCistRPVector3[75];   
	int		pbMstRootMaxAge;
	int		pbMstRootMsgAge;   
	int		pbMstRootHelloTime;   
	int		pbMstRootForwardDelay;   
	int		pbCistRootRemainingHops;   
	int		pbCistRootPortId;   
	int		pbMstCfgDigest_len;
	char		pbMstCfgDigest[16];   
}MIBpbCistBridgeStateTable_t;



















 



 
 
extern MIBDid_t pbMstiBridgeStateTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                               
	int		pbMstiNumber;                                                
	char		pbMstiRPVector1[75];   
	char		pbMstiRPVector2[75];   
	int		pbMstiRootRemainingHops;   
	int		pbMstiRootPortId;   
}MIBpbMstiBridgeStateTable_t;













 



 
 
extern MIBDid_t pbCistPortTable_Did;

   
typedef enum {
	pbMstPortAdminPointToPoint_forceTrue[TTT]=0,
	pbMstPortAdminPointToPoint_forceFalse=1,
	pbMstPortAdminPointToPoint_auto=2
} pbMstPortAdminPointToPoint_Tval;

typedef enum {
	pbMstPortBpduMode_standardMode[TTT]=0,
	pbMstPortBpduMode_tagMode=1
} pbMstPortBpduMode_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                                     
	PbEthInterfaceType_Tval pbMstPortType;                                  
	int		pbPortNo;                                                          
	int		pbMstPort;   
	int		pbCistPortPriority;   
	int		pbCistExPortPathCost;   
	int		pbCistInPortPathCost;   
	TruthValue_Tval pbMstPortAdminEdgePort;   
	pbMstPortAdminPointToPoint_Tval pbMstPortAdminPointToPoint;   
	PbEnableDisable_Tval pbMstPortEnable;   
	TruthValue_Tval pbMstPortCheck;
	pbMstPortBpduMode_Tval pbMstPortBpduMode;
}MIBpbCistPortTable_t;



















 



 
 
extern MIBDid_t pbMstiPortTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                     
	PbEthInterfaceType_Tval pbMstPortType;                  
	int		pbPortNo;                                          
	int		pbMstiNumber;                                      
	int		pbMstiPortPriority;   
	int		pbMstiPortPathCost;   
}MIBpbMstiPortTable_t;













 



 
 
extern MIBDid_t pbCistBridgeTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                               
	int		pbMstBaseBridgeAddress_len;
	char		pbMstBaseBridgeAddress[6];   
	int		pbCistPriority;   
	int		pbMstForceVersion;   
	int		pbMstBridgeMaxAge;   
	int		pbMstBridgeHelloTime;   
	int		pbMstBridgeForwardDelay;   
	int		pbMstTxHoldCount;   
	int		pbMstMaxHops;   
	TruthValue_Tval pbMstMstpBEGIN;   
	char		pbMstMstpConfigName[33];   
	int		pbMstMstpRevisonLevel;   
	TruthValue_Tval pbMstEventSwitch;
}MIBpbCistBridgeTable_t;




















 



 
 
extern MIBDid_t pbMstiBridgeTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                 
	int		pbMstiNumber;                                     
	char		pbMstiVlanNumber[255];   
	int		pbMstiPriority;   
}MIBpbMstiBridgeTable_t;











 



 
extern MIBDid_t enterpriseMstpMIB_Did;

   







 




 



 
 
extern MIBDid_t pbIpRouteTable_Did;

   
typedef enum {
	pbIpRouteProto_other[TTT]=1,
	pbIpRouteProto_local=2,
	pbIpRouteProto_netmgmt=3,
	pbIpRouteProto_icmp=4,
	pbIpRouteProto_egp=5,
	pbIpRouteProto_ggp=6,
	pbIpRouteProto_hello=7,
	pbIpRouteProto_rip=8,
	pbIpRouteProto_is_is=9,
	pbIpRouteProto_es_is=10,
	pbIpRouteProto_ciscoIgrp=11,
	pbIpRouteProto_bbnSpfIgp=12,
	pbIpRouteProto_ospf=13,
	pbIpRouteProto_bgp=14
} pbIpRouteProto_Tval;

typedef enum {
	pbIpRouteType_other[TTT]=1,
	pbIpRouteType_invalid=2,
	pbIpRouteType_direct=3,
	pbIpRouteType_indirect=4
} pbIpRouteType_Tval;

typedef struct
{
	unsigned int	pbIpRouteDest[TTT];                            
	unsigned int	pbIpRouteMask;                            
	pbIpRouteProto_Tval pbIpRouteProto;                    
	int		pbIpRouteIfIndex;   
	unsigned int	pbIpRouteNextHop;   
	pbIpRouteType_Tval pbIpRouteType;   
	int		pbIpRouteAge;   
	int		pbIpRouteMetric1;   
	int		pbIpRouteMetric2;   
	int		pbIpRouteMetric3;   
	int		pbIpRouteMetric4;   
	int		pbIpRouteMetric5;   
}MIBpbIpRouteTable_t;



















 



 
 
extern MIBDid_t dccCfgTable_Did;

   
typedef enum {
	mode_ms[TTT]=0,
	mode_rs=1,
	mode_hcoc9=2,
	mode_hcoc27=3,
	mode_ecc=4
} mode_Tval;

typedef enum {
	state_disable[TTT]=1,
	state_enable=2,
	state_transparent=3
} state_Tval;

typedef enum {
	protocol_ppp[TTT]=1,
	protocol_osi=2,
	protocol_iptunnel=3
} protocol_Tval;

typedef enum {
	linkStatus_down[TTT]=1,
	linkStatus_up=2
} linkStatus_Tval;

typedef enum {
	mspStatus_nonprotected[TTT]=1,
	mspStatus_protected=2
} mspStatus_Tval;

typedef enum {
	crcMode_crc16[TTT]=1,
	crcMode_crc32=2
} crcMode_Tval;

typedef enum {
	multilink_open[TTT]=1,
	multilink_close=2
} multilink_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;               
	int		pbPortNo;                                    
	mode_Tval mode;                                      
	state_Tval state;   
	protocol_Tval protocol;   
	unsigned int	dccBundleNumber;   
	linkStatus_Tval linkStatus;   
	mspStatus_Tval mspStatus;   
	int		destSlot;   
	int		destPort;   
	int		mtu;
	crcMode_Tval crcMode;   
	int		hcocIndex;   
	multilink_Tval multilink;   
}MIBdccCfgTable_t;





















 



 
 
extern MIBDid_t ipInIpCfgTable_Did;

   
typedef struct
{
	unsigned int	ipInIpIfIpAddr[TTT];                               
	unsigned int	ipInIpIfMask;                                 
	unsigned int	ipInIpDestIpAddr;                             
	unsigned int	ipInIpSourcIpAddr;   
	unsigned int	ipInIpIfIndex;   
	unsigned int	ipInIpIfMtu;   
	RowStatus_Tval ipInIpRowStatus;
	unsigned int	ipInIpPeerIfIpAddr;   
}MIBipInIpCfgTable_t;















 



 
 
extern MIBDid_t mpBundleCfgTable_Did;

   
typedef enum {
	bundleTOS_enable[TTT]=1,
	bundleTOS_disable=2
} bundleTOS_Tval;

typedef struct
{
	unsigned int	bundlePeerIpAddr[TTT];                         
	unsigned int	bundleIndex;   
	int		bundleStatus;   
	int		bundleNumber;   
	RowStatus_Tval bundleRowStatus;   
	bundleTOS_Tval bundleTOS;
}MIBmpBundleCfgTable_t;













 



 
 
extern MIBDid_t pbStaticIpRouteTable_Did;

   
typedef enum {
	pbStaticIpRouteProto_local[TTT]=1
} pbStaticIpRouteProto_Tval;

typedef enum {
	pbStaticIpRouteMetricType_none[TTT]=0,
	pbStaticIpRouteMetricType_aseType1Metric=1,
	pbStaticIpRouteMetricType_aseType2Metric=2
} pbStaticIpRouteMetricType_Tval;

typedef struct
{
	unsigned int	pbStaticIpRouteDest[TTT];                                          
	unsigned int	pbStaticIpRouteMask;                                          
	pbStaticIpRouteProto_Tval pbStaticIpRouteProto;                            
	int		pbStaticIpRouteIfIndex;   
	unsigned int	pbStaticIpRouteNextHop;   
	RouteStatus_Tval pbStaticIpRouteAdminStatus;   
	RouteStatus_Tval pbStaticIpRouteOperStatus;   
	pbStaticIpRouteMetricType_Tval pbStaticIpRouteMetricType;   
	int		pbStaticIpRouteCost;   
}MIBpbStaticIpRouteTable_t;
















 



 
 
extern MIBDid_t tracertCfgTable_Did;

   
typedef enum {
	tracertStart_start[TTT]=1,
	tracertStart_stop=2
} tracertStart_Tval;

typedef struct
{
	unsigned int	tracertPeerIpAddr[TTT];                       
	unsigned int	tracertTimeout;
	RowStatus_Tval tracertRowStatus;
	tracertStart_Tval tracertStart;
}MIBtracertCfgTable_t;











 



 
 
extern MIBDid_t tracertResultTable_Did;

   
typedef struct
{
	int		tracertTtlNumber[TTT];                                      
	int		tracertTripTime1;
	int		tracertTripTime2;
	int		tracertTripTime3;
	unsigned int	tracertPeerIpAddrDis;
	RowStatus_Tval tracertRstRowStatus;
}MIBtracertResultTable_t;













 



 
 
extern MIBDid_t pingCfgTable_Did;

   
typedef enum {
	pingStart_start[TTT]=1,
	pingStart_stop=2
} pingStart_Tval;

typedef struct
{
	unsigned int	pingTargetIpAddr[TTT];                      
	int		pingDataSize;
	int		pingCounts;
	int		pingTimeout;
	RowStatus_Tval pingRowStatus;
	pingStart_Tval pingStart;
}MIBpingCfgTable_t;













 



 
 
extern MIBDid_t pingResultTable_Did;

   
typedef struct
{
	int		pingIndex[TTT];                                           
	unsigned int	pingTargetIpAddrDis;
	int		pingDataSizeDis;
	int		pingTripTime;
	int		pingTtlnumber;
	int		pingResult;
	RowStatus_Tval pingRstRowStatus;
}MIBpingResultTable_t;














 



 
 
extern MIBDid_t dccReservePortTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;         
	int		phyPortNum;                            
	int		logPortNum;
}MIBdccReservePortTable_t;










 



 
extern MIBDid_t pbDccModule_Did;

   







 




 



 
 
extern MIBDid_t pbIpTunnelCfgTable_Did;

   
typedef enum {
	pbSdhServerType_ms[TTT]=0,
	pbSdhServerType_rs=1,
	pbSdhServerType_hcoc9=2,
	pbSdhServerType_hcoc27=3
} pbSdhServerType_Tval;

typedef enum {
	pbLapdNetworkSide_user[TTT]=0,
	pbLapdNetworkSide_network=1
} pbLapdNetworkSide_Tval;

typedef enum {
	pbLapdAITS_unconfirmed[TTT]=0,
	pbLapdAITS_acknowledged=1
} pbLapdAITS_Tval;

typedef enum {
	pbIpTunnelByPass_nobypass[TTT]=0,
	pbIpTunnelByPass_bypass=1
} pbIpTunnelByPass_Tval;

typedef enum {
	pbIpTunnelDstMode_ms[TTT]=0,
	pbIpTunnelDstMode_rs=1
} pbIpTunnelDstMode_Tval;

typedef enum {
	pbIpTunnelStatus_deactive[TTT]=0,
	pbIpTunnelStatus_active=1
} pbIpTunnelStatus_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                             
	int		pbPortNo;                                                  
	pbSdhServerType_Tval pbSdhServerType;                           
	pbLapdNetworkSide_Tval pbLapdNetworkSide;   
	int		pbLapdT200;   
	int		pbLapdT203;   
	int		pbLapdN200;   
	pbLapdAITS_Tval pbLapdAITS;   
	int		pbLapdWindow;   
	unsigned int	pbIpTunnelSrcIpAddress;   
	unsigned int	pbIpTunnelDesIpAddress;   
	pbIpTunnelByPass_Tval pbIpTunnelByPass;   
	int		pbIpTunnelDstSlot;   
	int		pbIpTunnelDstPort;   
	pbIpTunnelDstMode_Tval pbIpTunnelDstMode;   
	pbIpTunnelStatus_Tval pbIpTunnelStatus;   
}MIBpbIpTunnelCfgTable_t;























 



 
extern MIBDid_t pbIpTunnelModule_Did;

   







 




 



 
 
extern MIBDid_t pbOsiConfigTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                   
	int		pbPortNo;                                        
	int		pbOsiNetworkSide;   
	int		pbOsiT200;   
	int		pbOsiT203;   
	int		pbOsiN200;   
	int		pbOsiAITS;   
	int		pbOsiWindow;   
	int		pbOsiConfigTimer;   
	int		pbOsiTTL;   
	char		pbOsiLocalNasp[41];   
	char		pbOsiRemoteNasp[41];   
	unsigned int	pbOsiSrcIpAddress;   
	unsigned int	pbOsiDesIpAddress;   
	int		pbOsiIpIfMtu;   
}MIBpbOsiConfigTable_t;






















 



 
 
extern MIBDid_t osiTunnelConfigTable_Did;

   
typedef enum {
	osiTunnelStatus_deactive[TTT]=0,
	osiTunnelStatus_active=1
} osiTunnelStatus_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbSlotNumber;                           
	int		pbPortNo;                                                
	int		pbSdhServerType;                                            
	int		osiTunnelNetworkSide;   
	int		osiTunnelT200;   
	int		osiTunnelT203;   
	int		osiTunnelN200;   
	int		osiTunnelAITS;   
	int		osiTunnelWindow;   
	int		osiTunnelConfigTimer;   
	int		osiTunnelTTL;   
	char		osiTunnelLocalNasp[41];   
	char		osiTunnelRemoteNasp[41];   
	unsigned int	osiTunnelSrcIpAddress;   
	unsigned int	osiTunnelDesIpAddress;   
	int		osiTunnelIpIfMtu;   
	osiTunnelStatus_Tval osiTunnelStatus;
	unsigned int	osiTunnelIndex;   
}MIBosiTunnelConfigTable_t;

























 



 
extern MIBDid_t pbOsiModule_Did;

   







 




 



 
extern MIBDid_t epgGroup_Did;

   


 



 
extern MIBDid_t msspringGroup_Did;

   


 



 
extern MIBDid_t mspGroup_Did;

   


 



 
extern MIBDid_t sncpGroup_Did;

   


 



 
extern MIBDid_t mssp4fGroup_Did;

   


 



 
 
extern MIBDid_t mssp4fConfigTable_Did;

   
typedef enum {
	mssp4fProtectMode_normal[TTT]=1,
	mssp4fProtectMode_transoceanic=2
} mssp4fProtectMode_Tval;

typedef enum {
	mssp4fRingType_none[TTT]=0,
	mssp4fRingType_stm_1=1,
	mssp4fRingType_stm_4=4,
	mssp4fRingType_stm_16=16,
	mssp4fRingType_stm_64=64
} mssp4fRingType_Tval;

typedef struct
{
	unsigned int	mssp4fRingId[TTT];                                                     
	mssp4fProtectMode_Tval mssp4fProtectMode;   
	char		mssp4fRingName[64];   
	unsigned int	mssp4fGroupId;   
	unsigned int	mssp4fWaitToRestore;   
	mssp4fRingType_Tval mssp4fRingType;   
	char		mssp4fWestWorkChannelNutInfo[64];   
	char		mssp4fEastWorkChannelNutInfo[64];   
	TruthValue_Tval mssp4fConfigEnabled;   
	TruthValue_Tval mssp4fConfigDeleted;   
	TruthValue_Tval mssp4fRingSuspended;   
	TruthValue_Tval mssp4fAutoSquelchEnabled;   
	TruthValue_Tval mssp4fAutoMappingEnabled;   
	PbSlotNumberType_Tval mssp4fWestWorkSlotNum;   
	PbPortType_Tval mssp4fWestWorkPortType;   
	unsigned int	mssp4fWestWorkPortNum;   
	PbSlotNumberType_Tval mssp4fWestProtSlotNum;   
	PbPortType_Tval mssp4fWestProtPortType;   
	unsigned int	mssp4fWestProtPortNum;   
	PbSlotNumberType_Tval mssp4fEastWorkSlotNum;   
	PbPortType_Tval mssp4fEastWorkPortType;   
	unsigned int	mssp4fEastWorkPortNum;   
	PbSlotNumberType_Tval mssp4fEastProtSlotNum;   
	PbPortType_Tval mssp4fEastProtPortType;   
	unsigned int	mssp4fEastProtPortNum;   
	PbSlotNumberType_Tval mssp4fPeerWestWorkSlotNum;
	PbPortType_Tval mssp4fPeerWestWorkPortType;
	unsigned int	mssp4fPeerWestWorkPortNum;
	PbSlotNumberType_Tval mssp4fPeerWestProtSlotNum;
	PbPortType_Tval mssp4fPeerWestProtPortType;
	unsigned int	mssp4fPeerWestProtPortNum;
	PbSlotNumberType_Tval mssp4fPeerEastWorkSlotNum;
	PbPortType_Tval mssp4fPeerEastWorkPortType;
	unsigned int	mssp4fPeerEastWorkPortNum;
	PbSlotNumberType_Tval mssp4fPeerEastProtSlotNum;
	PbPortType_Tval mssp4fPeerEastProtPortType;
	unsigned int	mssp4fPeerEastProtPortNum;
}MIBmssp4fConfigTable_t;












































 



 
 
extern MIBDid_t mssp4fTopologyTable_Did;

   
typedef struct
{
	unsigned int	mssp4fRingId[TTT];                          
	unsigned int	mssp4fSumOfNodes;
	unsigned int	mssp4fNodeId0;
	unsigned int	mssp4fNodeId1;
	unsigned int	mssp4fNodeId2;
	unsigned int	mssp4fNodeId3;
	unsigned int	mssp4fNodeId4;
	unsigned int	mssp4fNodeId5;
	unsigned int	mssp4fNodeId6;
	unsigned int	mssp4fNodeId7;
	unsigned int	mssp4fNodeId8;
	unsigned int	mssp4fNodeId9;
	unsigned int	mssp4fNodeId10;
	unsigned int	mssp4fNodeId11;
	unsigned int	mssp4fNodeId12;
	unsigned int	mssp4fNodeId13;
	unsigned int	mssp4fNodeId14;
	unsigned int	mssp4fNodeId15;
	unsigned int	mssp4fNodeIp0;
	unsigned int	mssp4fNodeIp1;
	unsigned int	mssp4fNodeIp2;
	unsigned int	mssp4fNodeIp3;
	unsigned int	mssp4fNodeIp4;
	unsigned int	mssp4fNodeIp5;
	unsigned int	mssp4fNodeIp6;
	unsigned int	mssp4fNodeIp7;
	unsigned int	mssp4fNodeIp8;
	unsigned int	mssp4fNodeIp9;
	unsigned int	mssp4fNodeIp10;
	unsigned int	mssp4fNodeIp11;
	unsigned int	mssp4fNodeIp12;
	unsigned int	mssp4fNodeIp13;
	unsigned int	mssp4fNodeIp14;
	unsigned int	mssp4fNodeIp15;
}MIBmssp4fTopologyTable_t;









































 



 
 
extern MIBDid_t mssp4fCommandTable_Did;

   
typedef enum {
	mssp4fCommandCurrentSide_west[TTT]=0,
	mssp4fCommandCurrentSide_east=1
} mssp4fCommandCurrentSide_Tval;

typedef enum {
	mssp4fCommand_exerciseRing[TTT]=3,
	mssp4fCommand_exerciseSpan=4,
	mssp4fCommand_manualSwitchRing=6,
	mssp4fCommand_manualSwitchSpan=7,
	mssp4fCommand_forcedSwitchRing=13,
	mssp4fCommand_forcedSwitchSpan=14,
	mssp4fCommand_lockoutProtection=15,
	mssp4fCommand_clear=21,
	mssp4fCommand_noCommand=23
} mssp4fCommand_Tval;

typedef struct
{
	unsigned int	mssp4fRingId[TTT];                                          
	mssp4fCommandCurrentSide_Tval mssp4fCommandCurrentSide;             
	mssp4fCommand_Tval mssp4fCommand;
	char		mssp4fLastCommandStatus[64];   
}MIBmssp4fCommandTable_t;











 



 
 
extern MIBDid_t mssp4fNodeStatusTable_Did;

   
typedef enum {
	mssp4fNodeAgentState_init[TTT]=0,
	mssp4fNodeAgentState_ready=1,
	mssp4fNodeAgentState_suspend=2
} mssp4fNodeAgentState_Tval;

typedef enum {
	mssp4fNodeState_idle[TTT]=0,
	mssp4fNodeState_passthough=1,
	mssp4fNodeState_switching=2,
	mssp4fNodeState_isolated=3
} mssp4fNodeState_Tval;

typedef enum {
	mssp4fNodeCurrentSide_west[TTT]=0,
	mssp4fNodeCurrentSide_east=1
} mssp4fNodeCurrentSide_Tval;

typedef enum {
	mssp4fNodeCurrentReq_idle[TTT]=0,
	mssp4fNodeCurrentReq_bridge=1,
	mssp4fNodeCurrentReq_bridgeAndSwitch=2,
	mssp4fNodeCurrentReq_passthrough=3
} mssp4fNodeCurrentReq_Tval;

typedef enum {
	mssp4fNodeCurrentSrc_kByte[TTT]=0,
	mssp4fNodeCurrentSrc_line=1,
	mssp4fNodeCurrentSrc_external=2
} mssp4fNodeCurrentSrc_Tval;

typedef enum {
	mssp4fNodeKExpressMode_autoLocal[TTT]=0,
	mssp4fNodeKExpressMode_autoExpress=1,
	mssp4fNodeKExpressMode_forceExpress=2,
	mssp4fNodeKExpressMode_forceLocal=3
} mssp4fNodeKExpressMode_Tval;

typedef struct
{
	unsigned int	mssp4fRingId[TTT];                                        
	mssp4fNodeAgentState_Tval mssp4fNodeAgentState;
	mssp4fNodeState_Tval mssp4fNodeState;   
	mssp4fNodeCurrentSide_Tval mssp4fNodeCurrentSide;
	mssp4fNodeCurrentReq_Tval mssp4fNodeCurrentReq;
	mssp4fNodeCurrentSrc_Tval mssp4fNodeCurrentSrc;
	mssp4fNodeKExpressMode_Tval mssp4fNodeKExpressMode;
	Mssp4fSwitchCommand_Tval mssp4fWestSwitchCommand;
	Mssp4fLineRequest_Tval mssp4fWestLineReq;
	Mssp4fSwitchCommand_Tval mssp4fWestLastSwitchCmd;
	int		mssp4fWestSwitchStatus_len;
	char		mssp4fWestSwitchStatus[64];   
	unsigned int	mssp4fWestK1byteInput;
	unsigned int	mssp4fWestK2byteInput;
	unsigned int	mssp4fWestK1byteOutput;
	unsigned int	mssp4fWestK2byteOutput;
	Mssp4fSwitchCommand_Tval mssp4fEastSwitchCommand;
	Mssp4fLineRequest_Tval mssp4fEastLineReq;
	Mssp4fSwitchCommand_Tval mssp4fEastLastSwitchCmd;
	int		mssp4fEastSwitchStatus_len;
	char		mssp4fEastSwitchStatus[64];   
	unsigned int	mssp4fEastK1byteInput;
	unsigned int	mssp4fEastK2byteInput;
	unsigned int	mssp4fEastK1byteOutput;
	unsigned int	mssp4fEastK2byteOutput;
	unsigned int	mssp4fPassNodeId;
}MIBmssp4fNodeStatusTable_t;































 



 
 
extern MIBDid_t mssp4fAutoMappingTable_Did;

   
typedef struct
{
	unsigned int	mssp4fRingId[TTT];                                                
	unsigned int	mssp4fNodeId;                                                
	int		mssp4fWestWorkMappingString_len;
	char		mssp4fWestWorkMappingString[192];
	int		mssp4fEastWorkMappingString_len;
	char		mssp4fEastWorkMappingString[192];
	RowStatus_Tval mssp4fAutomappingRowStatus;
}MIBmssp4fAutoMappingTable_t;












 



 
 
extern MIBDid_t mssp4fXcTable_Did;

   
typedef enum {
	mssp4fXcSide_west[TTT]=0,
	mssp4fXcSide_east=1,
	mssp4fXcSide_both=2
} mssp4fXcSide_Tval;

typedef enum {
	mssp4fXcOrder_au4clear[TTT]=0,
	mssp4fXcOrder_au44c=1,
	mssp4fXcOrder_au416c=2,
	mssp4fXcOrder_au464c=3
} mssp4fXcOrder_Tval;

typedef enum {
	mssp4fXcType_adddrop[TTT]=0,
	mssp4fXcType_passthrough=1,
	mssp4fXcType_nonrelated=2,
	mssp4fXcType_invalid=3
} mssp4fXcType_Tval;

typedef struct
{
	unsigned int	mssp4fRingId[TTT];                          
	unsigned int	mssp4fNodeId;                          
	mssp4fXcSide_Tval mssp4fXcSide;                     
	unsigned int	mssp4fXcTimeSlot;                      
	mssp4fXcOrder_Tval mssp4fXcOrder;
	mssp4fXcType_Tval mssp4fXcType;
}MIBmssp4fXcTable_t;













 



 
 
extern MIBDid_t pbSncpConfigTable_Did;

   
typedef struct
{
	PbXcCapacity_Tval[TTT] pbSncpTPType;                                            
	PbSlotNumberType_Tval pbSncpWorkChSlotNum;                                 
	PbPortType_Tval pbSncpWorkChPortType;                                   
	int		pbSncpWorkChPortNum;                                                  
	int		pbSncpWorkSource;                                                     
	PbSlotNumberType_Tval pbSncpProtectChSlotNum;                              
	PbPortType_Tval pbSncpProtectChPortType;                                
	int		pbSncpProtectChPortNum;                                               
	int		pbSncpProtectSource;                                                  
	PbSlotNumberType_Tval pbSncpSrcOrDstSlotNum;                               
	PbPortType_Tval pbSncpSrcOrDstPortType;                                    
	int		pbSncpSrcOrDstPortNum;                                                
	int		pbSncpSrcOrDstSource;                                                 
	PbSNCPSignalDirection_Tval pbSncpSignalDircetion;                          
	int		pbSncpGroupId;   
	PbSNCPChannelState_Tval pbSncpWorkChState;   
	PbSNCPExternalCmd_Tval pbSncpExternalCmd;   
	PbSNCPExCmdRslt_Tval pbSncpExCmdRslt;   
	PbSNCPCurrentReq_Tval pbSncpCurSwitchReq;   
	PbSNCPSwitchReason_Tval pbSncpSwitchReason;   
	unsigned int	pbSncpHoldOffTime;   
	PbSNCPRestoreMode_Tval pbSncpRestoreMode;   
	unsigned int	pbSncpWTR;   
	PBSNCPSignalState_Tval pbSncpWorkSignalState;   
	PBSNCPSignalState_Tval pbSncpProtectSignalState;   
	RowStatus_Tval pbSncpRowStatus;   
	char		pbSncpLable[64];   
	PBSNCPAddRslt_Tval pbSncpAddRslt;   
	unsigned int	pbDNIId;   
	PBSNCPIntrusive_Tval pbSncpIntrusive;   
	int		pbSncpWorkGmplsVcNumber;   
	char		pbSncpWorkGmplsCallName[255];   
	int		pbSncpProtectGmplsVcNumber;   
	char		pbSncpProtectGmplsCallName[255];   
	PBSNCPWorkorProtToCC_Tval pbSncpWorkorProtToCC;   
	PbSncpCircuitDirection_Tval pbSncpDirection;   
	PbSncpFrom_Tval pbSncpFrom;   
	PbGmplsSncpDirection_Tval pbGmplsSncpDirection;   
	PBSNCPAction_Tval pbSncpAction;   
}MIBpbSncpConfigTable_t;














































 



 
 
extern MIBDid_t pbSncpStateTable_Did;

   
typedef struct
{
	int		pbSncpStateLineId[TTT];                                                    
	char		pbSncpDetailedStateString1[255];   
	char		pbSncpDetailedStateString2[255];   
	char		pbSncpDetailedStateString3[255];   
	char		pbSncpDetailedStateString4[255];   
}MIBpbSncpStateTable_t;












 



 
 
extern MIBDid_t pbDpnpConfigTable_Did;

   
typedef struct
{
	PbXcCapacity_Tval[TTT] pbDpnpTPType;                                         
	PbSlotNumberType_Tval pbDpnpDstSlotNum;                                 
	PbPortType_Tval pbDpnpDstPortType;                                      
	int		pbDpnpDstPortNum;                                                  
	int		pbDpnpDstSource;                                                   
	PbSlotNumberType_Tval pbVSncpWorkChSlotNum;                             
	PbPortType_Tval pbVSncpWorkChPortType;                                  
	int		pbVSncpWorkChPortNum;                                              
	int		pbVSncpWorkSource;                                                 
	PbSlotNumberType_Tval pbVSncpProtectChSlotNum;                          
	PbPortType_Tval pbVSncpProtectChPortType;                               
	int		pbVSncpProtectChPortNum;                                           
	int		pbVSncpProtectSource;                                              
	PbSlotNumberType_Tval pbVMsspringWorkChSlotNum;                         
	PbPortType_Tval pbVMsspringWorkChPortType;                              
	int		pbVMsspringWorkChPortNum;                                          
	int		pbVMsspringWorkSource;                                             
	PbSNCPSignalDirection_Tval pbDpnpSignalDircetion;                       
	int		pbDpnpGroupId;
	PbSNCPChannelState_Tval pbDpnpWorkChState;
	PbSNCPExternalCmd_Tval pbDpnpExternalCmd;
	PbSNCPExCmdRslt_Tval pbDpnpExCmdRslt;
	PbSNCPCurrentReq_Tval pbDpnpCurSwitchReq;
	PbSNCPSwitchReason_Tval pbDpnpSwitchReason;
	unsigned int	pbDpnpHoldOffTime;
	PbSNCPRestoreMode_Tval pbDpnpRestoreMode;
	unsigned int	pbDpnpWTR;
	PBSNCPSignalState_Tval pbDpnpWorkSignalState;
	PBSNCPSignalState_Tval pbDpnpProtectSignalState;
	PBSNCPSignalState_Tval pbDpnpVMsspringSignalState;
	RowStatus_Tval pbDpnpRowStatus;
	char		pbDpnpLable[64];
	PBSNCPAddRslt_Tval pbDpnpAddRslt;
	unsigned int	pbDpnpDNIId;
	PBSNCPIntrusive_Tval pbDpnpIntrusive;
	PbSncpCircuitDirection_Tval pbDpnpDirection;
	PbSncpFrom_Tval pbDpnpFrom;
	PbDpnpSwitchEvent_Tval pbDpnpSwitchEvent;
	PbGmplsSncpDirection_Tval pbGmplsDpnpDirection;
}MIBpbDpnpConfigTable_t;














































 



 
 
extern MIBDid_t pbDpnpStateTable_Did;

   
typedef struct
{
	int		pbDpnpStateLineId[TTT];                                                 
	char		pbDpnpDetailedStateString1[255];
	char		pbDpnpDetailedStateString2[255];
	char		pbDpnpDetailedStateString3[255];
	char		pbDpnpDetailedStateString4[255];
}MIBpbDpnpStateTable_t;












 



 
extern MIBDid_t pbSncpExtendParaGroup_Did;

   
typedef struct
{
	unsigned int	pbLoSncpWTR[TTT];
	unsigned int	pbLoSncpHoldOffTime;
}MIBpbSncpExtendParaGroup_t;







 



 
 
extern MIBDid_t pbMspConfigTable_Did;

   
typedef struct
{
	PbPortType_Tval[TTT] pbMspGroupActPortType;                                
	PbSlotNumberType_Tval pbMspProtectChSlotNum;                             
	int		pbMspProtectChPortNum;                                              
	PbPortType_Tval pbMspProtectChPortType;
	PBMSPSignalState_Tval pbMspProtectChSignalState;
	int		pbMspGroupId;   
	PBMSPType_Tval pbMspType;   
	PbMSPSignalDirection_Tval pbMspSignalDircetion;   
	PbMSPRestoreMode_Tval pbMspRestoreMode;   
	TruthValue_Tval pbMspExTrafficEnable;
	TruthValue_Tval pbMspEnable;
	PbMSPExternalCmd_Tval pbMspExternalCmd;   
	PbMspChNumberType_Tval pbMspExtCmdParam;
	PbMSPExCmdRslt_Tval pbMspExCmdRslt;   
	PbMspChNumberType_Tval pbMspSwitchState;
	PbMSPCurrentReq_Tval pbMspCurSwitchReq;   
	PbMSPSwitchReason_Tval pbMspSwitchReason;   
	unsigned int	pbMspWTR;   
	int		pbMspWorkChNum;
	PbSlotNumberType_Tval pbMspWorkCh1SlotNum;
	int		pbMspWorkCh1PortNum;
	PbPortType_Tval pbMspWorkCh1PortType;
	PBMSPSignalState_Tval pbMspWorkCh1SignalState;
	PBMSPChPriState_Tval pbMspWorkCh1PriState;
	PbSlotNumberType_Tval pbMspWorkCh2SlotNum;
	int		pbMspWorkCh2PortNum;
	PbPortType_Tval pbMspWorkCh2PortType;
	PBMSPSignalState_Tval pbMspWorkCh2SignalState;
	PBMSPChPriState_Tval pbMspWorkCh2PriState;
	PbSlotNumberType_Tval pbMspWorkCh3SlotNum;
	int		pbMspWorkCh3PortNum;
	PbPortType_Tval pbMspWorkCh3PortType;
	PBMSPSignalState_Tval pbMspWorkCh3SignalState;
	PBMSPChPriState_Tval pbMspWorkCh3PriState;
	PbSlotNumberType_Tval pbMspWorkCh4SlotNum;
	int		pbMspWorkCh4PortNum;
	PbPortType_Tval pbMspWorkCh4PortType;
	PBMSPSignalState_Tval pbMspWorkCh4SignalState;
	PBMSPChPriState_Tval pbMspWorkCh4PriState;
	PbSlotNumberType_Tval pbMspWorkCh5SlotNum;
	int		pbMspWorkCh5PortNum;
	PbPortType_Tval pbMspWorkCh5PortType;
	PBMSPSignalState_Tval pbMspWorkCh5SignalState;
	PBMSPChPriState_Tval pbMspWorkCh5PriState;
	PbSlotNumberType_Tval pbMspWorkCh6SlotNum;
	int		pbMspWorkCh6PortNum;
	PbPortType_Tval pbMspWorkCh6PortType;
	PBMSPSignalState_Tval pbMspWorkCh6SignalState;
	PBMSPChPriState_Tval pbMspWorkCh6PriState;
	PbSlotNumberType_Tval pbMspWorkCh7SlotNum;
	int		pbMspWorkCh7PortNum;
	PbPortType_Tval pbMspWorkCh7PortType;
	PBMSPSignalState_Tval pbMspWorkCh7SignalState;
	PBMSPChPriState_Tval pbMspWorkCh7PriState;
	PbSlotNumberType_Tval pbMspWorkCh8SlotNum;
	int		pbMspWorkCh8PortNum;
	PbPortType_Tval pbMspWorkCh8PortType;
	PBMSPSignalState_Tval pbMspWorkCh8SignalState;
	PBMSPChPriState_Tval pbMspWorkCh8PriState;
	PbSlotNumberType_Tval pbMspWorkCh9SlotNum;
	int		pbMspWorkCh9PortNum;
	PbPortType_Tval pbMspWorkCh9PortType;
	PBMSPSignalState_Tval pbMspWorkCh9SignalState;
	PBMSPChPriState_Tval pbMspWorkCh9PriState;
	PbSlotNumberType_Tval pbMspWorkCh10SlotNum;
	int		pbMspWorkCh10PortNum;
	PbPortType_Tval pbMspWorkCh10PortType;
	PBMSPSignalState_Tval pbMspWorkCh10SignalState;
	PBMSPChPriState_Tval pbMspWorkCh10PriState;
	PbSlotNumberType_Tval pbMspWorkCh11SlotNum;
	int		pbMspWorkCh11PortNum;
	PbPortType_Tval pbMspWorkCh11PortType;
	PBMSPSignalState_Tval pbMspWorkCh11SignalState;
	PBMSPChPriState_Tval pbMspWorkCh11PriState;
	PbSlotNumberType_Tval pbMspWorkCh12SlotNum;
	int		pbMspWorkCh12PortNum;
	PbPortType_Tval pbMspWorkCh12PortType;
	PBMSPSignalState_Tval pbMspWorkCh12SignalState;
	PBMSPChPriState_Tval pbMspWorkCh12PriState;
	PbSlotNumberType_Tval pbMspWorkCh13SlotNum;
	int		pbMspWorkCh13PortNum;
	PbPortType_Tval pbMspWorkCh13PortType;
	PBMSPSignalState_Tval pbMspWorkCh13SignalState;
	PBMSPChPriState_Tval pbMspWorkCh13PriState;
	PbSlotNumberType_Tval pbMspWorkCh14SlotNum;
	int		pbMspWorkCh14PortNum;
	PbPortType_Tval pbMspWorkCh14PortType;
	PBMSPSignalState_Tval pbMspWorkCh14SignalState;
	PBMSPChPriState_Tval pbMspWorkCh14PriState;
	TruthValue_Tval pbMspK2Bit5Mismatch;   
	TruthValue_Tval pbMspK1Bit1to4Mismatch;   
	TruthValue_Tval pbMspK1Bit5to8Mismatch;   
	int		pbMspReceiveK1;   
	int		pbMspReceiveK2;   
	int		pbMspSendoutK1;   
	int		pbMspSendoutK2;   
	RowStatus_Tval pbMspRowStatus;   
	TruthValue_Tval pbMspFreeze;
	char		pbMspLable[255];   
}MIBpbMspConfigTable_t;










































































































 



 
 
extern MIBDid_t pbMSMConfigTable_Did;

   
typedef enum {
	pbMSMProtectMode_none[TTT]=1,
	pbMSMProtectMode_msspring=2,
	pbMSMProtectMode_ulsr=3
} pbMSMProtectMode_Tval;

typedef enum {
	pbMSMConfigSdBerThreshold_ber10_5[TTT]=1,
	pbMSMConfigSdBerThreshold_ber10_6=2,
	pbMSMConfigSdBerThreshold_ber10_7=3,
	pbMSMConfigSdBerThreshold_ber10_8=4,
	pbMSMConfigSdBerThreshold_ber10_9=5,
	pbMSMConfigSdBerThreshold_global_sd=6
} pbMSMConfigSdBerThreshold_Tval;

typedef enum {
	pbMSMConfigSfBerThreshold_ber10_3[TTT]=1,
	pbMSMConfigSfBerThreshold_ber10_4=2,
	pbMSMConfigSfBerThreshold_ber10_5=3,
	pbMSMConfigSfBerThreshold_global_sf=4
} pbMSMConfigSfBerThreshold_Tval;

typedef enum {
	pbMSMCardFunction_none[TTT]=0,
	pbMSMCardFunction_stm_4=4,
	pbMSMCardFunction_stm_16=16,
	pbMSMCardFunction_stm_64=64
} pbMSMCardFunction_Tval;

typedef struct
{
	int		pbMSMSNMRingId[TTT];                                                     
	pbMSMProtectMode_Tval pbMSMProtectMode;   
	char		pbMSMSNMRingName[64];   
	int		pbMSMRingIdx;   
	PbSlotNumberType_Tval pbMSMWestSideSlotNum;   
	PbPortType_Tval pbMSMWestSidePortType;   
	int		pbMSMWestSidePortNum;   
	PbSlotNumberType_Tval pbMSMWestProtSlotNum;
	PbPortType_Tval pbMSMWestProtPortType;
	int		pbMSMWestProtPortNum;
	PbSlotNumberType_Tval pbMSMEastSideSlotNum;   
	PbPortType_Tval pbMSMEastSidePortType;   
	int		pbMSMEastSidePortNum;   
	PbSlotNumberType_Tval pbMSMEastProtSlotNum;
	PbPortType_Tval pbMSMEastProtPortType;
	int		pbMSMEastProtPortNum;
	PbOnOff_Tval pbMSMAutoSquelchDiscovery;
	PbOnOff_Tval pbMSMAutoRingDiscovery;
	unsigned int	pbMSMPeerWestAddress;   
	int		pbMSMPeerWestSlotNum;   
	int		pbMSMPeerWestPortType;   
	int		pbMSMPeerWestPortNum;   
	unsigned int	pbMSMPeerEastAddress;   
	int		pbMSMPeerEastSlotNum;   
	int		pbMSMPeerEastPortType;   
	int		pbMSMPeerEastPortNum;   
	pbMSMConfigSdBerThreshold_Tval pbMSMConfigSdBerThreshold;
	pbMSMConfigSfBerThreshold_Tval pbMSMConfigSfBerThreshold;
	int		pbMSMConfigWaitToRestore;   
	PbOnOff_Tval pbMSMConfigExtraTraffic;
	TruthValue_Tval pbMSMConfigEnable;   
	TruthValue_Tval pbMSMConfigDelete;   
	TruthValue_Tval pbMSMSquelchFin;
	pbMSMCardFunction_Tval pbMSMCardFunction;   
	char		pbMSMChannelInfo[255];   
	unsigned int	pbMSMSelfAddress;   
	TruthValue_Tval pbMSMStartAutoSquelch;   
	TruthValue_Tval pbMSMAutoMappingEnable;   
	PbEnableDisable_Tval pbMSMPortMapRefresh;   
}MIBpbMSMConfigTable_t;














































 



 
 
extern MIBDid_t pbMSMStatusTable_Did;

   
typedef enum {
	pbMSMSide_west[TTT]=0,
	pbMSMSide_east=1
} pbMSMSide_Tval;

typedef enum {
	pbMSMTransBridgeReq_noRequest[TTT]=0,
	pbMSMTransBridgeReq_reverseRequestRing=1,
	pbMSMTransBridgeReq_reverseRequestSpan=2,
	pbMSMTransBridgeReq_exerciserRing=3,
	pbMSMTransBridgeReq_exerciserSpan=4,
	pbMSMTransBridgeReq_waitToRestore=5,
	pbMSMTransBridgeReq_manualSwitchRing=6,
	pbMSMTransBridgeReq_manualSwitchSpan=7,
	pbMSMTransBridgeReq_signalDegradeRing=8,
	pbMSMTransBridgeReq_signalDegradeSpan=9,
	pbMSMTransBridgeReq_signalDegradeProtection=10,
	pbMSMTransBridgeReq_signalFailRing=11,
	pbMSMTransBridgeReq_signalFailSpan=12,
	pbMSMTransBridgeReq_forcedSwitchRing=13,
	pbMSMTransBridgeReq_forcedSwitchSpan=14,
	pbMSMTransBridgeReq_lockoutProtection=15
} pbMSMTransBridgeReq_Tval;

typedef enum {
	pbMSMTransLongShort_shortPath[TTT]=0,
	pbMSMTransLongShort_longPath=1
} pbMSMTransLongShort_Tval;

typedef enum {
	pbMSMTransStatus_idle[TTT]=0,
	pbMSMTransStatus_bridged=1,
	pbMSMTransStatus_bridgedAndSwitched=2,
	pbMSMTransStatus_extraTraffic=3,
	pbMSMTransStatus_msRDI=6,
	pbMSMTransStatus_msAIS=7
} pbMSMTransStatus_Tval;

typedef enum {
	pbMSMReceiveBridgeReq_noRequest[TTT]=0,
	pbMSMReceiveBridgeReq_reverseRequestRing=1,
	pbMSMReceiveBridgeReq_reverseRequestSpan=2,
	pbMSMReceiveBridgeReq_exerciserRing=3,
	pbMSMReceiveBridgeReq_exerciserSpan=4,
	pbMSMReceiveBridgeReq_waitToRestore=5,
	pbMSMReceiveBridgeReq_manualSwitchRing=6,
	pbMSMReceiveBridgeReq_manualSwitchSpan=7,
	pbMSMReceiveBridgeReq_signalDegradeRing=8,
	pbMSMReceiveBridgeReq_signalDegradeSpan=9,
	pbMSMReceiveBridgeReq_signalDegradeProtection=10,
	pbMSMReceiveBridgeReq_signalFailRing=11,
	pbMSMReceiveBridgeReq_signalFailSpan=12,
	pbMSMReceiveBridgeReq_forcedSwitchRing=13,
	pbMSMReceiveBridgeReq_forcedSwitchSpan=14,
	pbMSMReceiveBridgeReq_lockoutProtection=15
} pbMSMReceiveBridgeReq_Tval;

typedef enum {
	pbMSMReceiveLongShort_shortPath[TTT]=0,
	pbMSMReceiveLongShort_longPath=1
} pbMSMReceiveLongShort_Tval;

typedef enum {
	pbMSMReceiveStatus_idle[TTT]=0,
	pbMSMReceiveStatus_bridged=1,
	pbMSMReceiveStatus_bridgedAndSwitched=2,
	pbMSMReceiveStatus_extraTraffic=3,
	pbMSMReceiveStatus_msRDI=6,
	pbMSMReceiveStatus_msAIS=7
} pbMSMReceiveStatus_Tval;

typedef enum {
	pbMSMSideReq_noRequest[TTT]=0,
	pbMSMSideReq_reverseRequestRing=1,
	pbMSMSideReq_reverseRequestSpan=2,
	pbMSMSideReq_exerciserRing=3,
	pbMSMSideReq_exerciserSpan=4,
	pbMSMSideReq_waitToRestore=5,
	pbMSMSideReq_manualSwitchRing=6,
	pbMSMSideReq_manualSwitchSpan=7,
	pbMSMSideReq_signalDegradeRing=8,
	pbMSMSideReq_signalDegradeSpan=9,
	pbMSMSideReq_signalDegradeProtection=10,
	pbMSMSideReq_signalFailRing=11,
	pbMSMSideReq_signalFailSpan=12,
	pbMSMSideReq_forcedSwitchRing=13,
	pbMSMSideReq_forcedSwitchSpan=14,
	pbMSMSideReq_lockoutProtection=15,
	pbMSMSideReq_reset=20,
	pbMSMSideReq_clear=21,
	pbMSMSideReq_lockoutService=22
} pbMSMSideReq_Tval;

typedef enum {
	pbMSMSideSrc_kByte[TTT]=0,
	pbMSMSideSrc_line=1,
	pbMSMSideSrc_external=2
} pbMSMSideSrc_Tval;

typedef enum {
	pbMSMSwitchCommand_idle[TTT]=0,
	pbMSMSwitchCommand_bridge=1,
	pbMSMSwitchCommand_bridgeAndSwitch=2,
	pbMSMSwitchCommand_passthough=3
} pbMSMSwitchCommand_Tval;

typedef enum {
	pbMSMLineReq_signalDegradeRing[TTT]=8,
	pbMSMLineReq_signalFailRing=11,
	pbMSMLineReq_clear=21
} pbMSMLineReq_Tval;

typedef enum {
	pbMSMCmndReq_manualSwitchRing[TTT]=6,
	pbMSMCmndReq_forcedSwitchRing=13,
	pbMSMCmndReq_lockoutProtection=15,
	pbMSMCmndReq_reset=21
} pbMSMCmndReq_Tval;

typedef struct
{
	int		pbMSMSNMRingId[TTT];                                            
	pbMSMSide_Tval pbMSMSide;                                          
	pbMSMTransBridgeReq_Tval pbMSMTransBridgeReq;   
	int		pbMSMTransDestNodeId;   
	int		pbMSMTransSrcNodeId;   
	pbMSMTransLongShort_Tval pbMSMTransLongShort;   
	pbMSMTransStatus_Tval pbMSMTransStatus;   
	pbMSMReceiveBridgeReq_Tval pbMSMReceiveBridgeReq;   
	int		pbMSMReceiveDestNodeId;   
	int		pbMSMReceiveSrcNodeId;   
	pbMSMReceiveLongShort_Tval pbMSMReceiveLongShort;   
	pbMSMReceiveStatus_Tval pbMSMReceiveStatus;   
	pbMSMSideReq_Tval pbMSMSideReq;   
	pbMSMSideSrc_Tval pbMSMSideSrc;   
	pbMSMSwitchCommand_Tval pbMSMSwitchCommand;   
	pbMSMLineReq_Tval pbMSMLineReq;   
	pbMSMCmndReq_Tval pbMSMCmndReq;   
	TruthValue_Tval pbMSMIsSquelched;   
}MIBpbMSMStatusTable_t;

























 



 
 
extern MIBDid_t pbMSMNodeStatusTable_Did;

   
typedef enum {
	pbMSMNodeKExpressMode_autoLocal[TTT]=0,
	pbMSMNodeKExpressMode_autoExpress=1,
	pbMSMNodeKExpressMode_forceExpress=2,
	pbMSMNodeKExpressMode_forceLocal=3
} pbMSMNodeKExpressMode_Tval;

typedef struct
{
	int		pbMSMSNMRingId[TTT];                                            
	PbMsspAgentState_Tval pbMSMNodeAgentState;   
	PbMsspNodeState_Tval pbMSMNodeState;   
	PbMsspNodeSide_Tval pbMSMNodeCurrentSide;   
	PbMsspRequest_Tval pbMSMNodeCurrentReq;   
	PbMsspRequestSource_Tval pbMSMNodeCurrentSrc;   
	pbMSMNodeKExpressMode_Tval pbMSMNodeKExpressMode;   
	PbMsspRequest_Tval pbMSMEastSwitchCommand;   
	PbMsspLineRequest_Tval pbMSMEastLineReq;   
	PbMsspRequest_Tval pbMSMEastLastSwitchCmd;   
	TruthValue_Tval pbMSMEastIsSquelched;   
	PbMsspRequest_Tval pbMSMWestSwitchCommand;   
	PbMsspLineRequest_Tval pbMSMWestLineReq;   
	PbMsspRequest_Tval pbMSMWestLastSwitchCmd;   
	TruthValue_Tval pbMSMWestIsSquelched;   
	PbMsspSwitchStatus_Tval pbMSMEastSwitchStatus;   
	PbMsspSwitchStatus_Tval pbMSMWestSwitchStatus;   
	int		pbMSMPassNodeId;   
}MIBpbMSMNodeStatusTable_t;

























 



 
 
extern MIBDid_t pbMSMTopoConfigTable_Did;

   
typedef enum {
	pbMSMTopoStatus_unconfigured[TTT]=0,
	pbMSMTopoStatus_closed=1,
	pbMSMTopoStatus_open=2,
	pbMSMTopoStatus_locallyMisconfigured=3,
	pbMSMTopoStatus_remotelyMisconfigured=4
} pbMSMTopoStatus_Tval;

typedef enum {
	pbMSMTopoConfig_unsuspend[TTT]=1,
	pbMSMTopoConfig_suspend=2
} pbMSMTopoConfig_Tval;

typedef struct
{
	int		pbMSMSNMRingId[TTT];                                                    
	int		pbMSMTopoNumOfNodes;   
	int		pbMSMTopoNodeId0;   
	int		pbMSMTopoNodeId1;   
	int		pbMSMTopoNodeId2;   
	int		pbMSMTopoNodeId3;   
	int		pbMSMTopoNodeId4;   
	int		pbMSMTopoNodeId5;   
	int		pbMSMTopoNodeId6;   
	int		pbMSMTopoNodeId7;   
	int		pbMSMTopoNodeId8;   
	int		pbMSMTopoNodeId9;   
	int		pbMSMTopoNodeId10;   
	int		pbMSMTopoNodeId11;   
	int		pbMSMTopoNodeId12;   
	int		pbMSMTopoNodeId13;   
	int		pbMSMTopoNodeId14;   
	int		pbMSMTopoNodeId15;   
	pbMSMTopoStatus_Tval pbMSMTopoStatus;   
	pbMSMTopoConfig_Tval pbMSMTopoConfig;   
	unsigned int	pbMSMTopoNodeId0IpAddress;   
	unsigned int	pbMSMTopoNodeId1IpAddress;   
	unsigned int	pbMSMTopoNodeId2IpAddress;   
	unsigned int	pbMSMTopoNodeId3IpAddress;   
	unsigned int	pbMSMTopoNodeId4IpAddress;   
	unsigned int	pbMSMTopoNodeId5IpAddress;   
	unsigned int	pbMSMTopoNodeId6IpAddress;   
	unsigned int	pbMSMTopoNodeId7IpAddress;   
	unsigned int	pbMSMTopoNodeId8IpAddress;   
	unsigned int	pbMSMTopoNodeId9IpAddress;   
	unsigned int	pbMSMTopoNodeId10IpAddress;   
	unsigned int	pbMSMTopoNodeId11IpAddress;   
	unsigned int	pbMSMTopoNodeId12IpAddress;   
	unsigned int	pbMSMTopoNodeId13IpAddress;   
	unsigned int	pbMSMTopoNodeId14IpAddress;   
	unsigned int	pbMSMTopoNodeId15IpAddress;   
}MIBpbMSMTopoConfigTable_t;











































 



 
 
extern MIBDid_t pbMSMSquelchTable_Did;

   
typedef enum {
	pbMSMSquelchType_none[TTT]=0,
	pbMSMSquelchType_add=1,
	pbMSMSquelchType_drop=2,
	pbMSMSquelchType_passthrough=3
} pbMSMSquelchType_Tval;

typedef struct
{
	int		pbMSMSNMRingId[TTT];                                            
	PbMsspNodeSide_Tval pbMSMSquelchSide;                              
	PbMsspTrafficDirection_Tval pbMSMSquelchGress;                     
	int		pbMSMSquelchTimeSlot;                                         
	PbMsspTrafficOrder_Tval pbMSMSquelchOrder;   
	pbMSMSquelchType_Tval pbMSMSquelchType;   
	int		pbMSMSquelchSrcNodeId;   
	int		pbMSMSquelchDstNodeId;   
	int		pbMSMSquelchReference;   
	int		pbMSMSquelchOpTimeSlot;   
	RowStatus_Tval pbMSMSquelchRowStatus;   
}MIBpbMSMSquelchTable_t;


















 



 
 
extern MIBDid_t pbMSMCommandTable_Did;

   
typedef enum {
	pbMSMCommandResult_unknown[TTT]=0,
	pbMSMCommandResult_success=1,
	pbMSMCommandResult_fail=2
} pbMSMCommandResult_Tval;

typedef struct
{
	int		pbMSMSNMRingId[TTT];                                              
	PbMsspNodeSide_Tval pbMSMCommandCurrentSide;                         
	PbMsspExternalCommand_Tval pbMSMCommandSwitch;   
	char		pbMSMLastCommandStatus[64];   
	pbMSMCommandResult_Tval pbMSMCommandResult;   
}MIBpbMSMCommandTable_t;












 



 
 
extern MIBDid_t pbAutoMappingTable_Did;

   
typedef struct
{
	int		pbMSMSNMRingId[TTT];                                            
	int		pbAutoNodeId;                                                 
	int		pbPortMappingString_len;
	char		pbPortMappingString[768];   
	RowStatus_Tval pbAutoMappingRowStatus;   
}MIBpbAutoMappingTable_t;











 



 
 
extern MIBDid_t pbEpgTable_Did;

   
typedef enum {
	pbEpgType_onevsn[TTT]=1,
	pbEpgType_oneplusone=2
} pbEpgType_Tval;

typedef enum {
	pbEpgProtMode_none[TTT]=0,
	pbEpgProtMode_revertive=1,
	pbEpgProtMode_nonrevertive=2
} pbEpgProtMode_Tval;

typedef struct
{
	int		pbEpgId[TTT];                                                  
	PbBoardStyle_Tval pbEpgBoardType;   
	pbEpgType_Tval pbEpgType;   
	pbEpgProtMode_Tval pbEpgProtMode;   
	TruthValue_Tval pbEpgEnable;   
	PbEpgSwitchRequest_Tval pbEpgExtCmd;   
	int		pbEpgExtCmdParam;   
	PbEpgCmdResult_Tval pbEpgExtCmdResult;   
	int		pbEpgWtr;   
	PbEpgSwitchRequest_Tval pbEpgPreSwitchReason;   
	PbEpgSwitchRequest_Tval pbEpgCurRequest;   
	PbSlotNumberType_Tval pbEpgProtState;   
	int		pbEpgHoldOffTime;   
	PbSlotNumberType_Tval pbEpgProtSlotNum;   
	PbEpgFunctionCardStatus_Tval pbEpgProtSlotState;   
	PbSlotNumberType_Tval pbEpgWorkSlotNum1;   
	PbEpgFunctionCardStatus_Tval pbEpgWorkSlot1State;   
	PbSlotNumberType_Tval pbEpgWorkSlotNum2;   
	PbEpgFunctionCardStatus_Tval pbEpgWorkSlot2State;   
	PbSlotNumberType_Tval pbEpgWorkSlotNum3;   
	PbEpgFunctionCardStatus_Tval pbEpgWorkSlot3State;   
	PbSlotNumberType_Tval pbEpgWorkSlotNum4;   
	PbEpgFunctionCardStatus_Tval pbEpgWorkSlot4State;   
	PbSlotNumberType_Tval pbEpgWorkSlotNum5;   
	PbEpgFunctionCardStatus_Tval pbEpgWorkSlot5State;   
	PbSlotNumberType_Tval pbEpgWorkSlotNum6;   
	PbEpgFunctionCardStatus_Tval pbEpgWorkSlot6State;   
	PbSlotNumberType_Tval pbEpgWorkSlotNum7;   
	PbEpgFunctionCardStatus_Tval pbEpgWorkSlot7State;   
	PbSlotNumberType_Tval pbEpgWorkSlotNum8;   
	PbEpgFunctionCardStatus_Tval pbEpgWorkSlot8State;   
	RowStatus_Tval pbEpgRowStatus;   
}MIBpbEpgTable_t;







































 



 
 
extern MIBDid_t pbCpgTable_Did;

   
typedef enum {
	pbCpgProtectStatus_worker[TTT]=0,
	pbCpgProtectStatus_protector=1,
	pbCpgProtectStatus_na=2
} pbCpgProtectStatus_Tval;

typedef enum {
	pbCpgAct_none[TTT]=0,
	pbCpgAct_force_Worker=1,
	pbCpgAct_force_Protector=2,
	pbCpgAct_manual_Worker=3,
	pbCpgAct_manual_Protector=4,
	pbCpgAct_clear=5,
	pbCpgAct_lockout_protection=6
} pbCpgAct_Tval;

typedef enum {
	pbCpgActStatus_no_Request[TTT]=0,
	pbCpgActStatus_force_Worker=1,
	pbCpgActStatus_force_Protector=2,
	pbCpgActStatus_manual_Worker=3,
	pbCpgActStatus_manual_Protector=4,
	pbCpgActStatus_ufur_Worker=5,
	pbCpgActStatus_ufur_Protector=6,
	pbCpgActStatus_latchon_Worker=7,
	pbCpgActStatus_latchon_Protector=8,
	pbCpgActStatus_lockout_protection=9
} pbCpgActStatus_Tval;

typedef enum {
	pbCpgCurActStatus_no_Request[TTT]=0,
	pbCpgCurActStatus_force_Worker=1,
	pbCpgCurActStatus_force_Protector=2,
	pbCpgCurActStatus_manual_Worker=3,
	pbCpgCurActStatus_manual_Protector=4,
	pbCpgCurActStatus_ufur_Worker=5,
	pbCpgCurActStatus_ufur_Protector=6,
	pbCpgCurActStatus_latchon_Worker=7,
	pbCpgCurActStatus_latchon_Protector=8,
	pbCpgCurActStatus_lockout_protection=9
} pbCpgCurActStatus_Tval;

typedef struct
{
	int		pbCpgIndexNo[TTT];                                         
	PbSlotNumberType_Tval pbCpgWorkerSlot;   
	PbSlotNumberType_Tval pbCpgProtectorSlot;   
	pbCpgProtectStatus_Tval pbCpgProtectStatus;   
	PbCpgCardStatus_Tval pbWorkerStatus;   
	PbCpgCardStatus_Tval pbProtectorStatus;   
	pbCpgAct_Tval pbCpgAct;   
	pbCpgActStatus_Tval pbCpgActStatus;   
	pbCpgCurActStatus_Tval pbCpgCurActStatus;   
	TruthValue_Tval pbCpgReadyToSwitch;   
}MIBpbCpgTable_t;

















 



 
extern MIBDid_t scEpgGroup_Did;

   
typedef enum {
	scEpgRequest_clear[TTT]=0,
	scEpgRequest_lockout=1,
	scEpgRequest_manual_switch_to_sc1=2,
	scEpgRequest_manual_switch_to_sc2=3,
	scEpgRequest_no_Request=4
} scEpgRequest_Tval;

typedef enum {
	scEpgLastSwichReason_no_Request[TTT]=0,
	scEpgLastSwichReason_manual_switch_to_sc1=1,
	scEpgLastSwichReason_manual_switch_to_sc2=2,
	scEpgLastSwichReason_latchon_Switch=3,
	scEpgLastSwichReason_uf2_Switch=4,
	scEpgLastSwichReason_uf1_Switch=5,
	scEpgLastSwichReason_cr_Switch=6,
	scEpgLastSwichReason_lockout_protection=7
} scEpgLastSwichReason_Tval;

typedef enum {
	scEpgStandbySc_failed[TTT]=0,
	scEpgStandbySc_ok=1
} scEpgStandbySc_Tval;

typedef enum {
	scEpgASCSwithchState_no_switch[TTT]=0,
	scEpgASCSwithchState_begin_switch=1,
	scEpgASCSwithchState_end_switch=2
} scEpgASCSwithchState_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] scEpgScWorkerSlot;   
	int		scEpgSc1Status;   
	int		scEpgSc2Status;   
	scEpgRequest_Tval scEpgRequest;   
	scEpgLastSwichReason_Tval scEpgLastSwichReason;   
	scEpgStandbySc_Tval scEpgStandbySc;   
	scEpgASCSwithchState_Tval scEpgASCSwithchState;
}MIBscEpgGroup_t;












 



 
extern MIBDid_t pbSDHProtectionModule_Did;

   







 




 



 
extern MIBDid_t securityGlobalSettingGroup_Did;

   
typedef enum {
	securityTCBehavior_none[TTT]=1,
	securityTCBehavior_alarm=2,
	securityTCBehavior_disable_account=3
} securityTCBehavior_Tval;

typedef struct
{
	int		securityPasswordMinLen[TTT];   
	int		securityMaxInvalidLogin;   
	int		securityUnauthorizedAccessThreshold;   
	securityTCBehavior_Tval securityTCBehavior;   
}MIBsecurityGlobalSettingGroup_t;









 



 
extern MIBDid_t securityAlarmInhibitGroup_Did;

   
typedef struct
{
	PbEnableDisable_Tval[TTT] securityULEInhibit;   
	PbEnableDisable_Tval securityUAInhibit;   
	PbEnableDisable_Tval securityAEDInhibit;   
	PbEnableDisable_Tval securityLTWInhibit;   
	PbEnableDisable_Tval securityLFAInhibit;   
}MIBsecurityAlarmInhibitGroup_t;










 



 
extern MIBDid_t snmpSecurityGroup_Did;

   


 



 
extern MIBDid_t securityLogGroup_Did;

   
typedef enum {
	securityLogGetStatus_inactive[TTT]=0,
	securityLogGetStatus_getStarted=1,
	securityLogGetStatus_getPrepared=2,
	securityLogGetStatus_getCompleted=3,
	securityLogGetStatus_getCompletedNotClear=4
} securityLogGetStatus_Tval;

typedef enum {
	securityLogFullBehavior_wrap_around[TTT]=1,
	securityLogFullBehavior_stop=2
} securityLogFullBehavior_Tval;

typedef enum {
	securityLogControl_active[TTT]=1,
	securityLogControl_hold=2,
	securityLogControl_purge=3,
	securityLogControl_trap=4
} securityLogControl_Tval;

typedef struct
{
	int		securityLogMaxSize[TTT];
	securityLogGetStatus_Tval securityLogGetStatus;
	int		securityLogFullWarningThreshold;
	securityLogFullBehavior_Tval securityLogFullBehavior;
	securityLogControl_Tval securityLogControl;
}MIBsecurityLogGroup_t;










 



 
 
extern MIBDid_t pbTrapDestinationTable_Did;

   
typedef enum {
	trapDestAccessMode_read[TTT]=1,
	trapDestAccessMode_write=2
} trapDestAccessMode_Tval;

typedef struct
{
	unsigned int	pbTrapDestIPAddress[TTT];                                    
	int		pbTrapDestAlarmPort;                                            
	int		pbTrapDestOperationPort;                                        
	PbUpDown_Tval pbTrapDestAdminStatus;   
	RowStatus_Tval pbTrapDestRowStatus;   
	trapDestAccessMode_Tval trapDestAccessMode;   
	DateTime	trapDestLastWrite;   
	char		trapDestUserName[66];   
	unsigned int	trapDestClientIP;
	unsigned int	trapDestSysUpTime;
}MIBpbTrapDestinationTable_t;

















 



 
extern MIBDid_t writeAccessGroup_Did;

   
typedef struct
{
	int		writeAccessTimeout[TTT];   
	int		writeAccessAutoCleanup;
}MIBwriteAccessGroup_t;







 



 
 
extern MIBDid_t portProtectforTCPorUDPTable_Did;

   
typedef enum {
	portProtecttype_tcp[TTT]=1,
	portProtecttype_udp=2
} portProtecttype_Tval;

typedef struct
{
	int		portProtectIndex[TTT];                                        
	portProtecttype_Tval portProtecttype;                         
	char		portProtectDescrption[64];
	RowStatus_Tval portProtectStatus;
}MIBportProtectforTCPorUDPTable_t;











 



 
 
extern MIBDid_t usmUserExtendedTable_Did;

   
typedef struct
{
	int		usmUserEngineID_len[TTT];
	char		usmUserEngineID[32];                                                  
	char		usmUserName[32];                                                      
	RowStatus_Tval usmUserExtRowStatus;
	DateTime	usmUserLastSucLogin;
	int		usmUserInvalidLoginAttempts;
	int		usmUserUnauthAccessAttempts;
	int		usmUserPwExpirationDate;
	int		usmUserPwExpirationPeriod;
	int		usmUserAccountExpirationDate;
	int		usmUserID;
}MIBusmUserExtendedTable_t;

















 



 
extern MIBDid_t pbSecurityModule_Did;

   







 




 



 
extern MIBDid_t tasksGroup_Did;

   
typedef struct
{
	char		applTableVer[TTT][30];
}MIBtasksGroup_t;






 



 
 
extern MIBDid_t applTable_Did;

   
typedef enum {
	applStart_none[TTT]=0,
	applStart_full=1,
	applStart_diag=2,
	applStart_always=3
} applStart_Tval;

typedef struct
{
	int		applIndex[TTT];                                       
	PbBoardFunction_Tval applBoardFunction;
	PbBoardProperty_Tval applBoardProperty;
	PbBoardStyle_Tval applBoardStyle;
	PbChassisType_Tval applChassisType;
	char		applName[30];
	int		applNumber;
	char		applFname[15];
	char		applEntryfn[30];
	char		applTaskName[30];
	int		applTaskPri;
	int		applTaskStack;
	int		applLogLevels;
	int		applOptions;
	applStart_Tval applStart;
}MIBapplTable_t;






















 



 
 
extern MIBDid_t aapplTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] aapplSlotNo;              
	int		aapplNumber;                               
	char		aapplName[30];
	int		aapplCpuUsage;
	int		aapplLogLevels;
	int		aapplOptions;
	PbApplState_Tval aapplStatus;
	int		aapplLoadOrder;
}MIBaapplTable_t;















 



 
 
extern MIBDid_t bootpTable_Did;

   
typedef struct
{
	PbBoardStyle_Tval[TTT] bootpBoardType;                  
	char		bootpFname[20];   
}MIBbootpTable_t;









 



 
 
extern MIBDid_t pbIntVcTable_Did;

   
typedef struct
{
	int		pbIntVcLocalIntf[TTT];                                   
	int		pbIntVcLocalVpi;                                    
	int		pbIntVcLocalVci;                                    
	int		pbIntVcRemoteIntf;                                  
	int		pbIntVcRemoteVpi;                                   
	int		pbIntVcRemoteVci;                                   
}MIBpbIntVcTable_t;













 



 
 
extern MIBDid_t pbFileSystemTable_Did;

   
typedef struct
{
	char		pbFileDir[TTT][50];                       
	char		pbFileName[50];                      
	int		pbFileSize;   
	int		pbFileSlot;   
}MIBpbFileSystemTable_t;











 



 
 
extern MIBDid_t pbDivaMTable_Did;

   
typedef struct
{
	PbSlotNumberType_Tval[TTT] pbDivaMslotno;             
	int		pbDivaMportno;                              
	int		pbDivaMmetric;   
}MIBpbDivaMTable_t;










 



 
 
extern MIBDid_t moduleTable_Did;

   
typedef enum {
	moduleStart_none[TTT]=0,
	moduleStart_full=1,
	moduleStart_diag=2,
	moduleStart_always=3
} moduleStart_Tval;

typedef struct
{
	int		moduleIndex[TTT];                                         
	PbBoardFunction_Tval moduleBoardFunction;
	PbBoardProperty_Tval moduleBoardProperty;
	PbBoardStyle_Tval moduleBoardStyle;
	PbChassisType_Tval moduleChassisType;
	char		moduleName[30];
	char		moduleFname[15];
	moduleStart_Tval moduleStart;
	char		moduleInit[30];
}MIBmoduleTable_t;
















 



 
 
extern MIBDid_t pbPortLedsTable_Did;

   
typedef enum {
	pbPortLedColor_off[TTT]=0,
	pbPortLedColor_green=1,
	pbPortLedColor_yellow=2,
	pbPortLedColor_red=3,
	pbPortLedColor_blinkingGreen=4,
	pbPortLedColor_blinkingYellow=5,
	pbPortLedColor_blinkingRed=6
} pbPortLedColor_Tval;

typedef struct
{
	PbSlotNumberType_Tval[TTT] pbPortLedProxySlot;                  
	PbSlotNumberType_Tval pbPortLedSlot;                       
	int		pbPortLedIndexNo;                                     
	pbPortLedColor_Tval pbPortLedColor;   
}MIBpbPortLedsTable_t;
















 




 



 
extern MIBDid_t pbMgnt_Did;

   
typedef struct
{
	PbEnableDisable_Tval[TTT] pbTelnetLogin;   
	char		pbPhotonCommunityString[8];   
	char		pbPhotonTrapCommunity[8];   
}MIBpbMgnt_t;








 



 
 
extern MIBDid_t pbUserTable_Did;

   
typedef struct
{
	char		pbUserName[TTT][64];                                                  
	char		pbUserPassword[64];   
	int		pbUserInactivityTimeout;   
	PbUserAccessLevel_Tval pbUserAccessLevel;   
	TruthValue_Tval pbUserLoggedIn;   
	int		pbUserTimeLoggedIn;   
	int		pbUserLastAccessed;   
	TruthValue_Tval pbUserAccessBrowser;   
	TruthValue_Tval pbUserAccessCraft;   
	TruthValue_Tval pbUserAccessTL1;   
	TruthValue_Tval pbUserAccessFTP;   
	TruthValue_Tval pbUserAccessCLI;   
	PbEnableDisable_Tval pbCriticalAudible;   
	PbEnableDisable_Tval pbMajorAudible;   
	PbEnableDisable_Tval pbMinorAudible;   
	PbEnableDisable_Tval pbWarningAudible;   
	PbEnableDisable_Tval pbInfoAudible;   
	PbEnableDisable_Tval pbCriticalVisual;   
	PbEnableDisable_Tval pbMajorVisual;   
	PbEnableDisable_Tval pbMinorVisual;   
	PbEnableDisable_Tval pbWarningVisual;   
	PbEnableDisable_Tval pbInfoVisual;   
	PbUserAccessLevel_Tval pbUserCurrentAccessLevel;   
	RowStatus_Tval pbUserRowStatus;   
	int		pbUserLoginCount;   
}MIBpbUserTable_t;
































 



 
 
extern MIBDid_t pbCommunityStrTable_Did;

   
typedef struct
{
	char		pbCommunityStringName[TTT][32];                                               
	PbCommunityStringAccessLevel_Tval pbCommunityStringAccessLevel;   
	RowStatus_Tval pbCommunityStringRowStatus;   
	char		pbCommunityStringComment[64];   
}MIBpbCommunityStrTable_t;











 



 
extern MIBDid_t pbPrivateManagement_Did;

   




typedef struct {
	MIBDID[TTT] did;
	int    last_oid;
} LeafInfo;

extern LeafInfo pbUserTable_cookie;
extern LeafInfo pbTelnetLogin_cookie;
extern LeafInfo pbCommunityStrTable_cookie;
extern LeafInfo pbPhotonCommunityString_cookie;
extern LeafInfo pbPhotonTrapCommunity_cookie;
extern LeafInfo pbCommunityStringName_cookie;
extern LeafInfo pbCommunityStringAccessLevel_cookie;
extern LeafInfo pbCommunityStringRowStatus_cookie;
extern LeafInfo pbCommunityStringComment_cookie;
extern LeafInfo pbUserName_cookie;
extern LeafInfo pbUserPassword_cookie;
extern LeafInfo pbUserInactivityTimeout_cookie;
extern LeafInfo pbUserAccessLevel_cookie;
extern LeafInfo pbUserLoggedIn_cookie;
extern LeafInfo pbUserTimeLoggedIn_cookie;
extern LeafInfo pbUserLastAccessed_cookie;
extern LeafInfo pbUserAccessBrowser_cookie;
extern LeafInfo pbUserAccessCraft_cookie;
extern LeafInfo pbUserAccessTL1_cookie;
extern LeafInfo pbUserAccessFTP_cookie;
extern LeafInfo pbUserAccessCLI_cookie;
extern LeafInfo pbCriticalAudible_cookie;
extern LeafInfo pbMajorAudible_cookie;
extern LeafInfo pbMinorAudible_cookie;
extern LeafInfo pbWarningAudible_cookie;
extern LeafInfo pbInfoAudible_cookie;
extern LeafInfo pbCriticalVisual_cookie;
extern LeafInfo pbMajorVisual_cookie;
extern LeafInfo pbMinorVisual_cookie;
extern LeafInfo pbWarningVisual_cookie;
extern LeafInfo pbInfoVisual_cookie;
extern LeafInfo pbUserCurrentAccessLevel_cookie;
extern LeafInfo pbUserRowStatus_cookie;
extern LeafInfo pbUserLoginCount_cookie;
extern LeafInfo dod_cookie;
extern LeafInfo internet_cookie;
extern LeafInfo mgmt_cookie;
extern LeafInfo private_cookie;
extern LeafInfo snmpV2_cookie;
extern LeafInfo snmpModules_cookie;
extern LeafInfo snmpMIB_cookie;
extern LeafInfo snmpFrameworkMIB_cookie;
extern LeafInfo snmpMPDMIB_cookie;
extern LeafInfo snmpTargetMIB_cookie;
extern LeafInfo snmpNotificationMIB_cookie;
extern LeafInfo snmpUsmMIB_cookie;
extern LeafInfo snmpVacmMIB_cookie;
extern LeafInfo snmpCommunityMIB_cookie;
extern LeafInfo snmpCommunityMIBObjects_cookie;
extern LeafInfo snmpCommunityMIBConformance_cookie;
extern LeafInfo snmpCommunityMIBCompliances_cookie;
extern LeafInfo snmpCommunityMIBGroups_cookie;
extern LeafInfo snmpCommunityTable_cookie;
extern LeafInfo snmpTargetAddrExtTable_cookie;
extern LeafInfo snmpTrapAddress_cookie;
extern LeafInfo snmpTrapCommunity_cookie;
extern LeafInfo snmpTargetAddrName_cookie;
extern LeafInfo snmpTargetAddrTMask_cookie;
extern LeafInfo snmpTargetAddrMMS_cookie;
extern LeafInfo snmpCommunityIndex_cookie;
extern LeafInfo snmpCommunityName_cookie;
extern LeafInfo snmpCommunitySecurityName_cookie;
extern LeafInfo snmpCommunityContextEngineID_cookie;
extern LeafInfo snmpCommunityContextName_cookie;
extern LeafInfo snmpCommunityTransportTag_cookie;
extern LeafInfo snmpCommunityStorageType_cookie;
extern LeafInfo snmpCommunityStatus_cookie;
extern LeafInfo vacmMIBObjects_cookie;
extern LeafInfo vacmMIBConformance_cookie;
extern LeafInfo vacmMIBCompliances_cookie;
extern LeafInfo vacmMIBGroups_cookie;
extern LeafInfo vacmContextTable_cookie;
extern LeafInfo vacmSecurityToGroupTable_cookie;
extern LeafInfo vacmAccessTable_cookie;
extern LeafInfo vacmMIBViews_cookie;
extern LeafInfo vacmViewSpinLock_cookie;
extern LeafInfo vacmViewTreeFamilyTable_cookie;
extern LeafInfo vacmViewTreeFamilyViewName_cookie;
extern LeafInfo vacmViewTreeFamilySubtree_cookie;
extern LeafInfo vacmViewTreeFamilyMask_cookie;
extern LeafInfo vacmViewTreeFamilyType_cookie;
extern LeafInfo vacmViewTreeFamilyStorageType_cookie;
extern LeafInfo vacmViewTreeFamilyStatus_cookie;
extern LeafInfo vacmGroupName_cookie;
extern LeafInfo vacmAccessContextPrefix_cookie;
extern LeafInfo vacmAccessSecurityModel_cookie;
extern LeafInfo vacmAccessSecurityLevel_cookie;
extern LeafInfo vacmAccessContextMatch_cookie;
extern LeafInfo vacmAccessReadViewName_cookie;
extern LeafInfo vacmAccessWriteViewName_cookie;
extern LeafInfo vacmAccessNotifyViewName_cookie;
extern LeafInfo vacmAccessStorageType_cookie;
extern LeafInfo vacmAccessStatus_cookie;
extern LeafInfo vacmSecurityModel_cookie;
extern LeafInfo vacmSecurityName_cookie;
extern LeafInfo vacmGroupName_cookie;
extern LeafInfo vacmSecurityToGroupStorageType_cookie;
extern LeafInfo vacmSecurityToGroupStatus_cookie;
extern LeafInfo vacmContextName_cookie;
extern LeafInfo usmMIBObjects_cookie;
extern LeafInfo usmMIBConformance_cookie;
extern LeafInfo usmMIBCompliances_cookie;
extern LeafInfo usmMIBGroups_cookie;
extern LeafInfo usmStats_cookie;
extern LeafInfo usmUser_cookie;
extern LeafInfo usmUserSpinLock_cookie;
extern LeafInfo usmUserTable_cookie;
extern LeafInfo usmUserEngineID_cookie;
extern LeafInfo usmUserName_cookie;
extern LeafInfo usmUserSecurityName_cookie;
extern LeafInfo usmUserCloneFrom_cookie;
extern LeafInfo usmUserAuthProtocol_cookie;
extern LeafInfo usmUserAuthKeyChange_cookie;
extern LeafInfo usmUserOwnAuthKeyChange_cookie;
extern LeafInfo usmUserPrivProtocol_cookie;
extern LeafInfo usmUserPrivKeyChange_cookie;
extern LeafInfo usmUserOwnPrivKeyChange_cookie;
extern LeafInfo usmUserPublic_cookie;
extern LeafInfo usmUserStorageType_cookie;
extern LeafInfo usmUserStatus_cookie;
extern LeafInfo usmStatsUnsupportedSecLevels_cookie;
extern LeafInfo usmStatsNotInTimeWindows_cookie;
extern LeafInfo usmStatsUnknownUserNames_cookie;
extern LeafInfo usmStatsUnknownEngineIDs_cookie;
extern LeafInfo usmStatsWrongDigests_cookie;
extern LeafInfo usmStatsDecryptionErrors_cookie;
extern LeafInfo snmpNotifyObjects_cookie;
extern LeafInfo snmpNotifyConformance_cookie;
extern LeafInfo snmpNotifyCompliances_cookie;
extern LeafInfo snmpNotifyGroups_cookie;
extern LeafInfo snmpNotifyTable_cookie;
extern LeafInfo snmpNotifyFilterProfileTable_cookie;
extern LeafInfo snmpNotifyFilterTable_cookie;
extern LeafInfo snmpNotifyFilterProfileName_cookie;
extern LeafInfo snmpNotifyFilterSubtree_cookie;
extern LeafInfo snmpNotifyFilterMask_cookie;
extern LeafInfo snmpNotifyFilterType_cookie;
extern LeafInfo snmpNotifyFilterStorageType_cookie;
extern LeafInfo snmpNotifyFilterRowStatus_cookie;
extern LeafInfo snmpTargetParamsName_cookie;
extern LeafInfo snmpNotifyFilterProfileName_cookie;
extern LeafInfo snmpNotifyFilterProfileStorType_cookie;
extern LeafInfo snmpNotifyFilterProfileRowStatus_cookie;
extern LeafInfo snmpNotifyName_cookie;
extern LeafInfo snmpNotifyTag_cookie;
extern LeafInfo snmpNotifyType_cookie;
extern LeafInfo snmpNotifyStorageType_cookie;
extern LeafInfo snmpNotifyRowStatus_cookie;
extern LeafInfo snmpTargetObjects_cookie;
extern LeafInfo snmpTargetConformance_cookie;
extern LeafInfo snmpTargetCompliances_cookie;
extern LeafInfo snmpTargetGroups_cookie;
extern LeafInfo snmpTargetSpinLock_cookie;
extern LeafInfo snmpTargetAddrTable_cookie;
extern LeafInfo snmpTargetParamsTable_cookie;
extern LeafInfo snmpUnavailableContexts_cookie;
extern LeafInfo snmpUnknownContexts_cookie;
extern LeafInfo snmpTargetParamsName_cookie;
extern LeafInfo snmpTargetParamsMPModel_cookie;
extern LeafInfo snmpTargetParamsSecurityModel_cookie;
extern LeafInfo snmpTargetParamsSecurityName_cookie;
extern LeafInfo snmpTargetParamsSecurityLevel_cookie;
extern LeafInfo snmpTargetParamsStorageType_cookie;
extern LeafInfo snmpTargetParamsRowStatus_cookie;
extern LeafInfo snmpTargetAddrName_cookie;
extern LeafInfo snmpTargetAddrTDomain_cookie;
extern LeafInfo snmpTargetAddrTAddress_cookie;
extern LeafInfo snmpTargetAddrTimeout_cookie;
extern LeafInfo snmpTargetAddrRetryCount_cookie;
extern LeafInfo snmpTargetAddrTagList_cookie;
extern LeafInfo snmpTargetAddrParams_cookie;
extern LeafInfo snmpTargetAddrStorageType_cookie;
extern LeafInfo snmpTargetAddrRowStatus_cookie;
extern LeafInfo snmpMPDAdmin_cookie;
extern LeafInfo snmpMPDMIBObjects_cookie;
extern LeafInfo snmpMPDMIBConformance_cookie;
extern LeafInfo snmpMPDMIBCompliances_cookie;
extern LeafInfo snmpMPDMIBGroups_cookie;
extern LeafInfo snmpMPDStats_cookie;
extern LeafInfo snmpUnknownSecurityModels_cookie;
extern LeafInfo snmpInvalidMsgs_cookie;
extern LeafInfo snmpUnknownPDUHandlers_cookie;
extern LeafInfo snmpFrameworkAdmin_cookie;
extern LeafInfo snmpFrameworkMIBObjects_cookie;
extern LeafInfo snmpFrameworkMIBConformance_cookie;
extern LeafInfo snmpFrameworkMIBCompliances_cookie;
extern LeafInfo snmpFrameworkMIBGroups_cookie;
extern LeafInfo snmpEngine_cookie;
extern LeafInfo snmpEngineID_cookie;
extern LeafInfo snmpEngineBoots_cookie;
extern LeafInfo snmpEngineTime_cookie;
extern LeafInfo snmpEngineMaxMessageSize_cookie;
extern LeafInfo snmpAuthProtocols_cookie;
extern LeafInfo snmpPrivProtocols_cookie;
extern LeafInfo usmNoPrivProtocol_cookie;
extern LeafInfo usmDESPrivProtocol_cookie;
extern LeafInfo usmNoAuthProtocol_cookie;
extern LeafInfo usmHMACMD5AuthProtocol_cookie;
extern LeafInfo usmHMACSHAAuthProtocol_cookie;
extern LeafInfo snmpMIBObjects_cookie;
extern LeafInfo snmpMIBConformance_cookie;
extern LeafInfo snmpMIBCompliances_cookie;
extern LeafInfo snmpMIBGroups_cookie;
extern LeafInfo snmpTrap_cookie;
extern LeafInfo snmpTraps_cookie;
extern LeafInfo snmpSet_cookie;
extern LeafInfo snmpSetSerialNo_cookie;
extern LeafInfo snmpTrapOID_cookie;
extern LeafInfo snmpTrapEnterprise_cookie;
extern LeafInfo enterprises_cookie;
extern LeafInfo enterpriseRoot_cookie;
extern LeafInfo enterpriseCommonRoot_cookie;
extern LeafInfo enterpriseReg_cookie;
extern LeafInfo enterpriseGeneric_cookie;
extern LeafInfo enterpriseProducts_cookie;
extern LeafInfo enterpriseCaps_cookie;
extern LeafInfo enterpriseReqs_cookie;
extern LeafInfo enterpriseExpr_cookie;
extern LeafInfo productSeries1Products_cookie;
extern LeafInfo productSeries1Common_cookie;
extern LeafInfo productSeries1CmnConf_cookie;
extern LeafInfo productSeries1CmnObjs_cookie;
extern LeafInfo productSeries1CmnEvents_cookie;
extern LeafInfo productSeries1CmnTCs_cookie;
extern LeafInfo productSeries1TrapGroup_cookie;
extern LeafInfo pbTrapTimeStamp_cookie;
extern LeafInfo pbNode_cookie;
extern LeafInfo pbEvents_cookie;
extern LeafInfo pbCircuitBasedTransport_cookie;
extern LeafInfo pbTMS_cookie;
extern LeafInfo pbOspf_cookie;
extern LeafInfo pbMoln_cookie;
extern LeafInfo pbDcc_cookie;
extern LeafInfo pbEthernet_cookie;
extern LeafInfo pbDiagnostics_cookie;
extern LeafInfo pbOpticsMonitor_cookie;
extern LeafInfo pbPowerCircuitMonitor_cookie;
extern LeafInfo pbOr_cookie;
extern LeafInfo pbTrunk_cookie;
extern LeafInfo pbXcExtend_cookie;
extern LeafInfo pbSdhXcTable_cookie;
extern LeafInfo pbRpr_cookie;
extern LeafInfo pbOAObjects_cookie;
extern LeafInfo pbOsi_cookie;
extern LeafInfo pbIpTunnel_cookie;
extern LeafInfo pbProtection_cookie;
extern LeafInfo pbSecurity_cookie;
extern LeafInfo securityGlobalSettingGroup_cookie;
extern LeafInfo securityAlarmInhibitGroup_cookie;
extern LeafInfo snmpSecurityGroup_cookie;
extern LeafInfo securityLogGroup_cookie;
extern LeafInfo pbTrapDestinationTable_cookie;
extern LeafInfo writeAccessGroup_cookie;
extern LeafInfo portProtectforTCPorUDPTable_cookie;
extern LeafInfo portProtectIndex_cookie;
extern LeafInfo portProtecttype_cookie;
extern LeafInfo portProtectDescrption_cookie;
extern LeafInfo portProtectStatus_cookie;
extern LeafInfo writeAccessTimeout_cookie;
extern LeafInfo writeAccessAutoCleanup_cookie;
extern LeafInfo pbTrapDestIPAddress_cookie;
extern LeafInfo pbTrapDestAlarmPort_cookie;
extern LeafInfo pbTrapDestOperationPort_cookie;
extern LeafInfo pbTrapDestAdminStatus_cookie;
extern LeafInfo pbTrapDestRowStatus_cookie;
extern LeafInfo trapDestAccessMode_cookie;
extern LeafInfo trapDestLastWrite_cookie;
extern LeafInfo trapDestUserName_cookie;
extern LeafInfo trapDestClientIP_cookie;
extern LeafInfo trapDestSysUpTime_cookie;
extern LeafInfo securityLogMaxSize_cookie;
extern LeafInfo securityLogGetStatus_cookie;
extern LeafInfo securityLogFullWarningThreshold_cookie;
extern LeafInfo securityLogFullBehavior_cookie;
extern LeafInfo securityLogControl_cookie;
extern LeafInfo usmUserExtendedTable_cookie;
extern LeafInfo usmUserEngineID_cookie;
extern LeafInfo usmUserName_cookie;
extern LeafInfo usmUserExtRowStatus_cookie;
extern LeafInfo usmUserLastSucLogin_cookie;
extern LeafInfo usmUserInvalidLoginAttempts_cookie;
extern LeafInfo usmUserUnauthAccessAttempts_cookie;
extern LeafInfo usmUserPwExpirationDate_cookie;
extern LeafInfo usmUserPwExpirationPeriod_cookie;
extern LeafInfo usmUserAccountExpirationDate_cookie;
extern LeafInfo usmUserID_cookie;
extern LeafInfo securityULEInhibit_cookie;
extern LeafInfo securityUAInhibit_cookie;
extern LeafInfo securityAEDInhibit_cookie;
extern LeafInfo securityLTWInhibit_cookie;
extern LeafInfo securityLFAInhibit_cookie;
extern LeafInfo securityPasswordMinLen_cookie;
extern LeafInfo securityMaxInvalidLogin_cookie;
extern LeafInfo securityUnauthorizedAccessThreshold_cookie;
extern LeafInfo securityTCBehavior_cookie;
extern LeafInfo epgGroup_cookie;
extern LeafInfo msspringGroup_cookie;
extern LeafInfo mspGroup_cookie;
extern LeafInfo sncpGroup_cookie;
extern LeafInfo mssp4fGroup_cookie;
extern LeafInfo mssp4fConfigTable_cookie;
extern LeafInfo mssp4fTopologyTable_cookie;
extern LeafInfo mssp4fCommandTable_cookie;
extern LeafInfo mssp4fNodeStatusTable_cookie;
extern LeafInfo mssp4fAutoMappingTable_cookie;
extern LeafInfo mssp4fXcTable_cookie;
extern LeafInfo mssp4fRingId_cookie;
extern LeafInfo mssp4fNodeId_cookie;
extern LeafInfo mssp4fXcSide_cookie;
extern LeafInfo mssp4fXcTimeSlot_cookie;
extern LeafInfo mssp4fXcOrder_cookie;
extern LeafInfo mssp4fXcType_cookie;
extern LeafInfo mssp4fRingId_cookie;
extern LeafInfo mssp4fNodeId_cookie;
extern LeafInfo mssp4fWestWorkMappingString_cookie;
extern LeafInfo mssp4fEastWorkMappingString_cookie;
extern LeafInfo mssp4fAutomappingRowStatus_cookie;
extern LeafInfo mssp4fRingId_cookie;
extern LeafInfo mssp4fNodeAgentState_cookie;
extern LeafInfo mssp4fNodeState_cookie;
extern LeafInfo mssp4fNodeCurrentSide_cookie;
extern LeafInfo mssp4fNodeCurrentReq_cookie;
extern LeafInfo mssp4fNodeCurrentSrc_cookie;
extern LeafInfo mssp4fNodeKExpressMode_cookie;
extern LeafInfo mssp4fWestSwitchCommand_cookie;
extern LeafInfo mssp4fWestLineReq_cookie;
extern LeafInfo mssp4fWestLastSwitchCmd_cookie;
extern LeafInfo mssp4fWestSwitchStatus_cookie;
extern LeafInfo mssp4fWestK1byteInput_cookie;
extern LeafInfo mssp4fWestK2byteInput_cookie;
extern LeafInfo mssp4fWestK1byteOutput_cookie;
extern LeafInfo mssp4fWestK2byteOutput_cookie;
extern LeafInfo mssp4fEastSwitchCommand_cookie;
extern LeafInfo mssp4fEastLineReq_cookie;
extern LeafInfo mssp4fEastLastSwitchCmd_cookie;
extern LeafInfo mssp4fEastSwitchStatus_cookie;
extern LeafInfo mssp4fEastK1byteInput_cookie;
extern LeafInfo mssp4fEastK2byteInput_cookie;
extern LeafInfo mssp4fEastK1byteOutput_cookie;
extern LeafInfo mssp4fEastK2byteOutput_cookie;
extern LeafInfo mssp4fPassNodeId_cookie;
extern LeafInfo mssp4fRingId_cookie;
extern LeafInfo mssp4fCommandCurrentSide_cookie;
extern LeafInfo mssp4fCommand_cookie;
extern LeafInfo mssp4fLastCommandStatus_cookie;
extern LeafInfo mssp4fRingId_cookie;
extern LeafInfo mssp4fSumOfNodes_cookie;
extern LeafInfo mssp4fNodeId0_cookie;
extern LeafInfo mssp4fNodeId1_cookie;
extern LeafInfo mssp4fNodeId2_cookie;
extern LeafInfo mssp4fNodeId3_cookie;
extern LeafInfo mssp4fNodeId4_cookie;
extern LeafInfo mssp4fNodeId5_cookie;
extern LeafInfo mssp4fNodeId6_cookie;
extern LeafInfo mssp4fNodeId7_cookie;
extern LeafInfo mssp4fNodeId8_cookie;
extern LeafInfo mssp4fNodeId9_cookie;
extern LeafInfo mssp4fNodeId10_cookie;
extern LeafInfo mssp4fNodeId11_cookie;
extern LeafInfo mssp4fNodeId12_cookie;
extern LeafInfo mssp4fNodeId13_cookie;
extern LeafInfo mssp4fNodeId14_cookie;
extern LeafInfo mssp4fNodeId15_cookie;
extern LeafInfo mssp4fNodeIp0_cookie;
extern LeafInfo mssp4fNodeIp1_cookie;
extern LeafInfo mssp4fNodeIp2_cookie;
extern LeafInfo mssp4fNodeIp3_cookie;
extern LeafInfo mssp4fNodeIp4_cookie;
extern LeafInfo mssp4fNodeIp5_cookie;
extern LeafInfo mssp4fNodeIp6_cookie;
extern LeafInfo mssp4fNodeIp7_cookie;
extern LeafInfo mssp4fNodeIp8_cookie;
extern LeafInfo mssp4fNodeIp9_cookie;
extern LeafInfo mssp4fNodeIp10_cookie;
extern LeafInfo mssp4fNodeIp11_cookie;
extern LeafInfo mssp4fNodeIp12_cookie;
extern LeafInfo mssp4fNodeIp13_cookie;
extern LeafInfo mssp4fNodeIp14_cookie;
extern LeafInfo mssp4fNodeIp15_cookie;
extern LeafInfo mssp4fRingId_cookie;
extern LeafInfo mssp4fProtectMode_cookie;
extern LeafInfo mssp4fRingName_cookie;
extern LeafInfo mssp4fGroupId_cookie;
extern LeafInfo mssp4fWaitToRestore_cookie;
extern LeafInfo mssp4fRingType_cookie;
extern LeafInfo mssp4fWestWorkChannelNutInfo_cookie;
extern LeafInfo mssp4fEastWorkChannelNutInfo_cookie;
extern LeafInfo mssp4fConfigEnabled_cookie;
extern LeafInfo mssp4fConfigDeleted_cookie;
extern LeafInfo mssp4fRingSuspended_cookie;
extern LeafInfo mssp4fAutoSquelchEnabled_cookie;
extern LeafInfo mssp4fAutoMappingEnabled_cookie;
extern LeafInfo mssp4fWestWorkSlotNum_cookie;
extern LeafInfo mssp4fWestWorkPortType_cookie;
extern LeafInfo mssp4fWestWorkPortNum_cookie;
extern LeafInfo mssp4fWestProtSlotNum_cookie;
extern LeafInfo mssp4fWestProtPortType_cookie;
extern LeafInfo mssp4fWestProtPortNum_cookie;
extern LeafInfo mssp4fEastWorkSlotNum_cookie;
extern LeafInfo mssp4fEastWorkPortType_cookie;
extern LeafInfo mssp4fEastWorkPortNum_cookie;
extern LeafInfo mssp4fEastProtSlotNum_cookie;
extern LeafInfo mssp4fEastProtPortType_cookie;
extern LeafInfo mssp4fEastProtPortNum_cookie;
extern LeafInfo mssp4fPeerWestWorkSlotNum_cookie;
extern LeafInfo mssp4fPeerWestWorkPortType_cookie;
extern LeafInfo mssp4fPeerWestWorkPortNum_cookie;
extern LeafInfo mssp4fPeerWestProtSlotNum_cookie;
extern LeafInfo mssp4fPeerWestProtPortType_cookie;
extern LeafInfo mssp4fPeerWestProtPortNum_cookie;
extern LeafInfo mssp4fPeerEastWorkSlotNum_cookie;
extern LeafInfo mssp4fPeerEastWorkPortType_cookie;
extern LeafInfo mssp4fPeerEastWorkPortNum_cookie;
extern LeafInfo mssp4fPeerEastProtSlotNum_cookie;
extern LeafInfo mssp4fPeerEastProtPortType_cookie;
extern LeafInfo mssp4fPeerEastProtPortNum_cookie;
extern LeafInfo pbSncpConfigTable_cookie;
extern LeafInfo pbSncpStateTable_cookie;
extern LeafInfo pbDpnpConfigTable_cookie;
extern LeafInfo pbDpnpStateTable_cookie;
extern LeafInfo pbSncpExtendParaGroup_cookie;
extern LeafInfo pbLoSncpWTR_cookie;
extern LeafInfo pbLoSncpHoldOffTime_cookie;
extern LeafInfo pbDpnpStateLineId_cookie;
extern LeafInfo pbDpnpDetailedStateString1_cookie;
extern LeafInfo pbDpnpDetailedStateString2_cookie;
extern LeafInfo pbDpnpDetailedStateString3_cookie;
extern LeafInfo pbDpnpDetailedStateString4_cookie;
extern LeafInfo pbDpnpTPType_cookie;
extern LeafInfo pbDpnpDstSlotNum_cookie;
extern LeafInfo pbDpnpDstPortType_cookie;
extern LeafInfo pbDpnpDstPortNum_cookie;
extern LeafInfo pbDpnpDstSource_cookie;
extern LeafInfo pbVSncpWorkChSlotNum_cookie;
extern LeafInfo pbVSncpWorkChPortType_cookie;
extern LeafInfo pbVSncpWorkChPortNum_cookie;
extern LeafInfo pbVSncpWorkSource_cookie;
extern LeafInfo pbVSncpProtectChSlotNum_cookie;
extern LeafInfo pbVSncpProtectChPortType_cookie;
extern LeafInfo pbVSncpProtectChPortNum_cookie;
extern LeafInfo pbVSncpProtectSource_cookie;
extern LeafInfo pbVMsspringWorkChSlotNum_cookie;
extern LeafInfo pbVMsspringWorkChPortType_cookie;
extern LeafInfo pbVMsspringWorkChPortNum_cookie;
extern LeafInfo pbVMsspringWorkSource_cookie;
extern LeafInfo pbDpnpSignalDircetion_cookie;
extern LeafInfo pbDpnpGroupId_cookie;
extern LeafInfo pbDpnpWorkChState_cookie;
extern LeafInfo pbDpnpExternalCmd_cookie;
extern LeafInfo pbDpnpExCmdRslt_cookie;
extern LeafInfo pbDpnpCurSwitchReq_cookie;
extern LeafInfo pbDpnpSwitchReason_cookie;
extern LeafInfo pbDpnpHoldOffTime_cookie;
extern LeafInfo pbDpnpRestoreMode_cookie;
extern LeafInfo pbDpnpWTR_cookie;
extern LeafInfo pbDpnpWorkSignalState_cookie;
extern LeafInfo pbDpnpProtectSignalState_cookie;
extern LeafInfo pbDpnpVMsspringSignalState_cookie;
extern LeafInfo pbDpnpRowStatus_cookie;
extern LeafInfo pbDpnpLable_cookie;
extern LeafInfo pbDpnpAddRslt_cookie;
extern LeafInfo pbDpnpDNIId_cookie;
extern LeafInfo pbDpnpIntrusive_cookie;
extern LeafInfo pbDpnpDirection_cookie;
extern LeafInfo pbDpnpFrom_cookie;
extern LeafInfo pbDpnpSwitchEvent_cookie;
extern LeafInfo pbGmplsDpnpDirection_cookie;
extern LeafInfo pbSncpStateLineId_cookie;
extern LeafInfo pbSncpDetailedStateString1_cookie;
extern LeafInfo pbSncpDetailedStateString2_cookie;
extern LeafInfo pbSncpDetailedStateString3_cookie;
extern LeafInfo pbSncpDetailedStateString4_cookie;
extern LeafInfo pbSncpTPType_cookie;
extern LeafInfo pbSncpWorkChSlotNum_cookie;
extern LeafInfo pbSncpWorkChPortType_cookie;
extern LeafInfo pbSncpWorkChPortNum_cookie;
extern LeafInfo pbSncpWorkSource_cookie;
extern LeafInfo pbSncpProtectChSlotNum_cookie;
extern LeafInfo pbSncpProtectChPortType_cookie;
extern LeafInfo pbSncpProtectChPortNum_cookie;
extern LeafInfo pbSncpProtectSource_cookie;
extern LeafInfo pbSncpSrcOrDstSlotNum_cookie;
extern LeafInfo pbSncpSrcOrDstPortType_cookie;
extern LeafInfo pbSncpSrcOrDstPortNum_cookie;
extern LeafInfo pbSncpSrcOrDstSource_cookie;
extern LeafInfo pbSncpSignalDircetion_cookie;
extern LeafInfo pbSncpGroupId_cookie;
extern LeafInfo pbSncpWorkChState_cookie;
extern LeafInfo pbSncpExternalCmd_cookie;
extern LeafInfo pbSncpExCmdRslt_cookie;
extern LeafInfo pbSncpCurSwitchReq_cookie;
extern LeafInfo pbSncpSwitchReason_cookie;
extern LeafInfo pbSncpHoldOffTime_cookie;
extern LeafInfo pbSncpRestoreMode_cookie;
extern LeafInfo pbSncpWTR_cookie;
extern LeafInfo pbSncpWorkSignalState_cookie;
extern LeafInfo pbSncpProtectSignalState_cookie;
extern LeafInfo pbSncpRowStatus_cookie;
extern LeafInfo pbSncpLable_cookie;
extern LeafInfo pbSncpAddRslt_cookie;
extern LeafInfo pbDNIId_cookie;
extern LeafInfo pbSncpIntrusive_cookie;
extern LeafInfo pbSncpWorkGmplsVcNumber_cookie;
extern LeafInfo pbSncpWorkGmplsCallName_cookie;
extern LeafInfo pbSncpProtectGmplsVcNumber_cookie;
extern LeafInfo pbSncpProtectGmplsCallName_cookie;
extern LeafInfo pbSncpWorkorProtToCC_cookie;
extern LeafInfo pbSncpDirection_cookie;
extern LeafInfo pbSncpFrom_cookie;
extern LeafInfo pbGmplsSncpDirection_cookie;
extern LeafInfo pbSncpAction_cookie;
extern LeafInfo pbMspConfigTable_cookie;
extern LeafInfo pbMspGroupActPortType_cookie;
extern LeafInfo pbMspProtectChSlotNum_cookie;
extern LeafInfo pbMspProtectChPortNum_cookie;
extern LeafInfo pbMspProtectChPortType_cookie;
extern LeafInfo pbMspProtectChSignalState_cookie;
extern LeafInfo pbMspGroupId_cookie;
extern LeafInfo pbMspType_cookie;
extern LeafInfo pbMspSignalDircetion_cookie;
extern LeafInfo pbMspRestoreMode_cookie;
extern LeafInfo pbMspExTrafficEnable_cookie;
extern LeafInfo pbMspEnable_cookie;
extern LeafInfo pbMspExternalCmd_cookie;
extern LeafInfo pbMspExtCmdParam_cookie;
extern LeafInfo pbMspExCmdRslt_cookie;
extern LeafInfo pbMspSwitchState_cookie;
extern LeafInfo pbMspCurSwitchReq_cookie;
extern LeafInfo pbMspSwitchReason_cookie;
extern LeafInfo pbMspWTR_cookie;
extern LeafInfo pbMspWorkChNum_cookie;
extern LeafInfo pbMspWorkCh1SlotNum_cookie;
extern LeafInfo pbMspWorkCh1PortNum_cookie;
extern LeafInfo pbMspWorkCh1PortType_cookie;
extern LeafInfo pbMspWorkCh1SignalState_cookie;
extern LeafInfo pbMspWorkCh1PriState_cookie;
extern LeafInfo pbMspWorkCh2SlotNum_cookie;
extern LeafInfo pbMspWorkCh2PortNum_cookie;
extern LeafInfo pbMspWorkCh2PortType_cookie;
extern LeafInfo pbMspWorkCh2SignalState_cookie;
extern LeafInfo pbMspWorkCh2PriState_cookie;
extern LeafInfo pbMspWorkCh3SlotNum_cookie;
extern LeafInfo pbMspWorkCh3PortNum_cookie;
extern LeafInfo pbMspWorkCh3PortType_cookie;
extern LeafInfo pbMspWorkCh3SignalState_cookie;
extern LeafInfo pbMspWorkCh3PriState_cookie;
extern LeafInfo pbMspWorkCh4SlotNum_cookie;
extern LeafInfo pbMspWorkCh4PortNum_cookie;
extern LeafInfo pbMspWorkCh4PortType_cookie;
extern LeafInfo pbMspWorkCh4SignalState_cookie;
extern LeafInfo pbMspWorkCh4PriState_cookie;
extern LeafInfo pbMspWorkCh5SlotNum_cookie;
extern LeafInfo pbMspWorkCh5PortNum_cookie;
extern LeafInfo pbMspWorkCh5PortType_cookie;
extern LeafInfo pbMspWorkCh5SignalState_cookie;
extern LeafInfo pbMspWorkCh5PriState_cookie;
extern LeafInfo pbMspWorkCh6SlotNum_cookie;
extern LeafInfo pbMspWorkCh6PortNum_cookie;
extern LeafInfo pbMspWorkCh6PortType_cookie;
extern LeafInfo pbMspWorkCh6SignalState_cookie;
extern LeafInfo pbMspWorkCh6PriState_cookie;
extern LeafInfo pbMspWorkCh7SlotNum_cookie;
extern LeafInfo pbMspWorkCh7PortNum_cookie;
extern LeafInfo pbMspWorkCh7PortType_cookie;
extern LeafInfo pbMspWorkCh7SignalState_cookie;
extern LeafInfo pbMspWorkCh7PriState_cookie;
extern LeafInfo pbMspWorkCh8SlotNum_cookie;
extern LeafInfo pbMspWorkCh8PortNum_cookie;
extern LeafInfo pbMspWorkCh8PortType_cookie;
extern LeafInfo pbMspWorkCh8SignalState_cookie;
extern LeafInfo pbMspWorkCh8PriState_cookie;
extern LeafInfo pbMspWorkCh9SlotNum_cookie;
extern LeafInfo pbMspWorkCh9PortNum_cookie;
extern LeafInfo pbMspWorkCh9PortType_cookie;
extern LeafInfo pbMspWorkCh9SignalState_cookie;
extern LeafInfo pbMspWorkCh9PriState_cookie;
extern LeafInfo pbMspWorkCh10SlotNum_cookie;
extern LeafInfo pbMspWorkCh10PortNum_cookie;
extern LeafInfo pbMspWorkCh10PortType_cookie;
extern LeafInfo pbMspWorkCh10SignalState_cookie;
extern LeafInfo pbMspWorkCh10PriState_cookie;
extern LeafInfo pbMspWorkCh11SlotNum_cookie;
extern LeafInfo pbMspWorkCh11PortNum_cookie;
extern LeafInfo pbMspWorkCh11PortType_cookie;
extern LeafInfo pbMspWorkCh11SignalState_cookie;
extern LeafInfo pbMspWorkCh11PriState_cookie;
extern LeafInfo pbMspWorkCh12SlotNum_cookie;
extern LeafInfo pbMspWorkCh12PortNum_cookie;
extern LeafInfo pbMspWorkCh12PortType_cookie;
extern LeafInfo pbMspWorkCh12SignalState_cookie;
extern LeafInfo pbMspWorkCh12PriState_cookie;
extern LeafInfo pbMspWorkCh13SlotNum_cookie;
extern LeafInfo pbMspWorkCh13PortNum_cookie;
extern LeafInfo pbMspWorkCh13PortType_cookie;
extern LeafInfo pbMspWorkCh13SignalState_cookie;
extern LeafInfo pbMspWorkCh13PriState_cookie;
extern LeafInfo pbMspWorkCh14SlotNum_cookie;
extern LeafInfo pbMspWorkCh14PortNum_cookie;
extern LeafInfo pbMspWorkCh14PortType_cookie;
extern LeafInfo pbMspWorkCh14SignalState_cookie;
extern LeafInfo pbMspWorkCh14PriState_cookie;
extern LeafInfo pbMspK2Bit5Mismatch_cookie;
extern LeafInfo pbMspK1Bit1to4Mismatch_cookie;
extern LeafInfo pbMspK1Bit5to8Mismatch_cookie;
extern LeafInfo pbMspReceiveK1_cookie;
extern LeafInfo pbMspReceiveK2_cookie;
extern LeafInfo pbMspSendoutK1_cookie;
extern LeafInfo pbMspSendoutK2_cookie;
extern LeafInfo pbMspRowStatus_cookie;
extern LeafInfo pbMspFreeze_cookie;
extern LeafInfo pbMspLable_cookie;
extern LeafInfo pbMSMConfigTable_cookie;
extern LeafInfo pbMSMStatusTable_cookie;
extern LeafInfo pbMSMNodeStatusTable_cookie;
extern LeafInfo pbMSMTopoConfigTable_cookie;
extern LeafInfo pbMSMSquelchTable_cookie;
extern LeafInfo pbMSMCommandTable_cookie;
extern LeafInfo pbAutoMappingTable_cookie;
extern LeafInfo pbMSMSNMRingId_cookie;
extern LeafInfo pbAutoNodeId_cookie;
extern LeafInfo pbPortMappingString_cookie;
extern LeafInfo pbAutoMappingRowStatus_cookie;
extern LeafInfo pbMSMSNMRingId_cookie;
extern LeafInfo pbMSMCommandCurrentSide_cookie;
extern LeafInfo pbMSMCommandSwitch_cookie;
extern LeafInfo pbMSMLastCommandStatus_cookie;
extern LeafInfo pbMSMCommandResult_cookie;
extern LeafInfo pbMSMSNMRingId_cookie;
extern LeafInfo pbMSMSquelchSide_cookie;
extern LeafInfo pbMSMSquelchGress_cookie;
extern LeafInfo pbMSMSquelchTimeSlot_cookie;
extern LeafInfo pbMSMSquelchOrder_cookie;
extern LeafInfo pbMSMSquelchType_cookie;
extern LeafInfo pbMSMSquelchSrcNodeId_cookie;
extern LeafInfo pbMSMSquelchDstNodeId_cookie;
extern LeafInfo pbMSMSquelchReference_cookie;
extern LeafInfo pbMSMSquelchOpTimeSlot_cookie;
extern LeafInfo pbMSMSquelchRowStatus_cookie;
extern LeafInfo pbMSMSNMRingId_cookie;
extern LeafInfo pbMSMTopoNumOfNodes_cookie;
extern LeafInfo pbMSMTopoNodeId0_cookie;
extern LeafInfo pbMSMTopoNodeId1_cookie;
extern LeafInfo pbMSMTopoNodeId2_cookie;
extern LeafInfo pbMSMTopoNodeId3_cookie;
extern LeafInfo pbMSMTopoNodeId4_cookie;
extern LeafInfo pbMSMTopoNodeId5_cookie;
extern LeafInfo pbMSMTopoNodeId6_cookie;
extern LeafInfo pbMSMTopoNodeId7_cookie;
extern LeafInfo pbMSMTopoNodeId8_cookie;
extern LeafInfo pbMSMTopoNodeId9_cookie;
extern LeafInfo pbMSMTopoNodeId10_cookie;
extern LeafInfo pbMSMTopoNodeId11_cookie;
extern LeafInfo pbMSMTopoNodeId12_cookie;
extern LeafInfo pbMSMTopoNodeId13_cookie;
extern LeafInfo pbMSMTopoNodeId14_cookie;
extern LeafInfo pbMSMTopoNodeId15_cookie;
extern LeafInfo pbMSMTopoStatus_cookie;
extern LeafInfo pbMSMTopoConfig_cookie;
extern LeafInfo pbMSMTopoNodeId0IpAddress_cookie;
extern LeafInfo pbMSMTopoNodeId1IpAddress_cookie;
extern LeafInfo pbMSMTopoNodeId2IpAddress_cookie;
extern LeafInfo pbMSMTopoNodeId3IpAddress_cookie;
extern LeafInfo pbMSMTopoNodeId4IpAddress_cookie;
extern LeafInfo pbMSMTopoNodeId5IpAddress_cookie;
extern LeafInfo pbMSMTopoNodeId6IpAddress_cookie;
extern LeafInfo pbMSMTopoNodeId7IpAddress_cookie;
extern LeafInfo pbMSMTopoNodeId8IpAddress_cookie;
extern LeafInfo pbMSMTopoNodeId9IpAddress_cookie;
extern LeafInfo pbMSMTopoNodeId10IpAddress_cookie;
extern LeafInfo pbMSMTopoNodeId11IpAddress_cookie;
extern LeafInfo pbMSMTopoNodeId12IpAddress_cookie;
extern LeafInfo pbMSMTopoNodeId13IpAddress_cookie;
extern LeafInfo pbMSMTopoNodeId14IpAddress_cookie;
extern LeafInfo pbMSMTopoNodeId15IpAddress_cookie;
extern LeafInfo pbMSMSNMRingId_cookie;
extern LeafInfo pbMSMNodeAgentState_cookie;
extern LeafInfo pbMSMNodeState_cookie;
extern LeafInfo pbMSMNodeCurrentSide_cookie;
extern LeafInfo pbMSMNodeCurrentReq_cookie;
extern LeafInfo pbMSMNodeCurrentSrc_cookie;
extern LeafInfo pbMSMNodeKExpressMode_cookie;
extern LeafInfo pbMSMEastSwitchCommand_cookie;
extern LeafInfo pbMSMEastLineReq_cookie;
extern LeafInfo pbMSMEastLastSwitchCmd_cookie;
extern LeafInfo pbMSMEastIsSquelched_cookie;
extern LeafInfo pbMSMWestSwitchCommand_cookie;
extern LeafInfo pbMSMWestLineReq_cookie;
extern LeafInfo pbMSMWestLastSwitchCmd_cookie;
extern LeafInfo pbMSMWestIsSquelched_cookie;
extern LeafInfo pbMSMEastSwitchStatus_cookie;
extern LeafInfo pbMSMWestSwitchStatus_cookie;
extern LeafInfo pbMSMPassNodeId_cookie;
extern LeafInfo pbMSMSNMRingId_cookie;
extern LeafInfo pbMSMSide_cookie;
extern LeafInfo pbMSMTransBridgeReq_cookie;
extern LeafInfo pbMSMTransDestNodeId_cookie;
extern LeafInfo pbMSMTransSrcNodeId_cookie;
extern LeafInfo pbMSMTransLongShort_cookie;
extern LeafInfo pbMSMTransStatus_cookie;
extern LeafInfo pbMSMReceiveBridgeReq_cookie;
extern LeafInfo pbMSMReceiveDestNodeId_cookie;
extern LeafInfo pbMSMReceiveSrcNodeId_cookie;
extern LeafInfo pbMSMReceiveLongShort_cookie;
extern LeafInfo pbMSMReceiveStatus_cookie;
extern LeafInfo pbMSMSideReq_cookie;
extern LeafInfo pbMSMSideSrc_cookie;
extern LeafInfo pbMSMSwitchCommand_cookie;
extern LeafInfo pbMSMLineReq_cookie;
extern LeafInfo pbMSMCmndReq_cookie;
extern LeafInfo pbMSMIsSquelched_cookie;
extern LeafInfo pbMSMSNMRingId_cookie;
extern LeafInfo pbMSMProtectMode_cookie;
extern LeafInfo pbMSMSNMRingName_cookie;
extern LeafInfo pbMSMRingIdx_cookie;
extern LeafInfo pbMSMWestSideSlotNum_cookie;
extern LeafInfo pbMSMWestSidePortType_cookie;
extern LeafInfo pbMSMWestSidePortNum_cookie;
extern LeafInfo pbMSMWestProtSlotNum_cookie;
extern LeafInfo pbMSMWestProtPortType_cookie;
extern LeafInfo pbMSMWestProtPortNum_cookie;
extern LeafInfo pbMSMEastSideSlotNum_cookie;
extern LeafInfo pbMSMEastSidePortType_cookie;
extern LeafInfo pbMSMEastSidePortNum_cookie;
extern LeafInfo pbMSMEastProtSlotNum_cookie;
extern LeafInfo pbMSMEastProtPortType_cookie;
extern LeafInfo pbMSMEastProtPortNum_cookie;
extern LeafInfo pbMSMAutoSquelchDiscovery_cookie;
extern LeafInfo pbMSMAutoRingDiscovery_cookie;
extern LeafInfo pbMSMPeerWestAddress_cookie;
extern LeafInfo pbMSMPeerWestSlotNum_cookie;
extern LeafInfo pbMSMPeerWestPortType_cookie;
extern LeafInfo pbMSMPeerWestPortNum_cookie;
extern LeafInfo pbMSMPeerEastAddress_cookie;
extern LeafInfo pbMSMPeerEastSlotNum_cookie;
extern LeafInfo pbMSMPeerEastPortType_cookie;
extern LeafInfo pbMSMPeerEastPortNum_cookie;
extern LeafInfo pbMSMConfigSdBerThreshold_cookie;
extern LeafInfo pbMSMConfigSfBerThreshold_cookie;
extern LeafInfo pbMSMConfigWaitToRestore_cookie;
extern LeafInfo pbMSMConfigExtraTraffic_cookie;
extern LeafInfo pbMSMConfigEnable_cookie;
extern LeafInfo pbMSMConfigDelete_cookie;
extern LeafInfo pbMSMSquelchFin_cookie;
extern LeafInfo pbMSMCardFunction_cookie;
extern LeafInfo pbMSMChannelInfo_cookie;
extern LeafInfo pbMSMSelfAddress_cookie;
extern LeafInfo pbMSMStartAutoSquelch_cookie;
extern LeafInfo pbMSMAutoMappingEnable_cookie;
extern LeafInfo pbMSMPortMapRefresh_cookie;
extern LeafInfo pbEpgTable_cookie;
extern LeafInfo pbCpgTable_cookie;
extern LeafInfo scEpgGroup_cookie;
extern LeafInfo scEpgScWorkerSlot_cookie;
extern LeafInfo scEpgSc1Status_cookie;
extern LeafInfo scEpgSc2Status_cookie;
extern LeafInfo scEpgRequest_cookie;
extern LeafInfo scEpgLastSwichReason_cookie;
extern LeafInfo scEpgStandbySc_cookie;
extern LeafInfo scEpgASCSwithchState_cookie;
extern LeafInfo pbCpgIndexNo_cookie;
extern LeafInfo pbCpgWorkerSlot_cookie;
extern LeafInfo pbCpgProtectorSlot_cookie;
extern LeafInfo pbCpgProtectStatus_cookie;
extern LeafInfo pbWorkerStatus_cookie;
extern LeafInfo pbProtectorStatus_cookie;
extern LeafInfo pbCpgAct_cookie;
extern LeafInfo pbCpgActStatus_cookie;
extern LeafInfo pbCpgCurActStatus_cookie;
extern LeafInfo pbCpgReadyToSwitch_cookie;
extern LeafInfo pbEpgId_cookie;
extern LeafInfo pbEpgBoardType_cookie;
extern LeafInfo pbEpgType_cookie;
extern LeafInfo pbEpgProtMode_cookie;
extern LeafInfo pbEpgEnable_cookie;
extern LeafInfo pbEpgExtCmd_cookie;
extern LeafInfo pbEpgExtCmdParam_cookie;
extern LeafInfo pbEpgExtCmdResult_cookie;
extern LeafInfo pbEpgWtr_cookie;
extern LeafInfo pbEpgPreSwitchReason_cookie;
extern LeafInfo pbEpgCurRequest_cookie;
extern LeafInfo pbEpgProtState_cookie;
extern LeafInfo pbEpgHoldOffTime_cookie;
extern LeafInfo pbEpgProtSlotNum_cookie;
extern LeafInfo pbEpgProtSlotState_cookie;
extern LeafInfo pbEpgWorkSlotNum1_cookie;
extern LeafInfo pbEpgWorkSlot1State_cookie;
extern LeafInfo pbEpgWorkSlotNum2_cookie;
extern LeafInfo pbEpgWorkSlot2State_cookie;
extern LeafInfo pbEpgWorkSlotNum3_cookie;
extern LeafInfo pbEpgWorkSlot3State_cookie;
extern LeafInfo pbEpgWorkSlotNum4_cookie;
extern LeafInfo pbEpgWorkSlot4State_cookie;
extern LeafInfo pbEpgWorkSlotNum5_cookie;
extern LeafInfo pbEpgWorkSlot5State_cookie;
extern LeafInfo pbEpgWorkSlotNum6_cookie;
extern LeafInfo pbEpgWorkSlot6State_cookie;
extern LeafInfo pbEpgWorkSlotNum7_cookie;
extern LeafInfo pbEpgWorkSlot7State_cookie;
extern LeafInfo pbEpgWorkSlotNum8_cookie;
extern LeafInfo pbEpgWorkSlot8State_cookie;
extern LeafInfo pbEpgRowStatus_cookie;
extern LeafInfo pbIpTunnelCfgTable_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbSdhServerType_cookie;
extern LeafInfo pbLapdNetworkSide_cookie;
extern LeafInfo pbLapdT200_cookie;
extern LeafInfo pbLapdT203_cookie;
extern LeafInfo pbLapdN200_cookie;
extern LeafInfo pbLapdAITS_cookie;
extern LeafInfo pbLapdWindow_cookie;
extern LeafInfo pbIpTunnelSrcIpAddress_cookie;
extern LeafInfo pbIpTunnelDesIpAddress_cookie;
extern LeafInfo pbIpTunnelByPass_cookie;
extern LeafInfo pbIpTunnelDstSlot_cookie;
extern LeafInfo pbIpTunnelDstPort_cookie;
extern LeafInfo pbIpTunnelDstMode_cookie;
extern LeafInfo pbIpTunnelStatus_cookie;
extern LeafInfo pbOsiConfigTable_cookie;
extern LeafInfo osiTunnelConfigTable_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbSdhServerType_cookie;
extern LeafInfo osiTunnelNetworkSide_cookie;
extern LeafInfo osiTunnelT200_cookie;
extern LeafInfo osiTunnelT203_cookie;
extern LeafInfo osiTunnelN200_cookie;
extern LeafInfo osiTunnelAITS_cookie;
extern LeafInfo osiTunnelWindow_cookie;
extern LeafInfo osiTunnelConfigTimer_cookie;
extern LeafInfo osiTunnelTTL_cookie;
extern LeafInfo osiTunnelLocalNasp_cookie;
extern LeafInfo osiTunnelRemoteNasp_cookie;
extern LeafInfo osiTunnelSrcIpAddress_cookie;
extern LeafInfo osiTunnelDesIpAddress_cookie;
extern LeafInfo osiTunnelIpIfMtu_cookie;
extern LeafInfo osiTunnelStatus_cookie;
extern LeafInfo osiTunnelIndex_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbOsiNetworkSide_cookie;
extern LeafInfo pbOsiT200_cookie;
extern LeafInfo pbOsiT203_cookie;
extern LeafInfo pbOsiN200_cookie;
extern LeafInfo pbOsiAITS_cookie;
extern LeafInfo pbOsiWindow_cookie;
extern LeafInfo pbOsiConfigTimer_cookie;
extern LeafInfo pbOsiTTL_cookie;
extern LeafInfo pbOsiLocalNasp_cookie;
extern LeafInfo pbOsiRemoteNasp_cookie;
extern LeafInfo pbOsiSrcIpAddress_cookie;
extern LeafInfo pbOsiDesIpAddress_cookie;
extern LeafInfo pbOsiIpIfMtu_cookie;
extern LeafInfo pbOATable_cookie;
extern LeafInfo pbOASlotNo_cookie;
extern LeafInfo pbOAPortNo_cookie;
extern LeafInfo pbOAModuleConfiguration_cookie;
extern LeafInfo pbOAModuleType_cookie;
extern LeafInfo pbOAHWVersion_cookie;
extern LeafInfo pbOASWVersion_cookie;
extern LeafInfo pbOASerialNumber_cookie;
extern LeafInfo pbOAInputPower_cookie;
extern LeafInfo pbOACurrentOutputPower_cookie;
extern LeafInfo pbOACurrentModuleGain_cookie;
extern LeafInfo pbOAPump1Power_cookie;
extern LeafInfo pbOAPump2Power_cookie;
extern LeafInfo pbOATemperature_cookie;
extern LeafInfo pbOAPump1DriveCurrent_cookie;
extern LeafInfo pbOAPump2DriveCurrent_cookie;
extern LeafInfo pbOAPowerSupplyVoltage_cookie;
extern LeafInfo pbOAOperationMode_cookie;
extern LeafInfo pbOAExpectedOutputPower_cookie;
extern LeafInfo pbOAExpectedModuleGain_cookie;
extern LeafInfo pbOAInputThreshold_cookie;
extern LeafInfo pbOAOutputThreshold_cookie;
extern LeafInfo pbOAShutdownThreshold_cookie;
extern LeafInfo pbOALowTThreshold_cookie;
extern LeafInfo pbOAHighTThreshold_cookie;
extern LeafInfo pbOAAutoShutdown_cookie;
extern LeafInfo pbOAMaxoutputpower_cookie;
extern LeafInfo pbOAMaxPump1Current_cookie;
extern LeafInfo pbOAMaxPump2Current_cookie;
extern LeafInfo pbOARealOperationMode_cookie;
extern LeafInfo pbOARealExpectedOutputPower_cookie;
extern LeafInfo pbOARealExpectedModuleGain_cookie;
extern LeafInfo pbOARealInputThreshold_cookie;
extern LeafInfo pbOARealOutputThreshold_cookie;
extern LeafInfo pbOARealShutdownThreshold_cookie;
extern LeafInfo pbOARealLowTThreshold_cookie;
extern LeafInfo pbOARealHighTThreshold_cookie;
extern LeafInfo pbOARealAutoShutdown_cookie;
extern LeafInfo pbOARealCoolPumpTemp_cookie;
extern LeafInfo rprGeneral_cookie;
extern LeafInfo rprProtocols_cookie;
extern LeafInfo rprService_cookie;
extern LeafInfo rprWan_cookie;
extern LeafInfo rprHwPassThrough_cookie;
extern LeafInfo rprHwpXcTable_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo rprHwpXcCapacity_cookie;
extern LeafInfo rprHwpXcSrcSlot_cookie;
extern LeafInfo rprHwpXcSrcPort_cookie;
extern LeafInfo rprHwpXcSource_cookie;
extern LeafInfo rprHwpXcDstSlot_cookie;
extern LeafInfo rprHwpXcDstPort_cookie;
extern LeafInfo rprHwpXcDestination_cookie;
extern LeafInfo rprHwpXcSrcPortType_cookie;
extern LeafInfo rprHwpXcDstPortType_cookie;
extern LeafInfo rprHwpXcConnectId_cookie;
extern LeafInfo rprHwpXcCircuitDirection_cookie;
extern LeafInfo rprHwpXcCcsRpmMsgType_cookie;
extern LeafInfo rprHwpXcCcsRpmMsgState_cookie;
extern LeafInfo rprHwpXcCcsRpmMsgPriority_cookie;
extern LeafInfo rprHwpXcSrcSlotCard_cookie;
extern LeafInfo rprHwpXcDstSlotCard_cookie;
extern LeafInfo rprHwpXcReason_cookie;
extern LeafInfo rprHwpXcRowStatus_cookie;
extern LeafInfo rprHwpXcTableClass_cookie;
extern LeafInfo pbRprWanConfigTable_cookie;
extern LeafInfo pbRprLCASBase_cookie;
extern LeafInfo pbRprSOLCASConfigTable_cookie;
extern LeafInfo pbRprSKLCASConfigTable_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbTpType_cookie;
extern LeafInfo pbTpIndex_cookie;
extern LeafInfo pbRprSKLCASWanPort_cookie;
extern LeafInfo pbRprSKLCASState_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbTpType_cookie;
extern LeafInfo pbTpIndex_cookie;
extern LeafInfo pbRprSOLCASActive_cookie;
extern LeafInfo pbRprSOLCASWanPort_cookie;
extern LeafInfo pbRprSOLCASState_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbRprWanPortLabel_cookie;
extern LeafInfo pbRprWanPortCapacity_cookie;
extern LeafInfo pbRprWanPortMonitored_cookie;
extern LeafInfo pbRprWanPortXVType_cookie;
extern LeafInfo pbRprWanLCASSupport_cookie;
extern LeafInfo pbRprWanPortCapacityTrigger_cookie;
extern LeafInfo pbRprWanGFPFCS_cookie;
extern LeafInfo pbRprWanGFPFCSAutoDetect_cookie;
extern LeafInfo pbRprWanFlowControl_cookie;
extern LeafInfo rprServiceTable_cookie;
extern LeafInfo rprRateProfileTable_cookie;
extern LeafInfo pbRprMultiCastTable_cookie;
extern LeafInfo pbRprAclTable_cookie;
extern LeafInfo pbRprMultiBroadCastTable_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo rprIfIndex_cookie;
extern LeafInfo rprMultiBroadCastId_cookie;
extern LeafInfo rprMultiBroadCastTimeInterval_cookie;
extern LeafInfo rprMultiBroadCastPacketsInterval_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo rprIfIndex_cookie;
extern LeafInfo rprServiceId_cookie;
extern LeafInfo rprAclMacAddress_cookie;
extern LeafInfo rprAclMacType_cookie;
extern LeafInfo rprAclDoubleVlanId_cookie;
extern LeafInfo rprAclPortsList_cookie;
extern LeafInfo rprAclMode_cookie;
extern LeafInfo rprAclRowStatus_cookie;
extern LeafInfo rprAclTblIdx_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo rprIfIndex_cookie;
extern LeafInfo rprServiceId_cookie;
extern LeafInfo rprMultiCastMacAddress_cookie;
extern LeafInfo rprMultiCastDoubleVlanId_cookie;
extern LeafInfo rprMultiCastPortsList_cookie;
extern LeafInfo rprMultiCastGMRP_cookie;
extern LeafInfo rprMultiCastRowStatus_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo rprIfIndex_cookie;
extern LeafInfo rprRateProfNo_cookie;
extern LeafInfo rprTokenRate_cookie;
extern LeafInfo rprBurstSize_cookie;
extern LeafInfo rprExcessBurstSize_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo rprIfIndex_cookie;
extern LeafInfo rprServiceId_cookie;
extern LeafInfo rprLocalEthPortNo_cookie;
extern LeafInfo rprLocalVID_cookie;
extern LeafInfo rprLocalVPrio_cookie;
extern LeafInfo rprSvcClassifyType_cookie;
extern LeafInfo rprServiceType_cookie;
extern LeafInfo rprSvcMode_cookie;
extern LeafInfo rprRmtStationMac_cookie;
extern LeafInfo rprSvcRingletSel_cookie;
extern LeafInfo rprSvcRealRingletSel_cookie;
extern LeafInfo rprSvcAutoRingletSelEn_cookie;
extern LeafInfo rprSvcCos_cookie;
extern LeafInfo rprSvcTtlMode_cookie;
extern LeafInfo rprSvcTtl0_cookie;
extern LeafInfo rprSvcTtl1_cookie;
extern LeafInfo rprSvcRealTtl0_cookie;
extern LeafInfo rprSvcRealTtl1_cookie;
extern LeafInfo rprSvcWe_cookie;
extern LeafInfo rprSvcSteered_cookie;
extern LeafInfo rprSvcRateProfIndex_cookie;
extern LeafInfo rprSvcTokenRate_cookie;
extern LeafInfo rprSvcBurstSize_cookie;
extern LeafInfo rprSvcMaxDelay_cookie;
extern LeafInfo rprSvcMaxJitter_cookie;
extern LeafInfo rprSvcWeight_cookie;
extern LeafInfo rprGmiiSel_cookie;
extern LeafInfo rprDoubleVlanEn_cookie;
extern LeafInfo rprDoubleVID_cookie;
extern LeafInfo rprDoubleVPrio_cookie;
extern LeafInfo rprSvcLoop_cookie;
extern LeafInfo rprSvcActive_cookie;
extern LeafInfo rprSvcCurStatus_cookie;
extern LeafInfo rprSvcReason_cookie;
extern LeafInfo rprSvcLabel_cookie;
extern LeafInfo rprFlowRuleID_cookie;
extern LeafInfo rprSvcMulBrdCastID_cookie;
extern LeafInfo rprSvcMulBrdCastEn_cookie;
extern LeafInfo rprSvcRowStatus_cookie;
extern LeafInfo rprTopoImageTable_cookie;
extern LeafInfo rprFairnessTable_cookie;
extern LeafInfo rprOamTable_cookie;
extern LeafInfo rprTopoRingInfoTable_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo rprIfIndex_cookie;
extern LeafInfo rprRingMultiChoke0_cookie;
extern LeafInfo rprRingMultiChoke1_cookie;
extern LeafInfo rprRingMtuSize_cookie;
extern LeafInfo rprRingTotalHopsTx0_cookie;
extern LeafInfo rprRingTotalHopsTx1_cookie;
extern LeafInfo rprRingLastNeighborMac0_cookie;
extern LeafInfo rprRingLastNeighborMac1_cookie;
extern LeafInfo rprRingCheckSum_cookie;
extern LeafInfo rprRingNeighborCheckSum0_cookie;
extern LeafInfo rprRingNeighborCheckSum1_cookie;
extern LeafInfo rprRingCheckSumValid_cookie;
extern LeafInfo rprRingNeighborCksValid0_cookie;
extern LeafInfo rprRingNeighborCksValid1_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo rprIfIndex_cookie;
extern LeafInfo rprOamActionType_cookie;
extern LeafInfo rprOamDestAddress_cookie;
extern LeafInfo rprOamRequestRinglet_cookie;
extern LeafInfo rprOamResponseRinglet_cookie;
extern LeafInfo rprOamClassOfService_cookie;
extern LeafInfo rprOamUserData_cookie;
extern LeafInfo rprOamProtected_cookie;
extern LeafInfo rprOamRequestCount_cookie;
extern LeafInfo rprOamTimeout_cookie;
extern LeafInfo rprOamControl_cookie;
extern LeafInfo rprOamResponseCount_cookie;
extern LeafInfo rprOamAvResponseTime_cookie;
extern LeafInfo rprOamResponseStatus_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo rprIfIndex_cookie;
extern LeafInfo rprFairnessRinglet_cookie;
extern LeafInfo rprFairnessRingletWeight_cookie;
extern LeafInfo rprFairnessReservedRate_cookie;
extern LeafInfo rprFairnessMaxAllowed_cookie;
extern LeafInfo rprFairnessAgeCoef_cookie;
extern LeafInfo rprFairnessLpCoef_cookie;
extern LeafInfo rprFairnessAdvertisementRatio_cookie;
extern LeafInfo rprFairnessMcffReportCoef_cookie;
extern LeafInfo rprFairnessActiveWeightsCoef_cookie;
extern LeafInfo rprFairnessSTQHighThreshold_cookie;
extern LeafInfo rprFairnessSTQMedThreshold_cookie;
extern LeafInfo rprFairnessSTQLowThreshold_cookie;
extern LeafInfo rprFairnessRateHighThreshold_cookie;
extern LeafInfo rprFairnessRateLowThreshold_cookie;
extern LeafInfo rprFairnessResetWaterMarks_cookie;
extern LeafInfo rprFairnessSTQHighWaterMark_cookie;
extern LeafInfo rprFairnessSTQLowWaterMark_cookie;
extern LeafInfo rprFairnessRampUpCoef_cookie;
extern LeafInfo rprFairnessRampDnCoef_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo rprIfIndex_cookie;
extern LeafInfo rprTopoImageMacAddress_cookie;
extern LeafInfo rprTopoImageSecMacAddress1_cookie;
extern LeafInfo rprTopoImageSecMacAddress2_cookie;
extern LeafInfo rprTopoImageStationIfIndex_cookie;
extern LeafInfo rprTopoImageStationName_cookie;
extern LeafInfo rprTopoImageCapability_cookie;
extern LeafInfo rprTopoImageRinglet0Hops_cookie;
extern LeafInfo rprTopoImageRinglet0ReservedRate_cookie;
extern LeafInfo rprTopoImageRinglet1Hops_cookie;
extern LeafInfo rprTopoImageRinglet1ReservedRate_cookie;
extern LeafInfo rprTopoImageWestProtectionStatus_cookie;
extern LeafInfo rprTopoImageWestWeight_cookie;
extern LeafInfo rprTopoImageEastProtectionStatus_cookie;
extern LeafInfo rprTopoImageEastWeight_cookie;
extern LeafInfo rprTopoImageStatus_cookie;
extern LeafInfo rprTopoImageRemoteNEAddress_cookie;
extern LeafInfo rprTopoImageRemoteSlotNumber_cookie;
extern LeafInfo rprIfTable_cookie;
extern LeafInfo rprSpanTable_cookie;
extern LeafInfo rprSpanProtectionTable_cookie;
extern LeafInfo rprCardProtectionTable_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo rprIfIndex_cookie;
extern LeafInfo rprCardProtectionId_cookie;
extern LeafInfo rprCpfWorkSlot_cookie;
extern LeafInfo rprCpfProtSlot_cookie;
extern LeafInfo rprCpfActiveSlot_cookie;
extern LeafInfo rprCpfCoordSlot_cookie;
extern LeafInfo rprCpfCoordProtGroup_cookie;
extern LeafInfo rprCpfEnable_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo rprIfIndex_cookie;
extern LeafInfo rprSpanId_cookie;
extern LeafInfo rprSpanProtectionNeighborValid_cookie;
extern LeafInfo rprSpanProtectionHoldOffTimer_cookie;
extern LeafInfo rprSpanProtectionCommand_cookie;
extern LeafInfo rprSpanProtectionCount_cookie;
extern LeafInfo rprSpanProtectionDuration_cookie;
extern LeafInfo rprSpanProtectionLastActivationTime_cookie;
extern LeafInfo rprSpanProtectionCountReset_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo rprIfIndex_cookie;
extern LeafInfo rprSpanId_cookie;
extern LeafInfo rprSpanTotalRingletReservedRate_cookie;
extern LeafInfo rprSpanCurrentStatus_cookie;
extern LeafInfo rprSpanWanPortNo_cookie;
extern LeafInfo rprSpanHopsToWrap_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo rprIfIndex_cookie;
extern LeafInfo rprIfStationsOnRing_cookie;
extern LeafInfo rprIfReversionMode_cookie;
extern LeafInfo rprIfProtectionWTR_cookie;
extern LeafInfo rprIfProtectionFastTimer_cookie;
extern LeafInfo rprIfProtectionSlowTimer_cookie;
extern LeafInfo rprIfAtdTimer_cookie;
extern LeafInfo rprIfKeepaliveTimeout_cookie;
extern LeafInfo rprIfFairnessMode_cookie;
extern LeafInfo rprIfPtqSize_cookie;
extern LeafInfo rprIfStqSize_cookie;
extern LeafInfo rprIfSTQFullThreshold_cookie;
extern LeafInfo rprIfIdleThreshold_cookie;
extern LeafInfo rprIfSesThreshold_cookie;
extern LeafInfo rprIfProtectionMode_cookie;
extern LeafInfo rprIfJumboFramePreferred_cookie;
extern LeafInfo rprIfMacOperModes_cookie;
extern LeafInfo rprIfRingOperModes_cookie;
extern LeafInfo rprIfCurrentStatus_cookie;
extern LeafInfo rprIfLinkRate_cookie;
extern LeafInfo rprIfMplsMode_cookie;
extern LeafInfo rprIfMplsTypeTag_cookie;
extern LeafInfo rprIfVlanPrioEn_cookie;
extern LeafInfo rprIfMyMacAddress_cookie;
extern LeafInfo rprIfPassThroughEn_cookie;
extern LeafInfo rprIfHwPassThrough_cookie;
extern LeafInfo rprIfHwPassThroughStatus_cookie;
extern LeafInfo rprIfResRateR0_cookie;
extern LeafInfo rprIfResRateR1_cookie;
extern LeafInfo rprIfA0RateR0_cookie;
extern LeafInfo rprIfA0RateR1_cookie;
extern LeafInfo rprIfA1RateR0_cookie;
extern LeafInfo rprIfA1RateR1_cookie;
extern LeafInfo rprIfBcirRateR0_cookie;
extern LeafInfo rprIfBcirRateR1_cookie;
extern LeafInfo rprIfRealA0RateR0_cookie;
extern LeafInfo rprIfRealA0RateR1_cookie;
extern LeafInfo rprIfRealA1RateR0_cookie;
extern LeafInfo rprIfRealA1RateR1_cookie;
extern LeafInfo rprIfRealBcirRateR0_cookie;
extern LeafInfo rprIfRealBcirRateR1_cookie;
extern LeafInfo rprIfAlarmMon_cookie;
extern LeafInfo rprIfStationName_cookie;
extern LeafInfo rprIfInterWorking_cookie;
extern LeafInfo rprIfBandMode_cookie;
extern LeafInfo rprIfMulBrdCastEn_cookie;
extern LeafInfo rprIfCardProtection_cookie;
extern LeafInfo rprIfCardProtectionState_cookie;
extern LeafInfo rprIfL2RateLimitMode_cookie;
extern LeafInfo rprIfCrossPortsList_cookie;
extern LeafInfo rprIfLogSave_cookie;
extern LeafInfo rprIfL2CosFlowControl_cookie;
extern LeafInfo pbXConConnectCapacity_cookie;
extern LeafInfo pbXConConnectSrcSlot_cookie;
extern LeafInfo pbXConConnectSrcPort_cookie;
extern LeafInfo pbXConConnectSrcPortType_cookie;
extern LeafInfo pbXConConnectSource_cookie;
extern LeafInfo pbXConConnectDstSlot_cookie;
extern LeafInfo pbXConConnectDstPort_cookie;
extern LeafInfo pbXConConnectDstPortType_cookie;
extern LeafInfo pbXConConnectDestination_cookie;
extern LeafInfo pbXConConnectId_cookie;
extern LeafInfo pbXConConnectCircuitId_cookie;
extern LeafInfo pbXConConnectStatus_cookie;
extern LeafInfo pbXConConnectReason_cookie;
extern LeafInfo pbXConConnectType_cookie;
extern LeafInfo pbXConConnectCircuitDirection_cookie;
extern LeafInfo pbXConConnectAction_cookie;
extern LeafInfo pbXConFrom_cookie;
extern LeafInfo pbXConRowStatus_cookie;
extern LeafInfo pbXConConnectReqNo_cookie;
extern LeafInfo pbXCGmplsVcNumber_cookie;
extern LeafInfo pbXCGmplsCallName_cookie;
extern LeafInfo pbGmplsCcDirection_cookie;
extern LeafInfo pbXCExtendObjects_cookie;
extern LeafInfo pbSdhXcNewContextTable_cookie;
extern LeafInfo pbSdhXcNewLoMapTable_cookie;
extern LeafInfo pbXcMigrationGroup_cookie;
extern LeafInfo pbForwardXcId_cookie;
extern LeafInfo pbReverseXcId_cookie;
extern LeafInfo pbXcMigrationCommand_cookie;
extern LeafInfo pbXcMigrationStatus_cookie;
extern LeafInfo pbXConLoMapLOCCSlot_cookie;
extern LeafInfo pbXConLoMapLOCCPortType_cookie;
extern LeafInfo pbXConLoMapLOCCPort_cookie;
extern LeafInfo pbXConLoMapHOCCIndex_cookie;
extern LeafInfo pbXConLoMapLCSlot_cookie;
extern LeafInfo pbXConLoMapLCPortType_cookie;
extern LeafInfo pbXConLoMapLCPort_cookie;
extern LeafInfo pbXConLoMapLCTP_cookie;
extern LeafInfo gmplsReservationStatus_cookie;
extern LeafInfo gmplsReservationOperate_cookie;
extern LeafInfo pbXConContextLOCCBusNum_cookie;
extern LeafInfo pbXConContextLOCCAuNum_cookie;
extern LeafInfo pbXConContextHOCCAu3Num_cookie;
extern LeafInfo pbXConContextHOCCAu3Step_cookie;
extern LeafInfo pbXConContextHOCCAu3Count_cookie;
extern LeafInfo pbEthGlobalPortTable_cookie;
extern LeafInfo pbEthConfigTable_cookie;
extern LeafInfo pbEthWanConfigTable_cookie;
extern LeafInfo pbEthStaticMACTable_cookie;
extern LeafInfo pbEthStaticMulticastTable_cookie;
extern LeafInfo pbVlanPortCoSTable_cookie;
extern LeafInfo pbEthVlanNameTable_cookie;
extern LeafInfo pbPortQueueTable_cookie;
extern LeafInfo pbEthACLTable_cookie;
extern LeafInfo pbRstpBase_cookie;
extern LeafInfo pbEthStatusTable_cookie;
extern LeafInfo pbVlanPortQinQTable_cookie;
extern LeafInfo pbEthProtPktACLTable_cookie;
extern LeafInfo pbEthReservedTable_cookie;
extern LeafInfo pbIGMPSnooping_cookie;
extern LeafInfo pbMstpBase_cookie;
extern LeafInfo pbLagConfigTable_cookie;
extern LeafInfo pbLacpConfig_cookie;
extern LeafInfo pbEthStaticMplsTable_cookie;
extern LeafInfo eosMapper_cookie;
extern LeafInfo pbGvrpBase_cookie;
extern LeafInfo pbEthPolicingTable_cookie;
extern LeafInfo pbEthColorTable_cookie;
extern LeafInfo pbEthWredTable_cookie;
extern LeafInfo pbEthPortBasedACLTable_cookie;
extern LeafInfo pbGmrpBase_cookie;
extern LeafInfo pbGmrpBridgeTable_cookie;
extern LeafInfo pbGmrpPortTable_cookie;
extern LeafInfo pbVlanGmrpTable_cookie;
extern LeafInfo pbGmrpDMacTable_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbGmrpVlanId_cookie;
extern LeafInfo pbGmrpMacAddr_cookie;
extern LeafInfo pbGmrpMacMemberPort1_cookie;
extern LeafInfo pbGmrpMacMemberPort2_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbGmrpVlanNumber_cookie;
extern LeafInfo pbVlanGmrpEnable_cookie;
extern LeafInfo pbVlanGmrpRowStatus_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbGmrpPortType_cookie;
extern LeafInfo pbGmrpPortNo_cookie;
extern LeafInfo pbGmrpPortEnable_cookie;
extern LeafInfo pbGmrpPortRegAdminCtrl_cookie;
extern LeafInfo pbGmrpPortApplAdminCtrl_cookie;
extern LeafInfo pbGmrpForwardAllEnable_cookie;
extern LeafInfo pbGmrpBlockPortEnable_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbGmrpBridgeAddress_cookie;
extern LeafInfo pbGmrpEnable_cookie;
extern LeafInfo pbGmrpJoinTimer_cookie;
extern LeafInfo pbGmrpLeaveTimer_cookie;
extern LeafInfo pbGmrpLeaveallTimer_cookie;
extern LeafInfo pbGmrpMaxDMacNum_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbEthPortCls_cookie;
extern LeafInfo pbEthPortBasedACLMacAddr_cookie;
extern LeafInfo pbEthPortBasedACLVid_cookie;
extern LeafInfo pbEthPortBasedACLItemType_cookie;
extern LeafInfo pbEthPortBasedACLRateLimit_cookie;
extern LeafInfo pbEthPortBasedACLCoS_cookie;
extern LeafInfo pbEthPortBasedACLIndex_cookie;
extern LeafInfo pbEthPortBasedACLEntryRowStatus_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbEthWredIndex_cookie;
extern LeafInfo pbEthWredLowThr0_cookie;
extern LeafInfo pbEthWredUpThr0_cookie;
extern LeafInfo pbEthWredLowThr1_cookie;
extern LeafInfo pbEthWredUpThr1_cookie;
extern LeafInfo pbEthWredLowThr2_cookie;
extern LeafInfo pbEthWredUpThr2_cookie;
extern LeafInfo pbEthWredRowStatus_cookie;
extern LeafInfo pbEthWredCount_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbEthColorIndex_cookie;
extern LeafInfo pbEthPrio0Color_cookie;
extern LeafInfo pbEthPrio1Color_cookie;
extern LeafInfo pbEthPrio2Color_cookie;
extern LeafInfo pbEthPrio3Color_cookie;
extern LeafInfo pbEthPrio4Color_cookie;
extern LeafInfo pbEthPrio5Color_cookie;
extern LeafInfo pbEthPrio6Color_cookie;
extern LeafInfo pbEthPrio7Color_cookie;
extern LeafInfo pbEthColorRowStatus_cookie;
extern LeafInfo pbEthColorCount_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbEthPolicingIndex_cookie;
extern LeafInfo pbEthPolicingName_cookie;
extern LeafInfo pbEthPolicingMode_cookie;
extern LeafInfo pbEthPolicingEIRPIR_cookie;
extern LeafInfo pbEthPolicingCIR_cookie;
extern LeafInfo pbEthPolicingEBSPBS_cookie;
extern LeafInfo pbEthPolicingCBS_cookie;
extern LeafInfo pbEthPolicingColorAware_cookie;
extern LeafInfo pbEthPolicingDiscardColor_cookie;
extern LeafInfo pbEthPolicingRowStatus_cookie;
extern LeafInfo pbEthPolicingCount_cookie;
extern LeafInfo pbGvrpBridgeTable_cookie;
extern LeafInfo pbGvrpPortTable_cookie;
extern LeafInfo pbGvrpDVlanTable_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbGvrpDPortType_cookie;
extern LeafInfo pbGvrpDPortNo_cookie;
extern LeafInfo pbGvrpDVlanList_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbGvrpPortType_cookie;
extern LeafInfo pbGvrpPortNo_cookie;
extern LeafInfo pbGvrpPortEnable_cookie;
extern LeafInfo pbGvrpPortRegAdminCtrl_cookie;
extern LeafInfo pbGvrpPortApplAdminCtrl_cookie;
extern LeafInfo pbGvrpBlockPortEnable_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbGvrpBridgeAddress_cookie;
extern LeafInfo pbGvrpEnable_cookie;
extern LeafInfo pbGvrpJoinTimer_cookie;
extern LeafInfo pbGvrpLeaveTimer_cookie;
extern LeafInfo pbGvrpLeaveallTimer_cookie;
extern LeafInfo pbGvrpVlanList_cookie;
extern LeafInfo pbGvrpMaxDVlanNum_cookie;
extern LeafInfo vcgConfigTable_cookie;
extern LeafInfo eosGlobalConfigTable_cookie;
extern LeafInfo pbSOLCASConfigTable_cookie;
extern LeafInfo pbSKLCASConfigTable_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbTpType_cookie;
extern LeafInfo pbTpIndex_cookie;
extern LeafInfo pbSKLCASVCGPort_cookie;
extern LeafInfo pbSKLCASState_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbTpType_cookie;
extern LeafInfo pbTpIndex_cookie;
extern LeafInfo pbSOLCASActive_cookie;
extern LeafInfo pbSOLCASVCGPort_cookie;
extern LeafInfo pbSOLCASState_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo eosIPGConfig_cookie;
extern LeafInfo eosMTUSize_cookie;
extern LeafInfo eosEslConfig_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo vcgNo_cookie;
extern LeafInfo vcgLabel_cookie;
extern LeafInfo vcgXVType_cookie;
extern LeafInfo vcgChannelId_cookie;
extern LeafInfo vcgLCASSupport_cookie;
extern LeafInfo vcgCapacityTrigger_cookie;
extern LeafInfo vcgPauseTransparent_cookie;
extern LeafInfo vcgLcasHoldOffTime_cookie;
extern LeafInfo vcgGfpMode_cookie;
extern LeafInfo vcgGfpType_cookie;
extern LeafInfo vcgGfpFCS_cookie;
extern LeafInfo vcgGfpFcsAutoDetect_cookie;
extern LeafInfo vcgGfpCsfAutoMode_cookie;
extern LeafInfo vcgPortMonMode_cookie;
extern LeafInfo vcgPortAlarmDisable_cookie;
extern LeafInfo vcgPLCTThreshold_cookie;
extern LeafInfo vcgPLCRThreshold_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbEthLspLabel_cookie;
extern LeafInfo pbEthInPort_cookie;
extern LeafInfo pbEthInPortType_cookie;
extern LeafInfo pbEthPort_cookie;
extern LeafInfo pbEthOutPortType_cookie;
extern LeafInfo pbEthStaticMplsPolicingID_cookie;
extern LeafInfo pbEthStaticMplsColorID_cookie;
extern LeafInfo pbEthStaticMplsStatus_cookie;
extern LeafInfo pbEthLspName_cookie;
extern LeafInfo pbLacpGlobalCfgTable_cookie;
extern LeafInfo pbLacpAgConfigTable_cookie;
extern LeafInfo pbLacpAgInformTable_cookie;
extern LeafInfo pbLacpApConfigTable_cookie;
extern LeafInfo pbLacpApInformTable_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbLacpPortType_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbLacpPortLinkState_cookie;
extern LeafInfo pbLacpPortBelongAg_cookie;
extern LeafInfo pbLacpPortSync_cookie;
extern LeafInfo pbLacpPortOperKey_cookie;
extern LeafInfo pbLacpPartnerPortNo_cookie;
extern LeafInfo pbLacpPartnerPortMode_cookie;
extern LeafInfo pbLacpPartnerPortPri_cookie;
extern LeafInfo pbLacpPartnerOperKey_cookie;
extern LeafInfo pbLacpPartnerPortState_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbLacpPortType_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbLacpTimeoutMode_cookie;
extern LeafInfo pbLacpPortIndiv_cookie;
extern LeafInfo pbLacpActiveMode_cookie;
extern LeafInfo pbLacpDesigAggor_cookie;
extern LeafInfo pbLacpPortPri_cookie;
extern LeafInfo pbLacpPortBpduMode_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbLacpAgNo_cookie;
extern LeafInfo pbLacpAgOperKey_cookie;
extern LeafInfo pbLacpPortList_cookie;
extern LeafInfo pbLacpPartnerMac_cookie;
extern LeafInfo pbLacpPartnerSysPri_cookie;
extern LeafInfo pbLacpPartnerAgOperKey_cookie;
extern LeafInfo pbLacpPortTypeInAg_cookie;
extern LeafInfo pbLacpPortSpeedInAg_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbLacpAgNo_cookie;
extern LeafInfo pbLacpAgName_cookie;
extern LeafInfo pbLacpAgMac_cookie;
extern LeafInfo pbLacpAgMode_cookie;
extern LeafInfo pbLacpAgRowState_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbLacpEnable_cookie;
extern LeafInfo pbLacpSystemID_cookie;
extern LeafInfo pbLacpSystemPri_cookie;
extern LeafInfo pbLacpHashMode_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbLagId_cookie;
extern LeafInfo pbLagType_cookie;
extern LeafInfo pbLagFlowControl_cookie;
extern LeafInfo pbLagPvid_cookie;
extern LeafInfo pbLagVlan_cookie;
extern LeafInfo pbLagTagMode_cookie;
extern LeafInfo pbLagInputRateLimit_cookie;
extern LeafInfo pbLagBroadCastRateLimit_cookie;
extern LeafInfo pbLagDefaultVlanPriority_cookie;
extern LeafInfo pbLagTxPriAlg_cookie;
extern LeafInfo pbLagTxEnableHol_cookie;
extern LeafInfo pbLagChangeCoS_cookie;
extern LeafInfo pbLagQinQStatus_cookie;
extern LeafInfo pbLagQinQNewVlan_cookie;
extern LeafInfo pbLagQinQNewVlanPriority_cookie;
extern LeafInfo pbLagPortList_cookie;
extern LeafInfo pbLagEnableWred_cookie;
extern LeafInfo pbMstpBridgeBase_cookie;
extern LeafInfo pbMstpPortBase_cookie;
extern LeafInfo pbMstpBridgeStateBase_cookie;
extern LeafInfo pbMstpPortStateBase_cookie;
extern LeafInfo pbCistPortStateTable_cookie;
extern LeafInfo pbMstiPortStateTable_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbMstPortType_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbMstiNumber_cookie;
extern LeafInfo pbMstiPPVector1_cookie;
extern LeafInfo pbMstiPPVector2_cookie;
extern LeafInfo pbMstiDPVector1_cookie;
extern LeafInfo pbMstiDPVector2_cookie;
extern LeafInfo pbMstiMPVector1_cookie;
extern LeafInfo pbMstiMPVector2_cookie;
extern LeafInfo pbMstiPTimes_cookie;
extern LeafInfo pbMstiDTimes_cookie;
extern LeafInfo pbMstiMTimes_cookie;
extern LeafInfo pbMstiPState_cookie;
extern LeafInfo pbMstiPInfoIs_cookie;
extern LeafInfo pbMstiPRole_cookie;
extern LeafInfo pbMstiPSelectedRole_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbMstPortType_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbCistPortEnable_cookie;
extern LeafInfo pbCistPPVector1_cookie;
extern LeafInfo pbCistPPVector2_cookie;
extern LeafInfo pbCistPPVector3_cookie;
extern LeafInfo pbCistDPVector1_cookie;
extern LeafInfo pbCistDPVector2_cookie;
extern LeafInfo pbCistDPVector3_cookie;
extern LeafInfo pbCistMPVector1_cookie;
extern LeafInfo pbCistMPVector2_cookie;
extern LeafInfo pbCistMPVector3_cookie;
extern LeafInfo pbCistPTimes_cookie;
extern LeafInfo pbCistDTimes_cookie;
extern LeafInfo pbCistMTimes_cookie;
extern LeafInfo pbCistPState_cookie;
extern LeafInfo pbCistPInfoIs_cookie;
extern LeafInfo pbCistPRole_cookie;
extern LeafInfo pbCistPPState_cookie;
extern LeafInfo pbMstRcvdInternal_cookie;
extern LeafInfo pbPortBpduRule_cookie;
extern LeafInfo pbPortOperEdge_cookie;
extern LeafInfo pbCistBridgeStateTable_cookie;
extern LeafInfo pbMstiBridgeStateTable_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbMstiNumber_cookie;
extern LeafInfo pbMstiRPVector1_cookie;
extern LeafInfo pbMstiRPVector2_cookie;
extern LeafInfo pbMstiRootRemainingHops_cookie;
extern LeafInfo pbMstiRootPortId_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbMstBaseNumPorts_cookie;
extern LeafInfo pbCistRPVector1_cookie;
extern LeafInfo pbCistRPVector2_cookie;
extern LeafInfo pbCistRPVector3_cookie;
extern LeafInfo pbMstRootMaxAge_cookie;
extern LeafInfo pbMstRootMsgAge_cookie;
extern LeafInfo pbMstRootHelloTime_cookie;
extern LeafInfo pbMstRootForwardDelay_cookie;
extern LeafInfo pbCistRootRemainingHops_cookie;
extern LeafInfo pbCistRootPortId_cookie;
extern LeafInfo pbMstCfgDigest_cookie;
extern LeafInfo pbCistPortTable_cookie;
extern LeafInfo pbMstiPortTable_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbMstPortType_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbMstiNumber_cookie;
extern LeafInfo pbMstiPortPriority_cookie;
extern LeafInfo pbMstiPortPathCost_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbMstPortType_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbMstPort_cookie;
extern LeafInfo pbCistPortPriority_cookie;
extern LeafInfo pbCistExPortPathCost_cookie;
extern LeafInfo pbCistInPortPathCost_cookie;
extern LeafInfo pbMstPortAdminEdgePort_cookie;
extern LeafInfo pbMstPortAdminPointToPoint_cookie;
extern LeafInfo pbMstPortEnable_cookie;
extern LeafInfo pbMstPortCheck_cookie;
extern LeafInfo pbMstPortBpduMode_cookie;
extern LeafInfo pbCistBridgeTable_cookie;
extern LeafInfo pbMstiBridgeTable_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbMstiNumber_cookie;
extern LeafInfo pbMstiVlanNumber_cookie;
extern LeafInfo pbMstiPriority_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbMstBaseBridgeAddress_cookie;
extern LeafInfo pbCistPriority_cookie;
extern LeafInfo pbMstForceVersion_cookie;
extern LeafInfo pbMstBridgeMaxAge_cookie;
extern LeafInfo pbMstBridgeHelloTime_cookie;
extern LeafInfo pbMstBridgeForwardDelay_cookie;
extern LeafInfo pbMstTxHoldCount_cookie;
extern LeafInfo pbMstMaxHops_cookie;
extern LeafInfo pbMstMstpBEGIN_cookie;
extern LeafInfo pbMstMstpConfigName_cookie;
extern LeafInfo pbMstMstpRevisonLevel_cookie;
extern LeafInfo pbMstEventSwitch_cookie;
extern LeafInfo pbIgmpSnoopingGlobalTable_cookie;
extern LeafInfo pbVlanIgmpSnoopingTable_cookie;
extern LeafInfo pbIgmpSnoopingIpGroupTable_cookie;
extern LeafInfo pbIgmpSnoopingMacGroupTable_cookie;
extern LeafInfo pbIgmpSnoopingMulRouterTable_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbIgmpVlanNumber_cookie;
extern LeafInfo pbIgmpMulRouterPort_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbIgmpVlanNumber_cookie;
extern LeafInfo pbIgmpMacAddr_cookie;
extern LeafInfo pbIgmpMacMemberPort_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbIgmpVlanNumber_cookie;
extern LeafInfo pbGroupIp_cookie;
extern LeafInfo pbIgmpMacAddr_cookie;
extern LeafInfo pbIgmpIpMemberPort_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbIgmpVlanNumber_cookie;
extern LeafInfo pbVlanIgmpSnoopingEnable_cookie;
extern LeafInfo pbVlanIgmpSnoopingRowStatus_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbIgmpSnoopingEnable_cookie;
extern LeafInfo pbIgmpSnoopingAgingTime_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbEthReserveIndex_cookie;
extern LeafInfo pbEthReservedCfg_cookie;
extern LeafInfo pbEthReservedRowStatus_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbEthACLMacAddr_cookie;
extern LeafInfo pbEthProtPktACLPort_cookie;
extern LeafInfo pbEthProtPktACLIndex_cookie;
extern LeafInfo pbEthProtPktACLRowStatus_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbEthPortCls_cookie;
extern LeafInfo pbEthVlan_cookie;
extern LeafInfo pbEthQinQNewVlanId_cookie;
extern LeafInfo pbEthQinQNewVlanPriority_cookie;
extern LeafInfo pbVlanPortQinQIndex_cookie;
extern LeafInfo pbEthVlanPortQinQRowStatus_cookie;
extern LeafInfo pbEthQinQNewVlanPriMode_cookie;
extern LeafInfo pbEthQinQVlanSwapEnable_cookie;
extern LeafInfo pbEthQinQVlanSwapVid_cookie;
extern LeafInfo pbEthQinQVlanSwapMode_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbEthStatusPortStyle_cookie;
extern LeafInfo pbEthStatusPortType_cookie;
extern LeafInfo pbEthStatusPortOperStatus_cookie;
extern LeafInfo pbEthStatusLaserIBias_cookie;
extern LeafInfo pbEthStatusLaserRecvPwr_cookie;
extern LeafInfo pbEthStatusLaserTransPwr_cookie;
extern LeafInfo pbEthStatusLaserTemp_cookie;
extern LeafInfo pbEthStatusCompliance8472_cookie;
extern LeafInfo pbEthStatusNominalMBps_cookie;
extern LeafInfo pbEthStatusWavelength_cookie;
extern LeafInfo pbEthStatusLinkLength9125_cookie;
extern LeafInfo pbEthStatusLinkLength50125_cookie;
extern LeafInfo pbEthStatusLinkLength62125_cookie;
extern LeafInfo pbEthStatusLinkLengthCopper_cookie;
extern LeafInfo pbEthStatusVendorName_cookie;
extern LeafInfo pbEthStatusVendorPN_cookie;
extern LeafInfo pbEthStatusVendorSN_cookie;
extern LeafInfo pbEthStatusManuDate_cookie;
extern LeafInfo pbEthStatusTransCode_cookie;
extern LeafInfo pbEthStatusVendorOUI_cookie;
extern LeafInfo pbEthStatusConnectorType_cookie;
extern LeafInfo pbEthsSAGPartNumber_cookie;
extern LeafInfo pbEthnClLaserTemp_cookie;
extern LeafInfo pbEthnTECCurrent_cookie;
extern LeafInfo pbRstpBridgeTable_cookie;
extern LeafInfo pbRstpPortTable_cookie;
extern LeafInfo pbRstpBridgeStateTable_cookie;
extern LeafInfo pbRstpPortStateTable_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbRstpPortType_cookie;
extern LeafInfo pbRstpPortNo_cookie;
extern LeafInfo pbRstpPEnable_cookie;
extern LeafInfo pbRstpPPVector1_cookie;
extern LeafInfo pbRstpPPVector2_cookie;
extern LeafInfo pbRstpDsgPVector1_cookie;
extern LeafInfo pbRstpDsgPVector2_cookie;
extern LeafInfo pbRstpMsgPVector1_cookie;
extern LeafInfo pbRstpMsgPVector2_cookie;
extern LeafInfo pbRstpPTimes_cookie;
extern LeafInfo pbRstpDsgTimes_cookie;
extern LeafInfo pbRstpMsgTimes_cookie;
extern LeafInfo pbRstpPForward_cookie;
extern LeafInfo pbRstpPLearn_cookie;
extern LeafInfo pbRstpPInfoIs_cookie;
extern LeafInfo pbRstpPRole_cookie;
extern LeafInfo pbRstpPSelectedRole_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbRstpRPVector1_cookie;
extern LeafInfo pbRstpRPVector2_cookie;
extern LeafInfo pbRstpRootMaxAge_cookie;
extern LeafInfo pbRstpRootHelloTime_cookie;
extern LeafInfo pbRstpRootForwardDelay_cookie;
extern LeafInfo pbRstpRootPortId_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbRstpPortType_cookie;
extern LeafInfo pbRstpPortNo_cookie;
extern LeafInfo pbRstpPortPriority_cookie;
extern LeafInfo pbRstpPortEnable_cookie;
extern LeafInfo pbRstpPortPathCost_cookie;
extern LeafInfo pbRstpPortAdminEdgePort_cookie;
extern LeafInfo pbRstpPortAdminPointToPoint_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbRstpBridgeAddress_cookie;
extern LeafInfo pbRstpBridgePriority_cookie;
extern LeafInfo pbRstpBridgeMaxAge_cookie;
extern LeafInfo pbRstpBridgeHelloTime_cookie;
extern LeafInfo pbRstpBridgeForwardDelay_cookie;
extern LeafInfo pbRstpTxHoldCount_cookie;
extern LeafInfo pbRstpBEGIN_cookie;
extern LeafInfo pbRstpEventSwitch_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbEthACLMacAddr_cookie;
extern LeafInfo pbEthACLVid_cookie;
extern LeafInfo pbEthACLItemType_cookie;
extern LeafInfo pbEthACLRateLimit_cookie;
extern LeafInfo pbEthACLCoS_cookie;
extern LeafInfo pbEthACLIndex_cookie;
extern LeafInfo pbEthACLEntryRowStatus_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbEthPortStyle_cookie;
extern LeafInfo pbEthTxQueNo_cookie;
extern LeafInfo pbEthPortQueueWeight_cookie;
extern LeafInfo pbEthQueueWredID_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbEthNamedVlan_cookie;
extern LeafInfo pbEthVlanName_cookie;
extern LeafInfo pbEthVlanRowStatus_cookie;
extern LeafInfo pbEthVlanEnableMacLearning_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbEthPortCls_cookie;
extern LeafInfo pbEthVlan_cookie;
extern LeafInfo pbEthRateLimitValue_cookie;
extern LeafInfo pbEthVlanCoS_cookie;
extern LeafInfo pbEthVlanDisable_cookie;
extern LeafInfo pbEthRedirectionPort_cookie;
extern LeafInfo pbVlanPortCoSIndex_cookie;
extern LeafInfo pbEthVlanPortCoSRowStatus_cookie;
extern LeafInfo pbEthVlanPolicingID_cookie;
extern LeafInfo pbEthVlanColorID_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbStaticMulticastMacAddr_cookie;
extern LeafInfo pbStaticMulticastVlan_cookie;
extern LeafInfo pbStaticMulticastPortList_cookie;
extern LeafInfo pbStaticMulticastIndex_cookie;
extern LeafInfo pbStaticMulticastRowStatus_cookie;
extern LeafInfo pbStaticMulticastForGmrp_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbMACEntryMacAddr_cookie;
extern LeafInfo pbMACEntryVid_cookie;
extern LeafInfo pbMACEntryPort_cookie;
extern LeafInfo pbMACEntryTagged_cookie;
extern LeafInfo pbMACEntryIndex_cookie;
extern LeafInfo pbMACEntryRowStatus_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbWanLabel_cookie;
extern LeafInfo pbWanVlanList_cookie;
extern LeafInfo pbWanTaggedVlanList_cookie;
extern LeafInfo pbWanDefaultVlanPriority_cookie;
extern LeafInfo pbWanChangeCoS_cookie;
extern LeafInfo pbWanPvid_cookie;
extern LeafInfo pbWanTagMode_cookie;
extern LeafInfo pbWanFlowControl_cookie;
extern LeafInfo pbWanTxPriAlg_cookie;
extern LeafInfo pbWanTxEnableHol_cookie;
extern LeafInfo pbWanQinQStatus_cookie;
extern LeafInfo pbWanQinQNewVlan_cookie;
extern LeafInfo pbWanQinQNewVlanPriority_cookie;
extern LeafInfo pbWanTPID_cookie;
extern LeafInfo pbWanMirrorPort_cookie;
extern LeafInfo pbWanLinkStatus_cookie;
extern LeafInfo pbWanPortWorkMode_cookie;
extern LeafInfo pbWanEnableWred_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbEthPortType_cookie;
extern LeafInfo pbEthPortAdminStatus_cookie;
extern LeafInfo pbPortLinkStatus_cookie;
extern LeafInfo pbEthPortAutoNego_cookie;
extern LeafInfo pbEthPortFlowControl_cookie;
extern LeafInfo pbEthPortSpeed_cookie;
extern LeafInfo pbEthPortDuplex_cookie;
extern LeafInfo pbEthPortVlan_cookie;
extern LeafInfo pbEthPortPvid_cookie;
extern LeafInfo pbUnTagMode_cookie;
extern LeafInfo pbPortInputRateLimit_cookie;
extern LeafInfo pbEthPortMode_cookie;
extern LeafInfo pbEthPortBroadCastRateLimit_cookie;
extern LeafInfo pbPortDefaultVlanPriority_cookie;
extern LeafInfo pbEthPortLabel_cookie;
extern LeafInfo pbLanTxPriAlg_cookie;
extern LeafInfo pbLanTaggedVlan_cookie;
extern LeafInfo pbEthPortLoopback_cookie;
extern LeafInfo pbEthTxEnableHol_cookie;
extern LeafInfo pbEthAutoLaserShutdown_cookie;
extern LeafInfo pbEthAlsMode_cookie;
extern LeafInfo pbEthPortAlarmDisable_cookie;
extern LeafInfo ethPortOnCSF_cookie;
extern LeafInfo ethMDIorMDIX_cookie;
extern LeafInfo pbLanChangeCoS_cookie;
extern LeafInfo pbLanQinQStatus_cookie;
extern LeafInfo pbLanQinQNewVlan_cookie;
extern LeafInfo pbLanQinQNewVlanPriority_cookie;
extern LeafInfo pbLanTPID_cookie;
extern LeafInfo pbLanMirrorPort_cookie;
extern LeafInfo pbEthPortClassifier_cookie;
extern LeafInfo pbEthPortWorkMode_cookie;
extern LeafInfo pbEthEnableWred_cookie;
extern LeafInfo pbSFPWorkMode_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortTagProtocol_cookie;
extern LeafInfo pbAgingTime_cookie;
extern LeafInfo pbIPGConfig_cookie;
extern LeafInfo pbVlanTagProtocolType_cookie;
extern LeafInfo pbMTUSize_cookie;
extern LeafInfo pbEthACLType_cookie;
extern LeafInfo pbEthBroadcastEnableHol_cookie;
extern LeafInfo pbEthTunnelingRxTPID_cookie;
extern LeafInfo pbEthQoSIEEE802Version_cookie;
extern LeafInfo pbEthChangeCoSMode_cookie;
extern LeafInfo pbEthLabelBase_cookie;
extern LeafInfo pbEthWredDropProbability_cookie;
extern LeafInfo pbIpRouteTable_cookie;
extern LeafInfo dccCfgTable_cookie;
extern LeafInfo ipInIpCfgTable_cookie;
extern LeafInfo mpBundleCfgTable_cookie;
extern LeafInfo pbStaticIpRouteTable_cookie;
extern LeafInfo tracertCfgTable_cookie;
extern LeafInfo tracertResultTable_cookie;
extern LeafInfo pingCfgTable_cookie;
extern LeafInfo pingResultTable_cookie;
extern LeafInfo dccReservePortTable_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo phyPortNum_cookie;
extern LeafInfo logPortNum_cookie;
extern LeafInfo pingIndex_cookie;
extern LeafInfo pingTargetIpAddrDis_cookie;
extern LeafInfo pingDataSizeDis_cookie;
extern LeafInfo pingTripTime_cookie;
extern LeafInfo pingTtlnumber_cookie;
extern LeafInfo pingResult_cookie;
extern LeafInfo pingRstRowStatus_cookie;
extern LeafInfo pingTargetIpAddr_cookie;
extern LeafInfo pingDataSize_cookie;
extern LeafInfo pingCounts_cookie;
extern LeafInfo pingTimeout_cookie;
extern LeafInfo pingRowStatus_cookie;
extern LeafInfo pingStart_cookie;
extern LeafInfo tracertTtlNumber_cookie;
extern LeafInfo tracertTripTime1_cookie;
extern LeafInfo tracertTripTime2_cookie;
extern LeafInfo tracertTripTime3_cookie;
extern LeafInfo tracertPeerIpAddrDis_cookie;
extern LeafInfo tracertRstRowStatus_cookie;
extern LeafInfo tracertPeerIpAddr_cookie;
extern LeafInfo tracertTimeout_cookie;
extern LeafInfo tracertRowStatus_cookie;
extern LeafInfo tracertStart_cookie;
extern LeafInfo pbStaticIpRouteDest_cookie;
extern LeafInfo pbStaticIpRouteMask_cookie;
extern LeafInfo pbStaticIpRouteProto_cookie;
extern LeafInfo pbStaticIpRouteIfIndex_cookie;
extern LeafInfo pbStaticIpRouteNextHop_cookie;
extern LeafInfo pbStaticIpRouteAdminStatus_cookie;
extern LeafInfo pbStaticIpRouteOperStatus_cookie;
extern LeafInfo pbStaticIpRouteMetricType_cookie;
extern LeafInfo pbStaticIpRouteCost_cookie;
extern LeafInfo bundlePeerIpAddr_cookie;
extern LeafInfo bundleIndex_cookie;
extern LeafInfo bundleStatus_cookie;
extern LeafInfo bundleNumber_cookie;
extern LeafInfo bundleRowStatus_cookie;
extern LeafInfo bundleTOS_cookie;
extern LeafInfo ipInIpIfIpAddr_cookie;
extern LeafInfo ipInIpIfMask_cookie;
extern LeafInfo ipInIpDestIpAddr_cookie;
extern LeafInfo ipInIpSourcIpAddr_cookie;
extern LeafInfo ipInIpIfIndex_cookie;
extern LeafInfo ipInIpIfMtu_cookie;
extern LeafInfo ipInIpRowStatus_cookie;
extern LeafInfo ipInIpPeerIfIpAddr_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo mode_cookie;
extern LeafInfo state_cookie;
extern LeafInfo protocol_cookie;
extern LeafInfo dccBundleNumber_cookie;
extern LeafInfo linkStatus_cookie;
extern LeafInfo mspStatus_cookie;
extern LeafInfo destSlot_cookie;
extern LeafInfo destPort_cookie;
extern LeafInfo mtu_cookie;
extern LeafInfo crcMode_cookie;
extern LeafInfo hcocIndex_cookie;
extern LeafInfo multilink_cookie;
extern LeafInfo pbIpRouteDest_cookie;
extern LeafInfo pbIpRouteMask_cookie;
extern LeafInfo pbIpRouteProto_cookie;
extern LeafInfo pbIpRouteIfIndex_cookie;
extern LeafInfo pbIpRouteNextHop_cookie;
extern LeafInfo pbIpRouteType_cookie;
extern LeafInfo pbIpRouteAge_cookie;
extern LeafInfo pbIpRouteMetric1_cookie;
extern LeafInfo pbIpRouteMetric2_cookie;
extern LeafInfo pbIpRouteMetric3_cookie;
extern LeafInfo pbIpRouteMetric4_cookie;
extern LeafInfo pbIpRouteMetric5_cookie;
extern LeafInfo pbTMSRefSourceTable_cookie;
extern LeafInfo pbTMSSysTimingGroup_cookie;
extern LeafInfo pbTMSStClkInTable_cookie;
extern LeafInfo pbTMSStClkOutTable_cookie;
extern LeafInfo pbTMSStClkOutIndex_cookie;
extern LeafInfo pbTMSStClkOutType_cookie;
extern LeafInfo pbTMSStClkOutMonitored_cookie;
extern LeafInfo pbTMSStClkOutSaBit_cookie;
extern LeafInfo pbTMSStClkOutQlThreshold_cookie;
extern LeafInfo pbTMSStClkOutSquelchMode_cookie;
extern LeafInfo tMSStClkOutOhm_cookie;
extern LeafInfo pbTMSStClkOutQlIn_cookie;
extern LeafInfo pbTMSStClkOutQl_cookie;
extern LeafInfo tmsStClkOutputMode_cookie;
extern LeafInfo pbTMSStClkOutState_cookie;
extern LeafInfo pbTMSStClkInIndex_cookie;
extern LeafInfo pbTMSStClkInType_cookie;
extern LeafInfo pbTMSStClkInMonitored_cookie;
extern LeafInfo pbTMSStClkInSaBit_cookie;
extern LeafInfo tMSStClkInOhm_cookie;
extern LeafInfo pbTMSSwitchRequest_cookie;
extern LeafInfo pbTMSActiveTimingSource_cookie;
extern LeafInfo pbTMSTimingState_cookie;
extern LeafInfo pbTMSSysTimingMode_cookie;
extern LeafInfo pbTMSSwitchRequestStatus_cookie;
extern LeafInfo pbTMSHoldoverDTS_cookie;
extern LeafInfo pbTMSStaClkOutSource_cookie;
extern LeafInfo pbTMSQlEnabled_cookie;
extern LeafInfo pbTMSExpectedSMMB_cookie;
extern LeafInfo pbTMSStClkAutoLoopPrevention_cookie;
extern LeafInfo tmsSysSrcFDThreshold_cookie;
extern LeafInfo tmsSysFDValue_cookie;
extern LeafInfo pbTMSRefSourceIndex_cookie;
extern LeafInfo pbTMSRefSourceSlot_cookie;
extern LeafInfo pbTMSRefSourcePort_cookie;
extern LeafInfo pbTMSRefSourceMonitored_cookie;
extern LeafInfo pbTMSSignalStatus_cookie;
extern LeafInfo pbTMSRefSourcePriority_cookie;
extern LeafInfo pbTMSRefSourceLockOut_cookie;
extern LeafInfo pbTMSRefSourceQlIn_cookie;
extern LeafInfo pbTMSRefSourceQl_cookie;
extern LeafInfo pbTMSQlProvionedMode_cookie;
extern LeafInfo pbTMSQlProvioned_cookie;
extern LeafInfo pbTMSRefSourceValid_cookie;
extern LeafInfo pbTMSRefSourceWTR_cookie;
extern LeafInfo tMSIfSdhQLType_cookie;
extern LeafInfo tMSRefSourceQLOut_cookie;
extern LeafInfo tMSForceDnu_cookie;
extern LeafInfo tMSSupportQlOut_cookie;
extern LeafInfo tMSPortType_cookie;
extern LeafInfo tmsRefSourceFDUpband_cookie;
extern LeafInfo tmsRefSourceFDLowband_cookie;
extern LeafInfo tmsRefSourceFDValue_cookie;
extern LeafInfo tmsStoredDrvClkNum_cookie;
extern LeafInfo pbDigitalTransport_cookie;
extern LeafInfo pbSonetSdh_cookie;
extern LeafInfo pbPortConfigTable_cookie;
extern LeafInfo pbPortStatusTable_cookie;
extern LeafInfo pbPortHoTpReserveTable_cookie;
extern LeafInfo pbTPConfigTable_cookie;
extern LeafInfo pbOTUPortConfigTable_cookie;
extern LeafInfo pbSdhPmUpLoadInfo_cookie;
extern LeafInfo pbSdhMostRecentIndex_cookie;
extern LeafInfo pbSdhRecentUapPerfMon_cookie;
extern LeafInfo pbSdhUapPerfMon_cookie;
extern LeafInfo pbSdhRecentPerfMon_cookie;
extern LeafInfo pbSdhCurPerfMon_cookie;
extern LeafInfo pbPRBSPortHisTable_cookie;
extern LeafInfo pbPRBSPortCurTable_cookie;
extern LeafInfo pbOTUPortStatusTable_cookie;
extern LeafInfo pbOTUTPConfigTable_cookie;
extern LeafInfo pbPMFilterConfigGroup_cookie;
extern LeafInfo pbPMFilterTable_cookie;
extern LeafInfo pbPmFilterType_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortType_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbTpType_cookie;
extern LeafInfo pbTpIndex_cookie;
extern LeafInfo pbTableType_cookie;
extern LeafInfo pbPmEthId_cookie;
extern LeafInfo pbPmReserved_cookie;
extern LeafInfo pbPmDeleteAllFilter_cookie;
extern LeafInfo pbPmDeleteSlotNumber_cookie;
extern LeafInfo pbPmDeleteSlotFilter_cookie;
extern LeafInfo pbPmDeleteFilterTypeId_cookie;
extern LeafInfo pbPmDeleteFilterType_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortType_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbOTUTpChannelId_cookie;
extern LeafInfo pbOTUTpSegment_cookie;
extern LeafInfo pbOTUTpType_cookie;
extern LeafInfo pbOTUMonitored_cookie;
extern LeafInfo pbOTUTimAlmEnable_cookie;
extern LeafInfo pbOTUTimActEnable_cookie;
extern LeafInfo pbOTUTxTti_cookie;
extern LeafInfo pbOTUExpTti_cookie;
extern LeafInfo pbOTURxTti_cookie;
extern LeafInfo pbOTUDegEnable_cookie;
extern LeafInfo pbOTUDegThreshold_cookie;
extern LeafInfo pbOTUDegIntervals_cookie;
extern LeafInfo pbOTUSendMaintenanceType_cookie;
extern LeafInfo pbOTURecvMaintenanceType_cookie;
extern LeafInfo pbOTUPlmAlmEnable_cookie;
extern LeafInfo pbOTUMsimAlmEnable_cookie;
extern LeafInfo pbOTUPtAlmEnable_cookie;
extern LeafInfo pbOTUTxPt_cookie;
extern LeafInfo pbOTUExpPt_cookie;
extern LeafInfo pbOTURxPt_cookie;
extern LeafInfo pmOTUNearEnd15minMonitored_cookie;
extern LeafInfo pmOTUFarEnd15minMonitored_cookie;
extern LeafInfo pmOTUNearEnd24hrMonitored_cookie;
extern LeafInfo pmOTUFarEnd24hrMonitored_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortType_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbSMRxTti_cookie;
extern LeafInfo pbRxPt_cookie;
extern LeafInfo pbRxChannelId_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbPortType_cookie;
extern LeafInfo pbPRBSEnable_cookie;
extern LeafInfo pbPRBSPattern_cookie;
extern LeafInfo pbPRBSErrorBlocks_cookie;
extern LeafInfo pbPRBSErrorSeconds_cookie;
extern LeafInfo pbPRBSStatus_cookie;
extern LeafInfo pbPRBSActualPortType_cookie;
extern LeafInfo prbsMode_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbPortType_cookie;
extern LeafInfo pbPRBSHisErrorSeconds_cookie;
extern LeafInfo pbPRBSHisMeanError_cookie;
extern LeafInfo pbPRBSTrapTimeStamp_cookie;
extern LeafInfo pbPRBSHisActualPortType_cookie;
extern LeafInfo pbSdhCurPMTable_cookie;
extern LeafInfo pbEthCurPMTable_cookie;
extern LeafInfo pbEthPmMonTimeIntervalSet_cookie;
extern LeafInfo pbxSecEthPmMonTable_cookie;
extern LeafInfo pbRprClientCurPMTable_cookie;
extern LeafInfo pbRprSpanCurPMTable_cookie;
extern LeafInfo pbPdhCurSlipTable_cookie;
extern LeafInfo pbPmMonitoredNumberTable_cookie;
extern LeafInfo pbPdhPmSlipEventEnable_cookie;
extern LeafInfo pbxSecEthPMTable_cookie;
extern LeafInfo pbPdhCurPMTable_cookie;
extern LeafInfo pbEthVlanPMTable_cookie;
extern LeafInfo pbxSecEthVlanPMTable_cookie;
extern LeafInfo pbEthTcaPMTable_cookie;
extern LeafInfo pbFecCurPMTable_cookie;
extern LeafInfo pbOtuCurPMTable_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortType_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbOtuTableType_cookie;
extern LeafInfo pbChannelID_cookie;
extern LeafInfo pbSegmentNum_cookie;
extern LeafInfo pbOtuPmMonitor_cookie;
extern LeafInfo pbOtuEsPmCounter_cookie;
extern LeafInfo pbOtuBbePmCounter_cookie;
extern LeafInfo pbOtuSesPmCounter_cookie;
extern LeafInfo pbOtuUasPmCounter_cookie;
extern LeafInfo pbOtuCsesPmCounter_cookie;
extern LeafInfo pbOtuFcPmCounter_cookie;
extern LeafInfo pbOtuOfsPmCounter_cookie;
extern LeafInfo pbOtuIaesPmCounter_cookie;
extern LeafInfo pbOtuBiaesPmCounter_cookie;
extern LeafInfo pbOtuPmTableReset_cookie;
extern LeafInfo pbOtuPmTimeStart_cookie;
extern LeafInfo pbOtuPmTimeElapse_cookie;
extern LeafInfo pbOtuPmSuspect_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortType_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbFecTableType_cookie;
extern LeafInfo pbFecPmMonitor_cookie;
extern LeafInfo pbFecTecPmCounterHigh_cookie;
extern LeafInfo pbFecTecPmCounterLow_cookie;
extern LeafInfo pbFecZecPmCounterHigh_cookie;
extern LeafInfo pbFecZecPmCounterLow_cookie;
extern LeafInfo pbFecOecPmCounterHigh_cookie;
extern LeafInfo pbFecOecPmCounterLow_cookie;
extern LeafInfo pbFecFcPmCounter_cookie;
extern LeafInfo pbFecPmTableReset_cookie;
extern LeafInfo pbFecPmTimeStart_cookie;
extern LeafInfo pbFecPmTimeElapse_cookie;
extern LeafInfo pbFecPmSuspect_cookie;
extern LeafInfo pbFecUncorrectedBlkHigh_cookie;
extern LeafInfo pbFecUncorrectedBlkLow_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbEthPmPortType_cookie;
extern LeafInfo pbEthPmBbrEnable_cookie;
extern LeafInfo pbEthPmBbrThresholdValue_cookie;
extern LeafInfo pbEthPmBprEnable_cookie;
extern LeafInfo pbEthPmBprThresholdValue_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbEthPmPortType_cookie;
extern LeafInfo pbEthVlanNo_cookie;
extern LeafInfo pbxSecEthVlanPmEnableStatus_cookie;
extern LeafInfo pbxSecEthVlanPmTimeStart_cookie;
extern LeafInfo pbxSecEthVlanPmStartFlag_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbEthVlanTableType_cookie;
extern LeafInfo pbEthPmPortType_cookie;
extern LeafInfo pbEthVlanNo_cookie;
extern LeafInfo pbEthVlanPmMonitor_cookie;
extern LeafInfo pbEthVlanPmTimeStart_cookie;
extern LeafInfo pbEthVlanPmTimeElapse_cookie;
extern LeafInfo pbEthVlanPmTimeSuspect_cookie;
extern LeafInfo pbEthVlanPmTableReset_cookie;
extern LeafInfo pbEthVlanInPktsHigh_cookie;
extern LeafInfo pbEthVlanInPktsLow_cookie;
extern LeafInfo pbEthVlanInBytesHigh_cookie;
extern LeafInfo pbEthVlanInBytesLow_cookie;
extern LeafInfo pbEthVlanDropPktsHigh_cookie;
extern LeafInfo pbEthVlanDropPktsLow_cookie;
extern LeafInfo pbEthVlanRcvUnicastFramesHigh_cookie;
extern LeafInfo pbEthVlanRcvUnicastFramesLow_cookie;
extern LeafInfo pbEthVlanRcvTotalFramesHigh_cookie;
extern LeafInfo pbEthVlanRcvTotalFramesLow_cookie;
extern LeafInfo pbEthVlanRcvUnicastBytesHigh_cookie;
extern LeafInfo pbEthVlanRcvUnicastBytesLow_cookie;
extern LeafInfo pbEthVlanRcvTotalBytesHigh_cookie;
extern LeafInfo pbEthVlanRcvTotalBytesLow_cookie;
extern LeafInfo pbEthVlanPmEnableStatus_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortType_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbPdhTableType_cookie;
extern LeafInfo pbPdhPmMonitor_cookie;
extern LeafInfo pbPdhEsPmCounter_cookie;
extern LeafInfo pbPdhEsPmThresholdEnable_cookie;
extern LeafInfo pbPdhEsPmThresholdLow_cookie;
extern LeafInfo pbPdhEsPmThresholdHigh_cookie;
extern LeafInfo pbPdhBbePmCounter_cookie;
extern LeafInfo pbPdhBbePmThresholdEnable_cookie;
extern LeafInfo pbPdhBbePmThresholdLow_cookie;
extern LeafInfo pbPdhBbePmThresholdHigh_cookie;
extern LeafInfo pbPdhSesPmCounter_cookie;
extern LeafInfo pbPdhSesPmThresholdEnable_cookie;
extern LeafInfo pbPdhSesPmThresholdLow_cookie;
extern LeafInfo pbPdhSesPmThresholdHigh_cookie;
extern LeafInfo pbPdhUasPmCounter_cookie;
extern LeafInfo pbPdhUasPmThresholdEnable_cookie;
extern LeafInfo pbPdhUasPmThresholdLow_cookie;
extern LeafInfo pbPdhUasPmThresholdHigh_cookie;
extern LeafInfo pbPdhCsesPmCounter_cookie;
extern LeafInfo pbPdhCsesPmThresholdEnable_cookie;
extern LeafInfo pbPdhCsesPmThresholdLow_cookie;
extern LeafInfo pbPdhCsesPmThresholdHigh_cookie;
extern LeafInfo pbPdhFcPmCounter_cookie;
extern LeafInfo pbPdhFcPmThresholdEnable_cookie;
extern LeafInfo pbPdhFcPmThresholdLow_cookie;
extern LeafInfo pbPdhFcPmThresholdHigh_cookie;
extern LeafInfo pbPdhPmTableReset_cookie;
extern LeafInfo pbPdhPmTimeStart_cookie;
extern LeafInfo pbPdhPmTimeElapse_cookie;
extern LeafInfo pbPdhPmSuspect_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbxSecEthCurPmPortType_cookie;
extern LeafInfo pbxSecEthPmEnableStatus_cookie;
extern LeafInfo pbxSecEthPmTimeStart_cookie;
extern LeafInfo pbxSecEthPmStartFlag_cookie;
extern LeafInfo pbSdhFtpCmndHostIP_cookie;
extern LeafInfo pbPmMonitoredAll_cookie;
extern LeafInfo pbPmMonitoredCtp_cookie;
extern LeafInfo pbPmMonitoredTtp_cookie;
extern LeafInfo pbPmMonitoredEth_cookie;
extern LeafInfo pbPmMonitoredRprClient_cookie;
extern LeafInfo pbPmMonitoredRprSpan_cookie;
extern LeafInfo pbPmMonitoredAtm_cookie;
extern LeafInfo pbPmMonitoredPdhSlip_cookie;
extern LeafInfo pbPmMonitoredPdhCrc_cookie;
extern LeafInfo pbPmMonitoredFec_cookie;
extern LeafInfo pbPmMonitoredOtu_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortType_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbSlipTableType_cookie;
extern LeafInfo pbSlipMonitor_cookie;
extern LeafInfo pbPSlipCounter_cookie;
extern LeafInfo pbPSlipThresholdEnable_cookie;
extern LeafInfo pbPSlipThreshold_cookie;
extern LeafInfo pbNSlipCounter_cookie;
extern LeafInfo pbNSlipThresholdEnable_cookie;
extern LeafInfo pbNSlipThreshold_cookie;
extern LeafInfo pbSlipTableReset_cookie;
extern LeafInfo pbSlipTimeStart_cookie;
extern LeafInfo pbSlipTimeElapse_cookie;
extern LeafInfo pbSlipSuspect_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo rprIfIndex_cookie;
extern LeafInfo rprSpanId_cookie;
extern LeafInfo pbRprSpanTableType_cookie;
extern LeafInfo pbRprSpanPmMonitor_cookie;
extern LeafInfo pbRprSpanPmTimeStart_cookie;
extern LeafInfo pbRprSpanPmTimeElapse_cookie;
extern LeafInfo pbRprSpanPmTimeSuspect_cookie;
extern LeafInfo pbRprSpanPmTableReset_cookie;
extern LeafInfo pbRprSpanInAllFramesHigh_cookie;
extern LeafInfo pbRprSpanInAllFramesLow_cookie;
extern LeafInfo pbRprSpanInWrapFramesHigh_cookie;
extern LeafInfo pbRprSpanInWrapFramesLow_cookie;
extern LeafInfo pbRprSpanInDataFramesHigh_cookie;
extern LeafInfo pbRprSpanInDataFramesLow_cookie;
extern LeafInfo pbRprSpanInCtrlFramesHigh_cookie;
extern LeafInfo pbRprSpanInCtrlFramesLow_cookie;
extern LeafInfo pbRprSpanInFaFramesHigh_cookie;
extern LeafInfo pbRprSpanInFaFramesLow_cookie;
extern LeafInfo pbRprSpanOutAllFramesHigh_cookie;
extern LeafInfo pbRprSpanOutAllFramesLow_cookie;
extern LeafInfo pbRprSpanOutAddFramesHigh_cookie;
extern LeafInfo pbRprSpanOutAddFramesLow_cookie;
extern LeafInfo pbRprSpanOutTransitFramesHigh_cookie;
extern LeafInfo pbRprSpanOutTransitFramesLow_cookie;
extern LeafInfo pbRprSpanOutWrapFramesHigh_cookie;
extern LeafInfo pbRprSpanOutWrapFramesLow_cookie;
extern LeafInfo pbRprSpanOutTpFramesHigh_cookie;
extern LeafInfo pbRprSpanOutTpFramesLow_cookie;
extern LeafInfo pbRprSpanOutFaFramesHigh_cookie;
extern LeafInfo pbRprSpanOutFaFramesLow_cookie;
extern LeafInfo pbRprSpanOutOamFramesHigh_cookie;
extern LeafInfo pbRprSpanOutOamFramesLow_cookie;
extern LeafInfo pbRprSpanErrHecFramesHigh_cookie;
extern LeafInfo pbRprSpanErrHecFramesLow_cookie;
extern LeafInfo pbRprSpanErrParityFramesHigh_cookie;
extern LeafInfo pbRprSpanErrParityFramesLow_cookie;
extern LeafInfo pbRprSpanErrFcsFramesHigh_cookie;
extern LeafInfo pbRprSpanErrFcsFramesLow_cookie;
extern LeafInfo pbRprSpanErrEdgeFramesHigh_cookie;
extern LeafInfo pbRprSpanErrEdgeFramesLow_cookie;
extern LeafInfo pbRprSpanErrSelfSourceFramesHigh_cookie;
extern LeafInfo pbRprSpanErrSelfSourceFramesLow_cookie;
extern LeafInfo pbRprSpanInUcastClassAFramesHigh_cookie;
extern LeafInfo pbRprSpanInUcastClassAFramesLow_cookie;
extern LeafInfo pbRprSpanInUcastClassAOctetsHigh_cookie;
extern LeafInfo pbRprSpanInUcastClassAOctetsLow_cookie;
extern LeafInfo pbRprSpanInUcastClassBCirFramesHigh_cookie;
extern LeafInfo pbRprSpanInUcastClassBCirFramesLow_cookie;
extern LeafInfo pbRprSpanInUcastClassBCirOctetsHigh_cookie;
extern LeafInfo pbRprSpanInUcastClassBCirOctetsLow_cookie;
extern LeafInfo pbRprSpanInUcastClassBEirFramesHigh_cookie;
extern LeafInfo pbRprSpanInUcastClassBEirFramesLow_cookie;
extern LeafInfo pbRprSpanInUcastClassBEirOctetsHigh_cookie;
extern LeafInfo pbRprSpanInUcastClassBEirOctetsLow_cookie;
extern LeafInfo pbRprSpanInUcastClassCFramesHigh_cookie;
extern LeafInfo pbRprSpanInUcastClassCFramesLow_cookie;
extern LeafInfo pbRprSpanInUcastClassCOctetsHigh_cookie;
extern LeafInfo pbRprSpanInUcastClassCOctetsLow_cookie;
extern LeafInfo pbRprSpanInMcastClassAFramesHigh_cookie;
extern LeafInfo pbRprSpanInMcastClassAFramesLow_cookie;
extern LeafInfo pbRprSpanInMcastClassAOctetsHigh_cookie;
extern LeafInfo pbRprSpanInMcastClassAOctetsLow_cookie;
extern LeafInfo pbRprSpanInMcastClassBCirFramesHigh_cookie;
extern LeafInfo pbRprSpanInMcastClassBCirFramesLow_cookie;
extern LeafInfo pbRprSpanInMcastClassBCirOctetsHigh_cookie;
extern LeafInfo pbRprSpanInMcastClassBCirOctetsLow_cookie;
extern LeafInfo pbRprSpanInMcastClassBEirFramesHigh_cookie;
extern LeafInfo pbRprSpanInMcastClassBEirFramesLow_cookie;
extern LeafInfo pbRprSpanInMcastClassBEirOctetsHigh_cookie;
extern LeafInfo pbRprSpanInMcastClassBEirOctetsLow_cookie;
extern LeafInfo pbRprSpanInMcastClassCFramesHigh_cookie;
extern LeafInfo pbRprSpanInMcastClassCFramesLow_cookie;
extern LeafInfo pbRprSpanInMcastClassCOctetsHigh_cookie;
extern LeafInfo pbRprSpanInMcastClassCOctetsLow_cookie;
extern LeafInfo pbRprSpanOutUcastClassAFramesHigh_cookie;
extern LeafInfo pbRprSpanOutUcastClassAFramesLow_cookie;
extern LeafInfo pbRprSpanOutUcastClassAOctetsHigh_cookie;
extern LeafInfo pbRprSpanOutUcastClassAOctetsLow_cookie;
extern LeafInfo pbRprSpanOutUcastClassBCirFramesHigh_cookie;
extern LeafInfo pbRprSpanOutUcastClassBCirFramesLow_cookie;
extern LeafInfo pbRprSpanOutUcastClassBCirOctetsHigh_cookie;
extern LeafInfo pbRprSpanOutUcastClassBCirOctetsLow_cookie;
extern LeafInfo pbRprSpanOutUcastClassBEirFramesHigh_cookie;
extern LeafInfo pbRprSpanOutUcastClassBEirFramesLow_cookie;
extern LeafInfo pbRprSpanOutUcastClassBEirOctetsHigh_cookie;
extern LeafInfo pbRprSpanOutUcastClassBEirOctetsLow_cookie;
extern LeafInfo pbRprSpanOutUcastClassCFramesHigh_cookie;
extern LeafInfo pbRprSpanOutUcastClassCFramesLow_cookie;
extern LeafInfo pbRprSpanOutUcastClassCOctetsHigh_cookie;
extern LeafInfo pbRprSpanOutUcastClassCOctetsLow_cookie;
extern LeafInfo pbRprSpanOutMcastClassAFramesHigh_cookie;
extern LeafInfo pbRprSpanOutMcastClassAFramesLow_cookie;
extern LeafInfo pbRprSpanOutMcastClassAOctetsHigh_cookie;
extern LeafInfo pbRprSpanOutMcastClassAOctetsLow_cookie;
extern LeafInfo pbRprSpanOutMcastClassBCirFramesHigh_cookie;
extern LeafInfo pbRprSpanOutMcastClassBCirFramesLow_cookie;
extern LeafInfo pbRprSpanOutMcastClassBCirOctetsHigh_cookie;
extern LeafInfo pbRprSpanOutMcastClassBCirOctetsLow_cookie;
extern LeafInfo pbRprSpanOutMcastClassBEirFramesHigh_cookie;
extern LeafInfo pbRprSpanOutMcastClassBEirFramesLow_cookie;
extern LeafInfo pbRprSpanOutMcastClassBEirOctetsHigh_cookie;
extern LeafInfo pbRprSpanOutMcastClassBEirOctetsLow_cookie;
extern LeafInfo pbRprSpanOutMcastClassCFramesHigh_cookie;
extern LeafInfo pbRprSpanOutMcastClassCFramesLow_cookie;
extern LeafInfo pbRprSpanOutMcastClassCOctetsHigh_cookie;
extern LeafInfo pbRprSpanOutMcastClassCOctetsLow_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo rprIfIndex_cookie;
extern LeafInfo pbRprClientTableType_cookie;
extern LeafInfo pbRprClientPmMonitor_cookie;
extern LeafInfo pbRprClientPmTimeStart_cookie;
extern LeafInfo pbRprClientPmTimeElapse_cookie;
extern LeafInfo pbRprClientPmTimeSuspect_cookie;
extern LeafInfo pbRprClientPmTableReset_cookie;
extern LeafInfo pbRprClientInAllFramesHigh_cookie;
extern LeafInfo pbRprClientInAllFramesLow_cookie;
extern LeafInfo pbRprClientOutAllFramesHigh_cookie;
extern LeafInfo pbRprClientOutAllFramesLow_cookie;
extern LeafInfo pbRprClientOutPassFramesHigh_cookie;
extern LeafInfo pbRprClientOutPassFramesLow_cookie;
extern LeafInfo pbRprClientOutDropFramesHigh_cookie;
extern LeafInfo pbRprClientOutDropFramesLow_cookie;
extern LeafInfo pbRprClientOutErrLenFramesHigh_cookie;
extern LeafInfo pbRprClientOutErrLenFramesLow_cookie;
extern LeafInfo pbRprClientOutErrCrcFramesHigh_cookie;
extern LeafInfo pbRprClientOutErrCrcFramesLow_cookie;
extern LeafInfo pbRprClientInUcastClassAFramesHigh_cookie;
extern LeafInfo pbRprClientInUcastClassAFramesLow_cookie;
extern LeafInfo pbRprClientInUcastClassAOctetsHigh_cookie;
extern LeafInfo pbRprClientInUcastClassAOctetsLow_cookie;
extern LeafInfo pbRprClientInUcastClassBCirFramesHigh_cookie;
extern LeafInfo pbRprClientInUcastClassBCirFramesLow_cookie;
extern LeafInfo pbRprClientInUcastClassBCirOctetsHigh_cookie;
extern LeafInfo pbRprClientInUcastClassBCirOctetsLow_cookie;
extern LeafInfo pbRprClientInUcastClassBEirFramesHigh_cookie;
extern LeafInfo pbRprClientInUcastClassBEirFramesLow_cookie;
extern LeafInfo pbRprClientInUcastClassBEirOctetsHigh_cookie;
extern LeafInfo pbRprClientInUcastClassBEirOctetsLow_cookie;
extern LeafInfo pbRprClientInUcastClassCFramesHigh_cookie;
extern LeafInfo pbRprClientInUcastClassCFramesLow_cookie;
extern LeafInfo pbRprClientInUcastClassCOctetsHigh_cookie;
extern LeafInfo pbRprClientInUcastClassCOctetsLow_cookie;
extern LeafInfo pbRprClientInMcastClassAFramesHigh_cookie;
extern LeafInfo pbRprClientInMcastClassAFramesLow_cookie;
extern LeafInfo pbRprClientInMcastClassAOctetsHigh_cookie;
extern LeafInfo pbRprClientInMcastClassAOctetsLow_cookie;
extern LeafInfo pbRprClientInMcastClassBCirFramesHigh_cookie;
extern LeafInfo pbRprClientInMcastClassBCirFramesLow_cookie;
extern LeafInfo pbRprClientInMcastClassBCirOctetsHigh_cookie;
extern LeafInfo pbRprClientInMcastClassBCirOctetsLow_cookie;
extern LeafInfo pbRprClientInMcastClassBEirFramesHigh_cookie;
extern LeafInfo pbRprClientInMcastClassBEirFramesLow_cookie;
extern LeafInfo pbRprClientInMcastClassBEirOctetsHigh_cookie;
extern LeafInfo pbRprClientInMcastClassBEirOctetsLow_cookie;
extern LeafInfo pbRprClientInMcastClassCFramesHigh_cookie;
extern LeafInfo pbRprClientInMcastClassCFramesLow_cookie;
extern LeafInfo pbRprClientInMcastClassCOctetsHigh_cookie;
extern LeafInfo pbRprClientInMcastClassCOctetsLow_cookie;
extern LeafInfo pbRprClientOutUcastClassAFramesHigh_cookie;
extern LeafInfo pbRprClientOutUcastClassAFramesLow_cookie;
extern LeafInfo pbRprClientOutUcastClassAOctetsHigh_cookie;
extern LeafInfo pbRprClientOutUcastClassAOctetsLow_cookie;
extern LeafInfo pbRprClientOutUcastClassBCirFramesHigh_cookie;
extern LeafInfo pbRprClientOutUcastClassBCirFramesLow_cookie;
extern LeafInfo pbRprClientOutUcastClassBCirOctetsHigh_cookie;
extern LeafInfo pbRprClientOutUcastClassBCirOctetsLow_cookie;
extern LeafInfo pbRprClientOutUcastClassBEirFramesHigh_cookie;
extern LeafInfo pbRprClientOutUcastClassBEirFramesLow_cookie;
extern LeafInfo pbRprClientOutUcastClassBEirOctetsHigh_cookie;
extern LeafInfo pbRprClientOutUcastClassBEirOctetsLow_cookie;
extern LeafInfo pbRprClientOutUcastClassCFramesHigh_cookie;
extern LeafInfo pbRprClientOutUcastClassCFramesLow_cookie;
extern LeafInfo pbRprClientOutUcastClassCOctetsHigh_cookie;
extern LeafInfo pbRprClientOutUcastClassCOctetsLow_cookie;
extern LeafInfo pbRprClientOutMcastClassAFramesHigh_cookie;
extern LeafInfo pbRprClientOutMcastClassAFramesLow_cookie;
extern LeafInfo pbRprClientOutMcastClassAOctetsHigh_cookie;
extern LeafInfo pbRprClientOutMcastClassAOctetsLow_cookie;
extern LeafInfo pbRprClientOutMcastClassBCirFramesHigh_cookie;
extern LeafInfo pbRprClientOutMcastClassBCirFramesLow_cookie;
extern LeafInfo pbRprClientOutMcastClassBCirOctetsHigh_cookie;
extern LeafInfo pbRprClientOutMcastClassBCirOctetsLow_cookie;
extern LeafInfo pbRprClientOutMcastClassBEirFramesHigh_cookie;
extern LeafInfo pbRprClientOutMcastClassBEirFramesLow_cookie;
extern LeafInfo pbRprClientOutMcastClassBEirOctetsHigh_cookie;
extern LeafInfo pbRprClientOutMcastClassBEirOctetsLow_cookie;
extern LeafInfo pbRprClientOutMcastClassCFramesHigh_cookie;
extern LeafInfo pbRprClientOutMcastClassCFramesLow_cookie;
extern LeafInfo pbRprClientOutMcastClassCOctetsHigh_cookie;
extern LeafInfo pbRprClientOutMcastClassCOctetsLow_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbxSecEthPmPortType_cookie;
extern LeafInfo pbxSecEthPmReportStatus_cookie;
extern LeafInfo pbxSecEthPmMonitorStatus_cookie;
extern LeafInfo pbxSecEthPmFtpHostIP_cookie;
extern LeafInfo pbxSecEthPmFtpPath_cookie;
extern LeafInfo pbxSecEthPmFtpFileName_cookie;
extern LeafInfo pbxSecEthPmFtpUsername_cookie;
extern LeafInfo pbxSecEthPmFtpPassword_cookie;
extern LeafInfo pbxSecEthPmRequestId_cookie;
extern LeafInfo pbxSecEthPmRespMsg_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbEthTableType_cookie;
extern LeafInfo pbEthPmPortType_cookie;
extern LeafInfo pbEthPmMonitor_cookie;
extern LeafInfo pbEthPmTimeStart_cookie;
extern LeafInfo pbEthPmTimeElapse_cookie;
extern LeafInfo pbEthPmTimeSuspect_cookie;
extern LeafInfo pbEthPmTableReset_cookie;
extern LeafInfo pbEthInUnicastPktsHigh_cookie;
extern LeafInfo pbEthInUnicastPktsLow_cookie;
extern LeafInfo pbEthInMulcastPktsHigh_cookie;
extern LeafInfo pbEthInMulcastPktsLow_cookie;
extern LeafInfo pbEthInBrdcastPktsHigh_cookie;
extern LeafInfo pbEthInBrdcastPktsLow_cookie;
extern LeafInfo pbEthInAllBadPktsHigh_cookie;
extern LeafInfo pbEthInAllBadPktsLow_cookie;
extern LeafInfo pbEthInAllBadBytesHigh_cookie;
extern LeafInfo pbEthInAllBadBytesLow_cookie;
extern LeafInfo pbEthInAllGoodPktsHigh_cookie;
extern LeafInfo pbEthInAllGoodPktsLow_cookie;
extern LeafInfo pbEthInAllGoodBytesHigh_cookie;
extern LeafInfo pbEthInAllGoodBytesLow_cookie;
extern LeafInfo pbEthInOverSizePktsHigh_cookie;
extern LeafInfo pbEthInOverSizePktsLow_cookie;
extern LeafInfo pbEthInUnderSizePktsHigh_cookie;
extern LeafInfo pbEthInUnderSizePktsLow_cookie;
extern LeafInfo pbEthInCRCErrPktsHigh_cookie;
extern LeafInfo pbEthInCRCErrPktsLow_cookie;
extern LeafInfo pbEthOutUnicastPktsHigh_cookie;
extern LeafInfo pbEthOutUnicastPktsLow_cookie;
extern LeafInfo pbEthOutMulcastPktsHigh_cookie;
extern LeafInfo pbEthOutMulcastPktsLow_cookie;
extern LeafInfo pbEthOutBrdcastPktsHigh_cookie;
extern LeafInfo pbEthOutBrdcastPktsLow_cookie;
extern LeafInfo pbEthOutAllGoodPktsHigh_cookie;
extern LeafInfo pbEthOutAllGoodPktsLow_cookie;
extern LeafInfo pbEthOutAllGoodBytesHigh_cookie;
extern LeafInfo pbEthOutAllGoodBytesLow_cookie;
extern LeafInfo pbEthBbrEnable_cookie;
extern LeafInfo pbEthBbrThresholdValue_cookie;
extern LeafInfo pbEthBprEnable_cookie;
extern LeafInfo pbEthBprThresholdValue_cookie;
extern LeafInfo pbEthCurInAllBytesHigh_cookie;
extern LeafInfo pbEthCurInAllBytesLow_cookie;
extern LeafInfo pbEthCurInAllPktsHigh_cookie;
extern LeafInfo pbEthCurInAllPktsLow_cookie;
extern LeafInfo pbEthCurInAllGoodPktsHigh_cookie;
extern LeafInfo pbEthCurInAllGoodPktsLow_cookie;
extern LeafInfo pbEthCurInAllBadPktsHigh_cookie;
extern LeafInfo pbEthCurInAllBadPktsLow_cookie;
extern LeafInfo pbEthCurInUnicastPktsHigh_cookie;
extern LeafInfo pbEthCurInUnicastPktsLow_cookie;
extern LeafInfo pbEthCurInMulcastPktsHigh_cookie;
extern LeafInfo pbEthCurInMulcastPktsLow_cookie;
extern LeafInfo pbEthCurInBrdcastPktsHigh_cookie;
extern LeafInfo pbEthCurInBrdcastPktsLow_cookie;
extern LeafInfo pbEthCurInDropPktsHigh_cookie;
extern LeafInfo pbEthCurInDropPktsLow_cookie;
extern LeafInfo pbEthCurInUndersizeGoodPktsHigh_cookie;
extern LeafInfo pbEthCurInUndersizeGoodPktsLow_cookie;
extern LeafInfo pbEthCurInOversizeGoodPktsHigh_cookie;
extern LeafInfo pbEthCurInOversizeGoodPktsLow_cookie;
extern LeafInfo pbEthCurIn64PktsHigh_cookie;
extern LeafInfo pbEthCurIn64PktsLow_cookie;
extern LeafInfo pbEthCurIn65To127PktsHigh_cookie;
extern LeafInfo pbEthCurIn65To127PktsLow_cookie;
extern LeafInfo pbEthCurIn128To255PktsHigh_cookie;
extern LeafInfo pbEthCurIn128To255PktsLow_cookie;
extern LeafInfo pbEthCurIn256To511PktsHigh_cookie;
extern LeafInfo pbEthCurIn256To511PktsLow_cookie;
extern LeafInfo pbEthCurIn512To1023PktsHigh_cookie;
extern LeafInfo pbEthCurIn512To1023PktsLow_cookie;
extern LeafInfo pbEthCurIn1024To1518PktsHigh_cookie;
extern LeafInfo pbEthCurIn1024To1518PktsLow_cookie;
extern LeafInfo pbEthCurInPausePktsHigh_cookie;
extern LeafInfo pbEthCurInPausePktsLow_cookie;
extern LeafInfo pbEthCurInFragmentPktsHigh_cookie;
extern LeafInfo pbEthCurInFragmentPktsLow_cookie;
extern LeafInfo pbEthCurInJabberPktsHigh_cookie;
extern LeafInfo pbEthCurInJabberPktsLow_cookie;
extern LeafInfo pbEthCurInAlignmentErrorPktsHigh_cookie;
extern LeafInfo pbEthCurInAlignmentErrorPktsLow_cookie;
extern LeafInfo pbEthCurOutAllBytesHigh_cookie;
extern LeafInfo pbEthCurOutAllBytesLow_cookie;
extern LeafInfo pbEthCurOutAllPktsHigh_cookie;
extern LeafInfo pbEthCurOutAllPktsLow_cookie;
extern LeafInfo pbEthCurOutUnicastPktsHigh_cookie;
extern LeafInfo pbEthCurOutUnicastPktsLow_cookie;
extern LeafInfo pbEthCurOutMulcastPktsHigh_cookie;
extern LeafInfo pbEthCurOutMulcastPktsLow_cookie;
extern LeafInfo pbEthCurOutBrdcastPktsHigh_cookie;
extern LeafInfo pbEthCurOutBrdcastPktsLow_cookie;
extern LeafInfo pbEthCurOutGoodPausePktsHigh_cookie;
extern LeafInfo pbEthCurOutGoodPausePktsLow_cookie;
extern LeafInfo pbEthCurOutCollisionPktsHigh_cookie;
extern LeafInfo pbEthCurOutCollisionPktsLow_cookie;
extern LeafInfo pbCurOutInvalidSymbolsHigh_cookie;
extern LeafInfo pbCurOutInvalidSymbolsLow_cookie;
extern LeafInfo pbCurOutSuperblockCrcErrorHigh_cookie;
extern LeafInfo pbCurOutSuperblockCrcErrorLow_cookie;
extern LeafInfo pbCurOutSuperblockCorrectableCrcErrorHigh_cookie;
extern LeafInfo pbCurOutSuperblockCorrectableCrcErrorLow_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortType_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbTpType_cookie;
extern LeafInfo pbTpIndex_cookie;
extern LeafInfo pbTableType_cookie;
extern LeafInfo pbPmActualPortType_cookie;
extern LeafInfo pbSdhPmMonitor_cookie;
extern LeafInfo pbEsPmCounter_cookie;
extern LeafInfo pbEsPmThresholdEnable_cookie;
extern LeafInfo pbEsPmThresholdLow_cookie;
extern LeafInfo pbEsPmThresholdHigh_cookie;
extern LeafInfo pbBbePmCounter_cookie;
extern LeafInfo pbBbePmThresholdEnable_cookie;
extern LeafInfo pbBbePmThresholdLow_cookie;
extern LeafInfo pbBbePmThresholdHigh_cookie;
extern LeafInfo pbSesPmCounter_cookie;
extern LeafInfo pbSesPmThresholdEnable_cookie;
extern LeafInfo pbSesPmThresholdLow_cookie;
extern LeafInfo pbSesPmThresholdHigh_cookie;
extern LeafInfo pbUasPmCounter_cookie;
extern LeafInfo pbUasPmThresholdEnable_cookie;
extern LeafInfo pbUasPmThresholdLow_cookie;
extern LeafInfo pbUasPmThresholdHigh_cookie;
extern LeafInfo pbCsesPmCounter_cookie;
extern LeafInfo pbCsesPmThresholdEnable_cookie;
extern LeafInfo pbCsesPmThresholdLow_cookie;
extern LeafInfo pbCsesPmThresholdHigh_cookie;
extern LeafInfo pbFcPmCounter_cookie;
extern LeafInfo pbFcPmThresholdEnable_cookie;
extern LeafInfo pbFcPmThresholdLow_cookie;
extern LeafInfo pbFcPmThresholdHigh_cookie;
extern LeafInfo pbOfsPmCounter_cookie;
extern LeafInfo pbOfsPmThresholdEnable_cookie;
extern LeafInfo pbOfsPmThresholdLow_cookie;
extern LeafInfo pbOfsPmThresholdHigh_cookie;
extern LeafInfo pbPpjcPmCounter_cookie;
extern LeafInfo pbPpjcPmThresholdEnable_cookie;
extern LeafInfo pbPpjcPmThresholdLow_cookie;
extern LeafInfo pbPpjcPmThresholdHigh_cookie;
extern LeafInfo pbNpjcPmCounter_cookie;
extern LeafInfo pbNpjcPmThresholdEnable_cookie;
extern LeafInfo pbNpjcPmThresholdLow_cookie;
extern LeafInfo pbNpjcPmThresholdHigh_cookie;
extern LeafInfo pbPmTableReset_cookie;
extern LeafInfo pbPmTimeStart_cookie;
extern LeafInfo pbPmTimeElapse_cookie;
extern LeafInfo pbPmProtStatus_cookie;
extern LeafInfo pbPmTpStatus_cookie;
extern LeafInfo pbPmSuspect_cookie;
extern LeafInfo pbSdhRecentPMTable_cookie;
extern LeafInfo pbEthRecentPMTable_cookie;
extern LeafInfo pbRprClientRecentPMTable_cookie;
extern LeafInfo pbRprSpanRecentPMTable_cookie;
extern LeafInfo pbPdhRecentSlipTable_cookie;
extern LeafInfo pbxSecEthRecentPMTable_cookie;
extern LeafInfo pbPdhRecentPMTable_cookie;
extern LeafInfo pbEthVlanRecentPMTable_cookie;
extern LeafInfo pbxSecEthVlanRecentPMTable_cookie;
extern LeafInfo pbFecRecentPMTable_cookie;
extern LeafInfo pbOtuRecentPMTable_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortType_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbOtuRecentChannelID_cookie;
extern LeafInfo pbOtuRecentSegmentNum_cookie;
extern LeafInfo pbOtuRecentTableType_cookie;
extern LeafInfo pbOtuRecentTimesIndex_cookie;
extern LeafInfo pbOtuRecentEsPmCounter_cookie;
extern LeafInfo pbOtuRecentBbePmCounter_cookie;
extern LeafInfo pbOtuRecentSesPmCounter_cookie;
extern LeafInfo pbOtuRecentUasPmCounter_cookie;
extern LeafInfo pbOtuRecentCsesPmCounter_cookie;
extern LeafInfo pbOtuRecentFcPmCounter_cookie;
extern LeafInfo pbOtuRecentOfsPmCounter_cookie;
extern LeafInfo pbOtuRecentIaesPmCounter_cookie;
extern LeafInfo pbOtuRecentBiaesPmCounter_cookie;
extern LeafInfo pbOtuRecentPmTimeEnd_cookie;
extern LeafInfo pbOtuSuspect_cookie;
extern LeafInfo pbOtuComplete_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortType_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbFecRecentTableType_cookie;
extern LeafInfo pbFecRecentTimesIndex_cookie;
extern LeafInfo pbFecRecentTecPmCounterHigh_cookie;
extern LeafInfo pbFecRecentTecPmCounterLow_cookie;
extern LeafInfo pbFecRecentZecPmCounterHigh_cookie;
extern LeafInfo pbFecRecentZecPmCounterLow_cookie;
extern LeafInfo pbFecRecentOecPmCounterHigh_cookie;
extern LeafInfo pbFecRecentOecPmCounterLow_cookie;
extern LeafInfo pbFecRecentFcPmCounter_cookie;
extern LeafInfo pbFecRecentPmTimeEnd_cookie;
extern LeafInfo pbFecSuspect_cookie;
extern LeafInfo pbFecComplete_cookie;
extern LeafInfo pbFecRecUncorrectedBlkHigh_cookie;
extern LeafInfo pbFecRecUncorrectedBlkLow_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbEthPmPortType_cookie;
extern LeafInfo pbEthVlanNo_cookie;
extern LeafInfo pbxSecEthVlanTimesIndex_cookie;
extern LeafInfo pbxSecEthVlanRecentPmStartFlag_cookie;
extern LeafInfo pbxSecEthVlanRecentInPkts_cookie;
extern LeafInfo pbxSecEthVlanRecentInBytes_cookie;
extern LeafInfo pbxSecEthVlanRecentDropPkts_cookie;
extern LeafInfo pbxSecEthVlanRecentRcvUnicastFrames_cookie;
extern LeafInfo pbxSecEthVlanRecentRcvTotalFrames_cookie;
extern LeafInfo pbxSecEthVlanRecentRcvUnicastBytes_cookie;
extern LeafInfo pbxSecEthVlanRecentRcvTotalBytes_cookie;
extern LeafInfo pbxSecEthVlanFrmStartIndex_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbEthVlanRecentTableType_cookie;
extern LeafInfo pbEthPmPortType_cookie;
extern LeafInfo pbEthVlanNo_cookie;
extern LeafInfo pbEthVlanRecentTimesIndex_cookie;
extern LeafInfo pbEthVlanRecentPmTimeEnd_cookie;
extern LeafInfo pbEthVlanRecentPmTimeSuspect_cookie;
extern LeafInfo pbEthVlanRecentInPktsHigh_cookie;
extern LeafInfo pbEthVlanRecentInPktsLow_cookie;
extern LeafInfo pbEthVlanRecentInBytesHigh_cookie;
extern LeafInfo pbEthVlanRecentInBytesLow_cookie;
extern LeafInfo pbEthVlanRecentDropPktsHigh_cookie;
extern LeafInfo pbEthVlanRecentDropPktsLow_cookie;
extern LeafInfo pbEthVlanRecentRcvUnicastFramesHigh_cookie;
extern LeafInfo pbEthVlanRecentRcvUnicastFramesLow_cookie;
extern LeafInfo pbEthVlanRecentRcvTotalFramesHigh_cookie;
extern LeafInfo pbEthVlanRecentRcvTotalFramesLow_cookie;
extern LeafInfo pbEthVlanRecentRcvUnicastBytesHigh_cookie;
extern LeafInfo pbEthVlanRecentRcvUnicastBytesLow_cookie;
extern LeafInfo pbEthVlanRecentRcvTotalBytesHigh_cookie;
extern LeafInfo pbEthVlanRecentRcvTotalBytesLow_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortType_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbPdhRecentTableType_cookie;
extern LeafInfo pbPdhRecentTimesIndex_cookie;
extern LeafInfo pbPdhRecentEsPmCounter_cookie;
extern LeafInfo pbPdhRecentBbePmCounter_cookie;
extern LeafInfo pbPdhRecentSesPmCounter_cookie;
extern LeafInfo pbPdhRecentUasPmCounter_cookie;
extern LeafInfo pbPdhRecentCsesPmCounter_cookie;
extern LeafInfo pbPdhRecentFcPmCounter_cookie;
extern LeafInfo pbPdhRecentPmTimeEnd_cookie;
extern LeafInfo pbPdhSuspect_cookie;
extern LeafInfo pbPdhComplete_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbxSecEthRecentPmPortType_cookie;
extern LeafInfo pbxSecEthTimesIndex_cookie;
extern LeafInfo pbxSecEthRecentPmStartFlag_cookie;
extern LeafInfo pbxSecEthRecentInUnicastPkts_cookie;
extern LeafInfo pbxSecEthRecentInMulcastPkts_cookie;
extern LeafInfo pbxSecEthRecentInBrdcastPkts_cookie;
extern LeafInfo pbxSecEthRecentInAllBadPkts_cookie;
extern LeafInfo pbxSecEthRecentInAllBadBytes_cookie;
extern LeafInfo pbxSecEthRecentInAllGoodPkts_cookie;
extern LeafInfo pbxSecEthRecentInAllGoodBytes_cookie;
extern LeafInfo pbxSecEthRecentInOverSizePkts_cookie;
extern LeafInfo pbxSecEthRecentInUnderSizePkts_cookie;
extern LeafInfo pbxSecEthRecentInCRCErrPkts_cookie;
extern LeafInfo pbxSecEthRecentOutUnicastPkts_cookie;
extern LeafInfo pbxSecEthRecentOutMulcastPkts_cookie;
extern LeafInfo pbxSecEthRecentOutBrdcastPkts_cookie;
extern LeafInfo pbxSecEthRecentOutAllGoodPkts_cookie;
extern LeafInfo pbxSecEthRecentOutAllGoodBytes_cookie;
extern LeafInfo pbxSecEthFrmStartIndex_cookie;
extern LeafInfo pbxSecEthRcntInAllBytes_cookie;
extern LeafInfo pbxSecEthRcntInAllPkts_cookie;
extern LeafInfo pbxSecEthRcntInAllGoodPkts_cookie;
extern LeafInfo pbxSecEthRcntInAllBadPkts_cookie;
extern LeafInfo pbxSecEthRcntInUnicastPkts_cookie;
extern LeafInfo pbxSecEthRcntInMulcastPkts_cookie;
extern LeafInfo pbxSecEthRcntInBrdcastPkts_cookie;
extern LeafInfo pbxSecEthRcntInDropPkts_cookie;
extern LeafInfo pbxSecEthRcntInUndersizeGoodPkts_cookie;
extern LeafInfo pbxSecEthRcntInOversizeGoodPkts_cookie;
extern LeafInfo pbxSecEthRcntIn64Pkts_cookie;
extern LeafInfo pbxSecEthRcntIn65To127Pkts_cookie;
extern LeafInfo pbxSecEthRcntIn128To255Pkts_cookie;
extern LeafInfo pbxSecEthRcntIn256To511Pkts_cookie;
extern LeafInfo pbxSecEthRcntIn512To1023Pkts_cookie;
extern LeafInfo pbxSecEthRcntIn1024To1518Pkts_cookie;
extern LeafInfo pbxSecEthRcntInPausePkts_cookie;
extern LeafInfo pbxSecEthRcntInFragmentPkts_cookie;
extern LeafInfo pbxSecEthRcntInJabberPkts_cookie;
extern LeafInfo pbxSecEthRcntInAlignmentErrorPkts_cookie;
extern LeafInfo pbxSecEthRcntOutAllBytes_cookie;
extern LeafInfo pbxSecEthRcntOutAllPkts_cookie;
extern LeafInfo pbxSecEthRcntOutUnicastPkts_cookie;
extern LeafInfo pbxSecEthRcntOutMulcastPkts_cookie;
extern LeafInfo pbxSecEthRcntOutBrdcastPkts_cookie;
extern LeafInfo pbxSecEthRcntOutGoodPausePkts_cookie;
extern LeafInfo pbxSecEthRcntOutCollisionPkts_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortType_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbRecentSlipTableType_cookie;
extern LeafInfo pbRecentSlipTimesIndex_cookie;
extern LeafInfo pbRecentPSlipCounter_cookie;
extern LeafInfo pbRecentNSlipCounter_cookie;
extern LeafInfo pbSlipTimeEnd_cookie;
extern LeafInfo pbRecentSlipSuspect_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo rprIfIndex_cookie;
extern LeafInfo rprSpanId_cookie;
extern LeafInfo pbRprSpanRecentTableType_cookie;
extern LeafInfo pbRprSpanTableRecentTimesIndex_cookie;
extern LeafInfo pbRprSpanRecentPmTimeEnd_cookie;
extern LeafInfo pbRprSpanRecentPmTimeSuspect_cookie;
extern LeafInfo pbRprSpanRecentInAllFramesHigh_cookie;
extern LeafInfo pbRprSpanRecentInAllFramesLow_cookie;
extern LeafInfo pbRprSpanRecentInWrapFramesHigh_cookie;
extern LeafInfo pbRprSpanRecentInWrapFramesLow_cookie;
extern LeafInfo pbRprSpanRecentInDataFramesHigh_cookie;
extern LeafInfo pbRprSpanRecentInDataFramesLow_cookie;
extern LeafInfo pbRprSpanRecentInCtrlFramesHigh_cookie;
extern LeafInfo pbRprSpanRecentInCtrlFramesLow_cookie;
extern LeafInfo pbRprSpanRecentInFaFramesHigh_cookie;
extern LeafInfo pbRprSpanRecentInFaFramesLow_cookie;
extern LeafInfo pbRprSpanRecentOutAllFramesHigh_cookie;
extern LeafInfo pbRprSpanRecentOutAllFramesLow_cookie;
extern LeafInfo pbRprSpanRecentOutAddFramesHigh_cookie;
extern LeafInfo pbRprSpanRecentOutAddFramesLow_cookie;
extern LeafInfo pbRprSpanRecentOutTransitFramesHigh_cookie;
extern LeafInfo pbRprSpanRecentOutTransitFramesLow_cookie;
extern LeafInfo pbRprSpanRecentOutWrapFramesHigh_cookie;
extern LeafInfo pbRprSpanRecentOutWrapFramesLow_cookie;
extern LeafInfo pbRprSpanRecentOutTpFramesHigh_cookie;
extern LeafInfo pbRprSpanRecentOutTpFramesLow_cookie;
extern LeafInfo pbRprSpanRecentOutFaFramesHigh_cookie;
extern LeafInfo pbRprSpanRecentOutFaFramesLow_cookie;
extern LeafInfo pbRprSpanRecentOutOamFramesHigh_cookie;
extern LeafInfo pbRprSpanRecentOutOamFramesLow_cookie;
extern LeafInfo pbRprSpanRecentErrHecFramesHigh_cookie;
extern LeafInfo pbRprSpanRecentErrHecFramesLow_cookie;
extern LeafInfo pbRprSpanRecentErrParityFramesHigh_cookie;
extern LeafInfo pbRprSpanRecentErrParityFramesLow_cookie;
extern LeafInfo pbRprSpanRecentErrFcsFramesHigh_cookie;
extern LeafInfo pbRprSpanRecentErrFcsFramesLow_cookie;
extern LeafInfo pbRprSpanRecentErrEdgeFramesHigh_cookie;
extern LeafInfo pbRprSpanRecentErrEdgeFramesLow_cookie;
extern LeafInfo pbRprSpanRecentErrSelfSourceFramesHigh_cookie;
extern LeafInfo pbRprSpanRecentErrSelfSourceFramesLow_cookie;
extern LeafInfo pbRprSpanRecentInUcastClassAFramesHigh_cookie;
extern LeafInfo pbRprSpanRecentInUcastClassAFramesLow_cookie;
extern LeafInfo pbRprSpanRecentInUcastClassAOctetsHigh_cookie;
extern LeafInfo pbRprSpanRecentInUcastClassAOctetsLow_cookie;
extern LeafInfo pbRprSpanRecentInUcastClassBCirFramesHigh_cookie;
extern LeafInfo pbRprSpanRecentInUcastClassBCirFramesLow_cookie;
extern LeafInfo pbRprSpanRecentInUcastClassBCirOctetsHigh_cookie;
extern LeafInfo pbRprSpanRecentInUcastClassBCirOctetsLow_cookie;
extern LeafInfo pbRprSpanRecentInUcastClassBEirFramesHigh_cookie;
extern LeafInfo pbRprSpanRecentInUcastClassBEirFramesLow_cookie;
extern LeafInfo pbRprSpanRecentInUcastClassBEirOctetsHigh_cookie;
extern LeafInfo pbRprSpanRecentInUcastClassBEirOctetsLow_cookie;
extern LeafInfo pbRprSpanRecentInUcastClassCFramesHigh_cookie;
extern LeafInfo pbRprSpanRecentInUcastClassCFramesLow_cookie;
extern LeafInfo pbRprSpanRecentInUcastClassCOctetsHigh_cookie;
extern LeafInfo pbRprSpanRecentInUcastClassCOctetsLow_cookie;
extern LeafInfo pbRprSpanRecentInMcastClassAFramesHigh_cookie;
extern LeafInfo pbRprSpanRecentInMcastClassAFramesLow_cookie;
extern LeafInfo pbRprSpanRecentInMcastClassAOctetsHigh_cookie;
extern LeafInfo pbRprSpanRecentInMcastClassAOctetsLow_cookie;
extern LeafInfo pbRprSpanRecentInMcastClassBCirFramesHigh_cookie;
extern LeafInfo pbRprSpanRecentInMcastClassBCirFramesLow_cookie;
extern LeafInfo pbRprSpanRecentInMcastClassBCirOctetsHigh_cookie;
extern LeafInfo pbRprSpanRecentInMcastClassBCirOctetsLow_cookie;
extern LeafInfo pbRprSpanRecentInMcastClassBEirFramesHigh_cookie;
extern LeafInfo pbRprSpanRecentInMcastClassBEirFramesLow_cookie;
extern LeafInfo pbRprSpanRecentInMcastClassBEirOctetsHigh_cookie;
extern LeafInfo pbRprSpanRecentInMcastClassBEirOctetsLow_cookie;
extern LeafInfo pbRprSpanRecentInMcastClassCFramesHigh_cookie;
extern LeafInfo pbRprSpanRecentInMcastClassCFramesLow_cookie;
extern LeafInfo pbRprSpanRecentInMcastClassCOctetsHigh_cookie;
extern LeafInfo pbRprSpanRecentInMcastClassCOctetsLow_cookie;
extern LeafInfo pbRprSpanRecentOutUcastClassAFramesHigh_cookie;
extern LeafInfo pbRprSpanRecentOutUcastClassAFramesLow_cookie;
extern LeafInfo pbRprSpanRecentOutUcastClassAOctetsHigh_cookie;
extern LeafInfo pbRprSpanRecentOutUcastClassAOctetsLow_cookie;
extern LeafInfo pbRprSpanRecentOutUcastClassBCirFramesHigh_cookie;
extern LeafInfo pbRprSpanRecentOutUcastClassBCirFramesLow_cookie;
extern LeafInfo pbRprSpanRecentOutUcastClassBCirOctetsHigh_cookie;
extern LeafInfo pbRprSpanRecentOutUcastClassBCirOctetsLow_cookie;
extern LeafInfo pbRprSpanRecentOutUcastClassBEirFramesHigh_cookie;
extern LeafInfo pbRprSpanRecentOutUcastClassBEirFramesLow_cookie;
extern LeafInfo pbRprSpanRecentOutUcastClassBEirOctetsHigh_cookie;
extern LeafInfo pbRprSpanRecentOutUcastClassBEirOctetsLow_cookie;
extern LeafInfo pbRprSpanRecentOutUcastClassCFramesHigh_cookie;
extern LeafInfo pbRprSpanRecentOutUcastClassCFramesLow_cookie;
extern LeafInfo pbRprSpanRecentOutUcastClassCOctetsHigh_cookie;
extern LeafInfo pbRprSpanRecentOutUcastClassCOctetsLow_cookie;
extern LeafInfo pbRprSpanRecentOutMcastClassAFramesHigh_cookie;
extern LeafInfo pbRprSpanRecentOutMcastClassAFramesLow_cookie;
extern LeafInfo pbRprSpanRecentOutMcastClassAOctetsHigh_cookie;
extern LeafInfo pbRprSpanRecentOutMcastClassAOctetsLow_cookie;
extern LeafInfo pbRprSpanRecentOutMcastClassBCirFramesHigh_cookie;
extern LeafInfo pbRprSpanRecentOutMcastClassBCirFramesLow_cookie;
extern LeafInfo pbRprSpanRecentOutMcastClassBCirOctetsHigh_cookie;
extern LeafInfo pbRprSpanRecentOutMcastClassBCirOctetsLow_cookie;
extern LeafInfo pbRprSpanRecentOutMcastClassBEirFramesHigh_cookie;
extern LeafInfo pbRprSpanRecentOutMcastClassBEirFramesLow_cookie;
extern LeafInfo pbRprSpanRecentOutMcastClassBEirOctetsHigh_cookie;
extern LeafInfo pbRprSpanRecentOutMcastClassBEirOctetsLow_cookie;
extern LeafInfo pbRprSpanRecentOutMcastClassCFramesHigh_cookie;
extern LeafInfo pbRprSpanRecentOutMcastClassCFramesLow_cookie;
extern LeafInfo pbRprSpanRecentOutMcastClassCOctetsHigh_cookie;
extern LeafInfo pbRprSpanRecentOutMcastClassCOctetsLow_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo rprIfIndex_cookie;
extern LeafInfo pbRprClientRecentTableType_cookie;
extern LeafInfo pbRprClientTableRecentTimesIndex_cookie;
extern LeafInfo pbRprClientRecentPmTimeEnd_cookie;
extern LeafInfo pbRprClientRecentPmTimeSuspect_cookie;
extern LeafInfo pbRprClientRecentInAllFramesHigh_cookie;
extern LeafInfo pbRprClientRecentInAllFramesLow_cookie;
extern LeafInfo pbRprClientRecentOutAllFramesHigh_cookie;
extern LeafInfo pbRprClientRecentOutAllFramesLow_cookie;
extern LeafInfo pbRprClientRecentOutPassFramesHigh_cookie;
extern LeafInfo pbRprClientRecentOutPassFramesLow_cookie;
extern LeafInfo pbRprClientRecentOutDropFramesHigh_cookie;
extern LeafInfo pbRprClientRecentOutDropFramesLow_cookie;
extern LeafInfo pbRprClientRecentOutErrLenFramesHigh_cookie;
extern LeafInfo pbRprClientRecentOutErrLenFramesLow_cookie;
extern LeafInfo pbRprClientRecentOutErrCrcFramesHigh_cookie;
extern LeafInfo pbRprClientRecentOutErrCrcFramesLow_cookie;
extern LeafInfo pbRprClientRecentInUcastClassAFramesHigh_cookie;
extern LeafInfo pbRprClientRecentInUcastClassAFramesLow_cookie;
extern LeafInfo pbRprClientRecentInUcastClassAOctetsHigh_cookie;
extern LeafInfo pbRprClientRecentInUcastClassAOctetsLow_cookie;
extern LeafInfo pbRprClientRecentInUcastClassBCirFramesHigh_cookie;
extern LeafInfo pbRprClientRecentInUcastClassBCirFramesLow_cookie;
extern LeafInfo pbRprClientRecentInUcastClassBCirOctetsHigh_cookie;
extern LeafInfo pbRprClientRecentInUcastClassBCirOctetsLow_cookie;
extern LeafInfo pbRprClientRecentInUcastClassBEirFramesHigh_cookie;
extern LeafInfo pbRprClientRecentInUcastClassBEirFramesLow_cookie;
extern LeafInfo pbRprClientRecentInUcastClassBEirOctetsHigh_cookie;
extern LeafInfo pbRprClientRecentInUcastClassBEirOctetsLow_cookie;
extern LeafInfo pbRprClientRecentInUcastClassCFramesHigh_cookie;
extern LeafInfo pbRprClientRecentInUcastClassCFramesLow_cookie;
extern LeafInfo pbRprClientRecentInUcastClassCOctetsHigh_cookie;
extern LeafInfo pbRprClientRecentInUcastClassCOctetsLow_cookie;
extern LeafInfo pbRprClientRecentInMcastClassAFramesHigh_cookie;
extern LeafInfo pbRprClientRecentInMcastClassAFramesLow_cookie;
extern LeafInfo pbRprClientRecentInMcastClassAOctetsHigh_cookie;
extern LeafInfo pbRprClientRecentInMcastClassAOctetsLow_cookie;
extern LeafInfo pbRprClientRecentInMcastClassBCirFramesHigh_cookie;
extern LeafInfo pbRprClientRecentInMcastClassBCirFramesLow_cookie;
extern LeafInfo pbRprClientRecentInMcastClassBCirOctetsHigh_cookie;
extern LeafInfo pbRprClientRecentInMcastClassBCirOctetsLow_cookie;
extern LeafInfo pbRprClientRecentInMcastClassBEirFramesHigh_cookie;
extern LeafInfo pbRprClientRecentInMcastClassBEirFramesLow_cookie;
extern LeafInfo pbRprClientRecentInMcastClassBEirOctetsHigh_cookie;
extern LeafInfo pbRprClientRecentInMcastClassBEirOctetsLow_cookie;
extern LeafInfo pbRprClientRecentInMcastClassCFramesHigh_cookie;
extern LeafInfo pbRprClientRecentInMcastClassCFramesLow_cookie;
extern LeafInfo pbRprClientRecentInMcastClassCOctetsHigh_cookie;
extern LeafInfo pbRprClientRecentInMcastClassCOctetsLow_cookie;
extern LeafInfo pbRprClientRecentOutUcastClassAFramesHigh_cookie;
extern LeafInfo pbRprClientRecentOutUcastClassAFramesLow_cookie;
extern LeafInfo pbRprClientRecentOutUcastClassAOctetsHigh_cookie;
extern LeafInfo pbRprClientRecentOutUcastClassAOctetsLow_cookie;
extern LeafInfo pbRprClientRecentOutUcastClassBCirFramesHigh_cookie;
extern LeafInfo pbRprClientRecentOutUcastClassBCirFramesLow_cookie;
extern LeafInfo pbRprClientRecentOutUcastClassBCirOctetsHigh_cookie;
extern LeafInfo pbRprClientRecentOutUcastClassBCirOctetsLow_cookie;
extern LeafInfo pbRprClientRecentOutUcastClassBEirFramesHigh_cookie;
extern LeafInfo pbRprClientRecentOutUcastClassBEirFramesLow_cookie;
extern LeafInfo pbRprClientRecentOutUcastClassBEirOctetsHigh_cookie;
extern LeafInfo pbRprClientRecentOutUcastClassBEirOctetsLow_cookie;
extern LeafInfo pbRprClientRecentOutUcastClassCFramesHigh_cookie;
extern LeafInfo pbRprClientRecentOutUcastClassCFramesLow_cookie;
extern LeafInfo pbRprClientRecentOutUcastClassCOctetsHigh_cookie;
extern LeafInfo pbRprClientRecentOutUcastClassCOctetsLow_cookie;
extern LeafInfo pbRprClientRecentOutMcastClassAFramesHigh_cookie;
extern LeafInfo pbRprClientRecentOutMcastClassAFramesLow_cookie;
extern LeafInfo pbRprClientRecentOutMcastClassAOctetsHigh_cookie;
extern LeafInfo pbRprClientRecentOutMcastClassAOctetsLow_cookie;
extern LeafInfo pbRprClientRecentOutMcastClassBCirFramesHigh_cookie;
extern LeafInfo pbRprClientRecentOutMcastClassBCirFramesLow_cookie;
extern LeafInfo pbRprClientRecentOutMcastClassBCirOctetsHigh_cookie;
extern LeafInfo pbRprClientRecentOutMcastClassBCirOctetsLow_cookie;
extern LeafInfo pbRprClientRecentOutMcastClassBEirFramesHigh_cookie;
extern LeafInfo pbRprClientRecentOutMcastClassBEirFramesLow_cookie;
extern LeafInfo pbRprClientRecentOutMcastClassBEirOctetsHigh_cookie;
extern LeafInfo pbRprClientRecentOutMcastClassBEirOctetsLow_cookie;
extern LeafInfo pbRprClientRecentOutMcastClassCFramesHigh_cookie;
extern LeafInfo pbRprClientRecentOutMcastClassCFramesLow_cookie;
extern LeafInfo pbRprClientRecentOutMcastClassCOctetsHigh_cookie;
extern LeafInfo pbRprClientRecentOutMcastClassCOctetsLow_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbEthRecentTableType_cookie;
extern LeafInfo pbEthRecentPmPortType_cookie;
extern LeafInfo pbEthRecentTimesIndex_cookie;
extern LeafInfo pbEthRecentPmTimeEnd_cookie;
extern LeafInfo pbEthRecentPmTimeSuspect_cookie;
extern LeafInfo pbEthRecentInUnicastPktsHigh_cookie;
extern LeafInfo pbEthRecentInUnicastPktsLow_cookie;
extern LeafInfo pbEthRecentInMulcastPktsHigh_cookie;
extern LeafInfo pbEthRecentInMulcastPktsLow_cookie;
extern LeafInfo pbEthRecentInBrdcastPktsHigh_cookie;
extern LeafInfo pbEthRecentInBrdcastPktsLow_cookie;
extern LeafInfo pbEthRecentInAllBadPktsHigh_cookie;
extern LeafInfo pbEthRecentInAllBadPktsLow_cookie;
extern LeafInfo pbEthRecentInAllBadBytesHigh_cookie;
extern LeafInfo pbEthRecentInAllBadBytesLow_cookie;
extern LeafInfo pbEthRecentInAllGoodPktsHigh_cookie;
extern LeafInfo pbEthRecentInAllGoodPktsLow_cookie;
extern LeafInfo pbEthRecentInAllGoodBytesHigh_cookie;
extern LeafInfo pbEthRecentInAllGoodBytesLow_cookie;
extern LeafInfo pbEthRecentInOverSizePktsHigh_cookie;
extern LeafInfo pbEthRecentInOverSizePktsLow_cookie;
extern LeafInfo pbEthRecentInUnderSizePktsHigh_cookie;
extern LeafInfo pbEthRecentInUnderSizePktsLow_cookie;
extern LeafInfo pbEthRecentInCRCErrPktsHigh_cookie;
extern LeafInfo pbEthRecentInCRCErrPktsLow_cookie;
extern LeafInfo pbEthRecentOutUnicastPktsHigh_cookie;
extern LeafInfo pbEthRecentOutUnicastPktsLow_cookie;
extern LeafInfo pbEthRecentOutMulcastPktsHigh_cookie;
extern LeafInfo pbEthRecentOutMulcastPktsLow_cookie;
extern LeafInfo pbEthRecentOutBrdcastPktsHigh_cookie;
extern LeafInfo pbEthRecentOutBrdcastPktsLow_cookie;
extern LeafInfo pbEthRecentOutAllGoodPktsHigh_cookie;
extern LeafInfo pbEthRecentOutAllGoodPktsLow_cookie;
extern LeafInfo pbEthRecentOutAllGoodBytesHigh_cookie;
extern LeafInfo pbEthRecentOutAllGoodBytesLow_cookie;
extern LeafInfo pbEthRcntInAllBytesHigh_cookie;
extern LeafInfo pbEthRcntInAllBytesLow_cookie;
extern LeafInfo pbEthRcntInAllPktsHigh_cookie;
extern LeafInfo pbEthRcntInAllPktsLow_cookie;
extern LeafInfo pbEthRcntInAllGoodPktsHigh_cookie;
extern LeafInfo pbEthRcntInAllGoodPktsLow_cookie;
extern LeafInfo pbEthRcntInAllBadPktsHigh_cookie;
extern LeafInfo pbEthRcntInAllBadPktsLow_cookie;
extern LeafInfo pbEthRcntInUnicastPktsHigh_cookie;
extern LeafInfo pbEthRcntInUnicastPktsLow_cookie;
extern LeafInfo pbEthRcntInMulcastPktsHigh_cookie;
extern LeafInfo pbEthRcntInMulcastPktsLow_cookie;
extern LeafInfo pbEthRcntInBrdcastPktsHigh_cookie;
extern LeafInfo pbEthRcntInBrdcastPktsLow_cookie;
extern LeafInfo pbEthRcntInDropPktsHigh_cookie;
extern LeafInfo pbEthRcntInDropPktsLow_cookie;
extern LeafInfo pbEthRcntInUndersizeGoodPktsHigh_cookie;
extern LeafInfo pbEthRcntInUndersizeGoodPktsLow_cookie;
extern LeafInfo pbEthRcntInOversizeGoodPktsHigh_cookie;
extern LeafInfo pbEthRcntInOversizeGoodPktsLow_cookie;
extern LeafInfo pbEthRcntIn64PktsHigh_cookie;
extern LeafInfo pbEthRcntIn64PktsLow_cookie;
extern LeafInfo pbEthRcntIn65To127PktsHigh_cookie;
extern LeafInfo pbEthRcntIn65To127PktsLow_cookie;
extern LeafInfo pbEthRcntIn128To255PktsHigh_cookie;
extern LeafInfo pbEthRcntIn128To255PktsLow_cookie;
extern LeafInfo pbEthRcntIn256To511PktsHigh_cookie;
extern LeafInfo pbEthRcntIn256To511PktsLow_cookie;
extern LeafInfo pbEthRcntIn512To1023PktsHigh_cookie;
extern LeafInfo pbEthRcntIn512To1023PktsLow_cookie;
extern LeafInfo pbEthRcntIn1024To1518PktsHigh_cookie;
extern LeafInfo pbEthRcntIn1024To1518PktsLow_cookie;
extern LeafInfo pbEthRcntInPausePktsHigh_cookie;
extern LeafInfo pbEthRcntInPausePktsLow_cookie;
extern LeafInfo pbEthRcntInFragmentPktsHigh_cookie;
extern LeafInfo pbEthRcntInFragmentPktsLow_cookie;
extern LeafInfo pbEthRcntInJabberPktsHigh_cookie;
extern LeafInfo pbEthRcntInJabberPktsLow_cookie;
extern LeafInfo pbEthRcntInAlignmentErrorPktsHigh_cookie;
extern LeafInfo pbEthRcntInAlignmentErrorPktsLow_cookie;
extern LeafInfo pbEthRcntOutAllBytesHigh_cookie;
extern LeafInfo pbEthRcntOutAllBytesLow_cookie;
extern LeafInfo pbEthRcntOutAllPktsHigh_cookie;
extern LeafInfo pbEthRcntOutAllPktsLow_cookie;
extern LeafInfo pbEthRcntOutUnicastPktsHigh_cookie;
extern LeafInfo pbEthRcntOutUnicastPktsLow_cookie;
extern LeafInfo pbEthRcntOutMulcastPktsHigh_cookie;
extern LeafInfo pbEthRcntOutMulcastPktsLow_cookie;
extern LeafInfo pbEthRcntOutBrdcastPktsHigh_cookie;
extern LeafInfo pbEthRcntOutBrdcastPktsLow_cookie;
extern LeafInfo pbEthRcntOutGoodPausePktsHigh_cookie;
extern LeafInfo pbEthRcntOutGoodPausePktsLow_cookie;
extern LeafInfo pbEthRcntOutCollisionPktsHigh_cookie;
extern LeafInfo pbEthRcntOutCollisionPktsLow_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortType_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbTpType_cookie;
extern LeafInfo pbTpIndex_cookie;
extern LeafInfo pbRecentTableType_cookie;
extern LeafInfo pbRecentTimesIndex_cookie;
extern LeafInfo pbRecentEsPmCounter_cookie;
extern LeafInfo pbRecentBbePmCounter_cookie;
extern LeafInfo pbRecentSesPmCounter_cookie;
extern LeafInfo pbRecentUasPmCounter_cookie;
extern LeafInfo pbRecentCsesPmCounter_cookie;
extern LeafInfo pbRecentFcPmCounter_cookie;
extern LeafInfo pbRecentOfsPmCounter_cookie;
extern LeafInfo pbRecentPpjcPmCounter_cookie;
extern LeafInfo pbRecentNpjcPmCounter_cookie;
extern LeafInfo pbRecentPmTimeEnd_cookie;
extern LeafInfo pbSuspect_cookie;
extern LeafInfo pbComplete_cookie;
extern LeafInfo pbSdhUapPMTable_cookie;
extern LeafInfo pbPdhUapPMTable_cookie;
extern LeafInfo pbOtuUapPMTable_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortType_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbUapChannelID_cookie;
extern LeafInfo pbUapSegmentNum_cookie;
extern LeafInfo pbOtuUapType_cookie;
extern LeafInfo pbOtuIsAtUap_cookie;
extern LeafInfo pbOtuUAPCounter_cookie;
extern LeafInfo pbOtuUapTimeStart_cookie;
extern LeafInfo pbOtuUapTimeElapse_cookie;
extern LeafInfo pbOtuUAPReset_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortType_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbPdhUapType_cookie;
extern LeafInfo pbPdhIsAtUap_cookie;
extern LeafInfo pbPdhUAPCounter_cookie;
extern LeafInfo pbPdhUapTimeStart_cookie;
extern LeafInfo pbPdhUapTimeElapse_cookie;
extern LeafInfo pbPdhUAPReset_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortType_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbTpType_cookie;
extern LeafInfo pbTpIndex_cookie;
extern LeafInfo pbPmUapType_cookie;
extern LeafInfo pbIsAtUap_cookie;
extern LeafInfo pbUAPCounter_cookie;
extern LeafInfo pbUapTimeStart_cookie;
extern LeafInfo pbUapTimeElapse_cookie;
extern LeafInfo pbUAPReset_cookie;
extern LeafInfo pbSdhRecentUapPMTable_cookie;
extern LeafInfo pbPdhRecentUapPMTable_cookie;
extern LeafInfo pbOtuRecentUapPMTable_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortType_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbOtuRecUapChannelID_cookie;
extern LeafInfo pbOtuRecUapSegmentNum_cookie;
extern LeafInfo pbOtuRecUapType_cookie;
extern LeafInfo pbOtuUapTimesIndex_cookie;
extern LeafInfo pbOtuRecentUapTimeStart_cookie;
extern LeafInfo pbOtuRecentUapTimeEnd_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortType_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbPdhRecUapType_cookie;
extern LeafInfo pbPdhUapTimesIndex_cookie;
extern LeafInfo pbPdhRecentUapTimeStart_cookie;
extern LeafInfo pbPdhRecentUapTimeEnd_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortType_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbTpType_cookie;
extern LeafInfo pbTpIndex_cookie;
extern LeafInfo pbPmRecUapType_cookie;
extern LeafInfo pbUapTimesIndex_cookie;
extern LeafInfo pbRecentUapTimeStart_cookie;
extern LeafInfo pbRecentUapTimeEnd_cookie;
extern LeafInfo pbSdhMostRecentIndexTable_cookie;
extern LeafInfo pbEthMostRecentIndexTable_cookie;
extern LeafInfo pbRprClientMostRecentIndexTable_cookie;
extern LeafInfo pbRprSpanMostRecentIndexTable_cookie;
extern LeafInfo pbSlipMostRecentIndexTable_cookie;
extern LeafInfo pbxSecEthIndexTable_cookie;
extern LeafInfo pbPdhMostRecentIndexTable_cookie;
extern LeafInfo pbEthVlanMostRecentIndexTable_cookie;
extern LeafInfo pbxSecEthVlanIndexTable_cookie;
extern LeafInfo pbFecMostRecentIndexTable_cookie;
extern LeafInfo pbOtuMostRecentIndexTable_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortType_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbOtuRecChannelID_cookie;
extern LeafInfo pbOtuRecSegmentNum_cookie;
extern LeafInfo pbOtuRecIntervalTblType_cookie;
extern LeafInfo pbOtuRecentIntervalTblMRI_cookie;
extern LeafInfo pbOtuRecentIntervalUpMaxIndex_cookie;
extern LeafInfo pbOtuRecentUapTblMRI_cookie;
extern LeafInfo pbOtuRecentUapUpMaxIndex_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortType_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbFecRecIntervalTblType_cookie;
extern LeafInfo pbFecRecentIntervalTblMRI_cookie;
extern LeafInfo pbFecRecentIntervalUpMaxIndex_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbEthPmPortType_cookie;
extern LeafInfo pbEthVlanNo_cookie;
extern LeafInfo pbxSecEthVlanRecentIntervalTblMRI_cookie;
extern LeafInfo pbxSecEthVlanRecentIntervalUpMaxIndex_cookie;
extern LeafInfo pbxSecEthVlanRecentIndex_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbEthVlanIndexTableType_cookie;
extern LeafInfo pbEthPmPortType_cookie;
extern LeafInfo pbEthVlanNo_cookie;
extern LeafInfo pbEthVlanRecentIntervalTblMRI_cookie;
extern LeafInfo pbEthVlanRecentIntervalUpMaxIndex_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortType_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbPdhRecIntervalTblType_cookie;
extern LeafInfo pbPdhRecentIntervalTblMRI_cookie;
extern LeafInfo pbPdhRecentIntervalUpMaxIndex_cookie;
extern LeafInfo pbPdhRecentUapTblMRI_cookie;
extern LeafInfo pbPdhRecentUapUpMaxIndex_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbxSecEthIndexPortType_cookie;
extern LeafInfo pbxSecEthRecentIntervalTblMRI_cookie;
extern LeafInfo pbxSecEthRecentIntervalUpMaxIndex_cookie;
extern LeafInfo pbxSecEthRecentIndex_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortType_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbSlipRecentTblMRI_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo rprIfIndex_cookie;
extern LeafInfo rprSpanId_cookie;
extern LeafInfo pbRprSpanIndexTableType_cookie;
extern LeafInfo pbRprSpanRecentIntervalTblMRI_cookie;
extern LeafInfo pbRprSpanRecentIntervalUpMaxIndex_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo rprIfIndex_cookie;
extern LeafInfo pbRprClientIndexTableType_cookie;
extern LeafInfo pbRprClientRecentIntervalTblMRI_cookie;
extern LeafInfo pbRprClientRecentIntervalUpMaxIndex_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbEthIndexTableType_cookie;
extern LeafInfo pbEthIndexPmPortType_cookie;
extern LeafInfo pbEthRecentIntervalTblMRI_cookie;
extern LeafInfo pbEthRecentIntervalUpMaxIndex_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortType_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbTpType_cookie;
extern LeafInfo pbTpIndex_cookie;
extern LeafInfo pbPmRecIntervalTblType_cookie;
extern LeafInfo pbRecentIntervalTblMRI_cookie;
extern LeafInfo pbRecentIntervalUpMaxIndex_cookie;
extern LeafInfo pbRecentUapTblMRI_cookie;
extern LeafInfo pbRecentUapUpMaxIndex_cookie;
extern LeafInfo pbSdhPMUpLoadTable_cookie;
extern LeafInfo pbxSecEthUploadTable_cookie;
extern LeafInfo pbxSecEthFtpHostIP_cookie;
extern LeafInfo pbxSecEthFtpFileName_cookie;
extern LeafInfo pbxSecEthFtpUsername_cookie;
extern LeafInfo pbxSecEthFtpPassword_cookie;
extern LeafInfo pbSdhFtpCmndHostIP_cookie;
extern LeafInfo pbSdhFtpCmndPath_cookie;
extern LeafInfo pbSdhFtpFileName_cookie;
extern LeafInfo pbSdhFtpCmndUsername_cookie;
extern LeafInfo pbSdhFtpCmndPassword_cookie;
extern LeafInfo pbSdhFtpCmndLastState_cookie;
extern LeafInfo pbAdjustTimeDircetion_cookie;
extern LeafInfo pbAdjustTimeDays_cookie;
extern LeafInfo pbAdjustTimeHours_cookie;
extern LeafInfo pbAdjustTimeMins_cookie;
extern LeafInfo pbAdjustTimeSecs_cookie;
extern LeafInfo pbUpLoadStatus_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortType_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbOTUPortLabel_cookie;
extern LeafInfo pbOTUPortMode_cookie;
extern LeafInfo pbOTUPortAlarmDisable_cookie;
extern LeafInfo pbOTUPortLoopback_cookie;
extern LeafInfo pbFecEnable_cookie;
extern LeafInfo pbInsFecErrEnable_cookie;
extern LeafInfo pbInsFecErrRate_cookie;
extern LeafInfo pbWaveLengthId_cookie;
extern LeafInfo pbSMTimAlmEnable_cookie;
extern LeafInfo pbSMTimActEnable_cookie;
extern LeafInfo pbSMTxTti_cookie;
extern LeafInfo pbSMExpTti_cookie;
extern LeafInfo pbPTAlmEnable_cookie;
extern LeafInfo pbTxPt_cookie;
extern LeafInfo pbExpPt_cookie;
extern LeafInfo pbCIDAlmEnable_cookie;
extern LeafInfo pbTxChannelId_cookie;
extern LeafInfo pbAutoAdjustManulStopEnable_cookie;
extern LeafInfo pbPortPathMapping_cookie;
extern LeafInfo pbOTUFecMode_cookie;
extern LeafInfo pbOTUPortAdminStatus_cookie;
extern LeafInfo pbOTUPortUsageStatus_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortType_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbTpType_cookie;
extern LeafInfo pbTpIndex_cookie;
extern LeafInfo pbMonitored_cookie;
extern LeafInfo pbOutSignalType_cookie;
extern LeafInfo pbInSignalType_cookie;
extern LeafInfo pbTransPsl_cookie;
extern LeafInfo pbExpPsl_cookie;
extern LeafInfo pbSLEnable_cookie;
extern LeafInfo pbSLAccept_cookie;
extern LeafInfo pbTtiEnabled_cookie;
extern LeafInfo pbTimAisDis_cookie;
extern LeafInfo pbTtiTransmitMode_cookie;
extern LeafInfo pbTtiReceiveMode_cookie;
extern LeafInfo pbTtiOctetTransmitted_cookie;
extern LeafInfo pbTtiOctetExpected_cookie;
extern LeafInfo pbTtiOctetAccepted_cookie;
extern LeafInfo pbSdMode_cookie;
extern LeafInfo pbBurstyEnable_cookie;
extern LeafInfo pbBurstyPeriod_cookie;
extern LeafInfo pbBurstyPercent_cookie;
extern LeafInfo pbDegEnable_cookie;
extern LeafInfo pbDegThreshold_cookie;
extern LeafInfo pbExcEnable_cookie;
extern LeafInfo pbExcThreshold_cookie;
extern LeafInfo pbAISEnable_cookie;
extern LeafInfo pbRDIEnable_cookie;
extern LeafInfo pmNearEnd15minMonitored_cookie;
extern LeafInfo pmFarEnd15minMonitored_cookie;
extern LeafInfo pmNearEnd24hrMonitored_cookie;
extern LeafInfo pmFarEnd24hrMonitored_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortType_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo vc4ReservationStatus_cookie;
extern LeafInfo vc4ReservationOperate_cookie;
extern LeafInfo tpOperationLock_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortType_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbPortStatus_cookie;
extern LeafInfo pbPortOperStatus_cookie;
extern LeafInfo pbLaserIBias_cookie;
extern LeafInfo pbLaserRecvPwr_cookie;
extern LeafInfo pbLaserTransPwr_cookie;
extern LeafInfo pbLaserTemp_cookie;
extern LeafInfo pbCompliance8472_cookie;
extern LeafInfo pbnNominalMBps_cookie;
extern LeafInfo pbnWavelength_cookie;
extern LeafInfo pbnLinkLength9125_cookie;
extern LeafInfo pbnLinkLength50125_cookie;
extern LeafInfo pbnLinkLength62125_cookie;
extern LeafInfo pbnLinkLengthCopper_cookie;
extern LeafInfo pbsVendorName_cookie;
extern LeafInfo pbsVendorPN_cookie;
extern LeafInfo pbsVendorSN_cookie;
extern LeafInfo pbsManuDate_cookie;
extern LeafInfo pbnTransCode_cookie;
extern LeafInfo pbsVendorOUI_cookie;
extern LeafInfo pbnConnectorType_cookie;
extern LeafInfo pbnClLaserTemp_cookie;
extern LeafInfo pbnTECCurrent_cookie;
extern LeafInfo pbsSAGPartNumber_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbPortType_cookie;
extern LeafInfo pbPortNo_cookie;
extern LeafInfo pbPortLabel_cookie;
extern LeafInfo pbPortMode_cookie;
extern LeafInfo pbPdhPortMap_cookie;
extern LeafInfo pbPortAdminStatus_cookie;
extern LeafInfo pbPortMapRefresh_cookie;
extern LeafInfo pbPortAutoLaserShutdown_cookie;
extern LeafInfo pbPortLoopback_cookie;
extern LeafInfo pbFecMode_cookie;
extern LeafInfo pbActualPortType_cookie;
extern LeafInfo pbImpedance_cookie;
extern LeafInfo pbCodeType_cookie;
extern LeafInfo pbHaulType_cookie;
extern LeafInfo pbRetimingStatus_cookie;
extern LeafInfo pbPortAlsMode_cookie;
extern LeafInfo pbPortAlarmDisable_cookie;
extern LeafInfo expectedFrameStructure_cookie;
extern LeafInfo crcMultiframeDetector_cookie;
extern LeafInfo portClassification_cookie;
extern LeafInfo portUsageStatus_cookie;
extern LeafInfo portMappingString_cookie;
extern LeafInfo portOperationLock_cookie;
extern LeafInfo pbActiveAlarmTable_cookie;
extern LeafInfo pbAlarmTypeCfgTable_cookie;
extern LeafInfo pbCurrentEventsTable_cookie;
extern LeafInfo pbEventTypeCfgTable_cookie;
extern LeafInfo pbLogSizeGroup_cookie;
extern LeafInfo alarmPersistentTime_cookie;
extern LeafInfo logPolicyGroup_cookie;
extern LeafInfo pbAlarmStatGroup_cookie;
extern LeafInfo pbLogClearGroup_cookie;
extern LeafInfo pbClearAlarmLog_cookie;
extern LeafInfo pbClearEventsLog_cookie;
extern LeafInfo pbNumberOfCriticalAlarms_cookie;
extern LeafInfo pbNumberOfMajorAlarms_cookie;
extern LeafInfo pbNumberOfMinorAlarms_cookie;
extern LeafInfo pbNumberOfWarningAlarms_cookie;
extern LeafInfo pbNumberOfIndeterminateAlarms_cookie;
extern LeafInfo pbNumberOfEvents_cookie;
extern LeafInfo eventLogPolicy_cookie;
extern LeafInfo alarmDetectionPersistentTime_cookie;
extern LeafInfo alarmClearingPersistentTime_cookie;
extern LeafInfo pbAlarmLogSize_cookie;
extern LeafInfo pbEventLogSize_cookie;
extern LeafInfo pbEventTypeID_cookie;
extern LeafInfo pbEventTypeCategory_cookie;
extern LeafInfo pbEventTypeName_cookie;
extern LeafInfo pbEventTypeSendTrap_cookie;
extern LeafInfo pbCurrentEventIndex_cookie;
extern LeafInfo pbCurrentEventID_cookie;
extern LeafInfo pbCurrentEventDTS_cookie;
extern LeafInfo pbCurrentEventName_cookie;
extern LeafInfo pbCurrentEventCategory_cookie;
extern LeafInfo pbCurrentEventDetails_cookie;
extern LeafInfo pbAlarmTypeID_cookie;
extern LeafInfo pbAlarmTypeCode_cookie;
extern LeafInfo pbAlarmTypeDesc_cookie;
extern LeafInfo pbAlarmTypeCategory_cookie;
extern LeafInfo pbAlarmTypeSeverity_cookie;
extern LeafInfo pbAlarmTypeInhibit_cookie;
extern LeafInfo pbAlarmTypeMDO1_cookie;
extern LeafInfo pbAlarmTypeMDO2_cookie;
extern LeafInfo pbAlarmTypeTrapID_cookie;
extern LeafInfo pbAlarmTypeMDO3_cookie;
extern LeafInfo pbAlarmTypeMDO4_cookie;
extern LeafInfo pbAlmClassID_cookie;
extern LeafInfo pbAlarmTypeMDO5_cookie;
extern LeafInfo pbAlarmTypeMDO6_cookie;
extern LeafInfo pbAlarmTypeMDO7_cookie;
extern LeafInfo pbAlarmTypeMDO8_cookie;
extern LeafInfo pbActiveAlarmIndex_cookie;
extern LeafInfo pbActiveAlarmCode_cookie;
extern LeafInfo pbActiveAlarmSeverity_cookie;
extern LeafInfo pbActiveAlarmSource_cookie;
extern LeafInfo pbActiveAlarmDTS_cookie;
extern LeafInfo pbActiveAlarmClearDTS_cookie;
extern LeafInfo pbActiveAlarmSlotNum_cookie;
extern LeafInfo pbActiveAlarmPortNum_cookie;
extern LeafInfo pbActiveAlarmPortType_cookie;
extern LeafInfo pbActiveAlarmDesc_cookie;
extern LeafInfo pbActiveAlarmTypeID_cookie;
extern LeafInfo pbActiveAlarmCategory_cookie;
extern LeafInfo pbActiveAlarmPathType_cookie;
extern LeafInfo pbActiveAlarmSeqNum_cookie;
extern LeafInfo pbActiveAlarmAcknowledge_cookie;
extern LeafInfo pbActiveAlarmState_cookie;
extern LeafInfo pbActiveAlarmBoardStyle_cookie;
extern LeafInfo pbActiveAlarmActualPortType_cookie;
extern LeafInfo addressGroup_cookie;
extern LeafInfo systemGroup_cookie;
extern LeafInfo ledGroup_cookie;
extern LeafInfo pbSlotTable_cookie;
extern LeafInfo pbMibSaveRestoreGroup_cookie;
extern LeafInfo pbInterfaceGroup_cookie;
extern LeafInfo pbUpgradeGroup_cookie;
extern LeafInfo pbConfigCmndGroup_cookie;
extern LeafInfo pbStatsGroup_cookie;
extern LeafInfo alarmGroup_cookie;
extern LeafInfo pbNodeGroup_cookie;
extern LeafInfo nodeControlGroup_cookie;
extern LeafInfo ntpGroup_cookie;
extern LeafInfo pbDateTimeStampGroup_cookie;
extern LeafInfo pbCFCardGroup_cookie;
extern LeafInfo flashSpaceGroup_cookie;
extern LeafInfo pbExtensionShelfTable_cookie;
extern LeafInfo nodePropertyGroup_cookie;
extern LeafInfo eowFunctionGroup_cookie;
extern LeafInfo gmplsLicenseGroup_cookie;
extern LeafInfo e2romConfigGroup_cookie;
extern LeafInfo systemMonitorGroup_cookie;
extern LeafInfo cpuUtilEventGroup_cookie;
extern LeafInfo memUtilEventGroup_cookie;
extern LeafInfo cfCardUtilEventGroup_cookie;
extern LeafInfo flashUtilEventGroup_cookie;
extern LeafInfo flashUtilThreshold_cookie;
extern LeafInfo flashUtilEventEnable_cookie;
extern LeafInfo cfCardUtilThreshold_cookie;
extern LeafInfo cfCardUtilEventEnable_cookie;
extern LeafInfo memUtilThreshold_cookie;
extern LeafInfo memUtilEventEnable_cookie;
extern LeafInfo cpuUtilThreshold_cookie;
extern LeafInfo cpuUtilEventEnable_cookie;
extern LeafInfo pbE2RomConfigTable_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbE2RomPageNo_cookie;
extern LeafInfo pbE2RomTlvData_cookie;
extern LeafInfo gmplsLicenseStatus_cookie;
extern LeafInfo gmplsLicenseSyncFlag_cookie;
extern LeafInfo eowOhccTable_cookie;
extern LeafInfo siGlobalTable_cookie;
extern LeafInfo siChannelManageTable_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo ifIdx_cookie;
extern LeafInfo siChannelID_cookie;
extern LeafInfo siChannelGroup_cookie;
extern LeafInfo siChannelName_cookie;
extern LeafInfo siChannelEnable_cookie;
extern LeafInfo siChannelNoiseDetect_cookie;
extern LeafInfo siChannelNoiseState_cookie;
extern LeafInfo siChannelRingManage_cookie;
extern LeafInfo siChannelRingManageState_cookie;
extern LeafInfo siChannelRingManageDelta_cookie;
extern LeafInfo siChannelRingManageSwitch_cookie;
extern LeafInfo siChannelGroupSetting_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo ifIdx_cookie;
extern LeafInfo siName_cookie;
extern LeafInfo siPhoneNum_cookie;
extern LeafInfo siClipper_cookie;
extern LeafInfo siEnsThreshold_cookie;
extern LeafInfo siErmThreshold_cookie;
extern LeafInfo siErmAtt_cookie;
extern LeafInfo siErmStep_cookie;
extern LeafInfo siWorkingMode_cookie;
extern LeafInfo siUpdateDsp_cookie;
extern LeafInfo siUpdateDspState_cookie;
extern LeafInfo eowOhccDestination_cookie;
extern LeafInfo eowOhccSource_cookie;
extern LeafInfo eowOhccRingManaged_cookie;
extern LeafInfo nodeHoccCapability_cookie;
extern LeafInfo nodeLoccCapability_cookie;
extern LeafInfo pbExtensionShelfID_cookie;
extern LeafInfo pbMainShelfIP_cookie;
extern LeafInfo pbMainShelfReadString_cookie;
extern LeafInfo pbMainShelfWriteString_cookie;
extern LeafInfo pbMainShelfSlot_cookie;
extern LeafInfo pbMainShelfPort_cookie;
extern LeafInfo pbExtesionShelfIP_cookie;
extern LeafInfo pbExtesionShelfReadString_cookie;
extern LeafInfo pbExtesionShelfWriteString_cookie;
extern LeafInfo pbExtesionShelfSlot_cookie;
extern LeafInfo pbExtesionShelfPort_cookie;
extern LeafInfo pbExtesionShelfLabel_cookie;
extern LeafInfo pbExtesionShelfDesc_cookie;
extern LeafInfo pbExtesionShelfRowStatus_cookie;
extern LeafInfo boardFlashFreeSpace_cookie;
extern LeafInfo cfCardFreeSpace_cookie;
extern LeafInfo pbCFCardStatus_cookie;
extern LeafInfo pbCFCardMIBValidity_cookie;
extern LeafInfo pbStandbyCFCardStatus_cookie;
extern LeafInfo pbDateTimeStampSet_cookie;
extern LeafInfo pbDateTimeStampGet_cookie;
extern LeafInfo pbTimeZone_cookie;
extern LeafInfo pbNTPEnabled_cookie;
extern LeafInfo pbNTPIpAddress_cookie;
extern LeafInfo pbNTPRequestPeriods_cookie;
extern LeafInfo pbWarmRebootNode_cookie;
extern LeafInfo pbColdRebootNode_cookie;
extern LeafInfo pbResetNode_cookie;
extern LeafInfo pbNodeShutDown_cookie;
extern LeafInfo pbNodePowerOff_cookie;
extern LeafInfo pbNodeType_cookie;
extern LeafInfo pbNodeSoftwareVersion_cookie;
extern LeafInfo pbNodeIntSoftwareVersion_cookie;
extern LeafInfo pbDatabaseVersion_cookie;
extern LeafInfo pbNodeAlarmEnabling_cookie;
extern LeafInfo pbAISEnabled_cookie;
extern LeafInfo pbRDIEnabled_cookie;
extern LeafInfo pbAlarmSuppress_cookie;
extern LeafInfo pbAlarmCutOff_cookie;
extern LeafInfo pbACOGroup_cookie;
extern LeafInfo pbIoaTable_cookie;
extern LeafInfo pbDataExcDegTpNum_cookie;
extern LeafInfo alarmRuleSwitchGroup_cookie;
extern LeafInfo pbSEFEnabled_cookie;
extern LeafInfo lofMonitoringSwitch_cookie;
extern LeafInfo lomMonitoringSwitch_cookie;
extern LeafInfo lopMonitoringSwitch_cookie;
extern LeafInfo pbIoaIndexNo_cookie;
extern LeafInfo pbIoaLabel_cookie;
extern LeafInfo pbIoaEnableStatus_cookie;
extern LeafInfo pbIoaStatus_cookie;
extern LeafInfo pbAudibleACO_cookie;
extern LeafInfo pbVisualACO_cookie;
extern LeafInfo pbExtAudible_cookie;
extern LeafInfo pbExtVisual_cookie;
extern LeafInfo pbNumberOfReboots_cookie;
extern LeafInfo pbNodeDownDTS_cookie;
extern LeafInfo nodeMibCmnd_cookie;
extern LeafInfo nodeMibCmndState_cookie;
extern LeafInfo nodeMibCmndCancel_cookie;
extern LeafInfo nodeMibNmsOperateArea_cookie;
extern LeafInfo nodeMibUpDownLoadStatus_cookie;
extern LeafInfo nodeMibLastCommand_cookie;
extern LeafInfo nodeMibFailedIndex_cookie;
extern LeafInfo pbBackupMIBState_cookie;
extern LeafInfo pbMIBOperationDateTimeStamp_cookie;
extern LeafInfo nodeMIBFilesNoCheck_cookie;
extern LeafInfo pbUpgradeCurrRelease_cookie;
extern LeafInfo pbUpgradeBackupRelease_cookie;
extern LeafInfo pbUpgradeHostIP_cookie;
extern LeafInfo pbUpgradeHostUsername_cookie;
extern LeafInfo pbUpgradeHostPassword_cookie;
extern LeafInfo pbUpgradeHostFileName_cookie;
extern LeafInfo pbUpgradeCommand_cookie;
extern LeafInfo pbUpgradeCmndState_cookie;
extern LeafInfo pbUpgradeStateDescr_cookie;
extern LeafInfo pbUpgradeLoadCancel_cookie;
extern LeafInfo nodeUpgradeLastCommand_cookie;
extern LeafInfo nodeUpgradeFailedIndex_cookie;
extern LeafInfo nodeUpgradeSwitchPhySlot_cookie;
extern LeafInfo upgradeSoftwareInfoTable_cookie;
extern LeafInfo upgradeSoftwareSlotNumber_cookie;
extern LeafInfo upgradeSoftwareIndication_cookie;
extern LeafInfo upgradeSoftwareRole_cookie;
extern LeafInfo upgradeSoftwareName_cookie;
extern LeafInfo upgradeSoftwareDatetime_cookie;
extern LeafInfo pbPhysicalAdjacencyTable_cookie;
extern LeafInfo pbAutoLinkStarted_cookie;
extern LeafInfo pbAutoLinkTable_cookie;
extern LeafInfo pbLocalSlot_cookie;
extern LeafInfo pbLocalPort_cookie;
extern LeafInfo pbRemoteIPAddress_cookie;
extern LeafInfo pbRemoteSlot_cookie;
extern LeafInfo pbRemotePort_cookie;
extern LeafInfo pbLocalSlotNumber_cookie;
extern LeafInfo pbLocalPortNumber_cookie;
extern LeafInfo pbRemoteNodeMolnAdjacencyStatus_cookie;
extern LeafInfo pbRemoteNodeIPAddress_cookie;
extern LeafInfo pbRemoteSlotNumber_cookie;
extern LeafInfo pbRemotePortNumber_cookie;
extern LeafInfo pbLinkOperationalStatus_cookie;
extern LeafInfo pbInterfaceDescr_cookie;
extern LeafInfo pbLinkGeneralType_cookie;
extern LeafInfo pbLinkRowStatus_cookie;
extern LeafInfo pbAutoSaver_cookie;
extern LeafInfo pbAutoSaverFirstTimer_cookie;
extern LeafInfo pbAutoSaverLastTimer_cookie;
extern LeafInfo pbConfigType_cookie;
extern LeafInfo pbSaveMib_cookie;
extern LeafInfo pbClearMibSet_cookie;
extern LeafInfo pbSlotNumber_cookie;
extern LeafInfo pbSlotType_cookie;
extern LeafInfo pbBoardType_cookie;
extern LeafInfo pbBoardFunction_cookie;
extern LeafInfo pbCardState_cookie;
extern LeafInfo pbCardDesiredState_cookie;
extern LeafInfo pbSlotNumberDisplay_cookie;
extern LeafInfo pbSlotReset_cookie;
extern LeafInfo pbSlotNoFailuresTotal_cookie;
extern LeafInfo pbSlotResetNoFailures_cookie;
extern LeafInfo pbSlotResetDuration_cookie;
extern LeafInfo pbSlotName_cookie;
extern LeafInfo pbSlotDescr_cookie;
extern LeafInfo pbSlotIfCardDumb_cookie;
extern LeafInfo pbSlotCrashDumpAvail_cookie;
extern LeafInfo pbSlotLastBoardType_cookie;
extern LeafInfo pbSlotBoardTypeDifference_cookie;
extern LeafInfo pbSlotExplicitDeletion_cookie;
extern LeafInfo pbProvisionedCardType_cookie;
extern LeafInfo pbSlotCardSpecificInfo_cookie;
extern LeafInfo pbSlotTemperatureThreshold_cookie;
extern LeafInfo pbSlotTemperatureHysteresis_cookie;
extern LeafInfo pbSlotTemperatureCleanThreshold_cookie;
extern LeafInfo pbSlotLastBoardFunction_cookie;
extern LeafInfo pbDiagMode_cookie;
extern LeafInfo pbDiagActive_cookie;
extern LeafInfo pbLogicalSlotNumber_cookie;
extern LeafInfo pbSlotDisable_cookie;
extern LeafInfo pbForceResetSlot_cookie;
extern LeafInfo pbSlotFailureLedColor_cookie;
extern LeafInfo pbSlotActiveLedColor_cookie;
extern LeafInfo pbBoardSerialNumber_cookie;
extern LeafInfo pbBoardOption_cookie;
extern LeafInfo pbCode_cookie;
extern LeafInfo pbLatchState_cookie;
extern LeafInfo pbSlotAlarmDisable_cookie;
extern LeafInfo provisionedCardFunction_cookie;
extern LeafInfo slotConfigOption_cookie;
extern LeafInfo cardSoftwareVersion_cookie;
extern LeafInfo cardBootVersion_cookie;
extern LeafInfo cardBootDatetime_cookie;
extern LeafInfo cardHardwareVersion_cookie;
extern LeafInfo cardFusionVersion_cookie;
extern LeafInfo cardFpgaVersion_cookie;
extern LeafInfo macAddress_cookie;
extern LeafInfo slotMaxDCCNumber_cookie;
extern LeafInfo slotMapValue_cookie;
extern LeafInfo pbLedTest_cookie;
extern LeafInfo pbLedTable_cookie;
extern LeafInfo pbLedSlotNo_cookie;
extern LeafInfo pbLedIndexNo_cookie;
extern LeafInfo pbLedLabel_cookie;
extern LeafInfo pbLedColor_cookie;
extern LeafInfo pbMode_cookie;
extern LeafInfo pbLabel_cookie;
extern LeafInfo pbLocation_cookie;
extern LeafInfo pbDescription_cookie;
extern LeafInfo pbContact_cookie;
extern LeafInfo pbSerialNumber_cookie;
extern LeafInfo pbRelease_cookie;
extern LeafInfo pbBootImageVersion_cookie;
extern LeafInfo pbBackplaneHwVersion_cookie;
extern LeafInfo pbBackplaneCode_cookie;
extern LeafInfo pbIpAddress_cookie;
extern LeafInfo pbIpMask_cookie;
extern LeafInfo pbGatewayAddress_cookie;
extern LeafInfo pbEthernetAddress_cookie;
extern LeafInfo pbEthernetMask_cookie;
extern LeafInfo pbSystemMacAddress_cookie;
extern LeafInfo pbSlaveEthernetAddress_cookie;
extern LeafInfo pbEthernetAddressSecondary_cookie;
extern LeafInfo pbEthernetMaskSecondary_cookie;
extern LeafInfo pbEthernetEnable_cookie;
extern LeafInfo pbGMPLSIPAddress_cookie;
extern LeafInfo pbGMPLSIPMask_cookie;
extern LeafInfo pbMgmtPort1Status_cookie;
extern LeafInfo pbMgmtPort2Status_cookie;
extern LeafInfo enterpriseModules_cookie;
extern LeafInfo enterpriseNetworkingProducts_cookie;
extern LeafInfo product1Reg_cookie;
extern LeafInfo enterpriseGlobalRegModule_cookie;
extern LeafInfo productSeries1MibModule_cookie;
extern LeafInfo pbSecurityModule_cookie;
extern LeafInfo pbEventsModule_cookie;
extern LeafInfo pbSonetModule_cookie;
extern LeafInfo enterpriseGlobalTCModule_cookie;
extern LeafInfo enterpriseOAModule_cookie;
extern LeafInfo pbSDHProtectionModule_cookie;
extern LeafInfo enterpriseRstpMIB_cookie;
extern LeafInfo pbEthernetModule_cookie;
extern LeafInfo pbTMSModule_cookie;
extern LeafInfo pbXCContextModule_cookie;
extern LeafInfo pbXCModule_cookie;
extern LeafInfo pbSonetSDHPMModule_cookie;
extern LeafInfo pbNodeModule_cookie;
extern LeafInfo pbRprModule_cookie;
extern LeafInfo pbDccModule_cookie;
extern LeafInfo pbGvrpModule_cookie;
extern LeafInfo pbOsiModule_cookie;
extern LeafInfo pbIpTunnelModule_cookie;
extern LeafInfo enterpriseMstpMIB_cookie;
extern LeafInfo enterpriseEOSModule_cookie;
extern LeafInfo pbGmrpModule_cookie;
extern LeafInfo pbPrivateManagement_cookie;
extern LeafInfo mib_2_cookie;
extern LeafInfo system_cookie;
extern LeafInfo at_cookie;
extern LeafInfo interfaces_cookie;
extern LeafInfo ip_cookie;
extern LeafInfo icmp_cookie;
extern LeafInfo tcp_cookie;
extern LeafInfo udp_cookie;
extern LeafInfo egp_cookie;
extern LeafInfo transmission_cookie;
extern LeafInfo snmp_cookie;
extern LeafInfo ianaifType_cookie;
extern LeafInfo ifMIB_cookie;
extern LeafInfo agentxMIB_cookie;
extern LeafInfo agentxObjects_cookie;
extern LeafInfo agentxConformance_cookie;
extern LeafInfo agentxMIBGroups_cookie;
extern LeafInfo agentxMIBCompliances_cookie;
extern LeafInfo agentxGeneral_cookie;
extern LeafInfo agentxConnection_cookie;
extern LeafInfo agentxSession_cookie;
extern LeafInfo agentxRegistration_cookie;
extern LeafInfo agentxRegistrationTableLastChange_cookie;
extern LeafInfo agentxRegistrationTable_cookie;
extern LeafInfo agentxConnIndex_cookie;
extern LeafInfo agentxSessionIndex_cookie;
extern LeafInfo agentxRegIndex_cookie;
extern LeafInfo agentxRegContext_cookie;
extern LeafInfo agentxRegStart_cookie;
extern LeafInfo agentxRegRangeSubId_cookie;
extern LeafInfo agentxRegUpperBound_cookie;
extern LeafInfo agentxRegPriority_cookie;
extern LeafInfo agentxRegTimeout_cookie;
extern LeafInfo agentxRegInstance_cookie;
extern LeafInfo agentxSessionTableLastChange_cookie;
extern LeafInfo agentxSessionTable_cookie;
extern LeafInfo agentxConnIndex_cookie;
extern LeafInfo agentxSessionIndex_cookie;
extern LeafInfo agentxSessionObjectID_cookie;
extern LeafInfo agentxSessionDescr_cookie;
extern LeafInfo agentxSessionAdminStatus_cookie;
extern LeafInfo agentxSessionOpenTime_cookie;
extern LeafInfo agentxSessionAgentXVer_cookie;
extern LeafInfo agentxSessionTimeout_cookie;
extern LeafInfo agentxConnTableLastChange_cookie;
extern LeafInfo agentxConnectionTable_cookie;
extern LeafInfo agentxConnIndex_cookie;
extern LeafInfo agentxConnOpenTime_cookie;
extern LeafInfo agentxConnTransportDomain_cookie;
extern LeafInfo agentxConnTransportAddress_cookie;
extern LeafInfo agentxDefaultTimeout_cookie;
extern LeafInfo agentxMasterAgentXVer_cookie;
extern LeafInfo ifMIBObjects_cookie;
extern LeafInfo ifConformance_cookie;
extern LeafInfo ifGroups_cookie;
extern LeafInfo ifCompliances_cookie;
extern LeafInfo ifXTable_cookie;
extern LeafInfo ifTableLastChange_cookie;
extern LeafInfo ifTestTable_cookie;
extern LeafInfo ifRcvAddressTable_cookie;
extern LeafInfo ifStackTable_cookie;
extern LeafInfo ifStackLastChange_cookie;
extern LeafInfo ifStackHigherLayer_cookie;
extern LeafInfo ifStackLowerLayer_cookie;
extern LeafInfo ifStackStatus_cookie;
extern LeafInfo ifIndex_cookie;
extern LeafInfo ifRcvAddressAddress_cookie;
extern LeafInfo ifRcvAddressStatus_cookie;
extern LeafInfo ifRcvAddressType_cookie;
extern LeafInfo ifIndex_cookie;
extern LeafInfo ifTestId_cookie;
extern LeafInfo ifTestStatus_cookie;
extern LeafInfo ifTestType_cookie;
extern LeafInfo ifTestResult_cookie;
extern LeafInfo ifTestCode_cookie;
extern LeafInfo ifTestOwner_cookie;
extern LeafInfo ifIndex_cookie;
extern LeafInfo ifName_cookie;
extern LeafInfo ifInMulticastPkts_cookie;
extern LeafInfo ifInBroadcastPkts_cookie;
extern LeafInfo ifOutMulticastPkts_cookie;
extern LeafInfo ifOutBroadcastPkts_cookie;
extern LeafInfo ifHCInOctets_cookie;
extern LeafInfo ifHCInUcastPkts_cookie;
extern LeafInfo ifHCInMulticastPkts_cookie;
extern LeafInfo ifHCInBroadcastPkts_cookie;
extern LeafInfo ifHCOutOctets_cookie;
extern LeafInfo ifHCOutUcastPkts_cookie;
extern LeafInfo ifHCOutMulticastPkts_cookie;
extern LeafInfo ifHCOutBroadcastPkts_cookie;
extern LeafInfo ifLinkUpDownTrapEnable_cookie;
extern LeafInfo ifHighSpeed_cookie;
extern LeafInfo ifPromiscuousMode_cookie;
extern LeafInfo ifConnectorPresent_cookie;
extern LeafInfo ifAlias_cookie;
extern LeafInfo ifCounterDiscontinuityTime_cookie;
extern LeafInfo snmpInPkts_cookie;
extern LeafInfo snmpInBadVersions_cookie;
extern LeafInfo snmpOutPkts_cookie;
extern LeafInfo snmpInBadCommunityNames_cookie;
extern LeafInfo snmpInBadCommunityUses_cookie;
extern LeafInfo snmpInASNParseErrs_cookie;
extern LeafInfo snmpEnableAuthenTraps_cookie;
extern LeafInfo snmpOutTraps_cookie;
extern LeafInfo snmpOutGetResponses_cookie;
extern LeafInfo snmpOutSetRequests_cookie;
extern LeafInfo snmpOutGetNexts_cookie;
extern LeafInfo snmpOutGetRequests_cookie;
extern LeafInfo snmpOutGenErrs_cookie;
extern LeafInfo snmpOutBadValues_cookie;
extern LeafInfo snmpOutNoSuchNames_cookie;
extern LeafInfo snmpOutTooBigs_cookie;
extern LeafInfo snmpInTraps_cookie;
extern LeafInfo snmpInGetResponses_cookie;
extern LeafInfo snmpInSetRequests_cookie;
extern LeafInfo snmpInGetNexts_cookie;
extern LeafInfo snmpInGetRequests_cookie;
extern LeafInfo snmpInTotalSetVars_cookie;
extern LeafInfo snmpInTotalReqVars_cookie;
extern LeafInfo snmpInGenErrs_cookie;
extern LeafInfo snmpInReadOnlys_cookie;
extern LeafInfo snmpInBadValues_cookie;
extern LeafInfo snmpInNoSuchNames_cookie;
extern LeafInfo snmpInTooBigs_cookie;
extern LeafInfo snmpSilentDrops_cookie;
extern LeafInfo snmpProxyDrops_cookie;
extern LeafInfo egpInMsgs_cookie;
extern LeafInfo egpInErrors_cookie;
extern LeafInfo egpOutMsgs_cookie;
extern LeafInfo egpOutErrors_cookie;
extern LeafInfo egpNeighTable_cookie;
extern LeafInfo egpAs_cookie;
extern LeafInfo egpNeighAddr_cookie;
extern LeafInfo egpNeighState_cookie;
extern LeafInfo egpNeighAs_cookie;
extern LeafInfo egpNeighInMsgs_cookie;
extern LeafInfo egpNeighInErrs_cookie;
extern LeafInfo egpNeighOutMsgs_cookie;
extern LeafInfo egpNeighOutErrs_cookie;
extern LeafInfo egpNeighInErrMsgs_cookie;
extern LeafInfo egpNeighOutErrMsgs_cookie;
extern LeafInfo egpNeighStateUps_cookie;
extern LeafInfo egpNeighStateDowns_cookie;
extern LeafInfo egpNeighIntervalHello_cookie;
extern LeafInfo egpNeighIntervalPoll_cookie;
extern LeafInfo egpNeighMode_cookie;
extern LeafInfo egpNeighEventTrigger_cookie;
extern LeafInfo udpInDatagrams_cookie;
extern LeafInfo udpNoPorts_cookie;
extern LeafInfo udpInErrors_cookie;
extern LeafInfo udpOutDatagrams_cookie;
extern LeafInfo udpTable_cookie;
extern LeafInfo udpLocalAddress_cookie;
extern LeafInfo udpLocalPort_cookie;
extern LeafInfo tcpRtoAlgorithm_cookie;
extern LeafInfo tcpRtoMin_cookie;
extern LeafInfo tcpRtoMax_cookie;
extern LeafInfo tcpMaxConn_cookie;
extern LeafInfo tcpActiveOpens_cookie;
extern LeafInfo tcpPassiveOpens_cookie;
extern LeafInfo tcpAttemptFails_cookie;
extern LeafInfo tcpEstabResets_cookie;
extern LeafInfo tcpCurrEstab_cookie;
extern LeafInfo tcpInSegs_cookie;
extern LeafInfo tcpOutSegs_cookie;
extern LeafInfo tcpRetransSegs_cookie;
extern LeafInfo tcpConnTable_cookie;
extern LeafInfo tcpInErrs_cookie;
extern LeafInfo tcpOutRsts_cookie;
extern LeafInfo tcpConnLocalAddress_cookie;
extern LeafInfo tcpConnLocalPort_cookie;
extern LeafInfo tcpConnRemAddress_cookie;
extern LeafInfo tcpConnRemPort_cookie;
extern LeafInfo tcpConnState_cookie;
extern LeafInfo icmpInMsgs_cookie;
extern LeafInfo icmpInErrors_cookie;
extern LeafInfo icmpInDestUnreachs_cookie;
extern LeafInfo icmpInTimeExcds_cookie;
extern LeafInfo icmpInParmProbs_cookie;
extern LeafInfo icmpInSrcQuenchs_cookie;
extern LeafInfo icmpInRedirects_cookie;
extern LeafInfo icmpInEchos_cookie;
extern LeafInfo icmpInEchoReps_cookie;
extern LeafInfo icmpInTimestamps_cookie;
extern LeafInfo icmpInTimestampReps_cookie;
extern LeafInfo icmpInAddrMasks_cookie;
extern LeafInfo icmpInAddrMaskReps_cookie;
extern LeafInfo icmpOutMsgs_cookie;
extern LeafInfo icmpOutErrors_cookie;
extern LeafInfo icmpOutDestUnreachs_cookie;
extern LeafInfo icmpOutTimeExcds_cookie;
extern LeafInfo icmpOutParmProbs_cookie;
extern LeafInfo icmpOutSrcQuenchs_cookie;
extern LeafInfo icmpOutRedirects_cookie;
extern LeafInfo icmpOutEchos_cookie;
extern LeafInfo icmpOutEchoReps_cookie;
extern LeafInfo icmpOutTimestamps_cookie;
extern LeafInfo icmpOutTimestampReps_cookie;
extern LeafInfo icmpOutAddrMasks_cookie;
extern LeafInfo icmpOutAddrMaskReps_cookie;
extern LeafInfo ipForwarding_cookie;
extern LeafInfo ipDefaultTTL_cookie;
extern LeafInfo ipInReceives_cookie;
extern LeafInfo ipInHdrErrors_cookie;
extern LeafInfo ipInAddrErrors_cookie;
extern LeafInfo ipForwDatagrams_cookie;
extern LeafInfo ipInUnknownProtos_cookie;
extern LeafInfo ipInDiscards_cookie;
extern LeafInfo ipInDelivers_cookie;
extern LeafInfo ipOutRequests_cookie;
extern LeafInfo ipOutDiscards_cookie;
extern LeafInfo ipOutNoRoutes_cookie;
extern LeafInfo ipReasmTimeout_cookie;
extern LeafInfo ipReasmReqds_cookie;
extern LeafInfo ipReasmOKs_cookie;
extern LeafInfo ipReasmFails_cookie;
extern LeafInfo ipFragOKs_cookie;
extern LeafInfo ipFragFails_cookie;
extern LeafInfo ipFragCreates_cookie;
extern LeafInfo ipAddrTable_cookie;
extern LeafInfo ipRouteTable_cookie;
extern LeafInfo ipNetToMediaTable_cookie;
extern LeafInfo ipRoutingDiscards_cookie;
extern LeafInfo ipNetToMediaIfIndex_cookie;
extern LeafInfo ipNetToMediaNetAddress_cookie;
extern LeafInfo ipNetToMediaPhysAddress_cookie;
extern LeafInfo ipNetToMediaType_cookie;
extern LeafInfo ipRouteDest_cookie;
extern LeafInfo ipRouteIfIndex_cookie;
extern LeafInfo ipRouteMetric1_cookie;
extern LeafInfo ipRouteMetric2_cookie;
extern LeafInfo ipRouteMetric3_cookie;
extern LeafInfo ipRouteMetric4_cookie;
extern LeafInfo ipRouteNextHop_cookie;
extern LeafInfo ipRouteType_cookie;
extern LeafInfo ipRouteProto_cookie;
extern LeafInfo ipRouteAge_cookie;
extern LeafInfo ipRouteMask_cookie;
extern LeafInfo ipRouteMetric5_cookie;
extern LeafInfo ipRouteInfo_cookie;
extern LeafInfo ipAdEntAddr_cookie;
extern LeafInfo ipAdEntIfIndex_cookie;
extern LeafInfo ipAdEntNetMask_cookie;
extern LeafInfo ipAdEntBcastAddr_cookie;
extern LeafInfo ipAdEntReasmMaxSize_cookie;
extern LeafInfo ifNumber_cookie;
extern LeafInfo ifTable_cookie;
extern LeafInfo ifIndex_cookie;
extern LeafInfo ifDescr_cookie;
extern LeafInfo ifType_cookie;
extern LeafInfo ifMtu_cookie;
extern LeafInfo ifSpeed_cookie;
extern LeafInfo ifPhysAddress_cookie;
extern LeafInfo ifAdminStatus_cookie;
extern LeafInfo ifOperStatus_cookie;
extern LeafInfo ifLastChange_cookie;
extern LeafInfo ifInOctets_cookie;
extern LeafInfo ifInUcastPkts_cookie;
extern LeafInfo ifInNUcastPkts_cookie;
extern LeafInfo ifInDiscards_cookie;
extern LeafInfo ifInErrors_cookie;
extern LeafInfo ifInUnknownProtos_cookie;
extern LeafInfo ifOutOctets_cookie;
extern LeafInfo ifOutUcastPkts_cookie;
extern LeafInfo ifOutNUcastPkts_cookie;
extern LeafInfo ifOutDiscards_cookie;
extern LeafInfo ifOutErrors_cookie;
extern LeafInfo ifOutQLen_cookie;
extern LeafInfo ifSpecific_cookie;
extern LeafInfo atTable_cookie;
extern LeafInfo atIfIndex_cookie;
extern LeafInfo atNetAddress_cookie;
extern LeafInfo atPhysAddress_cookie;
extern LeafInfo sysDescr_cookie;
extern LeafInfo sysObjectID_cookie;
extern LeafInfo sysUpTime_cookie;
extern LeafInfo sysContact_cookie;
extern LeafInfo sysName_cookie;
extern LeafInfo sysLocation_cookie;
extern LeafInfo sysServices_cookie;
extern LeafInfo sysORLastChange_cookie;
extern LeafInfo sysORTable_cookie;
extern LeafInfo sysORIndex_cookie;
extern LeafInfo sysORID_cookie;
extern LeafInfo sysORDescr_cookie;
extern LeafInfo sysORUpTime_cookie;
extern LeafInfo applTable_cookie;
extern LeafInfo aapplTable_cookie;
extern LeafInfo bootpTable_cookie;
extern LeafInfo pbIntVcTable_cookie;
extern LeafInfo pbFileSystemTable_cookie;
extern LeafInfo pbDivaMTable_cookie;
extern LeafInfo moduleTable_cookie;
extern LeafInfo applTableVer_cookie;
extern LeafInfo pbPortLedsTable_cookie;
extern LeafInfo pbPortLedProxySlot_cookie;
extern LeafInfo pbPortLedSlot_cookie;
extern LeafInfo pbPortLedIndexNo_cookie;
extern LeafInfo pbPortLedColor_cookie;
extern LeafInfo moduleIndex_cookie;
extern LeafInfo moduleBoardFunction_cookie;
extern LeafInfo moduleBoardProperty_cookie;
extern LeafInfo moduleBoardStyle_cookie;
extern LeafInfo moduleChassisType_cookie;
extern LeafInfo moduleName_cookie;
extern LeafInfo moduleFname_cookie;
extern LeafInfo moduleStart_cookie;
extern LeafInfo moduleInit_cookie;
extern LeafInfo pbDivaMslotno_cookie;
extern LeafInfo pbDivaMportno_cookie;
extern LeafInfo pbDivaMmetric_cookie;
extern LeafInfo pbFileDir_cookie;
extern LeafInfo pbFileName_cookie;
extern LeafInfo pbFileSize_cookie;
extern LeafInfo pbFileSlot_cookie;
extern LeafInfo pbIntVcLocalIntf_cookie;
extern LeafInfo pbIntVcLocalVpi_cookie;
extern LeafInfo pbIntVcLocalVci_cookie;
extern LeafInfo pbIntVcRemoteIntf_cookie;
extern LeafInfo pbIntVcRemoteVpi_cookie;
extern LeafInfo pbIntVcRemoteVci_cookie;
extern LeafInfo bootpBoardType_cookie;
extern LeafInfo bootpFname_cookie;
extern LeafInfo aapplSlotNo_cookie;
extern LeafInfo aapplNumber_cookie;
extern LeafInfo aapplName_cookie;
extern LeafInfo aapplCpuUsage_cookie;
extern LeafInfo aapplLogLevels_cookie;
extern LeafInfo aapplOptions_cookie;
extern LeafInfo aapplStatus_cookie;
extern LeafInfo aapplLoadOrder_cookie;
extern LeafInfo applIndex_cookie;
extern LeafInfo applBoardFunction_cookie;
extern LeafInfo applBoardProperty_cookie;
extern LeafInfo applBoardStyle_cookie;
extern LeafInfo applChassisType_cookie;
extern LeafInfo applName_cookie;
extern LeafInfo applNumber_cookie;
extern LeafInfo applFname_cookie;
extern LeafInfo applEntryfn_cookie;
extern LeafInfo applTaskName_cookie;
extern LeafInfo applTaskPri_cookie;
extern LeafInfo applTaskStack_cookie;
extern LeafInfo applLogLevels_cookie;
extern LeafInfo applOptions_cookie;
extern LeafInfo applStart_cookie;




 




















































































































































































































































































































































                                                         



 























































































































































































































































































































 





















































































































































































































































































































typedef enum
{
    FMA_ALM_CLEAR[TTT] = 0,
    FMA_ALM_SET = 1
}                       FMA_ALM_STATE;

typedef struct
{
    unsigned int    entity[TTT];
    unsigned int    instance;
    HW_PORT_TYPE    portType;
    SDH_TP_TYPE     tpType;
    UINT32          e;
    UINT32          d;
    UINT32          c;
    UINT32          b;
    UINT32          a;
    UINT32          k;
    UINT32          l;
    UINT32          m;    
} FM_TP_PATH_T;

typedef struct {
    BOOL[TTT] phyPathValid;                      
    BOOL realPathValid;                     
    BOOL phyPathChanged;                    
    BOOL realPathChanged;                   
    unsigned int oldRealEntity;             
    FM_TP_PATH_T basePath;                  
    FM_TP_PATH_T phyPath;                   
    FM_TP_PATH_T realPath;                  
} FM_PCO_TP_T; 

 


 
typedef unsigned int    FM_AISMODE_T[TTT];



typedef unsigned int    FM_RDIMODE_T[TTT];



 










typedef PB_ERROR_CODE_T[TTT] (*FMA_AlmModDefectFunc)(UINT32 SlotId, INSTANCE_T Instance, UINT32 PortId, HW_PORT_TYPE PortType, SDH_TP_TYPE TpType, COMPACT_TP_T TpIndex, UINT32 DefectId, FMA_ALM_STATE state);

typedef PB_ERROR_CODE_T[TTT] (*FMC_AlmModDefectFunc)(UINT32 SlotId, INSTANCE_T Instance, UINT32 PortId, HW_PORT_TYPE PortType, SDH_TP_TYPE TpType, COMPACT_TP_T TpIndex, UINT32 DefectId, FMA_ALM_STATE state);

typedef PB_ERROR_CODE_T[TTT] (*FMA_AlmModDefectByBusFunc)(UINT16 busNo, UINT16 vc4No, TU_TP_T tpIndex, SDH_TP_TYPE tpType, UINT32 defectId, FMA_ALM_STATE state);


 






typedef PB_ERROR_CODE_T[TTT]  (*FMA_GetBusBySlot)(UINT32 slotId, UINT32 portNo, UINT32 portType, COMPACT_TP_T tpIndex, UINT16 * pBusNo, UINT16 * pVc4No);

typedef PB_ERROR_CODE_T[TTT]  (*FMA_GetSlotByBus)(UINT16 busNo, UINT16 vc4No, UINT32 * pSlotId, UINT32 * pPortNo,UINT32 * pEDCB, UINT32 * pPortType);

extern PB_ERROR_CODE_T FMA_RegisterBusBySlot(FMA_GetBusBySlot pFmaBusBySlot);
extern PB_ERROR_CODE_T FMA_RegisterSlotByBus(FMA_GetSlotByBus pFmaSlotByBus);





 


































































































 
typedef enum
{
    TMS_SSF_CLEAR[TTT] = 0,
    TMS_SSF_SET = 1
}TMS_SSF_ACTION;


 
typedef void (*TMA_S1ChangeCallbackFunc[TTT])(UINT32 instance, UINT8 port, UINT8 ssmb);
extern void TMA_S1ChangeCallback(UINT32 instance, UINT8 port, UINT8 ssmb);

 
typedef PB_ERROR_CODE_T[TTT] (*TMH_InitCCFPGAFunc)(UINT32 instance, BOOL ccstate, BOOL cardstate, BOOL warm);
extern PB_ERROR_CODE_T TMH_InitCCFPGA(UINT32 instance, BOOL ccstate, BOOL cardstate, BOOL warm);

 
typedef void (*TMA_ModDefectFunc[TTT])(UINT32 instance, UINT8 SlotId, UINT8 PortId, UINT32 DefectId, TMS_SSF_ACTION state);
extern void TMA_SetDefect(UINT32 instance, UINT8 SlotId, UINT8 PortId, UINT32 DefectId,TMS_SSF_ACTION state);

 
typedef PB_ERROR_CODE_T[TTT] (*TMH_SwitchHOCCFunc)(BOOL isWorkHOCC, BOOL bCallTmaStep);
extern PB_ERROR_CODE_T TMH_SwitchHOCC(BOOL isWorkHOCC, BOOL bCallTmaStep);

extern PB_ERROR_CODE_T TMT_DetectCardState(INSTANCE_T inst, BOOL *pbActive);
extern PB_ERROR_CODE_T TMT_DeActivateSICard (INSTANCE_T inst);
extern PB_ERROR_CODE_T TMT_ActivateSICard (INSTANCE_T inst, BOOL bWarm);
extern PB_ERROR_CODE_T TMT_InitSICard (INSTANCE_T inst, UINT32 ulStyle, UINT32 ulOption);
extern void TMI_ReportAlarm(FMC_AlmModDefectFunc pFunc);

typedef PB_ERROR_CODE_T[TTT] (*TM_RptPLLUnlock)(SLOT_NUMBER_T slot, BOOL bUnitFail);
void TMT_RegRptPLLUnlock(FMA_AlmModDefectFunc pFunc);
void TMH_RegRptPLLUnlock(TM_RptPLLUnlock pFunc);
void TMH_RegReportAlarmFunction(FMA_AlmModDefectFunc pFunc);













  









 
















typedef struct{
    UINT8[TTT] pbSlotNumber;
    UINT8 pbPortNo;
    UINT8 portType; 
    TP_INDEX_T tpIndex;
}__attribute__ ((packed))  PM_TP_NO_T;  

typedef struct {
    BOOL[TTT] bRsBipMon;
    BOOL bRsOfsMon;
    BOOL bMsBipMon;
    BOOL bMsReiMon;
}__attribute__ ((packed))  PMA_SOH_MON_T;

typedef struct {
    BOOL[TTT] bHpBipMon;
    BOOL bHpReiMon;
    BOOL bHpNpjcMon;
    BOOL bHpPpjcMon;
    BOOL bHpFeNpjcMon;
    BOOL bHpFePpjcMon;
}__attribute__ ((packed))  PMA_HP_MON_T;

typedef struct {
    BOOL[TTT] bLpBipMon;
    BOOL bLpReiMon;
}__attribute__ ((packed))  PMA_LP_MON_T;


typedef struct
{
    UINT8[TTT]    pbSlotNumber;                                 
    INSTANCE_T            instance;
    UINT8        pbPortNo;                                                 
    UINT32 pbEthTableType;                                  
    UINT8   pbEthPmPortType;                                  
    UINT32 pbEthPmMonitor;
    char        pbEthPmTimeStart[16];
    unsigned int    pbEthPmTimeElapse;
    BOOL            pbEthPmTimeSuspect;
    BOOL            pbEthPmTableReset;
    unsigned int    pbEthInUnicastPktsHigh;
    unsigned int    pbEthInUnicastPktsLow;
    unsigned int    pbEthInMulcastPktsHigh;
    unsigned int    pbEthInMulcastPktsLow;
    unsigned int    pbEthInBrdcastPktsHigh;
    unsigned int    pbEthInBrdcastPktsLow;
    unsigned int    pbEthInAllBadPktsHigh;
    unsigned int    pbEthInAllBadPktsLow;
    unsigned int    pbEthInAllBadBytesHigh;
    unsigned int    pbEthInAllBadBytesLow;
    unsigned int    pbEthInAllGoodPktsHigh;
    unsigned int    pbEthInAllGoodPktsLow;
    unsigned int    pbEthInAllGoodBytesHigh;
    unsigned int    pbEthInAllGoodBytesLow;
    unsigned int    pbEthInOverSizePktsHigh;
    unsigned int    pbEthInOverSizePktsLow;
    unsigned int    pbEthInUnderSizePktsHigh;
    unsigned int    pbEthInUnderSizePktsLow;
    unsigned int    pbEthInCRCErrPktsHigh;
    unsigned int    pbEthInCRCErrPktsLow;
    unsigned int    pbEthOutUnicastPktsHigh;
    unsigned int    pbEthOutUnicastPktsLow;
    unsigned int    pbEthOutMulcastPktsHigh;
    unsigned int    pbEthOutMulcastPktsLow;
    unsigned int    pbEthOutBrdcastPktsHigh;
    unsigned int    pbEthOutBrdcastPktsLow;
    unsigned int    pbEthOutAllGoodPktsHigh;
    unsigned int    pbEthOutAllGoodPktsLow;
    unsigned int    pbEthOutAllGoodBytesHigh;
    unsigned int    pbEthOutAllGoodBytesLow;
    UINT32          pbEthBbrEnable;
    int        pbEthBbrThresholdValue;
    UINT32         pbEthBprEnable;
    int        pbEthBprThresholdValue;
}__attribute__ ((packed))  ETH_PM_DTAT_T;  

typedef struct 
{  
    UINT8[TTT]                      slot;
    UINT8                      portType;
    UINT8                      actPortType;
    UINT8                      portNo;
    TP_INDEX_T             tpIndex;
}__attribute__ ((packed))  PM_TP_INDEX_T;


typedef struct
{
	UINT8[TTT]			   instance;
       UINT8                   slot;
       UINT8                   portType;                         
       UINT8                   portNo;                                  
}__attribute__ ((packed))  PM_ETH_INDEX_T;

 
typedef struct
{
    UINT8[TTT]  slot;
    int     rprIfIndex;
}__attribute__ ((packed))  PM_RPR_CLIENT_INDEX_T;

typedef struct
{
    UINT8[TTT]  slot;
    int     rprIfIndex;
    RprSpan_Tval rprSpanId;
}__attribute__ ((packed))  PM_RPR_SPAN_INDEX_T;

typedef struct
{
    UINT8[TTT]         slot;
    UINT8         portType;
    UINT8         portNo;
}__attribute__ ((packed))  PM_PDH_SLIP_INDEX_T;

typedef struct
{
    UINT8[TTT]                 slot;
    UINT8                 portType;
    UINT8                 portNo;
}__attribute__ ((packed))  PM_PDH_INDEX_T;

typedef struct
{
    UINT8[TTT]                 slot;
    UINT8                 portType;
    UINT8                 portNo;
}__attribute__ ((packed))  PM_FEC_INDEX_T;


typedef struct 
{
	 
	

    
     
    UINT32[TTT]  ethInAllBytes; 
    UINT32  ethInAllPkts; 
    UINT32  ethInAllGoodPkts; 
    UINT32  ethInAllBadPkts;  
    UINT32  ethInUnicastPkts; 
    UINT32  ethInMulcastPkts; 
    UINT32  ethInBrdcastPkts; 
    UINT32  ethInDropPkts;
    UINT32  ethInUndersizeGoodPkts; 
    UINT32  ethInOversizeGoodPkts;
    UINT32  ethIn64Pkts;
    UINT32  ethIn65To127Pkts;
    UINT32  ethIn128To255Pkts; 
    UINT32  ethIn256To511Pkts; 
    UINT32  ethIn512To1023Pkts;
    UINT32  ethIn1024To1518Pkts; 
    UINT32  ethInPausePkts;
    UINT32  ethInFragmentPkts; 
    UINT32  ethInJabberPkts; 
    UINT32  ethInAlignmentErrorPkts;
    UINT32  ethOutAllBytes; 
    UINT32  ethOutAllPkts;
    UINT32  ethOutUnicastPkts; 
    UINT32  ethOutMulcastPkts; 
    UINT32  ethOutBrdcastPkts; 
    UINT32  ethOutGoodPausePkts;
    UINT32  ethOutCollisionPkts;
}__attribute__ ((packed))  PM_ETH_DATA_T;

typedef struct
{
	UINT8[TTT] 				instance;
         UINT8                slot;
         UINT8                portNo; 
         UINT8                portType;
         UINT32              vlanId;
}__attribute__ ((packed))  PM_ETH_VLAN_INDEX_T;      

typedef struct 
{
       UINT32[TTT]    ethVlanInBytes;
       UINT32    ethVlanInPkts;  
       UINT32    ethVlanDropPkts;    
       UINT32    RcvUnicastFrames;
       UINT32    RcvTotalFrames;
       UINT32    RcvUnicastBytes;
       UINT32    RcvTotalBytes;
}__attribute__ ((packed))  PM_ETH_VLAN_DATA_T;    

typedef void (*PMP_GetRsOofFunc[TTT])(UINT8 slot,UINT16 port,HW_PORT_TYPE portType);













 
































































 





























 



 
 
 
 
 
 
















































 

 



















 















 






  
























































 


























 



 



 
typedef enum
{
    TASK_CORE_SECTION[TTT]       = 0,  
    TASK_URGENT_SECTION     = 1,  
    TASK_MANAGEMENT_SECTION = 2,  
    TASK_NORMAL_SECTION     = 3,  
    TASK_IDLE_SECTION       = 4  
} TASK_PRIORITY_SECTION_T;












 
 
 
 
 

 








 
 
 




















































 






 



































 





 














 







 




















 

 







































 















 


































 























 










































 


 



 




 







 
















































































































































































 







typedef enum msp_switch_type[TTT]
{
    MSP_REQ_LP        =     127,  
    MSP_REQ_SF_P      =     126,  
    MSP_REQ_FS_W      =     125,  
    MSP_REQ_FS_P      =     123,  
    MSP_REQ_FS_2      =     122,  
    MSP_REQ_FS_3      =     121,  
    MSP_REQ_FS_4      =     120,  
    MSP_REQ_FS_5      =     119,  
    MSP_REQ_FS_6      =     118,  
    MSP_REQ_FS_7      =     117,  
    MSP_REQ_FS_8      =     116,  
    MSP_REQ_FS_9      =     115,  
    MSP_REQ_FS_10     =     114,  
    MSP_REQ_FS_11     =     113,  
    MSP_REQ_FS_12     =     112,  
    MSP_REQ_FS_13     =     111,  
    MSP_REQ_FS_14     =     110,  
    MSP_REQ_FS_15     =     109,  

    MSP_REQ_SF_W      =     108,  
    MSP_REQ_SF_H_2    =     107,  
    MSP_REQ_SF_H_3    =     106,  
    MSP_REQ_SF_H_4    =     105,  
    MSP_REQ_SF_H_5    =     104,  
    MSP_REQ_SF_H_6    =     103,  
    MSP_REQ_SF_H_7    =     102,  
    MSP_REQ_SF_H_8    =     101,  
    MSP_REQ_SF_H_9    =     100,  
    MSP_REQ_SF_H_10   =     99,  
    MSP_REQ_SF_H_11   =     98,  
    MSP_REQ_SF_H_12   =     97,  
    MSP_REQ_SF_H_13   =     96,  
    MSP_REQ_SF_H_14   =     95,  

    MSP_REQ_SF_L_1    =     94,  
    MSP_REQ_SF_L_2    =     93,  
    MSP_REQ_SF_L_3    =     92,  
    MSP_REQ_SF_L_4    =     91,  
    MSP_REQ_SF_L_5    =     90,  
    MSP_REQ_SF_L_6    =     89,  
    MSP_REQ_SF_L_7    =     88,  
    MSP_REQ_SF_L_8    =     87,  
    MSP_REQ_SF_L_9    =     86,  
    MSP_REQ_SF_L_10   =     85,  
    MSP_REQ_SF_L_11   =     84,  
    MSP_REQ_SF_L_12   =     83,  
    MSP_REQ_SF_L_13   =     82,  
    MSP_REQ_SF_L_14   =     81,  

    MSP_REQ_SD_P      =     78,  
    MSP_REQ_SD_W      =     76,  
    MSP_REQ_SD_H_2    =     75,  
    MSP_REQ_SD_H_3    =     74,  
    MSP_REQ_SD_H_4    =     73,  
    MSP_REQ_SD_H_5    =     72,  
    MSP_REQ_SD_H_6    =     71,  
    MSP_REQ_SD_H_7    =     70,  
    MSP_REQ_SD_H_8    =     69,  
    MSP_REQ_SD_H_9    =     68,  
    MSP_REQ_SD_H_10   =     67,  
    MSP_REQ_SD_H_11   =     66,  
    MSP_REQ_SD_H_12   =     65,  
    MSP_REQ_SD_H_13   =     64,  
    MSP_REQ_SD_H_14   =     63,  

    MSP_REQ_SD_L_1    =     62,  
    MSP_REQ_SD_L_2    =     61,  
    MSP_REQ_SD_L_3    =     60,  
    MSP_REQ_SD_L_4    =     59,  
    MSP_REQ_SD_L_5    =     58,  
    MSP_REQ_SD_L_6    =     57,  
    MSP_REQ_SD_L_7    =     56,  
    MSP_REQ_SD_L_8    =     55,  
    MSP_REQ_SD_L_9    =     54,  
    MSP_REQ_SD_L_10   =     53,  
    MSP_REQ_SD_L_11   =     52,  
    MSP_REQ_SD_L_12   =     51,  
    MSP_REQ_SD_L_13   =     50,  
    MSP_REQ_SD_L_14   =     49,  

    MSP_REQ_MS_W      =     46,  
    MSP_REQ_MS_P      =     45,  
    MSP_REQ_MS_2      =     44,  
    MSP_REQ_MS_3      =     43,  
    MSP_REQ_MS_4      =     42,  
    MSP_REQ_MS_5      =     41,  
    MSP_REQ_MS_6      =     40,  
    MSP_REQ_MS_7      =     39,  
    MSP_REQ_MS_8      =     38,  
    MSP_REQ_MS_9      =     37,  
    MSP_REQ_MS_10     =     36,  
    MSP_REQ_MS_11     =     35,  
    MSP_REQ_MS_12     =     34,  
    MSP_REQ_MS_13     =     33,  
    MSP_REQ_MS_14     =     32,  
    MSP_REQ_MS_15     =     31,  
    MSP_REQ_WTR       =     30,  
    MSP_REQ_EXER_0    =     29,  
    MSP_REQ_EXER_1    =     28,  
    MSP_REQ_EXER_2    =     27,  
    MSP_REQ_EXER_3    =     26,  
    MSP_REQ_EXER_4    =     25,  
    MSP_REQ_EXER_5    =     24,  
    MSP_REQ_EXER_6    =     23,  
    MSP_REQ_EXER_7    =     22,  
    MSP_REQ_EXER_8    =     21,  
    MSP_REQ_EXER_9    =     20,  
    MSP_REQ_EXER_10   =     19,  
    MSP_REQ_EXER_11   =     18,  
    MSP_REQ_EXER_12   =     17,  
    MSP_REQ_EXER_13   =     16,  
    MSP_REQ_EXER_14   =     15,  
    MSP_REQ_EXER_15   =     14,  
    MSP_REQ_RR        =     13,  
    MSP_REQ_DNR       =     12,  
    MSP_REQ_NRM       =     0,  
    MSP_REQ_NR        =     0,  
} MSP_SWITCH_REQ_T;

typedef enum msp_switch_type_t[TTT]
{
    MSP_NO_REQUEST = 0,      
    MSP_DNOTREV_REQ,         
    MSP_REVERT_REQ,          
    MSP_UNUSED3_REQ,         
    MSP_EXERCISE_REQ,        
    MSP_UNUSED5_REQ,         
    MSP_WTR_REQ,             
    MSP_UNUSED7_REQ,         
    MSP_MAN_REQ,             
    MSP_UNUSED9_REQ,         
    MSP_SD_LPRI_REQ,         
    MSP_SD_HPRI_REQ,         
    MSP_SF_LPRI_REQ,         
    MSP_SF_HPRI_REQ,         
    MSP_FORCED_REQ,          
    MSP_LOCK_REQ,            
    MSP_UNKNOWN_REQ = 0x10
} MSP_SWITCH_REQ_TYPE_T;

 



typedef enum
{
    CTD_MSP_SIG_STATE_UNKNOWN[TTT]   = 0x0,
    CTD_MSP_SIG_STATE_NORMAL    = 0x1,
    CTD_MSP_SIG_STATE_DEGRADE   = 0x2,
    CTD_MSP_SIG_STATE_FAIL      = 0x3,
}CTD_MSP_SIG_STATE_T;

typedef enum
{
    CTD_MSP_UNIDIRECTION[TTT]    = 0x0,
    CTD_MSP_BIDIRECTION     = 0x1,
}CTD_MSP_DIR_MODE_T;

typedef enum
{
    CTD_MSP_NONREVERTIVE[TTT] = 0x0,
    CTD_MSP_REVERTIVE    = 0x1,
}CTD_MSP_RVT_MODE_T;

typedef enum
{
    CTD_MSP_ACTIVE[TTT]       = 0x0,
    CTD_MSP_STANDBY      = 0x1,
}CTD_MSP_CH_STATE_T;

typedef enum
{
    CTD_MSP_PRIORI_HIGH[TTT]       = 0x0,
    CTD_MSP_PRIORI_LOW        = 0x1,
}CTD_MSP_CH_PRIORITY_T;

typedef enum
{
    CTD_MSP_CMD_CLEAR[TTT]               = 0x7F,
    CTD_MSP_LOCK_OUT_PROT           = 0x7E,
    CTD_MSP_FORCE_SWTICH_WORK       = 0x7D,
    CTD_MSP_FORCE_SWITCH_PROT_1     = 0x7B,
    CTD_MSP_FORCE_SWITCH_PROT_2     = 0x7A,
    CTD_MSP_FORCE_SWITCH_PROT_3     = 0x79,    
    CTD_MSP_FORCE_SWITCH_PROT_4     = 0x78,    
    CTD_MSP_FORCE_SWITCH_PROT_5     = 0x77,    
    CTD_MSP_FORCE_SWITCH_PROT_6     = 0x76,    
    CTD_MSP_FORCE_SWITCH_PROT_7     = 0x75,    
    CTD_MSP_FORCE_SWITCH_PROT_8     = 0x74,    
    CTD_MSP_FORCE_SWITCH_PROT_9     = 0x73,    
    CTD_MSP_FORCE_SWITCH_PROT_10    = 0x72,        
    CTD_MSP_FORCE_SWITCH_PROT_11    = 0x71,        
    CTD_MSP_FORCE_SWITCH_PROT_12    = 0x70,        
    CTD_MSP_FORCE_SWITCH_PROT_13    = 0x6F,        
    CTD_MSP_FORCE_SWITCH_PROT_14    = 0x6E,
    CTD_MSP_FORCE_SWITCH_PROT_15    = 0x6D,            
    CTD_MSP_MANUAL_SWITCH_WORK      = 0x2E,
    CTD_MSP_MANUAL_SWITCH_PROT_1    = 0x2D,
    CTD_MSP_MANUAL_SWITCH_PROT_2    = 0x2C,
    CTD_MSP_MANUAL_SWITCH_PROT_3    = 0x2B,
    CTD_MSP_MANUAL_SWITCH_PROT_4    = 0x2A,
    CTD_MSP_MANUAL_SWITCH_PROT_5    = 0x29,
    CTD_MSP_MANUAL_SWITCH_PROT_6    = 0x28,
    CTD_MSP_MANUAL_SWITCH_PROT_7    = 0x27,
    CTD_MSP_MANUAL_SWITCH_PROT_8    = 0x26,
    CTD_MSP_MANUAL_SWITCH_PROT_9    = 0x25,
    CTD_MSP_MANUAL_SWITCH_PROT_10   = 0x24,
    CTD_MSP_MANUAL_SWITCH_PROT_11   = 0x23,
    CTD_MSP_MANUAL_SWITCH_PROT_12   = 0x22,
    CTD_MSP_MANUAL_SWITCH_PROT_13   = 0x21,
    CTD_MSP_MANUAL_SWITCH_PROT_14   = 0x20,
    CTD_MSP_MANUAL_SWITCH_PROT_15   = 0x1F,
    CTD_MSP_EXER_0                  = 0x1D,
    CTD_MSP_EXER_1                  = 0x1C,
    CTD_MSP_EXER_2                  = 0x1B,
    CTD_MSP_EXER_3                  = 0x1A,
    CTD_MSP_EXER_4                  = 0x19,
    CTD_MSP_EXER_5                  = 0x18,
    CTD_MSP_EXER_6                  = 0x17,
    CTD_MSP_EXER_7                  = 0x16,
    CTD_MSP_EXER_8                  = 0x15,
    CTD_MSP_EXER_9                  = 0x14,
    CTD_MSP_EXER_10                 = 0x13,
    CTD_MSP_EXER_11                 = 0x12,
    CTD_MSP_EXER_12                 = 0x11,
    CTD_MSP_EXER_13                 = 0x10,    
    CTD_MSP_EXER_14                 = 0x0F,    
    CTD_MSP_EXER_15                 = 0x0E,
    CTD_MSP_NO_COMMAND              = 0x00,
}CTD_MSP_CMD_TYPE_T;

typedef enum 
{
    CTD_MSP_CMD_RSLT_SUCC[TTT]        = 0x1,
    CTD_MSP_CMD_RSLT_LOWPRIORITY = 0x2,
    CTD_MSP_CMD_SWITCH_TO_ACTIVE = 0x3,
    CTD_MSP_CMD_SWITCH_FAIL      = 0x4,   
}CTD_MSP_CMD_RSLT_T;

typedef enum
{
    CTD_MSP_RSN_CLEAR_CMD[TTT]         = 0x1,
    CTD_MSP_RSN_LP_CMD            = 0x2,
    CTD_MSP_RSN_FORCED_SWITCH     = 0x3,
    CTD_MSP_RSN_MANUAL_SWITCH     = 0x4,
    CTD_MSP_RSN_SIGNAL_FAIL       = 0x5,
    CTD_MSP_RSN_SIGNAL_FAIL_CLEAR = 0x6,
    CTD_MSP_RSN_SIGNAL_DEG        = 0x7,
    CTD_MSP_RSN_SIGNAL_DEG_CLEAR  = 0x8,
    CTD_MSP_RSN_NO_SWITCH         = 0x9,
} CTD_MSP_SWITCH_RSN_T;

typedef enum
{
    CTD_MSP_PRIO_LOW[TTT]              = 0x0,
    CTD_MSP_PRIO_HIGH             = 0x1,
}CTD_MSP_PRIO_TYPE_T;

typedef struct
{
     
    CTD_MSP_SIG_STATE_T[TTT]  eWorkSigState[14];
    CTD_MSP_CH_STATE_T   eWorkChState[14]; 
     
    CTD_MSP_SIG_STATE_T  eProtSigState;
    CTD_MSP_CH_STATE_T   eProtChState; 
     
    CTD_MSP_CMD_TYPE_T   eMspExtCmd;                          
    CTD_MSP_CMD_RSLT_T   eMspExtCmdRslt;  
     
    MSP_SWITCH_REQ_T     eMspCurSwitchReq;                         
    CTD_MSP_SWITCH_RSN_T eMspSwitchReason;
     
    BOOL                 bFopAlarm;
     
    UINT8                ucRcvdK1Value;
    UINT8                ucRcvdK2Value;
     
    UINT8                ucTransK1Value;
    UINT8                ucTransK2Value;
     
    BOOL                 bIsExtra;
}CTD_MSP_STATE_T;

typedef struct
{
    UINT16[TTT]              usMspGrpNum;
    UINT8               ucMspWorkChNum;
    UINT8               ucMspType;   
    CTD_MSP_STATE_T     *sMspState;
}CTD_HW_MSP_STATE_T;


 
typedef struct
{
     
    UINT16[TTT] usGrpId;
    UINT16 usProtSlot;                  
    UINT16 usProtPort;
    UINT8  ucProtPortType;
    UINT16 usWorkNum;                   
    UINT16 usWorkSlot[14];
    UINT16 usWorkPort[14];
    UINT8  ucWorkPortType[14];
    UINT8  ucWorkPrio[14];
    UINT32              ulWtrVal;	    
    CTD_MSP_CMD_TYPE_T  eCmdType;       
    BOOL   bIsExtra;                    

    BOOL   bEnable;                     
}CTD_MSP_1VSN_CFG_T;

typedef struct
{
    UINT16[TTT] usWorkNum;
    CTD_MSP_PRIO_TYPE_T sPrio[14];
}CTD_MSP_PRIO_STAT_T;

 
typedef struct
{
    UINT16[TTT] usBusRx;
    UINT16 usBusTx;
    UINT16 usVc4;
}CTD_TP_PARAM_CFG_T;
typedef struct
{
    UINT16[TTT] usTpCount;
    UINT16 usGrpId;
    CTD_TP_PARAM_CFG_T *tp;
}CTD_1ToNMSP_TP_CFG_T;
typedef struct
{
     
     
    CTD_1ToNMSP_TP_CFG_T[TTT] sProtTp;                  
    UINT16 usWorkNum;                   
    CTD_1ToNMSP_TP_CFG_T sWorkTP[14];    
    UINT8 ucWorkPrio[14];    
    UINT32              ulWtrVal;	    
    CTD_MSP_CMD_TYPE_T  eCmdType;       
    BOOL   bIsExtra;                    

    BOOL   bEnable;                     
}CTD_MSP_1VSN_DRV_CFG_T;




typedef struct
{
    UINT16[TTT]              usGrpId;          
    UINT16              usWorkSlot;	    
    UINT16              usWorkPort;	    
    UINT16              usProtSlot;     
    UINT16              usProtPort;	    
    HW_PORT_TYPE        ePortType;      
    CTD_MSP_DIR_MODE_T  eDirMode;       
    CTD_MSP_RVT_MODE_T  eRvtMode;       
    UINT32              ulWtrVal;	    
    CTD_MSP_CMD_TYPE_T  eCmdType;       
    BOOL                bEnable;        
}CTD_MSP_1PLUS1_CFG_T;

typedef void (*MPA_Handle_RcvKbyte[TTT])(UINT16 usSlot, UINT16 ucPort, UINT8 ucPorttype, UINT8 ucK1, UINT8 ucK2);
typedef void (*MPA_RcvPhyDefect[TTT])(UINT16 usSlot, UINT16 ucPort, UINT8 ucPorttype, MSP_SWITCH_REQ_T eType, UINT32 ulFlag);
typedef void (*MPA_RprtMspStatus[TTT])(UINT16 wMspGrpId, CTD_MSP_STATE_T *psMspState);




 















 
 
 
 
 
 
 
 	
 
 













































	extern int stack(unsigned int *pStack[], int levels);
	extern void logBackN(const char *title, int n);
	extern void logBackM(const char *title, int n);
	extern void logExit(char *file, int line);
	extern void logDump(char *file, int line);
	extern void sys_panic(char *file, int line);

















 




























	typedef struct {
		int head[TTT];
		int tail;
		command_tt *queue[500 ];
	} LogQ_t;

	extern unsigned int utility_log;
	extern unsigned int MsgRecvLogOpen;
	extern unsigned int COL_Log;
	
	
	extern LogQ_t logq;
	void debug_log_init(void);
	void log_enqueue(command_tt * log);
	void log_clear(void);
	void consoleLog(const char *fmt, ...);
 
	void ulogit(int line, const char *file_name, int global, const char *fmt, ...);













 


typedef enum 
{
    LC_UNKNOWN[TTT] = 0,      
    LC_CLEAR   = 1,      
    LC_SD      = 2,      
    LC_SF      = 3,      
    LC_MAX     = 4 
}LINE_COND_T;

typedef enum 
{
    KEXP_AUTO_MODE[TTT]      = 0,     
    KEXP_LOCAL_HW_MODE  = 1,     
    KEXP_LOCAL_SW_MODE  = 2,     
    KEXP_FORCE_MODE     = 3,     
}CTD_KEXP_MODE_T;

typedef enum 
{
    KEXP_UNKNOWN_STATE[TTT]     = 0,     
    KEXP_AUTO_LOCAL_STATE  = 1,     
    KEXP_AUTO_EXP_STATE    = 2,     
    KEXP_FORCE_EXP_STATE   = 3,     
    KEXP_FORCE_SW_STATE    = 4,     
    KEXP_FORCE_HW_STATE    = 5,     
}CTD_KEXP_STATE_T;

typedef struct
{
    UINT32[TTT]          ulSlot;
    HW_PORT_TYPE    ePortType;
    UINT32          ulPort;
    UINT32          ulPeerSlot;
    HW_PORT_TYPE    ePeerPortType;
    UINT32          ulPeerPort;
    UINT8           ucNodeId;
    UINT8           ucNodeNum;    
    CTD_KEXP_MODE_T eMode;
    BOOL            bEnable;
}CTD_MSSP_ENABLE_T;

typedef struct
{
    UINT32[TTT]              ulSlot;
    UINT32              ulPortType;
    UINT32              ulPort;
    union
    {
        struct
        {
            UINT8       ucK1;
            UINT8       ucK2;
            UINT16      usBackup;
        } sKBytes;
        LINE_COND_T     eLineCond;
    } uRptChange;
} CTD_MSSP_CHANGERPT_T;

typedef void (*MSA_ChangeKbyteBatch[TTT])(CTD_MSSP_CHANGERPT_T *pKb, UINT32  batNo);
typedef void (*MSA_ChangeLineCondBatch[TTT])(CTD_MSSP_CHANGERPT_T *pLc, UINT32  batNo);

typedef void (*MST_ChangeOfKb[TTT])(UINT32 ulSlot, UINT8 ucPortType, UINT8 ucPort, UINT8 ucK1, UINT8 ucK2);
typedef void (*MST_ChangeOfLineCond[TTT])(UINT32 ulSlot, UINT8 ucPortType, UINT8 ucPort, LINE_COND_T eLcCond);




 





 
 
 
 
 
 
 
 
 
 
 
 




























 
typedef enum 
{
    SNCP_BACK_TP[TTT]       = 0,
    SNCP_WORK_TP1      = 1,
    SNCP_WORK_TP2      = 2,
    SNCP_WORK_TP3      = 3,
    SNCP_WORK_TP4      = 4,
    SNCP_WORK_TP5      = 5,
    SNCP_WORK_TP6      = 6,
    SNCP_WORK_TP7      = 7,
    SNCP_WORK_TP8      = 8,
    SNCP_WORK_TP9      = 9,
    SNCP_WORK_TP10     = 10,
    SNCP_WORK_TP11     = 11,
    SNCP_WORK_TP12     = 12,
    SNCP_WORK_TP13     = 13,
    SNCP_WORK_TP14     = 14,
    SNCP_WORK_TP15     = 15
}SNCP_TP_CHANNEL_T;

typedef enum 
{
    SNCP_LOGIC_TP[TTT]      = 0,
    SNCP_PHYSICAL_TP   = 1,
    SNCP_PHYSICAL_TP1  = 2
}SNCP_LOGIC_TP_DEFINE_T;


typedef enum 
{
    SNCP_I[TTT]             = 0,
    SNCP_N             = 1,
}SNCP_INTRUSIVE_T;

typedef struct 
{
    UINT16[TTT]               usSlotNum;
    UINT16               usPortType;
    UINT16               usPortNum;
    TP_INDEX_T           TpIndex;
    BOOL                  bInUse;       
}__attribute__ ((packed))  SNCP_CHANNEL_T;


typedef enum 
{
    SPC_TP_TYPE_PROTECT[TTT]             = 0,
    SPC_TP_TYPE_PROTECT_MS_PROTECT,    
    SPC_TP_TYPE_WORK,
    SPC_TP_TYPE_WORK_MS_PROTECT,
    SPC_TP_TYPE_WORK2,
    SPC_TP_TYPE_WORK2_MS_PROTECT,
    SPC_TP_TYPE_WORK3,
    SPC_TP_TYPE_WORK3_MS_PROTECT,
    SPC_TP_TYPE_WORK4,
    SPC_TP_TYPE_WORK4_MS_PROTECT,
    SPC_TP_TYPE_WORK5,
    SPC_TP_TYPE_WORK5_MS_PROTECT,
    SPC_TP_TYPE_WORK6,
    SPC_TP_TYPE_WORK6_MS_PROTECT,
    SPC_TP_TYPE_WORK7,
    SPC_TP_TYPE_WORK7_MS_PROTECT,
    SPC_TP_TYPE_WORK8,
    SPC_TP_TYPE_WORK8_MS_PROTECT,
    SPC_TP_TYPE_WORK9,
    SPC_TP_TYPE_WORK9_MS_PROTECT,
    SPC_TP_TYPE_WORK10,
    SPC_TP_TYPE_WORK10_MS_PROTECT,
    SPC_TP_TYPE_WORK11,
    SPC_TP_TYPE_WORK11_MS_PROTECT,
    SPC_TP_TYPE_WORK12,
    SPC_TP_TYPE_WORK12_MS_PROTECT,
    SPC_TP_TYPE_WORK13,
    SPC_TP_TYPE_WORK13_MS_PROTECT,
    SPC_TP_TYPE_WORK14,
    SPC_TP_TYPE_WORK14_MS_PROTECT,
    SPC_TP_TYPE_WORK15,
    SPC_TP_TYPE_WORK15_MS_PROTECT
}SNCP_TP_TYPE_T;


typedef enum
{
    SNCP_SIGNAL_UNKNOW[TTT]     = 0,
    SNCP_SIGNAL_NORMAL     = 1,
    SNCP_SIGNAL_FAIL       = 2,
    SNCP_SIGNAL_DEG        = 3,
}SNCP_SIGNAL_STATE_T;

 
typedef enum
{
    SNCP_1J1_TYPE[TTT]      = 0,
    SNCP_1BN_TYPE      = 1
}SNCP_GROUP_TYPE_T;

 
typedef struct 
{    
    BOOL[TTT]                  bEnableSncp;
    UINT32                ulSncpId;										
    UINT16                usWorkBus;
    UINT8                 ucWorkVc4;
    UINT16                usProtBus;
    UINT8                 ucProtVc4;
    UINT16                usDestBus;
    UINT8                 ucDestVc4;
     
    BOOL                 bXCEnable;
     
    UINT16                usDestFirstBus; 
    UINT8                 ucDestFirstVc4;

    UINT8                 ucSncpIntrusive;                
    UINT8                 ucSncpRestoreMode;                
    UINT16                usHoldOffTime;                    
    UINT16                usSncpWTR;   
}__attribute__ ((packed))  HW_HO3P_SNCP_CONFIG_T;

typedef struct 
{
    UINT8[TTT]                ucBus;
    UINT8                ucVc4;
    UINT16               KLM;   
}__attribute__ ((packed))  LO_MATRIX_ITEM_T;

 
typedef struct 
{    
    BOOL[TTT]                    bEnableSncp;
    UINT32                  ulSncpId;										
    LO_MATRIX_ITEM_T        WorkItem;
    LO_MATRIX_ITEM_T        ProtItem;
    LO_MATRIX_ITEM_T        DestItem;
    UINT8                	ucSncpIntrusive;                
    UINT8                   ucSncpRestoreMode;  
    UINT8                   ucSncpExtCmd;              
    UINT16                  usHoldOffTime;                    
    UINT16                  usSncpWTR;   
}__attribute__ ((packed))  HW_LO3P_SNCP_CONFIG_T;

typedef union
{
    HW_HO3P_SNCP_CONFIG_T[TTT]   HoSncpGroup;
    HW_LO3P_SNCP_CONFIG_T   LoScnpGroup;
}__attribute__ ((packed))  HW_3P_SNCP_CONFIG_T;



 
typedef struct 
{    
    UINT32[TTT]                ulSncpId;													 
    SNCP_GROUP_TYPE_T     GroupType;                          
    UINT8                 ucWorkTpNum;                        
    UINT32                ulTpType;                           
    SNCP_CHANNEL_T  	  Tp[1  + 1][3 ];   
    SNCP_CHANNEL_T        destOrSrcTp[1 +1];   
    UINT8                 ucSncpIntrusive;                    
    UINT8                 ucSncpRestoreMode;                  
    UINT16                usHoldOffTime;                      
    UINT16                usSncpWTR;   
	
 
    UINT8                 ucSncpSignalDircetion;              
}__attribute__ ((packed))  HW_SNCP_CONFIG_T;
typedef struct 
{    
    UINT32[TTT]                      ulSncpId;                                                    
    SNCP_GROUP_TYPE_T     GroupType;                          
    UINT8                       ucWorkTpNum;                        
    UINT32                      ulTpType;                           
    SNCP_CHANNEL_T          Tp[1  + 1][3 ];   
    SNCP_CHANNEL_T          destOrSrcTp[1 +1];   
    UINT8                       ucSncpIntrusive;                    
    UINT8                       ucSncpRestoreMode;                  
    UINT16                      usHoldOffTime;                      
    UINT16                      usSncpWTR;   
    
 
    UINT8                       ucSncpSignalDircetion;              

    UINT8                   ucSncpFrom;                           
    BOOL                    SncpNeedReportGMPL;           
}__attribute__ ((packed))  HW_SNCP_GMPL_CONFIG_T;  
 
typedef struct 
{
    UINT32[TTT]     ulSncpId;
    UINT8      ucTpSignalState[1  + 1][3 ];         
    UINT8      ucTpTransfer[1  + 1];               
    UINT8      ucChannelState;                    
    
    UINT16     usTimerStart;                       
    UINT32     ulTimerNum;
        
    UINT8      ucSncpExternalCmd;                            
    UINT8      ucSncpExtCmdResult;                           
    UINT8      ucSncpCurSwitchReq;                           
    UINT8      ucSncpSwitchReason;                           
}__attribute__ ((packed))  HW_SNCP_STATE_T;

 
typedef struct
{
    UINT32[TTT]                      ulSncpGroupId;
    SNCP_CHANNEL_T              Tp;    
    SNCP_TP_TYPE_T              TpId;
    BOOL                        bEnable;
    SNCP_INTRUSIVE_T            Intrusive;
}__attribute__ ((packed))  SW_SNCP_TP_ENABLE_STR_T;

 
typedef struct
{
    UINT16[TTT]               slot;
    UINT16               portType;
    UINT16               port;
    TP_INDEX_T           Tp;
    UINT32               SncpIndex;
    SNCP_TP_TYPE_T       WorkTpId;
    SNCP_SIGNAL_STATE_T  bSet;
}__attribute__ ((packed))  SW_SNCP_STATE_REPORT_T;

 

 
typedef void (*SPA_DrvIntHappenFunc[TTT])(UINT32 type);

 
typedef PB_ERROR_CODE_T[TTT] (*SPA_SncpDprFunc)(INSTANCE_T inst, UINT32* pulReportNum, SW_SNCP_STATE_REPORT_T** ppsReportData);
typedef PB_ERROR_CODE_T[TTT] (*SPA_SncpPollFunc)(INSTANCE_T inst, UINT32* pulReportNum, SW_SNCP_STATE_REPORT_T** ppsReportData);

 
typedef void (*SPA_BoardStateChangeFunc[TTT])(BOARD_EVENT_T ulEvent, SLOT_NUMBER_T usSlotNum, BOARD_STYLE_T ulCardType);

 
 
typedef PB_ERROR_CODE_T[TTT] (*SPA_SetProtModeFunc)(INSTANCE_T inst,  const SW_SNCP_TP_ENABLE_STR_T *pEnableStr);

 

 
 
typedef UINT32[TTT] (*SPA_AddHWSncpToDrvFunc)(INSTANCE_T inst,const HW_3P_SNCP_CONFIG_T *pSncpGrp);

 
typedef UINT32[TTT] (*SPA_DelHWSncpToDrvFunc)(INSTANCE_T inst, UINT32 ulSncpGrpId, UINT16 usDestBus, UINT8 ucDestVc4, UINT32 eDelMethod);

 
 
typedef UINT32[TTT] (*SPA_ExtSwitchCmdToDrvFunc)(INSTANCE_T inst, UINT32 ulSncpGrpId, UINT8 eCmdType, UINT16 usDestBus, UINT8 ucDestVc4);

 
typedef UINT32[TTT] (*SPA_SetSncpHoldOffTimeToDrvFunc)(INSTANCE_T inst, UINT32 ulSncpGrpId, UINT16 usTimeCnt, UINT16 usDestBus, UINT8 ucDestVc4);

 
typedef UINT32[TTT] (*SPA_SetSncpWtrToDrvFunc)(INSTANCE_T inst, UINT32 ulSncpGrpId, UINT16 usSncpWtr, UINT16 usDestBus, UINT8 ucDestVc4);

 
typedef UINT32[TTT] (*SPA_SetSncpIntrusiveToDrvFunc)(INSTANCE_T inst, UINT32 ulSncpGrpId, SNCP_INTRUSIVE_T eNIMode, UINT16 usDestBus, UINT8 ucDestVc4);

 
typedef UINT32[TTT] (*SPA_SetSncpRvtModeFunc)(INSTANCE_T inst, UINT32 ulSncpGrpId, UINT8 eRvtMode, UINT16 usDestBus, UINT8 ucDestVc4);

 
typedef UINT32[TTT] (*SPA_ConfigSncpEndFunc)(void);

 
 
typedef UINT32[TTT] (*SPA_ReportSncpStateFunc)(const HW_SNCP_STATE_T *pSncpGrpState);  


 
typedef PB_ERROR_CODE_T[TTT] (*SPA_SetHapsModeFunc)(INSTANCE_T inst, UINT32 ulPortType,UINT32 ulPort, TP_INDEX_T tpIndex, SNCP_INTRUSIVE_T  eNIMode, BOOL bEnable);
typedef UINT32[TTT] (*SPA_GetProtStatFromDrvFunc)(void);
 
 

 
extern void SPA_RegSetProtMode(SPA_SetProtModeFunc pFunc); 

 
extern void SPA_RegAddHWSncpToDrv(SPA_AddHWSncpToDrvFunc pFunc);
extern void SPA_RegDelHWSncpToDrv(SPA_DelHWSncpToDrvFunc pFunc);

 
extern void SPA_RegSetExCmdToDrv(SPA_ExtSwitchCmdToDrvFunc pFunc);
extern void SPA_RegSetHoldoffTimeToDrv(SPA_SetSncpHoldOffTimeToDrvFunc pFunc);
extern void SPA_RegSetWtrToDrv(SPA_SetSncpWtrToDrvFunc pFunc);
extern void SPA_RegSetIntrusiveToDrv(SPA_SetSncpIntrusiveToDrvFunc pFunc);
extern void SPA_RegSetRvtToDrv(SPA_SetSncpRvtModeFunc pFunc);

 
extern void SPA_RegConfigHWEnd(SPA_ConfigSncpEndFunc pFunc);

 
extern void SPA_RegSncpDpr(SPA_SncpDprFunc pFunc);

 
extern void SPA_RegSncpPoll(SPA_SncpPollFunc pFunc);

 
 
extern void SPA_RegSetHapsMode(SPA_SetHapsModeFunc pFunc); 
extern void SPA_RegGetProtStatFromDrv(SPA_GetProtStatFromDrvFunc pFunc);

typedef void (*SPC_BoardStateChangeFunc[TTT])(BOARD_EVENT_T ulEvent, SLOT_NUMBER_T usSlotNum, BOARD_STYLE_T ulCardType);

 
typedef PB_ERROR_CODE_T[TTT] (*SPA_SetForcRrptAlmFunc)(INSTANCE_T inst);
extern void SPA_RegSetForceRrptAlm(SPA_SetForcRrptAlmFunc pFunc);

 
typedef int (*SPA_RegGetPhyDestSncpFunc[TTT])(void *pTP, UINT32 ulTpNum);
extern void SPA_RegGetPhyDestSncp(SPA_RegGetPhyDestSncpFunc pFunc);

 
 
typedef PB_ERROR_CODE_T[TTT] (*SPA_SetLoSncpHoldOffTimeCommonValueToDrvFunc)(INSTANCE_T inst, UINT32 ulTimer1, UINT32 ulTimer2, UINT32 ulTimer3);
 
 
typedef PB_ERROR_CODE_T[TTT] (*SPA_SetLoSncpWtrCommoneValueToDrvFunc)(INSTANCE_T inst, UINT32 ulTimer1, UINT32 ulTimer2, UINT32 ulTimer3);
  
 
extern void SPA_RegSetLoSncpHoldOffTimeCommonValueToDrv (SPA_SetLoSncpHoldOffTimeCommonValueToDrvFunc pFunc);
extern void SPA_RegSetLoSncpWtrCommoneValueToDrv (SPA_SetLoSncpWtrCommoneValueToDrvFunc pFunc);
 
 
 
typedef int (*funcCCSetSncpGroupAdd[TTT])(INSTANCE_T inst, HW_3P_SNCP_CONFIG_T *psSncpGrp);

typedef int (*funcCCSetSncpExtCmd[TTT])(INSTANCE_T inst, UINT32 ulSncpGrpId, UINT32 eCmdType, UINT16 usDestBus, UINT8 ucDestVc4);

typedef int (*funcCCSetSncpHoldOffTime[TTT])(INSTANCE_T inst, UINT32 ulSncpGrpId, UINT16 usTimeCnt, UINT16 usDestBus, UINT8 ucDestVc4) ;

typedef int (*funcCCSetSncpWtr[TTT])(INSTANCE_T inst, UINT32 ulSncpGrpId, UINT16 usSncpWtr, UINT16 usDestBus, UINT8 ucDestVc4) ;
typedef int (*funcCCSetSncpNIMode[TTT])(INSTANCE_T inst, UINT32 ulSncpGrpId, SNCP_INTRUSIVE_T eNIMode, UINT16 usDestBus, UINT8 ucDestVc4) ;

typedef int (*funcCCSetSncpRvtMode[TTT])(INSTANCE_T inst, UINT32 ulSncpGrpId, UINT32 eRvtMode, UINT16 usDestBus, UINT8 ucDestVc4) ;
typedef int (*funcCCSetSncpDelete[TTT])(INSTANCE_T inst, UINT32 ulSncpGrpId, UINT16 usDestBus, UINT8 ucDestVc4, UINT32 eDelMethod) ;
typedef int (*funcCCSetHoSwitch[TTT])(INSTANCE_T inst, UINT16 fromBus, UINT8 fromVc4, UINT16 toBus, UINT8 toVc4, BOOL bSwitch);
 
typedef int (*funcCCReplaceLoSncpW[TTT])(INSTANCE_T inst,UINT16 SncpGroupId, LO_MATRIX_ITEM_T srcXcPoint,BOOL bWork);
typedef int  (*funcCCSetLoSncpGlobalWtr[TTT])(INSTANCE_T inst, UINT32 ulWtrTimer1, UINT32 ulWtrTimer2, UINT32 ulWtrTimer3);
typedef int (*funcCCSetLoSncpGloablHoldoff[TTT])(INSTANCE_T inst, UINT32 ulTimer1, UINT32 ulTimer2, UINT32 ulTimer3);













 




























typedef struct 
{
    command_tt[TTT] head;
    int state;
} PRAApplInitState_t;

typedef struct
{
    PbSlotNumberType_Tval[TTT] SlotNo;          
    UINT32 PortNo;              
    PbPortType_Tval            PortType;            


    TruthValue_Tval             PRBSEnable;        
    pbPRBSPattern_Tval       PRBSPattern;
    UINT32                          PRBSErrorBlocks;
    UINT32                          PRBSErrorSeconds;
    pbPRBSStatus_Tval         PRBSStatus;
    PbActualPortType_Tval        PRBSActualPortType;

    prbsMode_Tval   PRBSMode;
}PRA_PORTINFO_T;


 
PB_ERROR_CODE_T PRA_SetPortStatus (UINT8 slotNo,
    UINT8 port,
    UINT8 portType,
    pbPRBSStatus_Tval syncStatus);

typedef PB_ERROR_CODE_T[TTT] (*PRA_SetPortStatus_Func)
    (UINT8 slotNo,
    UINT8 port,
    UINT8 portType,
    pbPRBSStatus_Tval syncStatus);

 
typedef PB_ERROR_CODE_T[TTT] (*PRA_GetPortInfo_Func) 
    (INSTANCE_T inst, 
    UINT32 ulSlot, 
    HW_PORT_TYPE ePortType, 
    UINT32 ulPort, 
    UINT32 *pulPrbsCnt);

 
typedef PB_ERROR_CODE_T[TTT] (*PRA_SetPortInfo_Func) 
    (INSTANCE_T inst, 
    UINT32 ulSlot, 
    HW_PORT_TYPE ePortType, 
    UINT32 ulPort, 
    pbPRBSPattern_Tval ePrbsMode, 
    BOOL bEnable);

void PRA_PollData(UINT32 counter);
void PRA_RegGetPortInfo(PRA_GetPortInfo_Func pFunc);
void PRA_RegSetPortInfo(PRA_SetPortInfo_Func pFunc);




 











































 
typedef PB_ERROR_CODE_T[TTT] (*GFA_CfgAlm2DrvFunc)(INSTANCE_T inst, BOOL bEnable);
extern void GFA_RegSetAlmCfg(GFA_CfgAlm2DrvFunc pFunc);

 

 
 
typedef PB_ERROR_CODE_T[TTT] (*GFA_RprtAlarmDetect2GmplsFunc)(        UINT32          ulSlot,         HW_PORT_TYPE    tPortType,        HW_PORT_TYPE    tCurPortType,        UINT32          ulPort,        SDH_TP_TYPE     tpType,        COMPACT_TP_T    tpIndex,        UINT32          ulDefectId,        FMA_ALM_STATE   eState    );

 
extern PB_ERROR_CODE_T GFA_AlarmDetect(
        UINT32          ulSlot, 
        HW_PORT_TYPE    ePortType,
        HW_PORT_TYPE    eCurPortType,
        UINT32          ulPort,
        SDH_TP_TYPE     tpType,
        COMPACT_TP_T    tpIndex,
        UINT32          ulDefectId,
        FMA_ALM_STATE   eState);

 
extern void GFM_BoardStateChange(BOARD_EVENT_T ulEvent, SLOT_NUMBER_T usSlotNum, BOARD_STYLE_T ulCardType);












 
































 
typedef unsigned char       BYTE[TTT];

typedef unsigned short      WORD[TTT];
typedef unsigned int        DWORD[TTT];


 



















 




 






 







 










 


typedef enum 
{
     
    CTD_MODE_STM1[TTT]       = 0x0,
    CTD_MODE_STM1E      = 0x1,
    CTD_MODE_STM4       = 0x2,
    CTD_MODE_STM16      = 0x3,
    CTD_MODE_STM64      = 0x4,
    CTD_MODE_STM256     = 0x5,

     
    CTD_MODE_E1         = 0x6,
    CTD_MODE_DS1        = 0x7,
    CTD_MODE_E3         = 0x8,
    CTD_MODE_DS3        = 0x9,

     
    CTD_MODE_OTU2       = 0xa,
}CTD_MODE_TYPE_T;

 
typedef enum 
{
    CTD_FEC_MODE_RS[TTT]     = 0x0,
    CTD_FEC_MODE_UFEC   = 0x1,
}CTD_FEC_MODE_TYPE_T;

 
typedef struct
{
    BOOL[TTT] los;
    BOOL lof;
    BOOL oof;
    BOOL tim;
}CTD_RS_ALARM_T;

 
typedef struct
{
    BOOL[TTT] ais;
    BOOL exc;
    BOOL deg;
    BOOL rdi;
}CTD_MS_ALARM_T;

 
typedef struct
{
    BOOL[TTT] ais;
    BOOL lop;
}CTD_AU_ALARM_T;

 
typedef struct
{
    BOOL[TTT] tim;
    BOOL plm;
    BOOL uneq;
    BOOL exc;
    BOOL deg;
    BOOL rdi;
    BOOL lom;
    BOOL ais;
}CTD_HP_ALARM_T;

 
typedef struct
{
    BOOL[TTT] ais;
    BOOL lop;
}CTD_TU_ALARM_T;

 
typedef struct
{
    BOOL[TTT] tim;
    BOOL plm;
    BOOL uneq;
    BOOL exc;
    BOOL deg;
    BOOL rdi;
    BOOL rfi;
}CTD_LP_ALARM_T;

 
typedef struct
{
    BOOL[TTT] los;
    BOOL ais;
    BOOL lof;
    BOOL lom;
    BOOL rdi;
}CTD_PPI_ALARM_T;

 
typedef struct
{
    BOOL[TTT] mcd;
    BOOL fcd;
    BOOL fma;
    BOOL osr;
    BOOL tcu;
}CTD_EQ_ALARM_T;

 
typedef struct
{
    BOOL[TTT] los;
    BOOL ldf;
    BOOL oof;
    BOOL wca;
    BOOL cim;
}CTD_TR_ALARM_T;

 
typedef struct
{
    BOOL[TTT] lfa;
    BOOL lma;
    BOOL tim;
    BOOL iae;
    BOOL bdi;
    BOOL ptm;
}CTD_OTU_ALARM_T;

 
typedef struct
{
    BOOL[TTT] los;
    BOOL mfo;
    BOOL dfo;
}CTD_E1_ALARM_T;


 
typedef struct
{
    BOOL[TTT] lof;
    BOOL tim;
    BOOL ais;
    BOOL exc;
    BOOL deg;
    BOOL rdi;
}CTD_MSP_ALARM_INT_T;

 
typedef struct
{
    BOOL[TTT] lof;
    BOOL tim;
    BOOL ais;
    BOOL exc;
    BOOL deg;
    BOOL rdi;
}CTD_MSP_ALARM_DELTA_T;

 
typedef struct
{
    BOOL[TTT] lof;
    BOOL tim;
    BOOL ais;
    BOOL exc;
    BOOL deg;
    BOOL rdi;
}CTD_MSP_ALARM_STATE_T;

 
typedef struct
{
    BOOL[TTT] ais;
    BOOL lop;
    BOOL uneq;
    BOOL tim;
    BOOL vcais;
    BOOL exc;
    BOOL deg;
}CTD_SNCP_ALARM_INT_T;

 
typedef struct
{
    BOOL[TTT] ais;
    BOOL lop;
    BOOL uneq;
    BOOL tim;
    BOOL vcais;
    BOOL exc;
    BOOL deg;
}CTD_SNCP_ALARM_DELTA_T;

 
typedef struct
{
    BOOL[TTT] ais;
    BOOL lop;
    BOOL uneq;
    BOOL tim;
    BOOL vcais;
    BOOL exc;
    BOOL deg;
}CTD_SNCP_ALARM_STATE_T;

 
typedef enum
{
    CTD_INSERT_ALM_TYPE_MSAIS[TTT]       =   0x0,
    CTD_INSERT_ALM_TYPE_AUAIS       =   0x1,
    CTD_INSERT_ALM_TYPE_TUAIS       =   0x2,
    CTD_INSERT_ALM_TYPE_AIS         =   0x3,
    CTD_INSERT_ALM_TYPE_UNEQ        =   0x4, 
    CTD_INSERT_ALM_TYPE_RDI         =   0x5,
}CTD_INSERT_ALM_TYPE_T;

 
typedef enum
{
    CTD_INSERT_ALM_IN_LASER[TTT]         =   0x0,
    CTD_INSERT_ALM_OUT_LASER        =   0x1,
}CTD_INSERT_ALM_DIR_T;

 
typedef enum
{
    CTD_LOOPBACK_TYPE_NONE[TTT]              =   0x0,
    CTD_LOOPBACK_TYPE_OUTWARD_NEAR      =   0x1,
    CTD_LOOPBACK_TYPE_INWARD_FAR        =   0x2,
    CTD_LOOPBACK_TYPE_INWARD_NEAR       =   0x3,
    CTD_LOOPBACK_TYPE_OUTWARD_FAR       =   0x4, 
    CTD_LOOPBACK_TYPE_OUTWARD_TSI       =   0x5,
}CTD_LOOPBACK_TYPE_T;

 
typedef struct 
{
     
    WORD[TTT]                busNum;

    BYTE                portNum;
    WORD                augNum;
    CARDTYPE_T          type;    
}CTD_CARD_CONFIG_T;

 
typedef struct 
{
    BYTE[TTT]  byPort;
    BOOL  bEnable;
}CTD_TIMING_CONFIG_T;

 
typedef PB_ERROR_CODE_T[TTT] (*CPS_GetLatchState)(SLOT_NUMBER_T slot, LATCH_STATE_T eLatchState);
 
typedef PB_ERROR_CODE_T[TTT] (*CAD_RprtUnitFail)(SLOT_NUMBER_T slot, BOOL bUnitFail);
    
 
typedef struct
{
     
    TMA_S1ChangeCallbackFunc[TTT]        cRprtSsmToTMA;
    TMA_ModDefectFunc               cRprtDefectToTMA;
     
    FMA_AlmModDefectFunc            cRprtDefectToFMA;
    FMA_AlmModDefectByBusFunc       cRptDefectToFmaByBus;
     
    PMP_GetRsOofFunc                cRprtRsOofToPMA; 
     
    CPS_GetLatchState               cRprtLatchStateToCPA;
     
    CPS_GetLatchState               cRprtLatchStateToCAI;
     
    PRA_SetPortStatus_Func          cRprtPrbsStateToPRA;  
     
    MPA_Handle_RcvKbyte             cRprtMspKByte;
    MPA_RcvPhyDefect                cRprtMspLineCond;
    MPA_RprtMspStatus               cRprtMspStatus;
     
    MST_ChangeOfKb                  cRprtMsspKByte;
    MST_ChangeOfLineCond            cRprtMsspLineCond;
     
    MSA_ChangeKbyteBatch            cRprtMsspKByteBatch;
    MSA_ChangeLineCondBatch         cRprtMsspLineCondBatch;
     
    SPA_DrvIntHappenFunc            cRprtSpaDrvIntHappen; 
    SPA_ReportSncpStateFunc         cRprtSpaSncpState;
     
    TMH_InitCCFPGAFunc              cRprtCcInitToTmh;
    TMH_SwitchHOCCFunc              cRptCcStateToTmh;
     
    GFA_RprtAlarmDetect2GmplsFunc   cRprtDefectToGmpls;
     
    CAD_RprtUnitFail                cRprtUnitFailToCAD;
}CTD_CALLBACKS_T;

 
typedef enum
{
    CTD_MSG_TYPE_INT[TTT]        = 0x0,
    CTD_MSG_TYPE_POLLING    = 0x1,
    CTD_MSG_TYPE_1HZINT     = 0x2,
    CTD_MSG_TYPE_LATCH      = 0x3,
}CTD_MSG_TYPE_T;

 
typedef struct
{
    ENTITY_T[TTT]            etEntity;
    DWORD               dwPos;
    CTD_MSG_TYPE_T      eMsgType;
}CTD_MSG_DATA_T;

 
typedef enum
{
    CTD_SNCP_SIG_DIR_UNKNOWN[TTT]    = 0x0,
    CTD_SNCP_SIG_DIR_SOURCE     = 0x1,
    CTD_SNCP_SIG_DIR_SINK       = 0x2,
    CTD_SNCP_SIG_DIR_BIDRECTION = 0x3,
}CTD_SNCP_SIG_DIR_T;

 
typedef enum
{
    CTD_SNCP_CMD_UNKNOWN[TTT]        = 0x0,
    CTD_SNCP_CMD_CLEAR          = 0x1,
    CTD_SNCP_LOCK_OUT           = 0x2,
    CTD_SNCP_FORCE_SWITCH_TOP   = 0x3,
    CTD_SNCP_FORCE_SWITCH_TOW   = 0x4,
    CTD_SNCP_MANUAL_SWITCH_TOP  = 0x5,
    CTD_SNCP_MANUAL_SWITCH_TOW  = 0x6,
    CTD_SNCP_NO_COMMAND         = 0x7,
}CTD_SNCP_CMD_TYPE_T; 

 
typedef enum 
{
    CTD_SNCP_MODE_UNKNOWN[TTT]       = 0x0,
    CTD_SNCP_MODE_REVERTIVE     = 0x1,
    CTD_SNCP_MODE_NONREVERTIVE  = 0x2,
} CTD_SNCP_MODE_T;

 
typedef enum 
{
    CTD_SNCP_REQ_CLEAR[TTT]              = 0x1,
    CTD_SNCP_REQ_LOCKOUT            = 0x2,
    CTD_SNCP_REQ_FORCE_SWITCH_TOP   = 0x3,
    CTD_SNCP_REQ_FORCE_SWITCH_TOW   = 0x4,
    CTD_SNCP_REQ_SIGNAL_FAIL        = 0x5,
    CTD_SNCP_REQ_MANUAL_SWITCH_TOP  = 0x6,
    CTD_SNCP_REQ_MANUAL_SWITCH_TOW  = 0x7,
    CTD_SNCP_REQ_WAIT_TO_RESTORE    = 0x8,
    CTD_SNCP_REQ_NO_REQUEST         = 0x9,
    CTD_SNCP_REQ_SIGNAL_DEG         = 0xa,
} CTD_SNCP_REQ_TYPE_T;

 
typedef enum 
{
    CTD_SNCP_CMD_RSLT_SUCC[TTT]              = 0x1,
    CTD_SNCP_CMD_RSLT_LOWPRIORITY       = 0x2,
    CTD_SNCP_CMD_RSLT_SWITCH_TO_ACTIVE  = 0x3,
    CTD_SNCP_CMD_SWITCH_FAIL            = 0x4,
    CTD_SNCP_CMD_SWITCH_TIMEOUT         = 0x5,
    CTD_SNCP_CMD_WAIT_CC_RSP            = 0x6,
    CTD_SNCP_BAD_COMMAND                = 0x7,
} CTD_SNCP_CMD_RSLT_T;

 
typedef enum 
{
    CTD_SNCP_STATE_ACTIVE[TTT]  = 0x1,
    CTD_SNCP_STATE_STANDBY = 0x2,
} CTD_SNCP_CHL_STATE_T;

 
typedef enum 
{
    CTD_SNCP_RSN_CLEAR_CMD[TTT]         = 0x1,
    CTD_SNCP_RSN_LP_CMD            = 0x2,
    CTD_SNCP_RSN_FORCED_SWITCH     = 0x3,
    CTD_SNCP_RSN_MANUAL_SWITCH     = 0x4,
    CTD_SNCP_RSN_SIGNAL_FAIL       = 0x5,
    CTD_SNCP_RSN_SIGNAL_FAIL_CLEAR = 0x6,
    CTD_SNCP_RSN_NO_SWITCH         = 0x7,
    CTD_SNCP_RSN_SIGNAL_DEG        = 0x8,
    CTD_SNCP_RSN_SIGNAL_DEG_CLEAR  = 0x9,
} CTD_SNCP_SWITCH_RSN_T;

 
typedef struct
{
     
    BOOL[TTT]                bResult;
     
    SNCP_SIGNAL_STATE_T eWorkState;
    SNCP_SIGNAL_STATE_T eProtState;
     
    CTD_SNCP_REQ_TYPE_T eCmdReq;
}CTD_SNCP_STATE_T;




 




 

 


 

 

 

 

 

 


 


 

 


typedef enum
{
    CAH_DEBUG_LEVEL_ERROR[TTT]       =   0,
    CAH_DEBUG_LEVEL_CFGSET      =   1,
    CAH_DEBUG_LEVEL_CFGGET      =   2,
    CAH_DEBUG_LEVEL_INIT        =   3,
    CAH_DEBUG_LEVEL_INT         =   4,
    CAH_DEBUG_LEVEL_OP          =   5,
    CAH_DEBUG_LEVEL_PMON        =   6,
    CAH_DEBUG_LEVEL_CLOCK       =   7,
    CAH_DEBUG_LEVEL_SNCP        =   8,
    CAH_DEBUG_LEVEL_MSP         =   9,
    CAH_DEBUG_LEVEL_MSSP        =   10,
    CAH_DEBUG_LEVEL_ALARM       =   11
}CAH_DBG_LEVEL_T;





 





 





 
typedef enum
{
    CAH_REG_ATTRBT_RW[TTT]       =   0x0,
    CAH_REG_ATTRBT_RO       =   0x1,
    CAH_REG_ATTRBT_WO       =   0x2,
    CAH_REG_ATTRBT_RC       =   0x3,
    CAH_REG_ATTRBT_WC       =   0x4,
}CAH_REG_ATTRBT_T;

 
typedef struct
{
    DWORD[TTT]             dwBaseOffset;
    BYTE              bySimRegNum;
    DWORD             dwSimRegInterval;
    WORD              wValue;
    WORD              wMask;
    CAH_REG_ATTRBT_T  eRegAttrbt;
    WORD              wDelayTime;
}CAH_INIT_TABLE_T;

 
typedef struct
{
    DWORD[TTT]     dwBaseOffset;
    BYTE      bySimRegNum;
    DWORD     dwSimRegInterval;
    WORD      wValue;
    WORD      wMask;
}CAH_STATE_CHECK_TABLE_T;

 
typedef struct
{
    DWORD[TTT]  dwPeriodMsSet;
    DWORD  dwPeriodMsClear;
    WORD   wThreshSet;
    WORD   wThreshClear;
}CAH_B2_THRESHOLD_T;

 
typedef struct
{
    ENTITY_T[TTT]             dwEntityNo;
    DWORD                dwBaseAddr;
    CTD_MODE_TYPE_T      ePortType[0x7e ];
}CAH_CFG_INFO_T;

 
extern  WORD cah_WriteRegister(DWORD dwBaseAddr, DWORD dwOffset, WORD wValue, WORD wMask, CAH_REG_ATTRBT_T eRegAttrbt);
extern  WORD cah_ReadRegister(DWORD dwBaseAddr, DWORD dwOffset, WORD* pwValue, WORD wMask, CAH_REG_ATTRBT_T eRegAttrbt);
extern  WORD cah_PollBusyBit(DWORD dwBaseAddr, DWORD dwOffset);
extern  WORD cah_IndWrite(DWORD dwBaseAddr, DWORD dwAddrIndAddr, DWORD dwAddrIndData, WORD wAddr, WORD wValue, WORD wMaskval, WORD wMaskaddr);
extern  WORD cah_IndRead(DWORD dwBaseAddr, DWORD dwAddrIndAddr, DWORD dwAddrIndData, WORD wAddr, WORD *pwValue, WORD wMaskval, WORD wMaskaddr);
extern  WORD cah_IndWriteQuick(DWORD dwBaseAddr, DWORD dwAddrIndAddr, DWORD dwAddrIndData, WORD wAddr, WORD wValue, WORD wMaskval, WORD wMaskaddr);
extern  WORD cah_IndReadQuick(DWORD dwBaseAddr, DWORD dwAddrIndAddr, DWORD dwAddrIndData, WORD wAddr, WORD *pwValue, WORD wMaskval, WORD wMaskaddr);
extern  WORD cah_Write8Reg(DWORD dwBaseAddr, DWORD dwOffset, BYTE byValue, BYTE byMask, CAH_REG_ATTRBT_T eRegAttrbt);
extern  WORD cah_Read8Reg(DWORD dwBaseAddr, DWORD dwOffset, BYTE *pbyValue, BYTE byMask, CAH_REG_ATTRBT_T eRegAttrbt);
extern  WORD cah_Write32Reg(DWORD dwBaseAddr, DWORD dwOffset, DWORD dwValue, DWORD dwMask, CAH_REG_ATTRBT_T eRegAttrbt);
extern  WORD cah_Read32Reg(DWORD dwBaseAddr, DWORD dwOffset, DWORD *pdwValue, DWORD dwMask, CAH_REG_ATTRBT_T eRegAttrbt);
extern  WORD cah_Stm4TpConvert(CTD_MODE_TYPE_T ePortType, COMPACT_TP_T tpId, BYTE *byAug1No, BYTE *byAu3No);
extern  WORD cah_Stm16TpConvert(CTD_MODE_TYPE_T ePortType, COMPACT_TP_T tpId, BYTE *byAug4No, BYTE *byAug1No, BYTE *byAu3No);
extern  WORD cah_Stm64TpConvert(CTD_MODE_TYPE_T ePortType, COMPACT_TP_T tpId, BYTE *byAug16No, BYTE *byAug4No, BYTE *byAug1No, BYTE *byAu3No);
extern  WORD cah_Stm256TpConvert(CTD_MODE_TYPE_T ePortType, COMPACT_TP_T tpId, BYTE *byAug64No, BYTE *byAug16No, BYTE *byAug4No, BYTE *byAug1No, BYTE *byAu3No);
extern  DWORD CAH_GetCardBaseAddr(CARDTYPE_T eCardType);

 
extern  DBG_MODULE_T       gCahDbgModuleNo;
extern  CAH_B2_THRESHOLD_T gCahStm1B2Threshold[0x9  - 0x3  + 1];
extern  CAH_B2_THRESHOLD_T gCahStm4B2Threshold[0x9  - 0x3  + 1];
extern  CAH_B2_THRESHOLD_T gCahStm16B2Threshold[0x9  - 0x3  + 1];
extern  CAH_B2_THRESHOLD_T gCahStm64B2Threshold[0x9  - 0x3  + 1];
extern  CAH_B2_THRESHOLD_T gCahStm256B2Threshold[0x9  - 0x3  + 1];

 
extern  int sysClkRateGet(void);
extern  STATUS taskDelay(int ticks);
extern  UINT32 sysTimestampFreq(void);




 






















 





















 
 

 

 

 


























 

 

 
















union sigval
    {
    int			sival_int;
    void		*sival_ptr;
    };

struct sigevent
    {
    int			sigev_signo;
    union sigval	sigev_value;
    int			sigev_notify;
    };













typedef struct __timer[TTT] *timer_t ;




typedef unsigned int clock_t[TTT] ;








typedef int clockid_t[TTT];





struct tm
	{
	int tm_sec;	 
	int tm_min;	 
	int tm_hour;	 
	int tm_mday;	 
	int tm_mon;	 
	int tm_year;	 
	int tm_wday;	 
	int tm_yday;	 
	int tm_isdst;	 
	};

struct timespec
    {
    					 
    time_t tv_sec;			 
    long tv_nsec;			 
    };

struct itimerspec
    {
    struct timespec it_interval;	 
    struct timespec it_value;		 
    };






 



extern uint_t      _clocks_per_sec(void);
extern char *	   asctime (const struct tm *_tptr);
extern clock_t	   clock (void);
extern char *	   ctime (const time_t *_cal);
extern double	   difftime (time_t _t1, time_t _t0);
extern struct tm * gmtime (const time_t *_tod);
extern struct tm * localtime (const time_t *_tod);
extern time_t	   mktime (struct tm *_tptr);
extern size_t	   strftime (char *_s, size_t _n, const char *_format,
		   	      const struct tm *_tptr);
extern time_t	   time (time_t *_tod);

extern int 	clock_gettime (clockid_t clock_id, struct timespec *tp);
extern int 	clock_settime (clockid_t clock_id, const struct timespec *tp);
extern int 	clock_getres (clockid_t clock_id, struct timespec *res);

extern int 	timer_create (clockid_t clock_id, struct sigevent *evp,
			      timer_t *ptimer);
extern int 	timer_delete (timer_t timerid);
extern int 	timer_gettime (timer_t timerid, struct itimerspec *value);
extern int 	timer_settime (timer_t timerid, int flags,
		               const struct itimerspec *value,
			       struct itimerspec *ovalue);
extern int 	timer_getoverrun (timer_t timerid);

extern int      timer_connect (timer_t timerid, VOIDFUNCPTR routine, int arg);
extern int      timer_cancel (timer_t timerid);
extern int      timer_show (timer_t timerid);

extern int 	nanosleep (const struct timespec *rqtp, struct timespec *rmtp);




extern int	   asctime_r(const struct tm *_tm, char *_buffer,
			     size_t *_buflen);
extern char *	   ctime_r (const time_t *_cal, char *_buffer, size_t *_buflen);
extern int	   gmtime_r (const time_t *_tod, struct tm *_result);
extern int	   localtime_r (const time_t *_tod, struct tm *_result);





























 














 





 




































 






 









 







 









 



 









                                

























 














































 















































 

















































































                                    






































































































































 


extern int i2c_debug;





	
 







typedef struct {
    int addr[TTT];
	int maxChannelNum;
} I2C_MUX_ADDR_TBL_T;



typedef enum {
	I2C_ACCESS_OK[TTT]    = 0,
	I2C_BUS_ERROR    = 0x1000,      
	I2C_BUS_TIMEOUT  = 0x2000,    
	I2C_ERROR_UNKNOWN= 0x4000
} I2C_ERROR_TYPE;     

typedef struct {
    int          valid[TTT];        
	int          taskId;       
	const char * pTaskName;    
    const char * pCaller;      
    const char * pCallerFile; 
    int          callerLine;  
    int          muxAddr;      
    int          channel;      
} I2C_BUS_CHANNEL_STATUS;

typedef struct {
    int               valid[TTT];              
    int               taskId;             
    const char *      pTaskName;          
    int               devAddr;            
    const char *      pCaller;            
    const char *      pCallerFile;        
    int               callerLine;         
    struct tm        currTime;           
    I2C_ERROR_TYPE    reason;             
	                                       
	                                       
										  
    int               times;              
} I2C_BUS_ERR_RECORD;  

typedef struct {
    int               isSemInUse[TTT];          
    SEM_ID            selfID;              
    int               taskId;              
    const char *      pTaskName;           
    const char *      pSemOwner;           
    const char *      pSemOwnerFile;      
    int               semOwnerLine;       
    int               semForMuxAddr;      
    int               semTimeOut;          
    int               semCounter;          
} I2C_SEM_RECORD;        





typedef struct {
    int          valid[TTT];            
	int          taskId;           
	const char * pTaskName;       
} I2C_SEM_OVERTIME_RECORD_ITEM;   

typedef struct {
	int          nextItem[TTT];           
	I2C_SEM_OVERTIME_RECORD_ITEM item[10 ];    
} I2C_SEM_OVERTIME_RECORD;   



typedef enum {
	I2C_RAW[TTT],
	I2C_RAW_BASE,
	I2C_BASE,
} I2C_OPTION;        

typedef struct {
    void *tlvDataPtr[TTT];
    char deviceName[32];
} TLV_data_t;


















	



 









        
 
 







       
 






















 
int i2cDrvSemTake(const char*pCaller, const char* pCallerFile, 
        const int callerLine, int muxAddr, int wait);
int i2cDrvSemGive(void);

int tlvDrvSemTake(const char*pCaller, const char* pCallerFile, 
        const int callerLine, int wait);
int tlvDrvSemGive(void);

int i2cGeneralRead(const char* pCaller, const char* pCallerFile,
        int callerLine, int fd, int offset, int address, char *buffer, int numbytes, int *status, I2C_OPTION option);

int i2cGeneralWrite(const char* pCaller, const char* pCallerFile,
        int callerLine, int fd, int offset, int address, char *buffer, int numbytes, int *status, I2C_OPTION option);

void i2cBusChannelStatusClear(void);
void i2cBusChannelStatusSet(const char* pCaller, const char* pCallerFile, int callerLine, 
	int muxAddr, int channel);

void i2cTrace(int level, char* mname, int line, char*fname, char* fmt, ...);

void i2cCloseDrv(int value);  

int i2cCreate(char *name);
int i2cDrv(void);
void i2cFDClose(int fd);






 















 















































 


 





 


 



 


 














 
 


 






 


































































 


























extern UINT32 CRC32(UINT32 LastBufCRC,const UINT8 * pBuf,UINT32 BufLength);


 


 

typedef enum
{
    FM_DEFECT_BIT_TYPE_UNKNOW[TTT]       = 0,
        
    FM_DEFECT_BIT_TYPE_STM1_LC      = 1,
    FM_DEFECT_BIT_TYPE_STM1_PM      = 2,
    FM_DEFECT_BIT_TYPE_STM1_LOCC    = 3,
    FM_DEFECT_BIT_TYPE_STM4_LC      = 4,
    FM_DEFECT_BIT_TYPE_STM4_PM      = 5,
    FM_DEFECT_BIT_TYPE_STM4_LOCC    = 6,
    FM_DEFECT_BIT_TYPE_STM16_LC     = 7,
    FM_DEFECT_BIT_TYPE_STM16_PM     = 8,
    FM_DEFECT_BIT_TYPE_STM16_LOCC   = 9,
    FM_DEFECT_BIT_TYPE_STM64_LC     = 10,
    FM_DEFECT_BIT_TYPE_STM64_PM     = 11,
    FM_DEFECT_BIT_TYPE_STM64_LOCC   = 12,
    FM_DEFECT_BIT_TYPE_STM256_LC    = 13,
    FM_DEFECT_BIT_TYPE_STM256_PM    = 14,
    FM_DEFECT_BIT_TYPE_STM256_LOCC  = 15,
    
    FM_DEFECT_BIT_TYPE_E1           = 16,
    FM_DEFECT_BIT_TYPE_E1_PM        = 17,
    FM_DEFECT_BIT_TYPE_E3DS3        = 18,
    FM_DEFECT_BIT_TYPE_E3DS3_PM     = 19,
    
    FM_DEFECT_BIT_TYPE_LAN          = 20,
    FM_DEFECT_BIT_TYPE_VWAN         = 21,
    FM_DEFECT_BIT_TYPE_RPR          = 22,
    FM_DEFECT_BIT_TYPE_VSTM1        = 23,
    FM_DEFECT_BIT_TYPE_VSTM1_PM     = 24,
    FM_DEFECT_BIT_TYPE_VSTM4        = 25,
    FM_DEFECT_BIT_TYPE_VSTM4_PM     = 26,
    FM_DEFECT_BIT_TYPE_VSTM16       = 27,
    FM_DEFECT_BIT_TYPE_VSTM16_PM    = 28,
    FM_DEFECT_BIT_TYPE_VSTM64       = 29,
    FM_DEFECT_BIT_TYPE_VSTM64_PM    = 30,
    
    FM_DEFECT_BIT_TYPE_OA           = 31,
    
    FM_DEFECT_BIT_TYPE_SLOT         = 32,
    FM_DEFECT_BIT_TYPE_NE           = 33,

    FM_DEFECT_BIT_TYPE_OTU2         = 34
}FM_DEFECT_BIT_TYPE_T;


typedef struct 
{
    BOOL[TTT] empty;
    FM_DEFECT_BIT_TYPE_T  defectType;
    unsigned int  entity;
    unsigned int  instance;
    unsigned int  bitPos;
    unsigned int  index;
    unsigned char  state;            
} __attribute__ ((packed))  FMA_DEFECT_BIT_UNIT_T;


typedef struct
{
    unsigned int index[TTT];
    FMA_DEFECT_BIT_UNIT_T *pBitUnits;
    int number;
    void *pNext;
} __attribute__ ((packed))  FMA_SENT_BIT_MSG;

typedef struct
{
   int length[TTT];
   void *pNext;
}__attribute__ ((packed))  FMA_SENT_BIT_MSG_HEAD;

typedef struct 
{
    command_tt[TTT] head;
    unsigned int index;
    unsigned int defectBitNumber;

    unsigned int crc32;

    FMA_DEFECT_BIT_UNIT_T *pDefectTable;    
} FMA_FMC_DEFECT_BIT_REPORT_CMD_T;










 

  




typedef enum
{
    FM_GENERAL_TYPE_UNKOWN[TTT]  = 0,
    FM_GENERAL_TYPE_SDH_LC  = 1,
    FM_GENERAL_TYPE_PDH     = 2,
    FM_GENERAL_TYPE_DATA    = 3,
    FM_GENERAL_TYPE_CC      = 4,
    FM_GENERAL_TYPE_SC      = 5,
    FM_GENERAL_TYPE_OA      = 6,
} FM_GENERAL_TYPE_T;


 








typedef enum
{
    FMA_LOCATION_UNKNOW[TTT]    = 0,
    FMA_LOCATION_LC        = 1,
    FMA_LOCATION_CC        = 2,
    FMA_LOCATION_SC        = 3,
    FMA_LOCATION_SI        = 4,   
} FMA_CPU_LOCATION_T;


typedef enum
{
    FMA_START_UP_UNKNOW[TTT]            = 0,
    FMA_START_UP_AGENT_BOOT_UP     = 1,
    FMA_START_UP_SC_BOOT_UP        = 2,
} FMA_START_UP_INFO_T;

typedef struct
{
    command_tt[TTT] head;
    UINT32 slot;                   
    UINT32 cardStyle;
    UINT32 cardOption;
    FMA_START_UP_INFO_T agentInform;
    UINT8 cpuLocation;         
    UINT8 type;                     
} FMA_FMC_AGENT_START_UP_CMD_T;

 
typedef struct
{
    command_tt[TTT] head;
    UINT32 agentSlotId;
    UINT32 option;
} FMA_FMC_QUERY_ALARM_PERSISENT_TIME_CMD_T;

 
typedef struct
{
    command_tt[TTT] head;
    UINT32 slotNo;
    UINT32 portNo;
    UINT32 portType;
} FMA_FMC_LOS_STATE_CHANGE_CMD_T;

 
typedef struct
{
    command_tt[TTT] head;
    UINT32 queryId;    
} FMA_FMC_QUERY_STATE_CMD_T;

 
typedef FMA_FMC_QUERY_STATE_CMD_T[TTT] FMC_FMA_QUERY_STATE_ACK_CMD_T;


 
typedef struct
{
    command_tt[TTT] head;
     
} FMA_FMM_CUTOFF_STATE_FROM_BUTTON_CMD_T;

 
typedef struct
{
    command_tt[TTT] head;
    BOOL state;
} FMA_FMM_SUPPRESS_STATE_FROM_BUTTON_CMD_T;

 
typedef struct
{
    command_tt[TTT] head;
    UINT32 slotId;
    UINT32 portNo;
    UINT32 defectId;
    FMA_ALM_STATE state;
} PMA_FMA_LAN_DEFECT_REPORT_CMD_T;

 
typedef struct
{
	command_tt[TTT] head;
	UINT32 slotID;
}FMA_FMC_LOCC_CHANGE_CMD_T;


 
typedef struct
{
    command_tt[TTT] head;
    UINT32 slotId;
    UINT32 portNo;
    UINT32 defectId;
    FMA_ALM_STATE state;
} FMA_FMA_FAN_DEFECT_REPORT_CMD_T;





 





























typedef struct
{
    UINT32[TTT] slotNo;                
    
    INSTANCE_T instance;          
                               
    UINT32 portNo;                
                                  
    HW_PORT_TYPE portType;        
  
    SDH_TP_TYPE tpType;           

    COMPACT_TP_T tpIndex;         


    UINT32 defectId;              

    FMA_ALM_STATE state;          

    UINT8 deep;                   
    
} FM_SET_DEFECT_INFRMATION_T;

 







typedef enum
{
    FM_DEFECT_TYPE_NONE[TTT]    = 0, 
    FM_DEFECT_TYPE_LC      = 1,
    FM_DEFECT_TYPE_LOCC    = 2,
    FM_DEFECT_TYPE_DATA    = 3,
    FM_DEFECT_TYPE_PM      = 4,         
} FM_DEFECT_GROUP_TYPE_T;

extern  PB_ERROR_CODE_T FMA_SetDefectByBus_Callback(UINT16 busNo, UINT16 vc4No, TU_TP_T tpIndex, SDH_TP_TYPE tpType, UINT32 defectId, FMA_ALM_STATE state);
extern  PB_ERROR_CODE_T FMA_AddBoardEntity(UINT32 slot, UINT32 exist, UINT32 style, UINT32 option);
extern  PB_ERROR_CODE_T FMA_SetDefect_Callback(UINT32 SlotId, INSTANCE_T Instance, UINT32 PortId, HW_PORT_TYPE PortType, SDH_TP_TYPE TpType, COMPACT_TP_T TpIndex, UINT32 DefectId, FMA_ALM_STATE state);
extern void FMA_HandleButtonEvent(SDD_BUTTON_EVENT_TYPE buttonType, BUTTON_STATE_T oldState, BUTTON_STATE_T newState);
extern void FMA_TCL_CreateCommand(Tcl_Interp *interp);











 




















 
 
 
 
 
 
 
 
 
 





















 
 
 
 
 






 



 
 
 
 
 
 
 
 












 
 
 
 
 
typedef enum 
{   
    non_GMPLS[TTT]   = 0x0,
    I_NNI       = 0x1,
    E_NNI       = 0x2,
    UNI10       = 0x3,
    UNI20       = 0x4,
}PB_GMPLS_PORT_CLASSIFIER;


typedef enum 
{   
    unreserved[TTT]  = 0x0,
    migrating   = 0x1,
    reserved    = 0x2,
} PB_TP_RESERVATION;


typedef struct 
{
    UINT16[TTT]      slotNo;
    UINT16      portType;        
    							                            
    UINT16      portNo;
    TP_INDEX_T  tpIndex;         
}PB_GMPLS_TP_T;


typedef struct 
{
    UINT16[TTT]       vcgXVType;      
                                 
                                 
                                 
    UINT16       vcgLCASSupport; 
                                 
    UINT16       vcgGfpType;     
                                                                 
    char         vcgChannelId[50];   
 } PB_GMPLS_VCG_CONFIG_T;


typedef struct 
{
    PB_GMPLS_TP_T[TTT]       fromTP;
    PB_GMPLS_TP_T       toTP;
	int		GmplsVcNumber;   
	char	GmplsCallName[255];    
    PbGmplsCcDirection_Tval GmplsCcDirection; 
} PB_GMPLS_XC_T;

typedef enum 
{
	PB_GMPLS_XC_CREATION[TTT] = 0x1,
	PB_GMPLS_XC_DELETION = 0x2,
}PB_GMPLS_XC_OPERATION;

typedef enum 
{
	PB_GMPLS_XC_NORMAL_CONFIG[TTT] = 0x1,
	PB_GMPLS_XC_FAST_CONFIG = 0x2,
}PB_GMPLS_XC_CONFIG_MODE;

 typedef struct 
{
    PB_GMPLS_TP_T[TTT]       workingTP;
    PB_GMPLS_TP_T       protectingTP;
    PB_GMPLS_TP_T       srcOrDestTP;
    UINT16              direction;    
                                      
} PB_GMPLS_SNCP_T;

typedef enum 
{
	PB_GMPLS_SNCP_CREATION_OR_CC_TO_SNCP_CONVERTION[TTT] = 0x1,
	PB_GMPLS_SNCP_DELETION = 0x2,
	PB_GMPLS_SNCP_TO_CC = 0x3,
	PB_GMPLS_SNCP_EXTERNAL_SWITCHING = 0x4,
}PB_GMPLS_SNCP_OPERATION;	

typedef enum 
{
	PB_GMPLS_SNCP_WORKING_TO_CC[TTT] = 0x1,
	PB_GMPLS_SNCP_PROTECTION_TO_CC = 0x2,
}PB_GMPLS_SNCP_TO_CC_CONVERTION;	

typedef enum 
{
    PB_GMPLS_SNCP_CLEAR[TTT] = 0x1,
    PB_GMPLS_SNCP_MANUAL_TO_PROTECTING =0x2,
    PB_GMPLS_SNCP_MANUAL_TO_WORKING = 0x3,
    PB_GMPLS_SNCP_FORCED_TO_PROTECTING = 0x4,
    PB_GMPLS_SNCP_LOCKOUT = 0x5,
} PB_GMPLS_SNCP_SWITCHING_COMMAND;
	
typedef enum 
{
    PB_GMPLS_SNCP_ACTIVE[TTT] = 0x1,
    PB_GMPLS_SNCP_STANDBY = 0x2,
} PB_GMPLS_SNCP_STATUS;

 typedef struct 
{
    UINT16[TTT]      slotNo;
    UINT16      portNo;
} PB_GMPLS_MSP_PORT_T;


typedef enum 
{
    PB_GMPLS_LOF[TTT]         = 0x1,
    PB_GMPLS_TIM         = 0x2,
    PB_GMPLS_RSEXE      = 0x3,
    PB_GMPLS_RSDEG      = 0x4,
    PB_GMPLS_MSAIS      = 0x5,
    PB_GMPLS_MSEXE      = 0x6,
    PB_GMPLS_MSDEG      = 0x7,
    PB_GMPLS_MSRDI      = 0x8,
} PB_GMPLS_ALARM;

 
 
 
 
 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
PB_ERROR_CODE_T CBM_SDH_PORT_CLASSIFIER_CHANGE_CHECK(UINT16       slotNo,
                                           UINT16       portType,
                                           UINT16       portNo,
                                           PB_GMPLS_PORT_CLASSIFIER newPortClassifier);


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
PB_ERROR_CODE_T CBM_TP_RESERVATION_CHANGE_CHECK( UINT16   slotNo,
                                       UINT16   portType,
                                       UINT16   portNo,
                                       UINT16   action,
                                       UINT16   tpNum,
                                       UINT16   *tp);


 
 
 
 
 
 
gmplsLicenseStatus_Tval CBM_CheckGmplsStatus();


 
 
 
 
 
 
 
 
 
 
 
 
 
typedef struct 
{
    command_tt[TTT]    head;
    UINT16        slotNo;
    UINT16        portType;
    UINT16        realPortType;
    UINT16        portNo;
    UINT16        mapString_len;
    char          portMappingString[384];
}CMND_IFM_CBM_PORT_MAPPING_CHANGE_IND_T;


 
 
 
 
 


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
PB_ERROR_CODE_T CBM_ETH_PORT_CLASSIFIER_CHANGE_CHECK( UINT16      slotNo,
                                            UINT16      portType,
                                            UINT16      portNo,
                                            PB_GMPLS_PORT_CLASSIFIER    newPortClassifier);


 
 
 
 
 
 
                                                                             
 
 
 
 
 
 
 

PB_ERROR_CODE_T CBM_VCG_CONFIGURATION_CHANGE_CHECK( UINT16        slotNo,
                                          UINT16        vcgNo,
                                          PB_GMPLS_VCG_CONFIG_T         vcgConfiguration);

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

PB_ERROR_CODE_T CBM_VCG_CAPACITY_CHANGE_CHECK( UINT16             slotNo,
                                     PB_GMPLS_TP_T      tp,
                                     UINT16             vcgNo,
                                     UINT16             direction,
                                     UINT16             action);



 
 
 
 
 


 
 
 
 
 
 
 
 
 
 
 
 
 
 

PB_ERROR_CODE_T CBM_XC_CHANGE_CHECK( PB_GMPLS_XC_OPERATION        action,
                           PB_GMPLS_XC_T                xc);


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
typedef struct 
{
    command_tt[TTT]    head;
    UINT32        correlator;
    UINT16        configMode;   
    UINT16        deletedXcNum;
    UINT16        createdXcNum;
    PB_GMPLS_XC_T modifiedXc[1];
} CMND_CBM_CCS_MODIFY_XC_REQ_T;

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
typedef struct 
{
    command_tt[TTT]    head;
    UINT32        correlator;
    UINT16        deletedXcNum;
    UINT16        createdXcNum;
    UINT16        result[1];   
} CMND_CCS_CBM_MODIFY_XC_ACK_T;

 
 
 
 
 
 
 
 
 
 
 
typedef struct 
{
    command_tt[TTT]      head;
    UINT16          action;  
    UINT16          result;  
    PB_GMPLS_XC_T   xc;
}CMND_CCS_CBM_XC_CHANGE_IND_T;


 
 
 
 
 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

PB_ERROR_CODE_T CBM_SNCP_CHANGE_CHECK(PB_GMPLS_SNCP_OPERATION        action,
                            PB_GMPLS_SNCP_TO_CC_CONVERTION workOrProtToCc,
                            PB_GMPLS_SNCP_T                sncp);

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
typedef struct 
{
    command_tt[TTT]                       head;
    UINT32                           correlator;
    UINT16                           action;          
    UINT16                           workOrProtToCc;  
    UINT16                           sncpNum;
    PB_GMPLS_SNCP_T                  modifiedSncp[1];
} CMND_CBM_SPM_MODIFY_SNCP_REQ_T;

 
 
 
 
 
 
 
 
 
 
 
 
 
 
typedef struct 
{
    command_tt[TTT]    head;
    UINT32        correlator;
    UINT16        sncpNum;
    UINT16        result[1];  
} CMND_SPM_CBM_MODIFY_SNCP_ACK_T;

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
typedef struct 
{
    command_tt[TTT]                       head;
    UINT32                           correlator;
    UINT16                           action;     
    UINT16                           sncpNum;
    PB_GMPLS_SNCP_T                  switchedSncp[1];
} CMND_CBM_SPM_SWITCH_SNCP_REQ_T;


 
 
 
 
 
 
 
 
 
 
 
 
 
 
typedef struct 
{
    command_tt[TTT]    head;
    UINT32        correlator;
    UINT16        sncpNum; 
    UINT16        result[1];  
} CMND_SPM_CBM_SWITCH_SNCP_ACK_T;

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
typedef struct 
{
        command_tt[TTT]              head;
        UINT16                  action;  
        UINT16                  workOrProtToCc;  
        PB_GMPLS_SNCP_T         sncp;
        UINT16                  result;  
}CMND_SPM_CBM_SNCP_CHANGE_IND_T;

 
 
 
 
 
 
 
 
 
 
 
 
typedef struct 
{
    command_tt[TTT]            head;
    UINT16                           action;    
     
    UINT16                result; 
     
    PB_GMPLS_SNCP_T       sncp;
} CMND_SPM_CBM_SNCP_SWITCH_IND_T;

 
 
 
 
 
 
 
 
 
 
 
typedef struct 
{
    command_tt[TTT]            head;
    PB_GMPLS_SNCP_T       sncp;
    UINT16                currentStatus;  
} CMND_SPA_CBM_SNCP_SWITCHING_IND_T;


 
 
 
 
 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

PB_ERROR_CODE_T CBM_MSP_CREATION_CHECK(UINT16                     mspScheme,
                             UINT16                     portType,
                             PB_GMPLS_MSP_PORT_T        port);

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
typedef struct 
{
    command_tt[TTT]          head; 
    UINT16              action;
    UINT16              mspScheme;
    UINT16              portType;
    UINT16              workingPortNum;
    PB_GMPLS_MSP_PORT_T protectingPort;
    PB_GMPLS_MSP_PORT_T workingPort[14];
} CMND_MPM_CBM_MSP_CHANGE_IND_T;


 
 
 
 
 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
PB_ERROR_CODE_T CBM_MSSPRING_CREATION_CHECK(UINT16                protectionScheme,
                                  UINT16                portType,
                                  PB_GMPLS_MSP_PORT_T   port);

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
typedef struct 
{
    command_tt[TTT]          head;
    UINT16              action; 
    UINT16              protectionScheme;
    UINT16              portType;
    PB_GMPLS_MSP_PORT_T eastPort;
    PB_GMPLS_MSP_PORT_T eastProtectionPort;
    PB_GMPLS_MSP_PORT_T westPort;
    PB_GMPLS_MSP_PORT_T westProtectingPort;
}CMND_MSM_CBM_MSSPRING_CHANGE_IND_T;


 
 
 
 
 


 
 
 
 
 

 
 
 
 
 
 
 
 
 
 
typedef struct 
{
    command_tt[TTT]    head;
    UINT16        action;
} CMND_MFM_CBM_MIB_SAVING_ADMISSION_IND_T;
 
 
 
 
 

 
 
 
 
 
 
 
 
typedef struct 
{
    command_tt[TTT]    head;
    UINT16        gmplsStatus;
} CMND_CBM_SNMPAGENT_GMPLS_ACTIVE_IND_T;


 
 
 
 
 

 
 
 
 
 
 
 
 
 
typedef struct 
{
    command_tt[TTT]   head;
    UINT16       slotNo;
    UINT16       trigger;
} CMND_CBM_GFA_ALARM_IND_TRIGGER_T;


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
void CBM_SEND_ALARM_IND_TO_GMPLS(UINT16              slotNo,
                                 UINT16              portType,
                                 UINT16              portNo,
                                 UINT16              cardType,
                                 PB_GMPLS_ALARM      alarmType,
                                 UINT16              alarmStatus);
                                 
                                 

 
 
 
 
 

 
 
 
 
 
 
typedef struct 
{
   command_tt[TTT]    head;
} CMND_PSM_CBM_MANUAL_SC_SWITCHING_IND_T;



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
typedef struct 
{
    command_tt[TTT]    head;
    UINT16        slotNo;
    UINT16        reserved;
}CMND_UDM_MIB_RESTORE_READY_NOTIFY_T;

 
 
 
 
 
 
 
 
 
PB_ERROR_CODE_T 
	     CBM_IFM_OTU_PORT_PATH_MAPPING_CHANGE_CHECK(
	                                               UINT16       slotNo,                                        
                                                   UINT16       portNo,
                                                   UINT8        newPathMapping);


 
 
 
typedef unsigned int (*CHK_TP_RESERVE_CALLBACK[TTT])(const PB_GMPLS_TP_T* , UINT32 );
extern void grm_register_ccs_check_tp_reserve(CHK_TP_RESERVE_CALLBACK );
extern void grm_register_spm_check_tp_reserve(CHK_TP_RESERVE_CALLBACK );
























 













typedef enum{
    SDD_EC_P2W[TTT],
    SDD_EC_W2P,
}SDD_EC_SWITCH_T;

 
typedef enum{
    NO_TP_MAP[TTT] =0,        
    PDH_TP_MAP,              
    SDH_TP_MAP,                 
    GMPLS_TP_MAP             
}MAPPER_TYPE_T;

typedef enum{
    LO_MAPPING_TU12[TTT] = 0,
    LO_MAPPING_TU3,
    LO_MAPPING_TU11,
    LO_MAPPING_TU2
}LO_MAPPING_TYPE_T;

typedef struct LoTPMapperItem_s[TTT]
{
    MAPPER_TYPE_T TpType;     
    UINT8 bGmplsReserve;
    UINT8 LoBus;     
    UINT8 LoVC4;     
    UINT8  HoSlot;     
    UINT8  HoPortType;  
    UINT8  HoPort;     
    UINT8  HoE;          
    UINT8  HoD;         
    UINT8  HoC;         
    UINT8  HoB;         
} __attribute__ ((packed))  LO_TP_MAPPER_ITEM_T;

 
typedef struct CrossConnectionItem_s[TTT]
{    
    UINT8 fromBus;       
    UINT8 fromVC4;       
    UINT8 type : 5;     
    UINT8 k : 3;         
    UINT8 l : 4;         
    UINT8 m : 3;         
    UINT8 bChanged : 1;  
} __attribute__ ((packed))  CROSS_CONNECT_ITEM_T;

 
typedef struct CrossConnectionHCCMatrix_s[TTT]
{
    CROSS_CONNECT_ITEM_T    VC4List[136 ][16 ];     



} __attribute__ ((packed))  CROSS_CONNECT_HCC_MATRIX_T;
 
typedef struct CrossConnectionLCCMatrix_s[TTT]
{
    CROSS_CONNECT_ITEM_T    VC3List[9 ][16 ][3 ];     
    CROSS_CONNECT_ITEM_T    VC12List[9 ][16 ][3 ][7 ][3 ];     
} __attribute__ ((packed))  CROSS_CONNECT_LCC_MATRIX_T;

 
typedef struct CrossConnectionHLCMatrix_s[TTT]
{
    CROSS_CONNECT_ITEM_T    VC4List[18 ][16 ];     
    CROSS_CONNECT_ITEM_T    VC3List[18 ][16 ][3 ];     
    CROSS_CONNECT_ITEM_T    VC12List[18 ][16 ][3 ][7 ][3 ];     
} __attribute__ ((packed))  CrossConnectionHLCMatrix;

 
 
typedef int (*funcPBCCHCCAllCXC[TTT])(INSTANCE_T instance, CROSS_CONNECT_HCC_MATRIX_T *pMatrix);
typedef int (*funcPBCCLCCAllCXC[TTT])(INSTANCE_T instance, CROSS_CONNECT_LCC_MATRIX_T *pMatrix);
typedef int (*funcPBCCHLCAllCXC[TTT])(INSTANCE_T instance, CrossConnectionHLCMatrix *pMatrix);

 
 
typedef int (*funcPBCCSetVC4XC[TTT]) (INSTANCE_T instance, UINT16 FromBus, UINT16 FromVC4, UINT16 ToBus, UINT16 ToVC4);
typedef int (*funcPBCCSetVC3XC[TTT]) (INSTANCE_T instance,UINT16 FromBus, UINT16 FromVC4, UINT16 FromVC3, UINT16 ToBus, UINT16 ToVC4, UINT16 ToVC3);
typedef int (*funcPBCCSetVC12XC[TTT]) (INSTANCE_T instance,UINT16 FromBus, UINT16 FromVC4, UINT16 FromVC3, UINT16 FromVC2, UINT16 FromVC1, UINT16 ToBus, UINT16 ToVC4, UINT16 ToVC3, UINT16 ToVC2, UINT16 ToVC1);

 
 
typedef int (*funcPBCCTpMapper[TTT])(INSTANCE_T instance, LO_TP_MAPPER_ITEM_T *pMapper);
 
typedef int (*funcPBCCLoMapping[TTT])(INSTANCE_T instance, UINT16 LoBus, UINT16 LoVC4, UINT8 LoK, LO_MAPPING_TYPE_T type);

 
typedef int (*funcPBCCSetHOCCCardState[TTT]) (INSTANCE_T instance,BOOL bState);
typedef int (*funcPBCCFreezeAllSNCP[TTT]) (INSTANCE_T instance,BOOL bEnable);
typedef int (*funcPBCCFreezeAllHardWareMSP[TTT]) (INSTANCE_T instance,BOOL bEnable);

 
typedef int (*funcPBCCSetLOCCMode[TTT]) (INSTANCE_T instance,BOOL bState);

 
 
typedef int (*funcPBCCSetEPGSwitch[TTT]) (INSTANCE_T instance,UINT32 WorkSlot,UINT32 ProtSlot,BOOL bState);
typedef int (*funcPBCCSetMSPSwitch[TTT]) (INSTANCE_T instance,UINT32 WorkSlot,HW_PORT_TYPE eWorkPortType,UINT32 WorkPort,
											UINT32 ProtSlot,HW_PORT_TYPE eProtPortType,UINT32 ProtPort,BOOL bState);
typedef int (*funcPBCCSetDRISwitch[TTT]) (INSTANCE_T instance,UINT32 WorkSlot,HW_PORT_TYPE eWorkPortType,UINT32 WorkPort,TP_INDEX_T WorkTp,
											UINT32 ProtSlot,HW_PORT_TYPE eProtPortType,UINT32 ProtPort,TP_INDEX_T ProtTp,BOOL bState);

 
 
typedef int (*funcPBCCSetAis[TTT])(INSTANCE_T inst,HW_PORT_TYPE ePortType, UINT32 ulPort, TP_INDEX_T eTp, ALARM_DIRECTION_T eDir, BOOL bEnable);
typedef int (*funcPBCCSetCardAis[TTT])(INSTANCE_T inst,UINT32 Slot,BOOL bEnable);

typedef int (*funcGetLoccSlotFromLCTP[TTT])(UINT8 ucTpType, UINT8 ucSlot, UINT8 ucPortType
    , UINT8 ucPort, UINT32 ulTp);    

typedef PB_ERROR_CODE_T[TTT] (* funcPBCCSetLOCCSwitch)(ENTITY_T etEntity, CTD_LOCC_MODE_T eLccMode, BOOL bWorkState);

typedef int (*funcPBCCSetCardType[TTT]) (INSTANCE_T inst, UINT32 ulSlot, UINT32 ulStyle, UINT32 ulOption, BOOL bWarm);
typedef int (*funcCCSetPortType[TTT])(INSTANCE_T instance, UINT32 ulSlotNo, UINT32 ulPortType, UINT16  usPortId, UINT32 ulActualPortType);
typedef unsigned int (*funcCCGetNofreeCapacityslot[TTT])(UINT32 slot);

typedef  int (*funcCCGetGcbCheck[TTT])(PB_GMPLS_XC_OPERATION action, PB_GMPLS_XC_T xc);



















 


















 



 






















 


 

typedef struct 
{
    command_tt[TTT]          head;
    BOOL                enable;             
} FMM_HANDLE_SUPPRESS_CMND_T;

 
typedef struct
{
    command_tt[TTT]          head;
    MIBpbActiveAlarmTable_t  data;
} FMM_AEL_NEW_ALARM_RAISED_CMND_T;

 
typedef enum
{
    LOG_COMMAND_NONE[TTT] = 0,
    LOG_COMMAND_CLEAR_ALARMLOG  = 1,
    LOG_COMMAND_CLEAR_EVENTLOG  = 2,    
} LOG_COMMAND_T;

typedef struct
{
    command_tt[TTT]         head;
    LOG_COMMAND_T      logCmd;    
} FMM_AEL_LOG_STATUS_CMND_T;


 





typedef struct
{
    command_tt[TTT]         head;
    int                DetectTime;
    int                ClearTime;   
} FMM_FMC_ALM_PERSISTENT_TIME_CFG_CMND_T;


 
typedef struct
{
    command_tt[TTT]         head;
    BOOL               enable;
} FMM_FMC_ENABLE_CORRELATION_CMND_T;


 
typedef struct
{
    command_tt[TTT]          head;    
    BOOL                enable;
} FMM_FMC_NE_LEVEL_ALARM_INHIBIT_CMND_T;

 
typedef struct
{
    command_tt[TTT]          head;    
    BOOL                aisEnable;
    BOOL                rdiEnable;
} FMM_FMC_NE_LEVEL_AIS_RDI_INHIBIT_CMND_T;

 
typedef struct
{
	command_tt[TTT]          head;
	BOOL                alarmEnable;
    BOOL                aisEnable;
    BOOL                rdiEnable;
	BOOL                sefEnable;
	unsigned int        changeMsgBit;
}FMM_FMC_NE_LEVEL_CFG_CMND_T;

 
typedef struct
{
	PbEnableDisable_Tval[TTT] pbNodeAlarmEnabling;
	TruthValue_Tval pbAISEnabled;
	TruthValue_Tval pbRDIEnabled;
	TruthValue_Tval pbSEFEnabled;
	unsigned int    changeMsgBit; 
}FMM_NE_LEVEL_CFG_CHANGE_T;

 

typedef enum
{
	FMM_ALARM_ENABLE[TTT] = 0,
	FMM_AIS_ENABLE   = 1,
	FMM_RDI_ENABLE   = 2,
	FMM_SEF_ENABLE   = 3
}FMM_NE_CFG_NUM;

 
typedef struct
{
    command_tt[TTT]          head;
    UINT32              ledId;
    BOOL                ledOn;
} FMM_FMA_ALARM_OUT_STATE_CMND_T;

 
typedef struct
{
    command_tt[TTT]          head;
    UINT32              ledId;
    BOOL                ledOn;
} FMM_FMA_MDO_STATE_CMND_T;


 
 

































typedef struct
{
    command_tt[TTT]          head;
    UINT32              ioaIndex;
    BOOL                enable;
} FMM_FMC_MDI_ENABLE_CFG_CMND_T;


 
typedef struct
{
    command_tt[TTT]          head;
    UINT32              alarmId;
    BOOL                inhibit;
} FMM_FMC_ALARM_TYPE_INHIBIT_CFG_CMND_T;

 
typedef enum
{
    FM_ALARM_RULE_NO_CHANGE[TTT] = 0,           
    FM_ALARM_RULE_ENABLE = 1,               
    FM_ALARM_RULE_DISABLE = 2,              
} FM_ALARM_RULE_T;

typedef struct
{
    command_tt[TTT]          head;
    FM_ALARM_RULE_T     lof;
    FM_ALARM_RULE_T     lom;
    FM_ALARM_RULE_T     lop;
} FMM_FMC_ALARM_RULE_CFG_CMND_T;

extern int FMM_TclCmdShowProc(ClientData clientData, Tcl_Interp *interp, int argc, char *argv[]);








 
































































 






















 







typedef PB_ERROR_CODE_T[TTT] (*CAI_LoadCard)(UINT32 instance,
                                        UINT32 style,
                                        UINT32 option);

 





PB_ERROR_CODE_T CAI_RegisterLoad(CAI_LoadCard pFunc);

 









 





 
 


 






 

 





 

 





 

 





 

 





 

 





 

 







typedef PB_ERROR_CODE_T[TTT] (*CAI_BoardStateChangeFunc)(BOARD_EVENT_T event, SLOT_NUMBER_T slot, BOARD_STYLE_T style);
PB_ERROR_CODE_T CAI_BoardStateChange(BOARD_EVENT_T event, SLOT_NUMBER_T slot, BOARD_STYLE_T style);


 






 


 





 

 






typedef PB_ERROR_CODE_T[TTT] (*CAI_ReportCardFailureFunc)(INT16 entityNum, BOOL failure);
PB_ERROR_CODE_T CAI_ReportCardFailure(INT16 entityNum, BOOL failure);



 






typedef struct _CM_CARDPRESENCE_T[TTT]
{
    BOARD_PRESENCE_T  IsPresent[16  + 1];   
                                          
} CM_CARDPRESENCE_T;

typedef void (*CAI_ReportCardPresenceFunc[TTT])(INT16 entityNum,
                                       ENTITY_INFO_T *pInfo);
void CAI_ReportCardPresence(INT16 entityNum,
                                       ENTITY_INFO_T *pInfo);

 





 



 

 
 











 




















void Cad_PrintTask(void);
 







typedef PB_ERROR_CODE_T[TTT] (*CAD_InitCard)(UINT32 instance,
                                        UINT32 style,
                                        UINT32 option);

 





PB_ERROR_CODE_T CAD_RegisterInit(CAD_InitCard pFunc);


 






typedef PB_ERROR_CODE_T[TTT] (*CAD_ActivateCard)(UINT32 instance,BOOL bWarmFlag);

 





PB_ERROR_CODE_T CAD_RegisterActive(CAD_ActivateCard pFunc);

 





typedef PB_ERROR_CODE_T[TTT] (*CAD_DeinitCard)(UINT32 instance);

 





PB_ERROR_CODE_T CAD_RegisterDeinit(CAD_DeinitCard pFunc);

 





typedef PB_ERROR_CODE_T[TTT] (*CAD_DeactiveCard)(UINT32 instance);

 





PB_ERROR_CODE_T CAD_RegisterDeactive(CAD_DeactiveCard pFunc);

 







 
 


 






typedef PB_ERROR_CODE_T[TTT] (*CAD_Detecter)(INSTANCE_T instance, BOOL *pState);


 





PB_ERROR_CODE_T CAD_RegisterDetecter(CAD_Detecter pFunc);

 








 
 
 
 



 





 









 
 

 
                                       

 






typedef PB_ERROR_CODE_T[TTT] (*CAD_ColdRebootFunc)(void);
extern PB_ERROR_CODE_T CAD_RegisterColdReboot(CAD_ColdRebootFunc pFunc);

 






typedef PB_ERROR_CODE_T[TTT] (*CAD_ReportCardFailureFunc)(UINT32 slot, BOOL failure);
extern PB_ERROR_CODE_T CAD_ReportCardFailure(UINT32 slot, BOOL failure);

 






typedef PB_ERROR_CODE_T[TTT] (*CAD_ReportFanFailureFunc)(UINT32 slot, BOOL failure);
extern PB_ERROR_CODE_T CAD_ReportFanFailure(UINT32 slot, BOOL failure);

 






typedef PB_ERROR_CODE_T[TTT] (*CAD_FpgaVersion)(INSTANCE_T    inst, char *pFpgaVer);

PB_ERROR_CODE_T CAD_RegisterFpgaVersion(CAD_FpgaVersion pFunc);

 





typedef PB_ERROR_CODE_T[TTT] (*CAD_RebootL2Card)(UINT32 instance);
PB_ERROR_CODE_T CAD_RegisterRebootL2Card(CAD_RebootL2Card pFunc);

typedef PB_ERROR_CODE_T[TTT] (*CAD_SetLOCCCardState)(UINT32 instance, BOOL bState);
PB_ERROR_CODE_T CAD_RegSetLOCCCardState(CAD_SetLOCCCardState pFunc);

typedef PB_ERROR_CODE_T[TTT] (*CAD_SetLcAIS)(UINT32 instance,UINT32 slot, BOOL bSet);
PB_ERROR_CODE_T CAD_RegSetLcAIS(CAD_SetLcAIS pFunc);

 

extern PB_ERROR_CODE_T CMC_RegisterECCActive(CAD_ActivateCard pFunc);
extern PB_ERROR_CODE_T CMC_RegisterECCDeactive(CAD_DeactiveCard pFunc);

















 

typedef PB_ERROR_CODE_T[TTT] (*SDD_TEMP_EVENT_CBACK)(ENTITY_T entity,
                                     SDD_BOARD_TYPE_T boardtype,
                                     BOOL bOverheat);
 
typedef PB_ERROR_CODE_T[TTT] (*SDD_TEMP_LEM_EVENT_CBACK)(ENTITY_T entity,
                                     SDD_BOARD_TYPE_T boardtype,
                                     BOOL bOverheat);
 
typedef void (*HII_PTInitGESFPFunc[TTT])(int instance, int portId, int SFPType);

 
typedef PB_ERROR_CODE_T[TTT](*SDD_NotifyIfmSfpChange)(UINT32 ulSlotNo, UINT32 ulPortType, UINT32 ulPortNo, UINT32 ulConnectorType); 

 
SDD_RESET_REASON SDD_GetResetReason();
void SDD_LoadModule();
void SDD_SetModuleState(BOOL enable);
BOOL SDD_GetModuleState();
BOOL SDD_JudgeIfMaincard();
PbBoardStyle_Tval SDD_GetLocalBoardStyle();


 
PB_ERROR_CODE_T SDD_InitCard(ENTITY_T entity, CARDTYPE_T cardType, UINT32 ulOption);
PB_ERROR_CODE_T SDD_ActivateCard(ENTITY_T entity, BOOL bWarm);
PB_ERROR_CODE_T SDD_DeactivateCard(ENTITY_T entity);
PB_ERROR_CODE_T SDD_DeinitCard(ENTITY_T entity);

BOARD_PRESENCE_T SDD_GetBoardPresence(ENTITY_T entity);
PbBoardFunction_Tval SDD_GetBoardFunction(ENTITY_T entity);
PbBoardStyle_Tval SDD_GetBoardStyle(ENTITY_T entity);
UINT SDD_GetSlotBoardRev(ENTITY_T entity);
PB_ERROR_CODE_T SDD_ResetBoard(ENTITY_T entity);
PB_ERROR_CODE_T SDD_SetLedState(ENTITY_T entity, LED_TYPE_T ledType,UINT16 usLedId, LED_STATE_T ledState);
PB_ERROR_CODE_T SDD_GetLedState(ENTITY_T entity, LED_TYPE_T ledType,UINT16 usLedId, LED_STATE_T *pLedState);
PB_ERROR_CODE_T SDD_GetMdiPort(UINT16 portId, BOOL *pbState);
PB_ERROR_CODE_T SDD_SetMdoPort(UINT16 portId, BOOL bEnable);
PB_ERROR_CODE_T SDD_SetAlarmOut(UINT16 portId, BOOL bEnable);
PB_ERROR_CODE_T SDD_SetGlobalOutSignalStatus(BOOL bEnable);
PB_ERROR_CODE_T SDD_SetCardOutSignalStatus(ENTITY_T entity, BOOL bEnable);
PB_ERROR_CODE_T SDD_SetCardManageSignalStatus(ENTITY_T entity, UINT16 portId, BOOL bEnable);
PB_ERROR_CODE_T SDD_SetPortAdminStatus(ENTITY_T entity, HW_PORT_TYPE portType, UINT16 portId, BOOL bEnable);
PB_ERROR_CODE_T SDD_EnablePortAls(ENTITY_T entity, HW_PORT_TYPE portType, UINT16 portId, BOOL bEnable);
PB_ERROR_CODE_T SDD_GetInSignalPowerStatus(ENTITY_T entity, HW_PORT_TYPE portType, UINT16 portId, BOOL *pNip);
PB_ERROR_CODE_T SDD_NotifyLos(ENTITY_T entity, HW_PORT_TYPE portType, UINT16 portId, BOOL bLos);
PB_ERROR_CODE_T SDD_GetOutSignalStatus(ENTITY_T entity, HW_PORT_TYPE portType, UINT16 portId, BOOL *pStatus);
PB_ERROR_CODE_T SDD_SetSTMMode(ENTITY_T entity, HW_PORT_TYPE ePortType, UINT32 ulPort, HW_ACT_PORT_TYPE Mode);
PB_ERROR_CODE_T SDD_GetSfpPresence(ENTITY_T entity, HW_PORT_TYPE portType, UINT16 portId, BOOL *pState);
PB_ERROR_CODE_T SDD_GetLaserParameters(ENTITY_T entity, HW_PORT_TYPE portType, UINT16 portId, LASER_PARAMETER_T *pParam);
PB_ERROR_CODE_T SDD_GetRtcTime(struct tm *pMyTime);
PB_ERROR_CODE_T SDD_SetRtcTime(struct tm *myTime);
PB_ERROR_CODE_T SDD_GetTemperature(ENTITY_T entity, UINT16 id, INT16 *pTemp);
PB_ERROR_CODE_T SDD_SetTempThreshold(ENTITY_T entity, TEMPERATURE_T high, TEMPERATURE_T low);
 
void SDD_Enable1HzInterrupt(BOOL bEnable);
void SDD_RegisterReportDefect(FMA_AlmModDefectFunc pFunc);         
void SDD_RegisterBoardsPresence(CAI_ReportCardPresenceFunc pFunc); 
void SDD_RegisterReportCardFail(CAI_ReportCardFailureFunc pFunc);  
void SDD_RegisterNotifyIfmSfpChange(SDD_NotifyIfmSfpChange pFunc);  

PB_ERROR_CODE_T SDD_RegisterLatchEvent(SDD_LATCH_EVENT_CBACK pFunc);   
PB_ERROR_CODE_T SDD_NotifyLatchEvent(ENTITY_T entity,CARDTYPE_T cardType,BOARD_EVENT_T latchEvent);
PB_ERROR_CODE_T SDD_RegisterBoardEvent(SDD_BOARD_EVENT_CBACK pFunc);   
PB_ERROR_CODE_T SDD_RegisterEntityUpdate(SDD_ENTITY_UPDATE_CBACK pFunc);   
PB_ERROR_CODE_T SDD_RegisterOneSecTimer(SDD_ONE_SECOND_TIMER_CBACK pFunc);
PB_ERROR_CODE_T SDD_RegisterButtonEvent(SDD_BUTTON_EVENT_CBACK pFunc);
PB_ERROR_CODE_T SDD_RegisterTempEvent(SDD_TEMP_EVENT_CBACK pFunc);         
PB_ERROR_CODE_T SDD_RegisterTempLemEvent(SDD_TEMP_LEM_EVENT_CBACK pFunc);         
PB_ERROR_CODE_T SDD_SetNotifyTempEvent(ENTITY_T entity);

 


void SDD_RegisterReportFanFail(CAD_ReportFanFailureFunc pFunc);


PB_ERROR_CODE_T SDD_ECCardSwitch(ENTITY_T entity, SDD_EC_SWITCH_T switchStatus);
PB_ERROR_CODE_T SDD_TimingRefSel(ENTITY_T entity, TIMING_REF_T refSet);
PB_ERROR_CODE_T SDD_DetectFanFailure(ENTITY_T entity);
PB_ERROR_CODE_T SDD_DetectPwrFailure(ENTITY_T entity);
void SDD_EnableLedTest(BOOL bEnable);
PB_ERROR_CODE_T SDD_GetFanState(ENTITY_T entity, FAN_STATUS_T *pState);
PB_ERROR_CODE_T SDD_GetPowerState(ENTITY_T entity, UINT16 id, POWER_STATUS_T *pState);
PB_ERROR_CODE_T SDD_GetLocalSlot(SLOT_NUMBER_T *pSlot);

 
PB_ERROR_CODE_T SDD_SET_OAReset (BOOL bActive);
PB_ERROR_CODE_T SDD_SET_OADisable (BOOL bActive);
PB_ERROR_CODE_T SDD_SET_OAOutputMute (BOOL bActive);
PB_ERROR_CODE_T SDD_SET_OALinkLED (BOOL bActive);
PB_ERROR_CODE_T SDD_GET_OAPin (UINT16 *wStatus);
PB_ERROR_CODE_T SDD_ResetAsic(ENTITY_T entity);
PB_ERROR_CODE_T SDD_InitSi5319Sedres(ENTITY_T entity);

 
PB_ERROR_CODE_T SDD_SetGeElLaserParameters(ENTITY_T entity,HW_PORT_TYPE portType,
                                UINT16 port, UINT8 offset,UINT16 val);
PB_ERROR_CODE_T SDD_GetGeElLaserParameters(ENTITY_T entity,HW_PORT_TYPE portType,
                                UINT16 port, UINT8 offset,UINT16 * val);
void SDD_RegHIIInitGeSfp(HII_PTInitGESFPFunc fun);
 
PB_ERROR_CODE_T SDD_SetAlsMode(ENTITY_T entity, HW_PORT_TYPE portType, UINT16  usPortId, ALS_MODE_STATUS_T aMode);
PB_ERROR_CODE_T SDDSetPCA9555(UINT8 addr, UINT16 states);
PB_ERROR_CODE_T SDD_SetImpedanceMode(ENTITY_T entity, HW_PORT_TYPE ePortType, UINT32 ulPort, PDH_OHM_TYPE_T eOhmType);
void SDD_NotifyNERebootFinished();
void SDD_NotifyNERebootStarted();

 
PB_ERROR_CODE_T SDD_SetPortAdminStatus(ENTITY_T entity, HW_PORT_TYPE portType, UINT16 portId, BOOL bEnable);
PB_ERROR_CODE_T SDD_SetWavelength(ENTITY_T etEntity, HW_PORT_TYPE portType, UINT16 portId, UINT16 wWaveLengthId);
PB_ERROR_CODE_T SDD_SetDecisionThreshold(ENTITY_T etEntity, HW_PORT_TYPE portType, UINT16 portId, UINT16 wDecesionThreshold);
PB_ERROR_CODE_T SDD_GetOsrAbnormalStatus(ENTITY_T etEntity, HW_PORT_TYPE portType, UINT16 portId, BOOL *pbState);
PB_ERROR_CODE_T SDD_GetDecisionThreshold(ENTITY_T etEntity, HW_PORT_TYPE portType, UINT16 portId, UINT16 *wDecesionThreshold);

PB_ERROR_CODE_T SDD_ISELECSFP(ENTITY_T entity, HW_PORT_TYPE portType, UINT16 portId, BOOL *wIsElecSfp);

extern int sdd_get_ioN_port (int io, int * pFirst, int * pLast);
extern int SDD_126xE1IOPortConvert (int port);












 

























 

 

 























































 





 

extern  int intCnt;		 


 



 














 



extern STATUS 	intConnect (VOIDFUNCPTR *vector, VOIDFUNCPTR routine,
	       	    	    int parameter);
extern FUNCPTR 	intHandlerCreate (FUNCPTR routine, int parameter);
extern void 	intLockLevelSet (int newLevel);
extern int 	intLockLevelGet (void);
extern BOOL 	intContext (void);
extern int 	intCount (void);
extern void 	intVecBaseSet (FUNCPTR *baseAddr);
extern FUNCPTR *intVecBaseGet (void);
extern void 	intVecSet (FUNCPTR *vector, FUNCPTR function);
extern FUNCPTR 	intVecGet (FUNCPTR *vector);
extern int 	intLevelSet (int level);
extern int 	intLock (void);
extern int 	intUnlock (int oldSR);
extern int 	intRegsLock (REG_SET *pRegs);
extern void 	intRegsUnlock (REG_SET *pRegs, int lockKey);
extern STATUS   intVecTableWriteProtect (void);

























extern int	intDisable (int);
extern int	intEnable (int);






























 

 
 

 





 


















































     






















    typedef struct _FPGA_REGADDR_T[TTT]
    {
        UINT32 mask1;
        UINT32 mask2;
        UINT32 mask3;
        UINT32 status1;
        UINT32 status2;
        UINT32 status3;
    }
    FPGA_REGADDR_T;




     

 
     





     































    typedef struct _FPGA_SIG_PIN_T[TTT]
    {
        UINT32 port;                   
        UINT32 pin;                    
    }
    FPGA_SIG_PIN_T;






























    typedef struct _FPGA_PIN_XILINX_T[TTT]
    {
        FPGA_SIG_PIN_T BitInit;             
        FPGA_SIG_PIN_T BitProgram;          
        FPGA_SIG_PIN_T BitDone;             
 
        FPGA_SIG_PIN_T BitFpgaDln;          
    }
    FPGA_PIN_XILINX_T;

    typedef struct _FPGA_PIN_ALTERA_T[TTT]
    {
        FPGA_SIG_PIN_T BitDClk;             
        FPGA_SIG_PIN_T BitData0;            
        FPGA_SIG_PIN_T BitnConfig;          
        FPGA_SIG_PIN_T BitnStatus;          
        FPGA_SIG_PIN_T BitCfgDone;          
 
        FPGA_SIG_PIN_T BitFpgaDln;          
    }
    FPGA_PIN_ALTERA_T;

    typedef union _FPGA_PINCFG_T[TTT]
    {
        FPGA_PIN_ALTERA_T PinAltera;        
        FPGA_PIN_XILINX_T PinXilinx;        
    } FPGA_PINCFG_T;

     









     





























     


    typedef enum
    {
        FPGA_STATUS_INACTIVE[TTT],
        FPGA_STATUS_ACTIVE,
    } FPGA_STATUS_T;

    typedef int FPGA_HANDLE[TTT];







    typedef unsigned int FPGA_HOOK_ARG[TTT];
    typedef void ( * FPGA_HOOK_FUNC[TTT] ) ( FPGA_HANDLE handle, FPGA_HOOK_ARG usrHookArg );

    typedef struct _FPGA_INTHOOK_T[TTT]
    {
        FPGA_HOOK_FUNC UsrHookFunc;         
        FPGA_HOOK_ARG UsrHookArg;          
        UINT32 Interrupts;          
        UINT32 Missed;              
    }
    FPGA_INTHOOK_T;

    typedef struct _FPGA_ERR_STATS_T[TTT]
    {
        UINT32 Interrupts;                  
        UINT32 WriteViolate;                
        UINT32 AddressViolate;              
        UINT32 SizeViolate;                 
        UINT32 PortViolate;                 
        UINT32 BoundaryViolate;             
    }
    FPGA_ERRSTATS_T;


     


    typedef struct _FPGA_CHIP_DATA_T[TTT]
    {
        UINT8 Chip;                
        UCHAR CS;                  
        UINT16 IntNum;              
        UINT32 MemBase;             
        FPGA_PINCFG_T PinCfg;              
        UCHAR * FileName;            
        void ( *RegInit ) ( struct _FPGA_CHIP_DATA_T * );
         
        UINT32 SubFunction;         
        UCHAR * SubSlot;             

        FPGA_INTHOOK_T IntHook[ 64  ];
         
        FPGA_ERRSTATS_T ErrStats;            
        UINT32 Version;             
        UINT32 Status;
    }
    FPGA_CHIP_DATA_T;





    typedef struct
    {
        UCHAR[TTT] fileName[ 13  ];
        UINT32 fileLength;
    }
    FPGA_MEM_DATA_T;

    extern FPGA_CHIP_DATA_T *fpgaChips;



     



    extern int pbFpgaInit( void );

    extern FPGA_STATUS_T pbFpgaGetStatus( void );

     



    extern FPGA_HANDLE pbFpgaIsrHookAdd
        (
            int chip,
            int asic,
            int bank,
            FPGA_HOOK_FUNC usrHookFunc,
            FPGA_HOOK_ARG usrHookArg
        );
    extern FPGA_HANDLE pbFpgaIsrHookSlotAdd
        (
            PbSlotNumberType_Tval slot,
            FPGA_HOOK_FUNC usrHookFunc,
            FPGA_HOOK_ARG usrHookArg
        );

     



    extern int pbFpgaIsrHookDel( FPGA_HANDLE handle );

     



    extern int pbFpgaIntrEnable( FPGA_HANDLE handle );
    extern int pbFpgaIntrSlotEnable( PbSlotNumberType_Tval slot );

     



    extern int pbFpgaIntrDisable( FPGA_HANDLE handle );
    extern int pbFpgaIntrSlotDisable( PbSlotNumberType_Tval slot );

    extern int pbFpgaIsrEnable( int chip );
    extern int pbFpgaIsrDisable( int chip );
    extern int pbFpgaDownloadCS( UINT cs, char * fileName, UCHAR * data, UINT length );










    typedef void ( * FPGA_WRITE_FUNC[TTT] ) ( UINT32 addr, UINT32 var );
    typedef UINT32[TTT] ( * FPGA_READ_FUNC ) ( UINT32 addr );

    STATUS pbFpgaDownloadSlot( PbSlotNumberType_Tval slot, char * fileName, UINT32 memBase );
    STATUS pbFpgaInitSlot( PbSlotNumberType_Tval slot, char * fileName );








 



















































































 







































 









 



 






 



 


 










 


 


 


 

 

 

 


 

 

 

 


 


 


 





 
 
 

 



 
 
 

 

 
 
 

 




 
 
 

 


 


 


 


 


 


 


 

 

 


 
 
 

 


 
 
 

 


 


 


 


 




 



 


 


 
 
 

 



 
 
 

 



 

















 








 


















 
























 

























 

















 









     




 
 





 
 











    
 
 



 
 


 
 


 
 

















 
 




 
 









 
 













 
 













 




 


















 






























 





























 
















































































typedef enum
{
        eEm4EntEmp[TTT] = 0,
        eEm4EntInit,
        eEm4EntAct  
}
EM4_ENTITY_STATE_T;


typedef void (*CPA_LATCHSTATE_CHANGE_FUNC[TTT])(BOARD_EVENT_T ulEvent, SLOT_NUMBER_T usSlotNum, BOARD_STYLE_T ulCardType);
typedef struct
{
    FMA_AlmModDefectFunc[TTT] pFuncReportAlm;  
    CPA_LATCHSTATE_CHANGE_FUNC pFuncReportLatch;  
    PRA_SetPortStatus_Func pFuncReportPrbs;  
    CAI_BoardStateChangeFunc pFuncReportFault;
} CAH_EM4_CALLBACKS_T;

typedef struct {
    UINT32[TTT] address;
    UINT8 value;
}EM4_REG_CONF;

typedef struct 
{
    UINT32[TTT] baseAddr;

     


    UINT32 portMask[(63 )  + 1];    
}CAH_EM4_CHIP_CONFIG_T;



typedef struct
{
        PbTIModeType_Tval[TTT] J2Mode;
        UINT8 J2Data[64  + 1];
}
EM4_J2_BYTES_T;
typedef struct
{
        PRBS_MODE_T[TTT] prbsMode;
        PRBS_STATUS_T prbsStatus;
         


        UINT32 prbsErrCnt;
        BOOL bForceRpt;
}
EM4_PRBS_CONFIG_T;

typedef enum
{
    EM4_NONE_FORCE[TTT]  = 0,
    EM4_DOWN_FORCE  = 1<<1,
    EM4_UP_FORCE    = 1<<2
}EM4_FORCE_MODE_T;



 


typedef struct
{
        UINT16[TTT] almID[14  + 2];

 

























        UINT16 state[14  + 2];
        UINT16 e1state[14  + 2];

 
















        UINT16 ssf;
        UINT16 ssfFc;
         


        UINT16 rdi;
        UINT16 rfi;
        UINT16 rdiFc;
        UINT16 rfiFc;

         


        UINT16 temp;     
        UINT16 e1ssf;
        UINT16 e1ssfFc;
        UINT16 e1rdi;
        UINT16 e1rdiFc;
}
EM4_POH_ALM_T;




 


typedef struct
{
         


        CAH_EM4_CHIP_CONFIG_T[TTT] cfg;

         


        UINT32 su_id;

         


        BOOL bPlmEnable[(63 )  + 1];
        BOOL bTimEnable[(63 )  + 1];
        PORT_STATE_T adminState[(63 )  + 1];
        UINT8 ExpPSL[(63 )  + 1];
        UINT8 RcvPSL[(63 )  + 1];
        UINT8 TranPSL[(63 )  + 1];

        EM4_J2_BYTES_T strExpJ2[(63 )  + 1];
        EM4_J2_BYTES_T strTranJ2[(63 )  + 1];
        EM4_J2_BYTES_T strRcvJ2[(63 )  + 1];

         



        PDH_PORT_MODE_T portType[(63 )  + 1];

         


        EM4_PRBS_CONFIG_T prbsCfg[(63 )  + 1];

         


         unsigned int faisMode[(63 )  + 1];
        EM4_FORCE_MODE_T frdiMode[(63 )  + 1];

         


        PORT_LOOPBACK_T loopMode[(63 )  + 1];

         


        EM4_POH_ALM_T pohAlm[(63 )  + 1];
        int farcrc[(63 )  + 1];
        int crc[(63 )  + 1];
        int nslip[(63 )  + 1];
        int pslip[(63 )  + 1];

         



        BOOL forceRptAlm[(63 )  + 1];

         


        UINT32 nPrbsDelayCount[(63 )  + 1];

         


        BOOL bRestrainRDI[(63 )  + 1];
        BOOL bBlockAis[(63 )  + 1];
        int isFrcais [(63 )  + 1];
        int isFrcrdi [(63 )  + 1];

         


        int isRptLOM [(63 )  + 1];
        PDH_FRAME_MODE_T isFrame [(63 )  + 1];

        
}
EM4_CHIP_VAR_T;


 
 

typedef enum
{ 
    EM4_ENTITY_UNKNOWN[TTT] = 0,
    EM4_ENTITY_LATCH,
    EM4_ENTITY_DELATCH
}CAH_EM4_ENTITY_LATCH_T;




typedef enum{
    eEM4_DISABLE[TTT] = 0,
    eEM4_ENABLE  = 1
}eEM4SWITCH;





typedef struct
{
         






        ENTITY_T[TTT] entity;

         






        DWORD dwPos;

         




        UINT32 chipNum;

         


        EM4_ENTITY_STATE_T state;

         


        EM4_CHIP_VAR_T chip_var[(5) ];
}
CAH_EM4_ENTITY_DATA_T;







 




typedef union _ARG32[TTT]
{
    int arg;
    char tti[32 + 3];
}ARG32;
typedef void (*PMyFun[TTT])( );


typedef struct __E1_CALL[TTT]
{
     
    PMyFun p;
    int arg1;
    int arg2;
    int arg3;
 







    ARG32 arg4;
    int arg5;
    int arg6;
    int sn;
    int id;
    struct __E1_CALL *pNext;
    struct __E1_CALL *pHashNext[11];
    char fname[64];
}
E1_CALL;








 














 
 
typedef union _sexar_framer_cfgctrl[TTT]
{
	struct _cfgCtrlBit
	{
   		unsigned    loopback:1;     
		unsigned	IsDS3:1;	    
		unsigned	losEnable:1;    
		unsigned	reset:1;        
		unsigned	Unused:1;	    
        unsigned	format:1;	    
        unsigned	TimeRefSel:2;   
	} cfgCtrlBit;
	UINT1 cfgCtrl;
}EXAR_FRAMER_CTRL_T;


typedef union _sexar_rxj1_cfgctrl_x[TTT]
{
	struct _rxj1CtrlBit_x
	{
   		unsigned    reserved :3;   
		unsigned	bufMode:1;	   
		unsigned	threshold:1;   
		unsigned	alignment:1;   
		unsigned	length:2;	   
	} rxj1CtrlBit;
	UINT1 rxj1Ctrl;
}EXAR_RXJ2_CTRL_T;





typedef enum
{
        eEm4J2Tx[TTT] = 0,
        eEm4J2Rx,
        eEm4J2Exp
}
EM4_J2_DIRECTION_T;

typedef enum
{
        eEm4J2Rd[TTT] = 0,
        eEm4J2Wr,
}
EM4_J2_OPERATION_T;


typedef enum 
{
    EEM_LB_GL_TOH_IN[TTT] = 5 ,         
    EEM_LB_GL_POH_IN,         
    EEM_LB_LC_FRM_IN,         
    EEM_LB_LC_FRM_OUT,      

}EEM_LOOPBACK_T;

typedef enum 
{
    EEM_LB_CLEAR[TTT] , 
    EEM_LB_SET,

}EEM_LB_ACC_T;



 


typedef union __sexar_alarm_dect[TTT]
{
    struct __alarmCtrlBit
    {

         


        int rfi:1;
        int ppi_tlct:1;  
        int ppi_crc:1;
        int ppi_oof:1;   
        int ppi_lof:1;
        int ppi_lom:1;
        int ppi_rdi:1;
        int other1:1;          

         


        int tim:1;             
        int unstablePSL:1;     
        int uneq:1;            
        int plm:1;             

        int rdi:1;             
        int unstableRDI:1;     
        int lop:1;             
        int ais:1;             
    }
    alarmCtrlBit;
    UINT16 alarmCtrl;
}
ALARM_REGISTER_T;



typedef struct
{
        SEM_ID[TTT] semInst[((1) )  + 1];
        SEM_ID semData;
        SEM_ID semLink;
        SEM_ID semFind;

         


        SEM_ID semLatchIsr;
        SEM_ID semisr;

        SEM_ID semLatchIsrClose;
        SEM_ID semisrclose;

        int latchent;
        int fpgaHanle[((1) )  + 1];
        BOOL bEM4Running;
        MSG_Q_ID EM4MsgQId;
        CAH_EM4_ENTITY_LATCH_T EM4LatchStatus[((1) )  + 1];
        BOOL EM4LatchForceRpt[((1) )  + 1];
        UINT16 IntCount[((1) )  + 1];
}
CAH_EM4_ENTITY_TRIB_T;



typedef union sexar_prbs_cfgctrl[TTT]
{
	struct __prbsCtrlBit
	{
   		UINT1   TxOHSrc:1;    
		UINT1	Unused:2;	  
		UINT1	lock:1;       
		UINT1	RxPRBS:1;     
		UINT1	TxPRBS:1;	  
        UINT1	reserved:2;	  
	} prbsCtrlBit;
	UINT1 prbsCtrl;
}__EXAR_PRBS_CTRL_T;

typedef union sexar_ais_cfgctrl[TTT]
{
	struct __aisCtrlBit
	{
   		UINT1   reserved:1;       
		UINT1   unstableC2:1;	  
		UINT1	uneq:1;           
		UINT1	plm:1;            
		UINT1	unstableJ1:1;	  
		UINT1	tim:1;	          
                                  
		UINT1	lop:1;	          
        UINT1	enable:1;	      
	} aisCtrlBit;
	UINT1 aisCtrl;
}__EXAR_AIS_CTRL_T;


typedef union sexar_insert_cfgctrl[TTT]
{
	struct __insertCtrlBit
	{
   		UINT1   F2:1;              
		UINT1   rei:2;	           
		UINT1	rdi:2;             
		UINT1	c2:1;              
		UINT1	pdi:1;             
		UINT1	ais:1;             
	} insertCtrlBit;
	UINT1 insertCtrl;
}__EXAR_INSERT_CTRL_T;


            
typedef union sexar_alarm_dect_2[TTT]
{
	struct _alarmCtrlBit_2
	{
   		UINT1   tim:1;            
		UINT1   unstableC2:1;	  
		UINT1	uneq:1;           
		UINT1	plm:1;            
		UINT1	rdi:1;	          
		UINT1	unstableRDI:1;	  
		UINT1	lop:1;	          
        UINT1	ais:1;	          
	} alarmCtrlBit;
	UINT1 alarmCtrl;
}__EXAR_ALARM_DECT_T;


 



 
WORD CAH_EM4_SetPortLoopback(DWORD dwPos, BYTE byPortNo, CTD_LOOPBACK_TYPE_T eLpbckMd);

 
WORD CAH_EM4_SetInsertAlm(DWORD dwPos, BYTE byPortNo, CTD_INSERT_ALM_TYPE_T eAlmType, CTD_INSERT_ALM_DIR_T eInsAlmDir, BOOL bEnable);
 
 
WORD CAH_EM4_GetPrbsState(DWORD dwPos, BYTE byPortNo, BOOL *bPrbsSucc);
WORD CAH_EM4_EnablePrbs (DWORD dwPos, UINT32 byPortNo, BOOL bEnable) ;
WORD CAH_EM4_GetPrbsErrCount (DWORD dwPos, UINT32 byPortNo, DWORD *dwPrbsCnt);

 
UINT32 sysTimestamp(void);
UINT32 sysTimestampFreq(void);
 
WORD CAH_EM4_GetTimingRef(DWORD dwPos, BYTE   byClockNum, BYTE    *byPort,  BOOL  *bEnable);
WORD CAH_EM4_SetTimingRef(DWORD dwPos, BYTE    byPort, BYTE   byClockNum,  BOOL  bEnable);

 
WORD CAH_EM4_GetFpgaVersion(DWORD dwPos, char *pucFpgaVer);
WORD CAH_EM4_GetPpiAlmState(DWORD dwPos, UINT8 byPortNo, CTD_PPI_ALARM_T *psPpiAlarm);
WORD CAH_EM4_GetLpAlmState(DWORD dwPos, UINT8 byPortNo, CTD_LP_ALARM_T *psLpAlarm);
WORD CAH_EM4_GetTuAlmState(DWORD dwPos, UINT8 byPortNo, CTD_TU_ALARM_T *psTuAlarm);

 
WORD CAH_EM4_getLatchStatus (DWORD dwPos);

 
WORD CAH_EM4_EnableReTiming (DWORD dwPos, BYTE byPortNo,BOOL bEnable);

 
WORD CAH_EM4_GetLpBipCount (DWORD dwPos, BYTE byPortNo, DWORD * pLpBip, DWORD * pLpRei);
WORD CAH_EM4_GetPpiBipCount(DWORD dwPos, BYTE byPortNo, DWORD *pPpiBip, DWORD *pPpiFebe);
WORD CAH_EM4_GetSlip (DWORD dwPos, BYTE byPortNo ,DWORD *pdwPSlip, DWORD *pdwNSlip);

 
WORD CAH_EM4_SetRxLpTtiMode(DWORD dwPos, UINT32 byPortNo, TTI_LEN_T eTtiMode);
WORD CAH_EM4_SetTxLpTtiMode (DWORD dwPos, UINT32 byPortNo, TTI_LEN_T eTtiMode);
WORD CAH_EM4_SetRxLpTtiAisEnable(DWORD dwPos, BYTE byPortNo, BOOL bEnable);
WORD CAH_EM4_SetRxLpTtiAlmEnable(DWORD dwPos, BYTE byPortNo, BOOL bEnable);
WORD CAH_EM4_SetRxExpLpTti (DWORD dwPos, UINT32 byPortNo, TTI_LEN_T eTtiMode, const BYTE *pbyTtiValue);
WORD CAH_EM4_SetTxLpTti (DWORD dwPos, UINT32 byPortNo, TTI_LEN_T eTtiMode, const BYTE *pbyTtiValue);
WORD CAH_EM4_GetTxLpTti(DWORD dwPos, BYTE byPortNo, TTI_LEN_T eTtiMode, BYTE *pbyTtiValue);
WORD CAH_EM4_GetRxRcvLpTti(DWORD dwPos, BYTE byPortNo, TTI_LEN_T eTtiMode, BYTE *pbyTtiValue);
WORD CAH_EM4_GetRxExpLpTti(DWORD dwPos, BYTE byPortNo, TTI_LEN_T eTtiMode, BYTE *pbyTtiValue);

 
WORD CAH_EM4_SetRxLpPslEnable(DWORD dwPos, BYTE byPortNo, BOOL bEnable);
WORD CAH_EM4_SetRxTxLpPsl(DWORD dwPos, BYTE byPortNo,  BYTE byC2Value);
WORD CAH_EM4_SetRxExpLpPsl(DWORD dwPos, BYTE byPortNo,  BYTE byC2Value);
WORD CAH_EM4_SetTxLpPsl(DWORD dwPos, BYTE byPortNo,  BYTE byC2Value);
WORD CAH_EM4_GetRxRcvLpPsl (DWORD dwPos, UINT32 byPortNo, BYTE *pbyC2Value);
WORD CAH_EM4_GetRxExpLpPsl(DWORD dwPos, BYTE byPortNo,  BYTE *byC2Value);

 
WORD CAH_EM4_DetectCardState (DWORD dwPos, BOOL * pbActive);
WORD CAH_EM4_GetInnerB1Err(DWORD dwPos, BYTE byPortNo, DWORD *pdwB1Err);
WORD CAH_EM4_GetTdmLinkErr(DWORD dwPos, DWORD *pdwTdmErr);
WORD CAH_EM4_Get8KClkState(DWORD dwPos, BOOL *pbActive);
WORD CAH_EM4_Get19MClkState(DWORD dwPos, BOOL *pbActive);
WORD CAH_EM4_GetPllState(DWORD dwPos, BOOL *pbPllLock);

  
PB_ERROR_CODE_T CAH_EM4_loadModule ();
PB_ERROR_CODE_T CAH_EM4_activateEntity(ENTITY_T entity, BOOL b_warm) ;
PB_ERROR_CODE_T CAH_EM4_deActEntity(ENTITY_T entity);
WORD CAH_EM4_InitEntity (ENTITY_T etEntity, DWORD dwPos, CTD_MODE_TYPE_T eporttype);
WORD CAH_EM4_DeInitEntity (DWORD dwPos);
WORD CAH_EM4_Initialize(DWORD dwPos);


























 


 


 



 


typedef int (*CahEm4pTransFunc[TTT]) (ENTITY_T);
 














typedef struct
{
    INT32[TTT] id;
    INT8 *pName;
    INT32 pri;
    INT32 opt;
    INT32 stckSz;
    FUNCPTR pEntryPtr;
}
CAH_EM4_TSK_CTL_BLK_T;


int buffer_reset (void);



extern int sysClkRateGet (void);
extern unsigned long GetSystemTime (void);

unsigned short em4_bpc_rd (int page, int off);
unsigned short em4Map2Wr (int page, int off, unsigned short val);
unsigned short em4Map1Wr (int page, int off, unsigned short val);
unsigned short em4MapRd (int page, int off, unsigned short *pU1, unsigned short *pU2);
unsigned short em4Map2Rd (int page, int off);
unsigned short em4Map1Rd (int page, int off);
 


int cah_em4_hash (int sn);
void cah_em4_isrFunc (FPGA_HANDLE handle, FPGA_HOOK_ARG entity);
void cah_em4_EnableLatchInt (UINT32 entity, BOOL Enable);
void cah_em4_latch ();
void cah_em4_Dpr ();
void cah_em4_readAlarm (CAH_EM4_ENTITY_DATA_T * pEntity, UINT32 ulChip, UINT32 ulPort);
E1_CALL *cah_em4_findCall2 (ENTITY_T entity, void *pfun, int arg1   ,
                                   int arg2   , int arg3   , int sn);
CAH_EM4_ENTITY_DATA_T *cah_em4_fd2entptr (int fd);
int cah_em4_trace (int level, char *msg, ...);
int cah_em4_ent2fd (ENTITY_T ent);
int cah_em4_pohWrite (void *base, int port, unsigned short reg, unsigned short val);
CAH_EM4_ENTITY_DATA_T *cah_em4_getEntityPtr (ENTITY_T entity);
int cah_em4_registerCall (PMyFun pFun, int arg3, int arg4, int arg5, int sn, char *fname);
unsigned short cah_em4_pohRead (void *base, int port, unsigned short reg);
void *cah_em4_getEntityBase (ENTITY_T ent, int port);
void cah_em4_forceAis (void *baseaddr, int port, eEM4SWITCH ais);
CAH_EM4_ENTITY_DATA_T *cah_em4_getEntity (ENTITY_T ent);
void em4_PollBit (DWORD dwPos, DWORD addrOffset, int byPortNo);

void cah_em4_getprbsname (int, char *);

DBG_MODULE_T gCahEm4DbgModNum;   
DBG_INFO_T gCahEm4DbgInfo = {    
    "EM4",                       
    {
      
      
      
     {"ERROR", 1, "error occurs."},
     {"INIT", 0, "Init info."},
     {"CFGGET", 0, "Get config information."},
     {"CFGSET", 0, "Set config information."},
     {"ALM", 0, "Alarm report information."},
     {"PMON", 0, "Performance information. "},
     {"INTR", 0, "Interrupt information. "},
     {"EGP", 0, "Egp information. "},
     {"OP", 0, "Operation information. "},
     }
};

 


CAH_EM4_ENTITY_TRIB_T gCahEm4TribVar;




CAH_EM4_ENTITY_DATA_T *gppCahEm4CfgVar[((1) )  + 1];
CAH_CFG_INFO_T gCahEm4CfgData[((1) )  + 1];

 



unsigned int g_cah_em4entity = 0;

 


unsigned int g_isrcount = 0;

 


CahEm4pTransFunc g_pTransFunc;

 


E1_CALL *gpCahEm4HashHead[((1) )  + 1][11 + 1] = { {0} };
E1_CALL gCahEm4Head[((1) )  + 1] = { {((void *)0) , 0, 0, 0, {0}, 0, 0, 0} };
E1_CALL *pCahEm4Head[((1) )  + 1];
int gCahEm4LinkFlag = 0;

 
static char g_aname[32];

 
int g_fflag = 1;

 


int gCahEm4SelectEnt = 5;
int gCahEm4SelectPort = 0;

  int g_UseInt = 1;

 
int g_waste = 0, g_wasetCnt = 10;


 





int g_crccnt = 8;
 


int gggg_cnt = 0;
UINT32 g_StampStart = 0, g_StampStop = 0;

 


int g_cnt = 14;
int g_flaggg = 0;

int nnn = 1;
int g_delay = 0;
int g_port = 0;

 



int g_testcrc = 0;
int cah_em4_blockupais = 0;
BOOL gbCahEm4RunPollingTask[3 + 1] = { 1 , 1 , 1 , 1  };
FMA_AlmModDefectFunc cah_em4_gpFunRptAlm = ((void *)0) ;
CPA_LATCHSTATE_CHANGE_FUNC cah_em4_gpFunRptLatch = ((void *)0) ;
PRA_SetPortStatus_Func cah_em4_gpFunRptPRBS = ((void *)0) ;

int gCahEm4Flag[((1) )  + 2] = { 0 };

 
char g_CahEm4Des[] = "  gCahEm4DebugLevel ::= {        1:      ,         2: how cah_em4_AlmPollingTask () is running now ?         3: how cah_em4_set_global_register () is running now ?                 how cah_em4_StopPolling ... ?                 what's the EM4_GetFarCRCErrCount () result ?                 what's the EM4_GetCRCErrCount () result ?         4: what's the cah_em4_ReportAlarm () result ?         5: none,         6: none,         7: none,         8: none,         9: 10: 11: how cah_em4_AlmPollingTask () is polling in detail ?         12: none,         13: how cah_em4_ClearAlarm ()/cah_em4_RiseAlarm () is running now ?         14: what's the indirect register's content in cah_em4_read_hardware_alarm () ?         15: watch EM4_EnablePlm ()         16: watch how is cah_em4_ReadPrbsStatus () running ?         17: watch EM4_SetTransTti ()         18: HOW EM4_GetLpPmPara () IS RUNNING NOW?         19: how are EM4_PrbsEnable ()/EM4_SetPrbsMode ()/cah_em4_getprbsstatus ()              running now ?         20: how is cah_em4_Dpr () running now ?         21: how is EM4_GetSlip () running now ?         22: how is cah_em4_latch () running now ?         23: how is EM4_GetPDHPM () running now ?         24: is there any PDH-NOTHING/SDH-NOTHING ?         33: ReadAlarm and ReportAlamr debug info.                                    // operated by polling g_testcrc(0) // control for test crc-error-counter g_UseInt=0; // if(g_UseInt == 1) the use polling to collect data,                // or use 1hz-interrupt only. int g_waste=0, g_wasetCnt=10; int g_pollcnt=0, g_hdcnt=0, }        " ;

const char *cah_em4_fmsg[] = {
    "__________________________________________________________________",
    "unsigned short\tem4Map1Wr\t(int page, int off, unsigned short val)",
    "unsigned short\tem4MapRd\t(int page, int off)",
    "unsigned short\tem4_bpc_rd\t(int page, int off)", 
    "unsigned short\tem4_bpc_wr\t(int page, int off)", 
    " ",    
    "void\tem4help\t\t(void)",
    "int\tem4BpcShow\t(void)",
    "int\tem4MapShow\t(void)",
    "int\tem4ShowCons\t(int port)",
    "int\tem4ShowEnable\t(int port)",
    "int\tem4AllInLoop\t(int flag) //backplane inloop",
    " ",
    "int\tem4ShowIntMask\t(int port)",
    "int\tem4ShowPageAddr\t(void)",
    "int\tem4ShowAlarms\t(int port)",
    "int\tem4ShowPortMap\t(void)",
    "int\tem4TtiRxTest\t(int port)",
    "int\tem4TtiTxTest\t(int port)",
    "int\tem4SetExpPslTest\t(int port, int c2)", 
    "int\tem4GetExpPslTest\t(int port)",
    "int\tem4GetExpTtiTest\t(int port)",
    "int\tem4SetExpTtiTest\t(int port)", 
    " ",
    "__________________________________________________________________",
    "",
    ((void *)0) 
};

 
static int g_phyportmap [130];
int em4ShowPortMap (void)
{
    int i = 0;

    for (i = 0; i < 130; i ++) {
        if (g_phyportmap[i] != i) {
            printf ("\r\ng_phyportmap[%3d]\t=\t[%3d]", i, g_phyportmap[i]);
        }
    }

    printf ("\r\n");
    return 0;
}


int
em4showsample (void)
{
    unsigned short u = 0;

    cah_ReadRegister (0x50000000, ((0x00 << 10) | 0x00) , &u, 0xffff, CAH_REG_ATTRBT_RO);
    printf ("\r\n%s(): devid(%x)", __FUNCTION__, u);

    cah_ReadRegister (0x50000000, (((0x00 << 10) | 0x01)) , &u, 0xffff, CAH_REG_ATTRBT_RO);
    printf ("\r\n%s(): PAGE0(%x)", __FUNCTION__, u);

    cah_ReadRegister (0x50000000, ((0x00 << 10) | 0x05) , &u, 0xffff, CAH_REG_ATTRBT_RO);
    printf ("\r\n%s(): EM4_IRQ_IN(%x)", __FUNCTION__, u);

    cah_ReadRegister (0x50000000, ((0x00 << 10) | 0x0a) , &u, 0xffff, CAH_REG_ATTRBT_RO);
    printf ("\r\n%s(): EM4_MON_INTER(%x)", __FUNCTION__, u);

    cah_ReadRegister (0x50000000, ((0x00 << 10) | 0x0b) , &u, 0xffff, CAH_REG_ATTRBT_RO);
    printf ("\r\n%s(): EM4_TIMING_SEL(%x)", __FUNCTION__, u);

    cah_ReadRegister (0x50000000, ((0x00 << 10) | 0x10) , &u, 0xffff, CAH_REG_ATTRBT_RO);
    printf ("\r\n%s(): EM4_TEST(%x)", __FUNCTION__, u);

    printf ("\r\n");
    return 0;
}



int g_cahem4version = 30;
int g_CahEm4Delay = 2;


CAH_EM4_TSK_CTL_BLK_T cah_em4_PollingTask = {
    0x00,                        
    "cahem4Poll",                
    231 ,   
    0x00,                        
    20480,                       
    (FUNCPTR) ((void *)0) 
};

CAH_EM4_TSK_CTL_BLK_T cah_em4_EpgTask = {
    0x00,                        
      "cahem4Epg",
     
    230 ,   
    0x00,                        
    20480,                       
    (FUNCPTR) cah_em4_latch
};


CAH_EM4_TSK_CTL_BLK_T cah_em4_DprTsk = {
    0x00,                        
      "cahem4Dpr",
     
    230 ,   
    0x00,                        
    20480,                       
    (FUNCPTR) cah_em4_Dpr
};


 



int gCahEm4PrbsPort = 0;

 
int g_wait = 0;

 

int gHardSlot = 0;
int gHardPort = 0;


int gCahEm4DebugLevel = 0;


 






WORD
cah_em4_deInitEntity (DWORD dwPos)
{
    WORD wRtn = ((WORD)0x0) ;

     
    memset (&gCahEm4CfgData[0], 0, sizeof (gCahEm4CfgData));
    CAH_EM4_DeInitEntity (0);

     
    return wRtn;
}



 




int
cah_em4_mapPort (int port)
{
    return ((port > 62) ? ((port + 1) - 63) : (port + 1));
}


int g_logbackn = 0;
 




int
cah_em4_port2chip (int port)
{
    if (0 > port || 125 < port)
    {
        printf ("\r\n%s: port(%d) overflow!!!", __FUNCTION__, port);
        if (g_logbackn == 1)
        {
            logBackN ("cah_em4_port2chip ", 5);
        }
    }

    return (0 <= port && 62 >= port) ? 1 : 2;
}


int
cah_em4_dwPos2id (DWORD dwPos)
{
    int id = 0;

    return (id);
}

 


int
cah_em4_dwPos2ent (DWORD dwPos)
{
    return (cah_em4_dwPos2id (dwPos));
}

 




PB_ERROR_CODE_T
cah_em4_initModule ()
{
    static int flag = 1;
    UINT8 slot;

    if (0 == flag)
    {
        return ((WORD)0x0) ;
    }
    flag = 0;

    gCahEm4DbgModNum = DBG_RegisterModule (&gCahEm4DbgInfo);

    for (slot = 0; slot < ((1) ) ; slot++)
    {
        gCahEm4TribVar.EM4LatchForceRpt[slot] = 1 ;
		 


        gppCahEm4CfgVar[slot] = ((void *)0) ;
        printf ("\r\n%s(): set gppCahEm4CfgVar[%d] to 0", __FUNCTION__, slot);
    }

    return ((WORD)0x0) ;
}




 






PB_ERROR_CODE_T
cah_em4_loadModule ()
{
    PB_ERROR_CODE_T pbRtn = ((WORD)0x0) ;

    memset (&gCahEm4CfgData, 0, sizeof (gCahEm4CfgData));
    cah_em4_initModule ();

    return pbRtn;
}

int
cah_em4_getChipBase (int slot, int chipno)
{
    int base = 0;

    base = 0;

    return (base);
}

 






void
cah_em4_Info ()
{
    DWORD dwPos;

    for (dwPos = 0; dwPos < ((1) ) ; dwPos++)
    {
        if (CTD_MODE_E1 == gCahEm4CfgData[dwPos].ePortType[0]
            || CTD_MODE_DS1 == gCahEm4CfgData[dwPos].ePortType[0])
        {
            printf ("EntityNo[%d],portType[%d],dwBaseAddr[0x%x].\r\n",
                    gCahEm4CfgData[dwPos].dwEntityNo, gCahEm4CfgData[dwPos].ePortType[0],
                    gCahEm4CfgData[dwPos].dwBaseAddr);
        }
    }
}

 


unsigned short
cah_em4_rd (void *base, int offset)
{
    unsigned short ud = 0xcc;

    ud = *((volatile unsigned short *) (base) + offset);

    return (ud);
}


 


int
cah_em4_wr (void *base, int offset, unsigned short data)
{
    *((volatile unsigned short *) (base) + offset) = data;

    return 0;
}

 



int
cah_em4_enableLatchIntr (void *baseaddr, int flag)
{
    unsigned short u = 0;

    if (flag)
    {
        u = 0x0001;              
    }
    else
    {
        u = 0x0000;
    }

    cah_WriteRegister ((DWORD) baseaddr, ((0x00 << 10) | 0X09) , u, 0x00ff, CAH_REG_ATTRBT_RW);



    return (((WORD)0x0) );
}


 


void
cah_em4_pollBitDmapper (unsigned short *baseaddr, int offset)
{
    int i = 0;
    unsigned short u = 0x0000;

    for (;;)
    {
        u = cah_em4_rd (baseaddr, offset);
        if ((u & 0x8000))
        {
            i = i + 1;
            if (i >= 100)
            {
                printf ("\r\n%s(): FATAL ERROR ON INDRECT REG ACCESS", __FUNCTION__);
                break;
            }
        }
        else
        {
            break;
        }
    }
}


 


void
cah_em4_pollBit (unsigned short *baseaddr, int offset)
{
    int i = 0;
    unsigned short u = 0x0000;

    for (;;)
    {
        u = cah_em4_rd (baseaddr, offset);
        if ((u & 0x8000))
        {
            i = i + 1;
            if (i >= 100)
			{
				printf ("\r\n%s():\t register unstable forever!!!", __FUNCTION__);
                break;
			}
        } else {
            break;
        }
    }
}


 


void
cah_em4_enablePlm (void *baseaddr, UINT32 ulChip, UINT32 ulPort, int mode)
{
    unsigned short u = 0x0000;

     


    cah_em4_wr (baseaddr, (0x02 << 10) | 0x01 ,          0x8000 + (ulPort << 8) + 0x00 );
    cah_em4_pollBit ((unsigned short *) baseaddr, (0x02 << 10) | 0x01 );
    u = cah_em4_rd (baseaddr, (0x02 << 10) | 0x03 );

    u &= ~0x0004;
    u |= (mode ? 1 : 0) << 2;

    cah_em4_wr (baseaddr, (0x02 << 10) | 0x02 , u);

    cah_em4_wr (baseaddr, (0x02 << 10) | 0x01 , 0xc000 + (ulPort << 8) + 0x00 );
    cah_em4_pollBit ((unsigned short *) baseaddr, (0x02 << 10) | 0x01 );

     


    cah_em4_wr (baseaddr, (0x02 << 10) | 0x01 ,   0x8000 + (ulPort << 8) + 0x01 );
    cah_em4_pollBit ((unsigned short *) baseaddr, (0x02 << 10) | 0x01 );
    u = cah_em4_rd (baseaddr, (0x02 << 10) | 0x03 );

    if (1 == mode)
    {
         
        u &= ~0x0040;
        u |= 0x0010;
    }
    else
    {
        u &= ~0x0040;
        u &= ~0x0010;
    }
    u |= (0x0020 | 0x0080);
    cah_em4_wr (baseaddr, (0x02 << 10) | 0x02 , u);
    cah_em4_wr (baseaddr, (0x02 << 10) | 0x01 , 0xc000 + (ulPort << 8) + 0x01 );
    cah_em4_pollBit ((unsigned short *) baseaddr, (0x02 << 10) | 0x01 );
}

 


int
cah_em4_setPrbs (void *baseaddr, eEM4SWITCH flag)
{
    unsigned short u = 0;

    if (eEM4_ENABLE == flag)
    {
        u |= 0x0001;
    }
    else
    {
        u &= ~0x0001;
    }
    cah_em4_wr (baseaddr, (0x04 << 10) | 0x47 , u);
    return (((WORD)0x0) );
}

 



void
cah_em4_enableTim (void *baseaddr, UINT32 ulChip, UINT32 ulPort, int mode)
{
    unsigned short u = 0x0000;

     


    cah_em4_wr (baseaddr, (0x02 << 10) | 0x01 ,         
                0x8000 + (ulPort << 8) + 0x00 );
    cah_em4_pollBit ((unsigned short *) baseaddr, (0x02 << 10) | 0x01 );
    u = cah_em4_rd (baseaddr, (0x02 << 10) | 0x03 );

    u &= ~(0x0001 + 0x0080);
    u |= (mode ? (1 + 0x0080) : 0);

    cah_em4_wr (baseaddr, (0x02 << 10) | 0x02 , u);
    cah_em4_wr (baseaddr, (0x02 << 10) | 0x01 , 0xc000 + (ulPort << 8) + 0x00 );
    cah_em4_pollBit ((unsigned short *) baseaddr, (0x02 << 10) | 0x01 );

     


    cah_em4_wr (baseaddr, (0x02 << 10) | 0x01 ,   0x8000 + (ulPort << 8) + 0x01 );
    cah_em4_pollBit ((unsigned short *) baseaddr, (0x02 << 10) | 0x01 );
    u = cah_em4_rd (baseaddr, (0x02 << 10) | 0x03 );

    if (1 == mode)
    {
        u |= 0x0008;
        u |= 0x0004;
    }
    else
    {
        u &= ~0x0008;
        u &= ~0x0004;
    }

    u |= (0x0020 | 0x0080);
    cah_em4_wr (baseaddr, (0x02 << 10) | 0x02 , u);
    cah_em4_wr (baseaddr, (0x02 << 10) | 0x01 , 0xc000 + (ulPort << 8) + 0x01 );
    cah_em4_pollBit ((unsigned short *) baseaddr, (0x02 << 10) | 0x01 );
}
 



void
cah_em4_enableTimRdi (void *baseaddr, UINT32 ulChip, UINT32 ulPort, int mode)
{
    unsigned short u = 0x0000;

     


    cah_em4_wr (baseaddr, (0x02 << 10) | 0x01 ,         
                0x8000 + (ulPort << 8) + 0x00 );
    cah_em4_pollBit ((unsigned short *) baseaddr, (0x02 << 10) | 0x01 );
    u = cah_em4_rd (baseaddr, (0x02 << 10) | 0x03 );

    u &= ~(0x0001 + 0x0080);
    u |= (mode ? (1 + 0x0080) : 0);

    cah_em4_wr (baseaddr, (0x02 << 10) | 0x02 , u);
    cah_em4_wr (baseaddr, (0x02 << 10) | 0x01 , 0xc000 + (ulPort << 8) + 0x00 );
    cah_em4_pollBit ((unsigned short *) baseaddr, (0x02 << 10) | 0x01 );

     


    cah_em4_wr (baseaddr, (0x02 << 10) | 0x01 ,   0x8000 + (ulPort << 8) + 0x01 );
    cah_em4_pollBit ((unsigned short *) baseaddr, (0x02 << 10) | 0x01 );
    u = cah_em4_rd (baseaddr, (0x02 << 10) | 0x03 );

    if (1 == mode)
    {
        u |= 0x0008;
         
    }
    else
    {
        u &= ~0x0008;
         
    }

    u |= (0x0020 | 0x0080);
    cah_em4_wr (baseaddr, (0x02 << 10) | 0x02 , u);
    cah_em4_wr (baseaddr, (0x02 << 10) | 0x01 , 0xc000 + (ulPort << 8) + 0x01 );
    cah_em4_pollBit ((unsigned short *) baseaddr, (0x02 << 10) | 0x01 );
}

 



void
cah_em4_enableTimAis (void *baseaddr, UINT32 ulChip, UINT32 ulPort, int mode)
{
    unsigned short u = 0x0000;

     


    cah_em4_wr (baseaddr, (0x02 << 10) | 0x01 ,         
                0x8000 + (ulPort << 8) + 0x00 );
    cah_em4_pollBit ((unsigned short *) baseaddr, (0x02 << 10) | 0x01 );
    u = cah_em4_rd (baseaddr, (0x02 << 10) | 0x03 );

    u &= ~(0x0001 + 0x0080);
    u |= (mode ? (1 + 0x0080) : 0);

    cah_em4_wr (baseaddr, (0x02 << 10) | 0x02 , u);
    cah_em4_wr (baseaddr, (0x02 << 10) | 0x01 , 0xc000 + (ulPort << 8) + 0x00 );
    cah_em4_pollBit ((unsigned short *) baseaddr, (0x02 << 10) | 0x01 );

     


    cah_em4_wr (baseaddr, (0x02 << 10) | 0x01 ,   0x8000 + (ulPort << 8) + 0x01 );
    cah_em4_pollBit ((unsigned short *) baseaddr, (0x02 << 10) | 0x01 );
    u = cah_em4_rd (baseaddr, (0x02 << 10) | 0x03 );

    if (1 == mode)
    {
         
        u |= 0x0004;
    }
    else
    {
         
        u &= ~0x0004;
    }

    u |= (0x0020 | 0x0080);
    cah_em4_wr (baseaddr, (0x02 << 10) | 0x02 , u);
    cah_em4_wr (baseaddr, (0x02 << 10) | 0x01 , 0xc000 + (ulPort << 8) + 0x01 );
    cah_em4_pollBit ((unsigned short *) baseaddr, (0x02 << 10) | 0x01 );
}


 


void
cah_em4_setTtiMode (void *baseaddr, UINT32 ulChip, UINT32 ulPort, int mode)
{
    unsigned short u = 0x0000;

    cah_em4_wr (baseaddr, (0x02 << 10) | 0x01 ,   0x8000 + (ulPort << 8) + 0x01 );
    cah_em4_pollBit ((unsigned short *) baseaddr, (0x02 << 10) | 0x01 );
    u = cah_em4_rd (baseaddr, (0x02 << 10) | 0x03 );

    u &= ~0x0001;
    u |= mode;

    u |= (0x0020 | 0x0080);
    cah_em4_wr (baseaddr, (0x02 << 10) | 0x02 , u);
    cah_em4_wr (baseaddr, (0x02 << 10) | 0x01 , 0xc000 + (ulPort << 8) + 0x01 );
    cah_em4_pollBit ((unsigned short *) baseaddr, (0x02 << 10) | 0x01 );
}


 



void
cah_em4_setPrbs2 (void *baseaddr, int port, eEM4SWITCH flag)
{
     


    cah_em4_wr (baseaddr, (0x04 << 10) | 0x30 , port);
    cah_em4_setPrbs (baseaddr, flag);
}


 


void
cah_em4_initERdi (void *baseaddr, eEM4SWITCH flag)
{
     


    unsigned short u = 0;


    cah_ReadRegister ((DWORD) baseaddr, (0x04 << 10) | 0x42 , &u, 0xffff, CAH_REG_ATTRBT_RO);



    if (eEM4_ENABLE == flag)
    {
        u |= 0x0001;
    }
    else
    {
        u &= ~0x0001;
    }


    cah_WriteRegister ((DWORD) baseaddr, (0x04 << 10) | 0x42 , u, 0xffff, CAH_REG_ATTRBT_RW);



}


 




void
cah_em4_forceAis (void *baseaddr, int port, eEM4SWITCH ais)
{
    unsigned short u1 = 0;

    cah_em4_wr (baseaddr, (0x04 << 10) | 0x30 , port);
    u1 = cah_em4_rd (baseaddr, (   (0x04 << 10) | 0x40 ));
    if (gCahEm4SelectPort == port)
        cah_em4_trace (40 , "%s: base(%x), offset(%x), port(%d), u1(%x)",
                       __FUNCTION__, baseaddr, (0x04 << 10) | 0x40 , port, u1);

    if (eEM4_ENABLE == ais)
    {
        if (u1 & 0x8000)
        {
            if (gCahEm4SelectPort == port)
                cah_em4_trace (40 , "already set, skip");
            goto endfrcais;
        }
        else
        {
            if (gCahEm4SelectPort == port)
                cah_em4_trace (40 , "set tu-asi insertion");
            u1 |= 0x8000;
        }
    }
    else
    {
        if (u1 & 0x8000)
        {
            if (gCahEm4SelectPort == port)
                cah_em4_trace (40 , "clear tu-asi insertion");
            u1 &= ~0x8000;
        }
        else
        {
            if (gCahEm4SelectPort == port)
                cah_em4_trace (40 , "already cleared, skip");
            goto endfrcais;
        }
    }
    cah_em4_wr (baseaddr, (   (0x04 << 10) | 0x40 ), u1);
  endfrcais:

  return;
}

void
cah_em4_forceRdi (void *baseaddr, int port, eEM4SWITCH rdi)
{
    unsigned short u = 0;

    cah_em4_wr (baseaddr, (0x04 << 10) | 0x30 , port);
    u = cah_em4_rd (baseaddr, (0x04 << 10) | 0x40 );

    if (eEM4_ENABLE == rdi)
    {
        if ((u & 0x0001) && !(u & 0x0002))
        {
            goto endFrcrdi;
        }
        else
        {
            u |= 0x0001;
            u &= ~0x0002;
        }
    }
    else
    {
        if ((u & 0x0002) && !(u & 0x0001))
        {
            goto endFrcrdi;
        }
        else
        {
            u |= 0x0002;
            u &= (~0x0001);
        }
    }
    cah_em4_wr (baseaddr, (0x04 << 10) | 0x40 , u);
  endFrcrdi:

  return;
}

int
cah_em4_initReiRdiRfi (void *baseaddr, eEM4SWITCH rei, eEM4SWITCH rdi, eEM4SWITCH rfi)
{
    unsigned short u = 0;

    u = cah_em4_rd (baseaddr, (0x04 << 10) | 0x40 );

    if (eEM4_ENABLE == rei)
    {
        u |= 0x0080;
    }
    else
    {
        u &= (~0x0080);
    }


    if (eEM4_ENABLE == rdi)
    {
        u |= 0x0002;
    }
    else
    {
        u &= (~0x0002);
    }

    if (eEM4_ENABLE == rfi)
    {
        u |= 0x0020;
    }
    else
    {
        u &= (~0x0020);
    }

    cah_em4_wr (baseaddr, (0x04 << 10) | 0x40 , u);
    return (((WORD)0x0) );

}


int
cah_em4_initPsl (void *baseaddr, unsigned short psl)
{
    unsigned short u = 0;

    u = cah_em4_rd (baseaddr, (0x04 << 10) | 0x40 );
    u &= 0xffe3;
    u &= ~0x0020;                
    u |= ((psl & 0x0007) << 2);
    cah_em4_wr (baseaddr, (0x04 << 10) | 0x40 , u);
    return (((WORD)0x0) );
}

void
em4SetPsl2 (void *baseaddr, unsigned short port, unsigned short psl)
{
    unsigned short u = 0;

    cah_em4_wr (baseaddr, (0x04 << 10) | 0x30 , port);
    u = cah_em4_rd (baseaddr, (0x04 << 10) | 0x40 );
    u &= 0xffe3;                 
    u &= ~0x0020;
    u |= ((psl & 0x0007) << 2);
    cah_em4_wr (baseaddr, (0x04 << 10) | 0x40 , u);
}


void
em4SetPsl (int ent, unsigned short port, unsigned short psl)
{
    void *baseaddr = ((void *)0) ;

    if (((void *)0)  == cah_em4_getEntity (ent))
    {
        printf ("\r\nent(%d) NOT active", ent);
        return;
    }

    baseaddr = cah_em4_getEntityBase (ent, port);

    em4SetPsl2 (baseaddr, port, psl);
}



int
cah_em4_setTxj2 (void *baseaddr, const unsigned char *j2)
{
    int r = 0;

    if (((void *)0)  == j2)
    {
        printf ("\r\nem4_set_j2: j2 NULL");
        return (r = -1);
    }

    cah_em4_wr (baseaddr, (((0x04 << 10) | 0x50 ) + 0), (unsigned short) j2[0] | (j2[1] << 8));
    cah_em4_wr (baseaddr, (((0x04 << 10) | 0x50 ) + 1), (unsigned short) j2[2] | (j2[3] << 8));
    cah_em4_wr (baseaddr, (((0x04 << 10) | 0x50 ) + 2), (unsigned short) j2[4] | (j2[5] << 8));
    cah_em4_wr (baseaddr, (((0x04 << 10) | 0x50 ) + 3), (unsigned short) j2[6] | (j2[7] << 8));
    cah_em4_wr (baseaddr, (((0x04 << 10) | 0x50 ) + 4), (unsigned short) j2[8] | (j2[9] << 8));
    cah_em4_wr (baseaddr, (((0x04 << 10) | 0x50 ) + 5), (unsigned short) j2[10] | (j2[11] << 8));
    cah_em4_wr (baseaddr, (((0x04 << 10) | 0x50 ) + 6), (unsigned short) j2[12] | (j2[13] << 8));
    cah_em4_wr (baseaddr, (((0x04 << 10) | 0x50 ) + 7), (unsigned short) j2[14] | (j2[15] << 8));

    return (((WORD)0x0) );
}

void
cahem4setTxj2_2 (void *baseaddr, unsigned short port, const unsigned char *j2)
{
    cah_em4_wr (baseaddr, (0x04 << 10) | 0x30 , port);
    cah_em4_setTxj2 (baseaddr, j2);
}


int
cah_em4_setConsequentAction (void *baseaddr, int port, eEM4SWITCH uneqrdi, eEM4SWITCH plmrdi,
                             eEM4SWITCH uneqais, eEM4SWITCH plmais, eEM4SWITCH timrdi,
                             eEM4SWITCH timais, int ttimode)
{
     



    unsigned short u = 0;

    if (eEM4_ENABLE == uneqrdi)
    {
        u |= 0x0080;
    }
    else
    {
        u &= ~0x0080;
    }

    if (eEM4_ENABLE == plmrdi)
    {
        u |= 0x0040;
    }
    else
    {
        u &= ~0x0040;
    }

    if (eEM4_ENABLE == uneqais)
    {
        u &= ~0x0020;
    }
    else
    {
        u |= 0x0020;
    }

    if (eEM4_ENABLE == plmais)
    {
        u &= ~0x0010;
    }
    else
    {
        u |= 0x0010;
    }


    if (eEM4_ENABLE == timrdi)
    {
        u |= 0x0008;
    }
    else
    {
        u &= ~0x0008;
    }

    if (eEM4_ENABLE == timais)
    {
        u &= ~0x0004;
    }
    else
    {
        u |= 0x0004;
    }

    if (eEM4_ENABLE == ttimode)
    {
        u &= ~0x0001;
    }
    else
    {
        u |= 0x0001;
    }

    cah_em4_wr (baseaddr, (0x02 << 10) | 0x02 , u);
    cah_em4_wr (baseaddr, (0x02 << 10) | 0x01 , 0xc000 + (port << 8) + 0x01 );
    cah_em4_pollBit ((unsigned short *) baseaddr, (0x02 << 10) | 0x01 );

    return (((WORD)0x0) );
}


int
cah_em4_setDegThreshold (void *baseaddr, int port, unsigned short threshold)
{
    cah_em4_wr (baseaddr, (0x02 << 10) | 0x02 , threshold);
    cah_em4_wr (baseaddr, (0x02 << 10) | 0x01 , 0xc000 + (port << 8) + ((0x02 << 10) | 0x20 ));
    cah_em4_pollBit ((unsigned short *) baseaddr, (0x02 << 10) | 0x01 );
    return (((WORD)0x0) );
}



void
cah_em4_getTslNow (void *baseaddr, int port, unsigned short *tslexp)
{
    unsigned short u = 0;

    cah_em4_wr (baseaddr, (0x02 << 10) | 0x01 ,   0x8000 + (port << 8) + 0x0d );
    cah_em4_pollBit ((unsigned short *) baseaddr, (0x02 << 10) | 0x01 );
    u = cah_em4_rd (baseaddr, (0x02 << 10) | 0x03 );
    *tslexp = ((u & 0x7000) >> 12);
}

void
em4GetTslAcc (int ent, int port)
{
    unsigned short tsl;
    void *baseaddr = ((void *)0) ;

    if (((void *)0)  == cah_em4_getEntity (ent))
    {
        printf ("\r\nent(%d) NOT active", ent);
        return;
    }

    baseaddr = cah_em4_getEntityBase (ent, port);

    cah_em4_getTslNow (baseaddr, port, &tsl);
    printf ("\r\nent(%d), port(%d), accepted psl(0x%x)", ent, port, tsl & 0x0007);
    printf ("\r\n");
}

void
cah_em4_get_j2exp (void *baseaddr, int port, unsigned char *j2exp)
{
    unsigned short u = 0;
    int i = 0;

	printf ("\r\n%s(): base(%p), port(%d)", __FUNCTION__, baseaddr, port);
    for (i = 0; i < 8; i++)
    {
        cah_em4_wr (baseaddr, (0x02 << 10) | 0x01 , 0x8000 + (port << 8) + (0X20  + i));
        cah_em4_pollBit ((unsigned short *) baseaddr, (0x02 << 10) | 0x01 );
        u = cah_em4_rd (baseaddr, (0x02 << 10) | 0x03 );
		j2exp[i * 2] = u & 0x00ff;
		j2exp[i * 2 + 1] = (u >> 8) & 0x00ff;
    }
}



void
cah_em4_set_j2exp (void *baseaddr, int port, const unsigned char *j2exp)
{
    unsigned short u = 0;
    int i = 0;

    for (i = 0; i < 8; i++)
    {
        u = j2exp[i * 2] + (j2exp[i * 2 + 1] << 8);
        cah_em4_wr (baseaddr, (0x02 << 10) | 0x02 , u);
        cah_em4_wr (baseaddr, (0x02 << 10) | 0x01 , 0xc000 + (port << 8) + (0X20  + i));
        cah_em4_pollBit ((unsigned short *) baseaddr, (0x02 << 10) | 0x01 );
    }
}

 


int
em4ShowJ2Exp (int entity, int port)
{
    unsigned short u = 0;
    int i = 0;
    void *baseaddr = (void *) 0;

    baseaddr = cah_em4_getEntityBase (entity, port);

    if ((void *) 0 == baseaddr)
    {
        printf ("\r\nentity(%d) not active", entity);
        return (0);
    }
    for (i = 0; i < 8; i++)
    {

        cah_WriteRegister ((DWORD) baseaddr, (0x02 << 10) | 0x01 ,      
                           0x8000 + (port << 8) + (0X20  + i), 0x7f3f,
                           CAH_REG_ATTRBT_RW);




        cah_em4_pollBit ((unsigned short *) baseaddr, (0x02 << 10) | 0x01 );

        cah_ReadRegister ((DWORD) baseaddr, (0x02 << 10) | 0x03 , &u, 0xffff, CAH_REG_ATTRBT_RO);



        printf ("\r\nj2exp[%2d]=[%x]", i * 2, u & 0x00ff);
        printf ("\r\nj2exp[%2d]=[%x]", i * 2 + 1, (u & 0xff00) >> 8);
    }
    printf ("\r\n");

    return (0);
}


void
cah_em4_getJ2Acc (void *baseaddr, int port, unsigned char *j2exp)
{
    unsigned short u = 0;
    int i = 0;

    for (i = 0; i < 16; i++)
    {
        cah_em4_wr (baseaddr, (0x02 << 10) | 0x01 ,     
                    0x8000 + (port << 8) + (0x10  + i));
        cah_em4_pollBit ((unsigned short *) baseaddr, (0x02 << 10) | 0x01 );
        u = cah_em4_rd (baseaddr, (0x02 << 10) | 0x03 );
        *(j2exp + i) = u & (0x00ff);
         
    }
}


int
cah_em4_setIntMask (void *baseaddr, int port, eEM4SWITCH tsl, eEM4SWITCH rdi, eEM4SWITCH uneq,
                    eEM4SWITCH plm, eEM4SWITCH tim, eEM4SWITCH erdi, unsigned short tslexp)
{
    unsigned short u = 0;


    if (eEM4_ENABLE == tsl)
    {
        u |= 0x0100;
    }
    else
    {
        u &= ~0x0100;
    }

    if (eEM4_ENABLE == rdi)
    {
        u |= 0x0010;
    }
    else
    {
        u &= ~0x0010;
    }
    if (eEM4_ENABLE == uneq)
    {
        u |= 0x0008;
    }
    else
    {
        u &= ~0x0008;
    }
    if (eEM4_ENABLE == plm)
    {
        u |= 0x0004;
    }
    else
    {
        u &= ~0x0004;
    }
    if (eEM4_ENABLE == tim)
    {
        u |= 0x0001;
    }
    else
    {
        u &= ~0x0001;
    }
    if (eEM4_ENABLE == erdi)
    {
        u |= 0x0200;
    }
    else
    {
        u &= ~0x0200;
    }

    u &= ~0x3800;
    u |= ((tslexp & 0x0007) << 11);

    u |= 0xc000;                 

    cah_em4_wr (baseaddr, (0x02 << 10) | 0x02 , u);
    cah_em4_wr (baseaddr, (0x02 << 10) | 0x01 , 0xc000 + (port << 8) + 0x00 );
    cah_em4_pollBit ((unsigned short *) baseaddr, (0x02 << 10) | 0x01 );
    return (((WORD)0x0) );
}

void
em4SetPslexp (void *baseaddr, unsigned short port, unsigned short pslexp)
{
    unsigned short u = 0x0000;

    u = cah_em4_pohRead (baseaddr, port, 0x00 );
    u &= (~0x3800);
    u |= ((pslexp & 0x0007) << 11);

    cah_em4_wr (baseaddr, (0x02 << 10) | 0x02 , u);
    cah_em4_wr (baseaddr, (0x02 << 10) | 0x01 , 0xc000 + (port << 8) + 0x00 );
    cah_em4_pollBit ((unsigned short *) baseaddr, (0x02 << 10) | 0x01 );
}



int
cah_em4_set_inloopretiming (void *baseaddr, int port, eEM4SWITCH inloop, eEM4SWITCH retiming)
{
    unsigned short u = 0;

    u = cah_em4_rd (baseaddr, ((0x05 << 10) | 0x100 ) + port);


    if (eEM4_ENABLE == retiming)
    {
        u |= 0x0001;
    }
    else
    {
        u &= ~0x0001;
    }

    cah_em4_wr (baseaddr, ((0x05 << 10) | 0x100 ) + port, u);

    return (((WORD)0x0) );
}




UINT16 cah_em4_PollBusyBit(UINT32 dwBaseAddr, UINT32 dwOffset)
{
    UINT16    wcnt     = 0x0;
    UINT16    wdelay   = 0x0;
    UINT16    wdummy   = 0x0;
    
    while (((UINT16)(*(volatile UINT16*)( (UINT32)(dwBaseAddr + (dwOffset * 2)) )))  & 0x8000 )
    {
        if (wcnt++ > 50 )
        {
            return ((UINT16)0x4) ;
        }
        
        for (wdelay = 0; wdelay < 100 ; wdelay++)
        {
            wdummy = wdummy + wdelay;
        }
    }
    
    return ((WORD)0x0) ;
}

 
typedef enum
{
    EM4_REG_ATTRBT_RW[TTT]   = 0x0,
    EM4_REG_ATTRBT_RO   = 0x1,
    EM4_REG_ATTRBT_WO   = 0x2,
    EM4_REG_ATTRBT_RC   = 0x3,
    EM4_REG_ATTRBT_WC   = 0x4,
}EM4_REG_ATTRBT_T;

UINT16 cah_em4_WriteRegister(UINT32 dwBaseAddr,         UINT32 dwOffset,         UINT16 wValue,         UINT16 wMask,         EM4_REG_ATTRBT_T eRegAttrbt)




{
    UINT32   dwAbsAddr          = 0x0;
    UINT16   wCurRegValue       = 0x0;
    UINT16   wShouldWrtValue    = 0x0;
    UINT16   wRtn               = ((WORD)0x0) ;

     
    dwAbsAddr = (UINT32)(dwBaseAddr + (dwOffset * 2));
     
    wCurRegValue = ((UINT16)(*(volatile UINT16*)( dwAbsAddr ))) ;
     
    wShouldWrtValue = (UINT16)((wValue & wMask) | (wCurRegValue & (~wMask)));
     
    ((UINT16)(*(volatile UINT16*)( dwAbsAddr )))  = wShouldWrtValue;

     
    


     
    return wRtn;
}



UINT16 cah_em4_ReadRegister(UINT32 dwBaseAddr, UINT32 dwOffset, UINT16 *pwValue, UINT16 wMask, EM4_REG_ATTRBT_T eRegAttrbt)
{
    UINT32   dwAbsAddr       = 0x0;
    UINT16   wCurRegValue    = 0x0;
    UINT16   wRtn            = ((WORD)0x0) ;

    if (((void *)0)  != pwValue)
    {
         
        dwAbsAddr = (UINT32)(dwBaseAddr + (dwOffset * 2));
         
        wCurRegValue = ((UINT16)(*(volatile UINT16*)( dwAbsAddr ))) ;
         
        *pwValue = (UINT16)(wCurRegValue & wMask);

         
        if (EM4_REG_ATTRBT_WC == eRegAttrbt)
        {
             
            ((UINT16)(*(volatile UINT16*)( dwAbsAddr )))  = wMask;
        }
        
         
        if (EM4_REG_ATTRBT_RW == eRegAttrbt)
        {          
            if (0xcccc!= ((UINT16)(*(volatile UINT16*)( ((0x00 << 10) | 0x10)  ))) )
            {
                wRtn = ((UINT16)0x2) ;
            }
        }
    }
    else
    {
        wRtn = ((UINT16)0x1) ;
    }
    
     
    return wRtn;
}



UINT16 cah_em4_IndRead(UINT32 dwbaseAddr ,     UINT32 dwaddrIndAddr ,     UINT32 addrIndData ,     UINT16 waddr ,     UINT16 *pwvalue,     UINT16 wMaskval,     UINT16 wMaskaddr)






{
    UINT16 wRtn    = ((WORD)0x0) ;

     
    wRtn |= cah_em4_PollBusyBit(dwbaseAddr, dwaddrIndAddr);
    if (((WORD)0x0)  != wRtn)
    {
        return ((UINT16)0x8) ;
    }

     
    wRtn |= cah_em4_WriteRegister(dwbaseAddr, dwaddrIndAddr, ((waddr & (~0x4000 )) | 0x8000 ), wMaskaddr, EM4_REG_ATTRBT_WO);
	
     
    wRtn |= cah_em4_PollBusyBit(dwbaseAddr, dwaddrIndAddr);
    if (((WORD)0x0)  != wRtn)
    {
        return ((UINT16)0x8) ;
    }

     
    wRtn |= cah_em4_ReadRegister(dwbaseAddr, addrIndData , pwvalue, wMaskval, EM4_REG_ATTRBT_RO);

    return ((WORD)0x0) ;
}



 



PB_ERROR_CODE_T
cah_em4_setPdhPortMode (ENTITY_T entity, UINT32 ulChip, UINT32 ulPort, PDH_PORT_MODE_T type)
{
    void *base = 0x0000;
    int port = 0;
    unsigned short u = 0x0000;
    CAH_EM4_ENTITY_DATA_T *pEntity = ((void *)0) ;

    pEntity = cah_em4_getEntityPtr (entity);
    cah_em4_registerCall ((PMyFun) cah_em4_setPdhPortMode, (int) ulPort, (int) type, 0, 11, __FUNCTION__);

    if (pEntity->state != eEm4EntAct)
    {
        return PB_ERR_STATE;
    }
    base = (void *) cah_em4_getEntityBase (entity, ulPort);
    u = cah_em4_pohRead (base, port = ulPort, 0x00 );
    u &= ~0x000c;                
    cah_em4_pohWrite (base, port, 0x00 , u);

    return ((WORD)0x0) ;
}

int cah_em4_gete1outloop (void * base, int port)
{
	unsigned short loop = 0;
	int byte = 0;
	int bit = 0;

	byte = (port / 16);
	bit = (port % 16);
	
	loop = cah_em4_rd (base, (((0x04 << 10) | 0x10 ) + byte));

    return (loop & (0x0001 << bit)) ? 1:0;
}


int cah_em4_e1outloop (void * base, int port, int enable)
{
	unsigned short loop = 0;
	int byte = 0;
	int bit = 0;

	byte = (port / 16);
	bit = (port % 16);
	
	loop = cah_em4_rd (base, (((0x04 << 10) | 0x10 ) + byte));
	if (enable)
	{
		loop |= (0x0001 << bit);
	} else {
		loop &= ~(0x0001 << bit);
	}

	cah_em4_wr (base, (((0x04 << 10) | 0x10 ) + byte), loop);

	return ((WORD)0x0) ;
}

int cah_em4_e1inloop (void * base, int port, int enable)
{
	unsigned short loop = 0;
	
	loop = cah_em4_rd (base, (((0x05 << 10) | 0x100 ) + port));
	if (enable)
	{
		loop |= (0x0002);
	} else {
		loop &= ~(0x0002);
	}

	cah_em4_wr (base, (((0x05 << 10) | 0x100 ) + port), loop);

	return ((WORD)0x0) ;
}
 


WORD
CAH_EM4_SetPortLoopback (DWORD dwPos, BYTE byPortNo, CTD_LOOPBACK_TYPE_T eLpbckMd)
{
    WORD wRtn = ((WORD)0x0) ;
	int port = 0;
	void * base = 0;

	{if (125 <  SDD_126xE1IOPortConvert(byPortNo) ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  SDD_126xE1IOPortConvert(byPortNo) ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;
    cah_em4_registerCall ((PMyFun) CAH_EM4_SetPortLoopback, (int) SDD_126xE1IOPortConvert(byPortNo), (int) eLpbckMd, 0, 16, __FUNCTION__);
	port = cah_em4_mapPort (SDD_126xE1IOPortConvert(byPortNo)) - 1;
	base = cah_em4_getEntityBase (0, SDD_126xE1IOPortConvert(byPortNo));

    switch (eLpbckMd)
    {
    case CTD_LOOPBACK_TYPE_NONE:
		cah_em4_e1inloop (base, port, CTD_LOOPBACK_TYPE_NONE);
		cah_em4_e1outloop (base, port, CTD_LOOPBACK_TYPE_NONE);
        break;

    case CTD_LOOPBACK_TYPE_INWARD_NEAR:
        break;

    case CTD_LOOPBACK_TYPE_OUTWARD_FAR:
        break;

    case CTD_LOOPBACK_TYPE_OUTWARD_NEAR:
         
         

		cah_em4_e1inloop (base, port, eLpbckMd);
        break;

    case CTD_LOOPBACK_TYPE_INWARD_FAR:
         
         

		cah_em4_e1outloop (base, port, eLpbckMd);
		return ((WORD)0x0) ;
        break;

    default:
        wRtn = ((WORD)0x1) ;
		return wRtn;
    }

    return wRtn;
}

 


PB_ERROR_CODE_T
cah_em4_prbsEnable (ENTITY_T entity, UINT32 ulChip, UINT32 ulPort, BOOL bEnable)
{
    CAH_EM4_ENTITY_DATA_T *pEntity;
    PB_ERROR_CODE_T ret = ((WORD)0x0) ;
    void *base = 0x0000;
     
     


    if ((((  entity   >= ((1) ) )) || ((   ulChip  )  >=  (1) ) || ((   ulPort  ) >= (63 ) ) ) )
    {
        printf ("\r\n%s!  Entity= %d; File=%s; Line=%d  \r\n", __FUNCTION__, entity, "cah_126e1.c",
                1758);
        return PB_ERR_PARAM;
    }

    pEntity = cah_em4_getEntityPtr (entity);
    cah_em4_registerCall ((PMyFun) cah_em4_prbsEnable, (int) ulPort, (int) bEnable, 0, 16, __FUNCTION__);

    if (pEntity->state != eEm4EntAct)
    {
        return PB_ERR_STATE;
    }

    if (bEnable)
    {
         


        base = (void *) cah_em4_getEntityBase (entity, ulPort);
        cah_em4_setPrbs2 (base, ulPort, eEM4_ENABLE);

        ret = ((WORD)0x0) ;
        if (((WORD)0x0)  == ret)
        {
            pEntity->chip_var[ulChip].prbsCfg[ulPort].prbsMode = PRBS_MODE_POWER15;
            pEntity->chip_var[ulChip].prbsCfg[ulPort].prbsStatus = PRBS_STATUS_SYNCING;
            pEntity->chip_var[ulChip].prbsCfg[ulPort].prbsErrCnt = 0;
        }
    }
    else
    {
        base = (void *) cah_em4_getEntityBase (entity, ulPort);
        cah_em4_setPrbs2 (base, ulPort, eEM4_DISABLE);
        ret = ((WORD)0x0) ;
        if (((WORD)0x0)  == ret)
        {
            pEntity->chip_var[ulChip].prbsCfg[ulPort].prbsMode = PRBS_MODE_NA;
            pEntity->chip_var[ulChip].prbsCfg[ulPort].prbsStatus = PRBS_STATUS_NA;
            pEntity->chip_var[ulChip].prbsCfg[ulPort].prbsErrCnt = 0;
        }
    }

    if (((WORD)0x0)  != ret)
    {
        printf ("\r\n%s!  Entity= %d; File=%s; Line=%d  \r\n", __FUNCTION__, entity, "cah_126e1.c",
                1802);
        return ((WORD)0x1) ;
    }

    pEntity->chip_var[ulChip].prbsCfg[ulPort].bForceRpt = 1 ;
    cah_em4_trace (19, "%s: entity(%d), port(%d), flag(%d)", __FUNCTION__, entity, ulPort, bEnable);

    return ((WORD)0x0) ;
}

double cah_em4_wasteOfTime (void);


int g_ulport = 200;


UINT16
cah_em4_readPdhAlarm(void *base, int port)
{
    unsigned short val = 0, val1 = 0;

    int i = 0   ;

    g_waste = 1 + cah_em4_wr (base, (0x04 << 10) | 0x17 , port | 0x8000);   
    for (;;)
    {
if (0) taskDelay (1);            
else cah_em4_wasteOfTime ();
        val = cah_em4_rd (base, (0x04 << 10) | 0x17 );
        if (0 == (val & 0x8000))
        {
            break;
        }
        else
        {
            i = i + 1;
            if (i >= 100)
            {
                printf ("\r\n%s():\tbase(%p), port(%d), FATAL ERROR INDIRECT REG ACCESS ERROR !!!", __FUNCTION__, base, port);
                { { if (DBG_GetLevel(  gCahDbgModuleNo ,     CAH_DEBUG_LEVEL_ERROR  )) {printf("[%s] %d: ", "cah_126e1.c", 1852); printf   ("\r\ncah_em4_readPdhAlarm():\tbase(%p), port(%d), FATAL ERROR INDIRECT REG ACCESS ERROR !!!\r\n", base, port)  ;} if (DBG_NvGetLevel(  gCahDbgModuleNo ,     CAH_DEBUG_LEVEL_ERROR  ))    ; } ; } ;
                break;
            }
        }
    }

    val 	= cah_em4_rd (base, (0x04 << 10) | 0x1b ) & 0x0007;
    val1 	= cah_em4_rd (base, (0x04 << 10) | 0x1c ) & 0x0001;
    if (port == g_ulport)
    {
        printf ("\r\ncah_em4_readPdhAlarm:port(%d), val(%x), val1(%x)", port, val, val1);
    }

    val     = val & 0x0007;
    val1    = val1 & 0x0001;
	val 	= val | ((val1 & 0x0001) ? 0x0008 : 0x0000);

    return (val);
}


static double gCahEm4Time = 0;

double cah_em4_wasteOfTime ()
{
    static double ary [16];
    double r = 0.0;
    int i = 0;

    for (i = 0; i < 5; i ++)
    {
        r = ary[i] = ary[i+1] * ary[i+2] / ary[i+3];
    }

    gCahEm4Time = r;

    return r;
}

int g_inderr = 1;


UINT32
cah_em4_readCrc4RemoteReg (void *base, int port, UINT16 *pNear, UINT16 *pRemote)
{
    UINT16 val;
    
    int i = 0   ;
    g_waste = 1 + cah_em4_wr (base, (0x04 << 10) | 0x18 , port | 0x8000);   
    for (;;)
    {
        val = cah_em4_rd (base, (0x04 << 10) | 0x18 );
        if (0 == (val & 0x8000))
        {
            break;
        }
        else
        {
            i = i + 1;
if (0) taskDelay (1);            
else cah_em4_wasteOfTime ();
            if (i >= 100)
            {
                if (g_inderr)
                printf ("\r\n%s():\tbase(%p), port(%d), FATAL ERROR ON INDIRECT REG ACCESS", __FUNCTION__, base, port);
                break;
            }
        }
    }
    val = cah_em4_rd (base, (0x04 << 10) | 0x1a );
    *pNear = val;

    val = cah_em4_rd (base, (0x04 << 10) | 0x19 );
    val &= ~0xfc00;                
    *pRemote = val;

    return val;
}



UINT32
cah_em4_readCrc4Reg (void *base, int port)
{
    UINT16 val;
    








    int i = 0   ;
    g_waste = 1 + cah_em4_wr (base, (0x04 << 10) | 0x18 , port | 0x8000);   
    for (;;)
    {
        val = cah_em4_rd (base, (0x04 << 10) | 0x18 );
        if (0 == (val & 0x8000))
        {
            break;
        }
        else
        {
            i = i + 1;
if (0) taskDelay (1);            
else cah_em4_wasteOfTime ();
            if (i >= 100)
            {
                if (g_inderr)
                printf ("\r\n%s():\tbase(%p), port(%d), FATAL ERROR ON INDIRECT REG ACCESS", __FUNCTION__, base, port);
                break;
            }
        }
    }
    val = cah_em4_rd (base, (0x04 << 10) | 0x1a );

    return val;
}






unsigned short
cah_em4_getFarCrcErrCount (void *base, int port)
{
    unsigned short u = 0;








    int i = 0;
    cah_em4_wr (base, (0x04 << 10) | 0x18 , port | 0x8000);         
    for (;;)
    {
        u = cah_em4_rd (base, (0x04 << 10) | 0x18 );
        if (0 == (u & 0x8000))
        {
            break;
        }
        else
        {
            i = i + 1;
if (0) taskDelay (1);            
else cah_em4_wasteOfTime ();
            if (i >= 100)
            {
if (g_inderr)
                printf ("\r\n%s():\tbase(%p), port(%d), FATAL ERROR ON INDRECT REG ACCESS", __FUNCTION__, base, port);
                break;
            }
        }
    }
    u = cah_em4_rd (base, (0x04 << 10) | 0x19 );
    u &= ~0xfc00;                



    return u;
}






inline int
cah_em4_ent2chipno (ENTITY_T entity)
{
    return cah_em4_ent2fd (entity);
}



 


PB_ERROR_CODE_T
cah_em4_insertUpAis (ENTITY_T entity, UINT32 ulChip, UINT32 ulPort, BOOL bEnable)
{
    CAH_EM4_ENTITY_DATA_T *pEntity;
     


    if (cah_em4_blockupais && bEnable)
    {
        printf ("\r\n%s, has been blocked! entity%d ulChip%d ulPort%d \r\n", __FUNCTION__, entity,
                ulChip, ulChip);
        bEnable = 0 ;
    }

    if ((((  entity   >= ((1) ) )) || ((   ulChip  )  >=  (1) ) || ((   ulPort  ) >= (63 ) ) ) )
    {
        printf ("\r\n%s!  Entity= %d; File=%s; Line=%d  \r\n", __FUNCTION__, entity, "cah_126e1.c",
                2247);
        return PB_ERR_PARAM;
    }

    pEntity = cah_em4_getEntityPtr (entity);

    if (pEntity->state != eEm4EntAct)
    {
        printf ("\r\n%s!  Entity= %d; File=%s; Line=%d  \r\n", __FUNCTION__, entity, "cah_126e1.c",
                2256);
        return PB_ERR_STATE;
    }

    return ((WORD)0x0) ;
}

extern STATUS vxMemProbe(char * adrs, int mode, int length, char * pVal);

 



PB_ERROR_CODE_T
cah_em4_detectCardStateEx (CAH_EM4_ENTITY_DATA_T * pEntity, BOOL * pbActive)
{
    void *base = (void *) 0;
    unsigned short val = 0;
    static int flag = 1;
    volatile unsigned short *p = ((void *)0) ;

    *pbActive = 0 ;
     


	base = cah_em4_getEntityBase(0, 3);
    p = (unsigned short *)0x50000020;
    if (-1 == vxMemProbe((char *)p, 0 , 2, (char *)&val))
    {
 
        *pbActive = 0 ;
        return ((WORD)0x0) ;
    } else {
   
    }

    p = (unsigned short *)0x60000020;
    if (-1 == vxMemProbe((char *)p, 0 , 2, (char *)&val))
    {
    
        *pbActive = 0 ;
        return ((WORD)0x0) ;
    } else {
     
    }

     
    val = cah_em4_rd (base, (((0x00 << 10) | 0x01)) );
    if (0x28 == (val&0xff))
    {
        if (flag)
            printf ("\r\ndetect(TRUE), base(%x), val(%x)", (int) base, val);
        *pbActive = 1 ;
    }
    else
    {
        printf ("\r\ndetect(FALSE), base(%x), val(%x)", (int) base, val);
        *pbActive = 0 ;
    }

	base = cah_em4_getEntityBase(0, 77);
     
    val = cah_em4_rd (base, (((0x00 << 10) | 0x01)) );
    if (0x28 == (val&0xff))
    {
        if (flag)
            printf ("\r\ndetect(TRUE), base(%x), val(%x)", (int) base, val);
        *pbActive = 1 ;
    }
    else
    {
        printf ("\r\ndetect(FALSE), base(%x), val(%x)", (int) base, val);
        *pbActive = 0 ;
    }
 
    flag = 0;

    return ((WORD)0x0) ;
}







 





















 




void
cah_em4_showbuild (void)
{
    printf ("\r\n>>>>> EM4: this load is build at (%s):(%s)(%s) <<<<<\r\n", "Apr 13 2009", "15:08:05",
            __FUNCTION__);
}

 



int
cah_em4_show (char *fmt, ...)
{
    va_list argptr;
    int cnt;

    printf ("\r\n");
    (__builtin_next_arg (  fmt ), __builtin_memcpy ((  argptr  ), __builtin_saveregs (), sizeof(__gnuc_va_list)) ) ;
    cnt = vprintf (fmt, argptr);
    ((void)0) ;

    return (cnt);
}

 






int
em4help (void)
{
    int i = 0;

    printf ("\r\nEM4 version(%d)", g_cahem4version);

    while (cah_em4_fmsg[i] != ((void *)0) )
    {
        cah_em4_show ("%s", cah_em4_fmsg[i]);
        i++;
    }

    return 0;

}



 


int
cah_em4_portCfg2 (void *baseaddr)
{
    int port = 0;
    char *j2 = "FPGA_BENCH_T";
    int j = 0, i = 0;
    int r = 0;
    
    cah_em4_wr(baseaddr, (0x02 << 10) | 0x00 , 0x8000);
    taskDelay (10);
    cah_em4_wr(baseaddr, (0x02 << 10) | 0x00 , 0x0001);
    
    for (port = 0; port < (63 ) ; port++)
    {
         



		cah_em4_wr (baseaddr, (0x02 << 10) | 0x02 , 0xd3ff);
         

		cah_em4_wr (baseaddr, (0x02 << 10) | 0x01 , 0xc000+(port << 8) + 0);
         

        taskDelay (2);
		cah_em4_wr (baseaddr, (0x02 << 10) | 0x02 , 0x01c8);
         

		cah_em4_wr (baseaddr, (0x02 << 10) | 0x01 , 0xc000+(port << 8) + 1);
         
        taskDelay (2);

        if ((port << 10))
        {
            for (i = 0; i < 16; i++)
            {
                if (((WORD)0x0)  !=
                    (r = cah_em4_setDegThreshold (baseaddr, port, (j2[1] << 8) + 0x80 + j2[0])))
                {
                    printf ("\r\ncah_em4_setDegThreshold () failed");
                    return (r);
                }
                for (j = 1; j < 8; j++)
                {
                    if (((WORD)0x0)  !=
                        (r =
                         cah_em4_setDegThreshold (baseaddr, port,
                                                  (j2[j * 2 + 1] << 8) + j2[j * 2])))
                    {
                        printf ("\r\ncah_em4_setDegThreshold() failed");
                        return (r);
                    }
                }
            }
        }
        else
        {
            for (i = 0; i < 16; i++)
            {
                if (((WORD)0x0)  !=
                    (r = cah_em4_setDegThreshold (baseaddr, port, (j2[1] << 8) + 0x80 + j2[0])))
                {
                    printf ("\r\ncah_em4_setDegThreshold () failed");
                    return (r);
                }

                for (j = 1; j < 8; j++)
                {
                    if (((WORD)0x0)  !=
                        (r =
                         cah_em4_setDegThreshold (baseaddr, port,
                                                  (j2[j * 2 + 1] << 8) + j2[j * 2])))
                    {
                        printf ("\r\ncah_em4_setDegThreshold () failed");
                        return (r);
                    }
                }
            }
        }
    }

    return 0;
}

int
cah_em4_portCfg1 (void *baseaddr)
{
    char buffer[256];
    int port = 0;
    char *j2 = "FPGA_BENCH_T";
    int r = 0;
    unsigned short u = 0;


     


    for (port = 0; port < (63 ) ; port++)
    {
         



        cah_em4_wr (baseaddr, (0x04 << 10) | 0x30 , port);       
        cah_em4_wr (baseaddr, (0x04 << 10) | 0x40 , 0x8a);
        cah_em4_wr (baseaddr, (0x04 << 10) | 0x47 , 0);
        cah_em4_wr (baseaddr, (0x04 << 10) | 0x41 , 0);

         
        u = 0;





  

 
         sprintf (buffer, "%s%d", j2, port);
        if (((WORD)0x0)  != (r = cah_em4_setTxj2 (baseaddr, (const unsigned char *) buffer)))
        {
            printf ("\r\n%s(): cah_em4_setTxj2() failed", __FUNCTION__);
            return (r);
        }
    }
    return (((WORD)0x0) );
}



void
e1_init (void)
{
    printf ("\r\nInitialize 63-E1 Mapper (%x) : version (%x)(%x)", (0x50000000) , em4Map1Rd (0, 0),
            em4Map2Rd (0, 0));
    em4Map1Wr (0, 1, 0x29);
    taskDelay (sysClkRateGet () / 4);
    em4Map1Wr (0, 1, 0x28);

    taskDelay (sysClkRateGet () / 2);

    printf ("\r\nInitialize DCM monitor interval to 15ms ");
    em4Map1Wr (0, 0x0a, 0x3200);
}

int gCahEm4Print = 0;
int
cah_em4_printf (char *msg, ...)
{
    va_list argptr;
    int cnt = 0;

    if (0 == gCahEm4Print) 
    {
        taskDelay (3);
        return 0;
    }

    if (1 == gCahEm4Print)
    {
        printf ("\r\n");
        (__builtin_next_arg (  msg ), __builtin_memcpy ((  argptr  ), __builtin_saveregs (), sizeof(__gnuc_va_list)) ) ;
        cnt = vprintf (msg, argptr);
        ((void)0) ;
    }

    return (cnt);
}



void
e1_dcm_state (void *baseaddr)
{
    unsigned short v = 0;

    v = cah_em4_rd (baseaddr, ((0x00 << 10) | 0x0a) );
    if (v & 0x80)
    {
        printf ("\r\nDCM: locked");
    }
    else
    {
        printf ("\r\nDCM: UNlocked!");
    }
    printf ("\r\n monitored at interval 15 ms, resetted ");
}

 




















































extern UINT8 GetSlotNumber(void);



 





































































































































void cah_em4_e1desync_default(void *baseaddr)
{
    int i=0;   
    unsigned short u = 0;
    cah_em4_printf("\r\nDesync: set to 32-byte fifo with center 12");
    cah_em4_wr (baseaddr, (0x05 << 10) | 0x00 , 0x30c);
    cah_em4_wr (baseaddr, ((0x05 << 10) | 0x00 ) | 0x0c, 0);
    cah_em4_wr (baseaddr, ((0x05 << 10) | 0x00 ) | 0x0d, 0);
    cah_em4_wr (baseaddr, ((0x05 << 10) | 0x00 ) | 0x0e, 0);
    cah_em4_wr (baseaddr, ((0x05 << 10) | 0x00 ) | 0x0f, 0);
    
    cah_em4_printf ("\r\nInitial desynchronizer (macro): ");
    for (i = 0; i < (63 ) ; i++)
    {      
        u = cah_em4_rd (baseaddr, (0x05 << 10) |( 0x100+ i));
        u &= ~0x0007;
        cah_em4_wr (baseaddr, (0x05 << 10) |( 0x100+ i), u );        
    }

}
void cah_em4_e1sync_default(void *baseaddr)
{
      cah_em4_printf("\r\nsync: set LIU fall edge");
       
     cah_em4_wr (baseaddr, (0x04 << 10) | 0x00 , 0x0010);
     cah_em4_printf("\r\nall ports are set E1");
     cah_em4_wr (baseaddr, (0x04 << 10) | 0x0c, 0);
     cah_em4_wr (baseaddr, (0x04 << 10) | 0x0d, 0);
     cah_em4_wr (baseaddr, (0x04 << 10) | 0x0e, 0);
     cah_em4_wr (baseaddr, (0x04 << 10) | 0x0f, 0);
}
void  cah_em4_e1_tb_outloop_disable(void *baseaddr)
{    
    unsigned short u = 0;
    u=cah_em4_rd(baseaddr,(((0x00 << 10) | 0x01)) );
    u=u& 0xfffd;
    cah_em4_wr (baseaddr, (((0x00 << 10) | 0x01)) ,u);
     
    u=cah_em4_rd(baseaddr,(0x04 << 10) | 0x00 );
    u=u|0x0010;
    cah_em4_wr (baseaddr, (0x04 << 10) | 0x00 ,u);
    
}
void cah_em4_e1_poh_rx_mask_int(void *baseaddr)
{
    int i=0;
    cah_em4_printf ("\r\ndisable plmais and timais");
    for (i = 0; i < (63 ) ; i++)
    {                     
        cah_em4_wr (baseaddr, (0x02 << 10) | 0x02 , 0x1000);
        cah_em4_wr (baseaddr, (0x02 << 10) | 0x01 , 0xc000 + (i << 8) + 0x00 );
        cah_em4_pollBit ((unsigned short *) baseaddr, (0x02 << 10) | 0x01 );
    }
}


void cah_em4_e1_poh_set_degrade (void *baseaddr,int level,int thr,int period)
{

    cah_em4_printf ("\r\nSet poh rx degrade ...");
    cah_em4_wr(baseaddr, (0x02 << 10) | (0x020+2*(level&0x07)), (thr&0x7f)+((period&0xff)<<8)  );
    cah_em4_wr(baseaddr, (0x02 << 10) | (0x021+2*(level&0x07)), ((period&0xffff00)>>8)  );
}

void cah_em4_e1_poh_clr_degrade (void *baseaddr,int level,int thr,int period)
{

    cah_em4_printf ("\r\nSet poh rx degrade ...");
    cah_em4_wr(baseaddr, (0x02 << 10) | (0x030+2*(level&0x07)), (thr&0x7f)+((period&0xff)<<8)  );
    cah_em4_wr(baseaddr, (0x02 << 10) | (0x031+2*(level&0x07)), ((period&0xffff00)>>8)  );
}

int
cah_em4_setGlobalRegister (void *baseaddr)
{
    int r = 0;
    int j1_locked = 0;
    int i = 0;
     
     

    cah_em4_printf ("\r\n%s(): base(%p)", __FUNCTION__, baseaddr);
    
    
 
    cah_em4_printf ("\r\nInitialize 63-E1 Mapper (%p) : version (%x)", baseaddr, em4Map1Rd (0, 0));
    cah_em4_wr (baseaddr, (((0x00 << 10) | 0x01)) , 0x29);
     
    taskDelay (10);
    cah_em4_wr (baseaddr, (((0x00 << 10) | 0x01)) , 0x28);
     
    taskDelay (40);
    
     












    cah_em4_printf ("\r\nInitialize DCM monitor interval to 15ms ");
    cah_em4_wr(baseaddr, ((0x00 << 10) | 0x0a) , 0x3200);
    
    if ((((WORD)0x0)  != (r = cah_em4_portCfg1 (baseaddr))))
    {
        cah_em4_printf ("\r\n%s(): cah_em4_portCfg1() failed", __FUNCTION__);
        return (r);
    }



      
    
    cah_em4_trace (3, "e1j2 set");

    cah_em4_wr (baseaddr, (0x02 << 10) | 0x00 , 0x8000);
     
   taskDelay (sysClkRateGet () / 2);
    cah_em4_wr (baseaddr, (0x02 << 10) | 0x00 , 0x0001);
    taskDelay (sysClkRateGet () / 2);
    

    

    
    cah_em4_trace (3, "e1ram reset");
    if (((WORD)0x0)  != (r = cah_em4_portCfg2 (baseaddr)))
    {
        cah_em4_printf ("\r\ncah_em4_portCfg2 () failed");
        return (r);
    }



    cah_em4_trace (3, "e1rx&tx set");
    cah_em4_printf ("\r\nResetting mapper ...");
    cah_em4_wr (baseaddr, (0x04 << 10) | 0x00 , 0x0119);
     
    taskDelay (40);
    cah_em4_wr (baseaddr, (0x04 << 10) | 0x00 , 0x0118);
    
    cah_em4_printf ("\r\nwait for telecom bus stable ...");
    
     
    j1_locked = 0;
    while (j1_locked == 0)
    {
        j1_locked = cah_em4_rd (baseaddr, (0x05 << 10) | 0x00 ) & 0x80;
    }
     

    
    cah_em4_printf ("\r\nResetting demapper ...");
    cah_em4_wr (baseaddr, (0x05 << 10) | 0x00 , 0x8004);
     
     
    taskDelay (50);
    cah_em4_wr (baseaddr, (0x05 << 10) | 0x00 , 0x0004);
    cah_em4_printf ("\r\nResetting poh ...");
    cah_em4_wr (baseaddr, (0x02 << 10) | 0x00 , 0x8000);
      
    taskDelay (50);
    cah_em4_wr (baseaddr, (0x02 << 10) | 0x00 , 0x0000);
    e1_dcm_state (baseaddr);
    cah_em4_printf ("\r\nWaiting DCM stablized ...");
     
    taskDelay (50);
    e1_dcm_state (baseaddr);
     
    
     
    cah_em4_e1desync_default(baseaddr);
    cah_em4_e1sync_default(baseaddr);
    
    cah_em4_printf ("\r\ndisable plmais and timais");
    for (i = 0; i < (63 ) ; i++)
    {                     
        cah_em4_wr (baseaddr, (0x02 << 10) | 0x02 , 0x01c8);
        cah_em4_wr (baseaddr, (0x02 << 10) | 0x01 , 0xc000 + (i << 8) + 0x01 );
        cah_em4_pollBit ((unsigned short *) baseaddr, (0x02 << 10) | 0x01 );
    }


     cah_em4_e1_tb_outloop_disable(baseaddr);
     cah_em4_e1_poh_rx_mask_int(baseaddr);

     cah_em4_e1_poh_set_degrade (baseaddr,0,40,16000);
     cah_em4_e1_poh_clr_degrade(baseaddr,0,6,16000);
     	
     cah_em4_e1_poh_set_degrade (baseaddr,1,80,16000);     
     cah_em4_e1_poh_clr_degrade(baseaddr,1,8,16000);
     
     
    cah_em4_wr (baseaddr, (0x05 << 10) | 0x200 , (0x3f)  | ((0x3f)  << 8));
    cah_em4_wr (baseaddr, (0x05 << 10) | 0x201 , (0x3f)  | ((0x3f)  << 8));


    
    cah_Write8Reg (0x70000000 ,  
                    0x1b  + 0, 
                    0x07,  
                    0x07,  
                    CAH_REG_ATTRBT_RW);
    cah_Write8Reg (0x70000000 ,  
                    0x1b  + 1,  
                    0x07,  
                    0x07,  
                    CAH_REG_ATTRBT_RW);
    cah_Write8Reg (0x70000000 ,  
                    0x1b  + 2,  
                    0x07,  
                    0x07,  
                    CAH_REG_ATTRBT_RW);
    cah_Write8Reg (0x70000000 ,  
                    0x1b  + 3, 
                    0x07,  
                    0x07,  
                    CAH_REG_ATTRBT_RW);
    return ((WORD)0x0) ;
}




 


PB_ERROR_CODE_T
cah_em4_initChip (ENTITY_T entity)
{

    cah_em4_printf ("\r\n%s: ent(%d), base address(0x%x)", __FUNCTION__, entity, (int) (0x50000000) );
    cah_em4_printf ("\r\n%s: setGlobalRegister-1", __FUNCTION__);
    if (((WORD)0x0)  != cah_em4_setGlobalRegister ((void *) (0x50000000) ))
    {
        cah_em4_printf ("\r\n%s(): set map1 failed", __FUNCTION__);
        return ((WORD)0x1) ;
    }

    cah_em4_printf ("\r\n%s: ent(%d), base address(0x%x)", __FUNCTION__, entity, (int) (0x60000000) );
    cah_em4_printf ("\r\n%s: setGlobalRegister-2", __FUNCTION__);
    if (((WORD)0x0)  != cah_em4_setGlobalRegister ((void *) (0x60000000) ))
    {
        cah_em4_printf ("\r\n%s(): set map2 failed", __FUNCTION__);
        return ((WORD)0x1) ;
    }
    
    return ((WORD)0x0) ;
}





 



void
cah_em4_InitAlmID (CAH_EM4_ENTITY_DATA_T * pEntity, int ulChip, int ulPort)
{
    pEntity->chip_var[ulChip].pohAlm[ulPort].almID[0] = 34 ;
    pEntity->chip_var[ulChip].pohAlm[ulPort].almID[1] = 32 ;
    pEntity->chip_var[ulChip].pohAlm[ulPort].almID[2] = 36 ;
    pEntity->chip_var[ulChip].pohAlm[ulPort].almID[3] = 39 ;
    pEntity->chip_var[ulChip].pohAlm[ulPort].almID[4] = 37 ;
    pEntity->chip_var[ulChip].pohAlm[ulPort].almID[5] = 38 ;
    pEntity->chip_var[ulChip].pohAlm[ulPort].almID[6] = 91 ;
    pEntity->chip_var[ulChip].pohAlm[ulPort].almID[7] = 92 ;
    pEntity->chip_var[ulChip].pohAlm[ulPort].almID[8] = 42 ;
     


    pEntity->chip_var[ulChip].pohAlm[ulPort].almID[9] = 232 ;
    pEntity->chip_var[ulChip].pohAlm[ulPort].almID[10] = 233 ;
    pEntity->chip_var[ulChip].pohAlm[ulPort].almID[11] = 235 ;
    pEntity->chip_var[ulChip].pohAlm[ulPort].almID[12] = 230 ;
    pEntity->chip_var[ulChip].pohAlm[ulPort].almID[13] = 231 ;




}

void
cah_em4_initVars (CAH_EM4_ENTITY_DATA_T * pEntity, int chipNum)
{
    UINT32 ulChip, ulPort;

    for (ulChip = 0; (int)ulChip < chipNum; ulChip++)
    {
        for (ulPort = 0; ulPort < (63 ) ; ulPort++)
        {
             


            pEntity->chip_var[ulChip].bPlmEnable[ulPort] = 0 ;
            pEntity->chip_var[ulChip].bTimEnable[ulPort] = 0 ;
            pEntity->chip_var[ulChip].bRestrainRDI[ulPort] = 0 ;
            pEntity->chip_var[ulChip].bBlockAis[ulPort] = 0 ;
            pEntity->chip_var[ulChip].adminState[ulPort] = PORT_STATE_UP;
            pEntity->chip_var[ulChip].faisMode[ulPort] =   0;
            pEntity->chip_var[ulChip].frdiMode[ulPort] = EM4_NONE_FORCE;
            pEntity->chip_var[ulChip].loopMode[ulPort] = PORT_LOOP_NONE;
            pEntity->chip_var[ulChip].portType[ulPort] = PDH_MODE_E1;
            memset((INT1 *)( &pEntity->chip_var[ulChip].prbsCfg[ulPort] ), (  0 ), (  sizeof (EM4_PRBS_CONFIG_T) )) ;
            pEntity->chip_var[ulChip].prbsCfg[ulPort].prbsMode = PRBS_MODE_NA;

             


            pEntity->chip_var[ulChip].strExpJ2[ulPort].J2Mode = PbTIModeType_modeFixedOneByte;
            pEntity->chip_var[ulChip].strTranJ2[ulPort].J2Mode = PbTIModeType_modeFixedOneByte;
            pEntity->chip_var[ulChip].strRcvJ2[ulPort].J2Mode = PbTIModeType_modeFixedOneByte;
            memset((INT1 *)( pEntity->chip_var[ulChip].strExpJ2[ulPort].J2Data ), (  0 ), (  64  + 1 )) ;
            memset((INT1 *)( pEntity->chip_var[ulChip].strTranJ2[ulPort].J2Data ), (  0 ), (  64  + 1 )) ;
            memset((INT1 *)( pEntity->chip_var[ulChip].strRcvJ2[ulPort].J2Data ), (  0 ), (  64  + 1 )) ;

             


            pEntity->chip_var[ulChip].ExpPSL[ulPort] = 0;
            pEntity->chip_var[ulChip].RcvPSL[ulPort] = 0;
            pEntity->chip_var[ulChip].TranPSL[ulPort] = 0;

             


            pEntity->chip_var[ulChip].forceRptAlm[ulPort] = 1 ;
            pEntity->chip_var[ulChip].pohAlm[ulPort].ssf = 0;
            pEntity->chip_var[ulChip].pohAlm[ulPort].ssfFc = 0;
            pEntity->chip_var[ulChip].pohAlm[ulPort].rdi = 0;
            pEntity->chip_var[ulChip].pohAlm[ulPort].rfi = 0;
            pEntity->chip_var[ulChip].pohAlm[ulPort].rdiFc = 0;
            pEntity->chip_var[ulChip].pohAlm[ulPort].rfiFc = 0;
            pEntity->chip_var[ulChip].pohAlm[ulPort].e1rdiFc = 0;

            cah_em4_InitAlmID (pEntity, ulChip, ulPort);
        }
    }
}

int
cah_em4_chkdwPos (DWORD dwPos)
{
    return 0;
}

int
cah_em4_chkId (ENTITY_T entity, int port)
{
    unsigned short u = 0x0000;

    u = cah_em4_rd (cah_em4_getEntityBase (entity, port), ((0x00 << 10) | 0x00) );
    if (0x8915  != u)
    {
        return 0;
    }
    else
    {
        return 1;
    }
}

 






















int
cah_em4_revise (int isCall)
{
    E1_CALL *ppp = ((void *)0) , *ppp1 = ((void *)0) ;
	ENTITY_T entity = 0;
    int fd = 0;
    int j = 0;

    fd = cah_em4_ent2fd (entity);
    printf ("\r\n%s: entity(%d), fd(%d), isCall(%s)", __FUNCTION__, entity, fd,
            isCall ? "CALL" : "CLEAR");
    if (((void *)0)  == pCahEm4Head[fd])
    {
        printf ("\r\n%s, pointer NULL entity(%d)", __FUNCTION__, entity);
        return (0);
    }

    ppp1 = pCahEm4Head[fd];

    for (;;)
    {
        ppp = ppp1;
        if (1 == isCall)
        {
            if (((void *)0)  == ppp->p)
            {
                printf ("\r\npCahEm4Head[%d]->p NULL", fd);
                break;
            }
            else
            {
                 
                if (5 == ppp->sn || 6 == ppp->sn)
                {
                    (*(ppp->p)) (ppp->arg1, ppp->arg3, ppp->arg4.tti, ppp->arg5, ppp->arg6, ppp->arg2);
                }
                else
                {
                    (*(ppp->p)) (ppp->arg1, ppp->arg3, ppp->arg4.arg, ppp->arg5, ppp->arg6, ppp->arg2);
                }
            }
        }

        ppp1 = ppp1->pNext;
        if (0 == isCall)
        {
            if (((void *)0)  == pCahEm4Head[fd]->pNext)
            {
                printf ("\r\nEM4 link empty");
                break;
            }
            pCahEm4Head[fd] = pCahEm4Head[fd]->pNext;
            ppp->pNext = ((void *)0) ;
            free (ppp);
            ppp = ((void *)0) ;
        }
        if (ppp1)
        {
            if (((void *)0)  == ppp1->p)
            {
                printf ("\r\nem4 link end!!!");
                if (0 == isCall)
                    for (j = 0; j < 11; j++)
                    {
                        gpCahEm4HashHead[fd][j] = &gCahEm4Head[fd];
                    }
                break;
            }
            if (((void *)0)  == ppp1->pNext)
            {
                printf ("\r\nEM4 link empty");
                if (0 == isCall)
                    for (j = 0; j < 11; j++)
                    {
                        gpCahEm4HashHead[fd][j] = &gCahEm4Head[fd];
                    }
                break;
            }
        }
        else
        {
            printf ("\r\nlink end for NULL");
            if (0 == isCall)
                for (j = 0; j < 11; j++)
                {
                    gpCahEm4HashHead[fd][j] = &gCahEm4Head[fd];
                }
            break;
        }
    }

    return (0);
}



 


void
cah_em4_initLink (void)
{
    int i = 0, j = 0;

    for (i = 0; i < ((1) ) ; i++)
    {
        pCahEm4Head[i] = &gCahEm4Head[i];
        for (j = 0; j < 11; j++)
        {
            gpCahEm4HashHead[i][j] = &gCahEm4Head[i];
        }
        memset (&gCahEm4Head[i], 0, sizeof (E1_CALL));
    }
}



 


int
cah_em4_registerCall (PMyFun pFun, int port, int arg4, int arg5, int sn, char *fname)
{
    E1_CALL *p = ((void *)0) , *pold = ((void *)0) ;
    int fd = 0;
    int hash = 0;

    if (0 == gCahEm4LinkFlag)
    {
        cah_em4_initLink ();
        gCahEm4LinkFlag = 1;
    }
    fd = cah_em4_ent2fd (0);

if (1) return 0;

    pold = ((void *)0) ;

    pold = cah_em4_findCall2 (0, pFun, 0, 0, port, sn);
    if (pold)
    {
        pold->p = pFun;
        pold->arg1 = 0;
        pold->arg2 = 0;
        pold->arg3 = port;

         


        if (5 == sn || 6 == sn)
        {
            memcpy (pold->arg4.tti, (unsigned char *) arg4, 16);
        }
        else
        {
            pold->arg4.arg = arg4;
        }
        pold->arg5 = arg5;
        pold->arg6 = arg5;
        pold->sn = sn;

        return (0);
    }

    if (((void *)0)  == (p = (E1_CALL *) malloc (sizeof (E1_CALL))))
    {
        printf ("\r\n%s: malloc error", __FUNCTION__);
        return (0);
    }
    p->id = pCahEm4Head[fd]->id + 1;
    p->p = pFun;
    p->arg1 = 0;
    p->arg2 = 0;
    p->arg3 = port;
    memcpy (p->fname, fname, strlen (fname));
    if (5 == sn || 6 == sn)
    {
        memcpy (p->arg4.tti, (unsigned char *) arg4, 16);
    }
    else
    {
        p->arg4.arg = arg4;
    }
    p->arg5 = arg5;
    p->arg6 = arg5;
    p->sn = sn;

    p->pNext = pCahEm4Head[fd];
     
    hash = cah_em4_hash (sn);
    p->pHashNext[hash] = gpCahEm4HashHead[fd][hash];     
    pCahEm4Head[fd] = p;
    gpCahEm4HashHead[fd][hash] = p;      

    return (0);
}




 


int
cahem4tree (void)
{
    E1_CALL *ppp = ((void *)0) , *ppp1 = ((void *)0) ;
    int fd = 0;
	ENTITY_T entity = 0;

    if (((void *)0)  == cah_em4_getEntity (entity))
    {
        printf ("\r\nEnt(%d) NOT active", entity);
        return (0);
    }

    fd = cah_em4_ent2fd (entity);
    if (((void *)0)  == pCahEm4Head[fd])
    {
        printf ("\r\n%s, pointer NULL entity(%d)", __FUNCTION__, entity);
        return (0);
    }

    ppp1 = pCahEm4Head[fd];

    for (;;)
    {
        ppp = ppp1;
        if (1)
        {
            if (((void *)0)  == ppp->p)
            {
                printf ("\r\npCahEm4Head[%d]->p NULL", fd);
                break;
            }
            else
            {
                 
                if (5 == ppp->sn || 6 == ppp->sn)
                {
                    printf ("\r\nid(%2d), arg3(%d), arg4(%d), sn(%3d), n(%s)",
                            ppp->id, ppp->arg3, ppp->arg4.arg, ppp->sn,
                            ppp->fname);
                }
                else
                {
                    printf ("\r\nid(%2d), arg3(%d), arg4(%d), sn(%3d), n(%s)",
                            ppp->id, ppp->arg3, ppp->arg4.arg, ppp->sn,
                            ppp->fname);
                }
            }
        }

        ppp1 = ppp1->pNext;
        if (0)
        {
            pCahEm4Head[fd] = pCahEm4Head[fd]->pNext;
            ppp->pNext = ((void *)0) ;
            free (ppp);
            ppp = ((void *)0) ;
        }
        if (((void *)0)  == ppp1->p)
        {
            printf ("\r\nem4 link end!!!");
            break;
        }
    }

    return (0);
}




  










E1_CALL *
cah_em4_findCall2 (ENTITY_T entity, void *pfun, int arg1   ,
                   int arg2   ,
                   int arg3   ,
                   int sn)
{
    E1_CALL *ppp = ((void *)0) , *ppp1 = ((void *)0) ;
    E1_CALL *pr = ((void *)0) ;
    int fd = 0;
    int hash = 0;
     

    if (((void *)0)  == cah_em4_getEntityPtr (entity))
    {
        printf ("\r\nEnt(%d) NOT active", entity);
        return (((void *)0) );
    }

    hash = cah_em4_hash (sn);

    fd = cah_em4_ent2fd (entity);
    if (((void *)0)  == gpCahEm4HashHead[fd][hash])
    {
        printf ("\r\n%s, pointer NULL entity(%d)", __FUNCTION__, entity);
        return (((void *)0) );
    }

    ppp1 = gpCahEm4HashHead[fd][hash];

    for (;;)
    {
        ppp = ppp1;
        if (((void *)0)  == ppp->p)
        {
            printf ("\r\n%s(): pEm4HashHead[%d]->p NULL, func NOT found, first time!", __FUNCTION__, fd);
            break;
        }
        else
        {
             


            if (ppp1->p == pfun && ppp1->sn == sn && ppp1->arg1 == arg1 && ppp1->arg2 == arg2
                && ppp1->arg3 == arg3)
            {
                 
                pr = ppp1;
                cah_em4_trace (4, "\r\n%s: GOT ent(%d:%d), su(%d), port(%d)", __FUNCTION__, entity,
                               arg1, arg2, arg3);
                return (pr);
            }

        }

        ppp1 = ppp1->pHashNext[hash];

        if (((void *)0)  == ppp1->p)
        {
            break;
        }
    }

    return (((void *)0) );
}




  




int
cah_em4_hash (int sn)
{
    int r = 0;

    switch (sn)
    {
    case 4:
        r = 0;
        break;
    case 2:
        r = 1;
        break;
    case 8:
        r = 2;
        break;
    case 6:
        r = 3;
        break;
    case 99:
        r = 4;
        break;
    case 1:
        r = 5;
        break;
    case 5:
        r = 6;
        break;
    case 9:
        r = 7;
        break;
    case 111:
        r = 8;
        break;

    case 25:
    case 26:
        r = 9;
        break;

    default:
        r = 9;
        break;
    }

    return (r);
}


 


int
cahem4tree2 (int hash)
{
    E1_CALL *ppp = ((void *)0) , *ppp1 = ((void *)0) ;
    int fd = 0;
	ENTITY_T entity = 0;

    if (0 > hash || 10 < hash)
    {
        printf ("\r\nhash index error");
        return (0);
    }

    if (((void *)0)  == cah_em4_getEntity (entity))
    {
        printf ("\r\nEnt(%d) NOT active", entity);
        return (0);
    }

    fd = cah_em4_ent2fd (entity);
    if (((void *)0)  == gpCahEm4HashHead[fd][hash])
    {
        printf ("\r\n%s, pointer NULL entity(%d)", __FUNCTION__, entity);
        return (0);
    }

    ppp1 = gpCahEm4HashHead[fd][hash];

    for (;;)
    {
        ppp = ppp1;
        if (1)
        {
            if (((void *)0)  == ppp->p)
            {
                printf ("\r\ngpCahEm4HashHead[%d][%d]->p NULL", fd, hash);
                break;
            }
            else
            {
                if (5 == ppp->sn || 6 == ppp->sn)
                {
                    printf ("\r\nid(%4d), arg3(%d), arg4(%d), sn(%3d),n(%s)",
                            ppp->id, ppp->arg3, ppp->arg4.arg, ppp->sn,
                            ppp->fname);
                }
                else
                {
                    printf ("\r\nid(%4d), arg3(%d), arg4(%d), sn(%3d),n(%s)",
                            ppp->id, ppp->arg3, ppp->arg4.arg, ppp->sn,
                            ppp->fname);
                }
            }
        }

        ppp1 = ppp1->pHashNext[hash];
        if (0)
        {
            gpCahEm4HashHead[fd][hash] = gpCahEm4HashHead[fd][hash]->pHashNext[hash];
            ppp->pNext = ((void *)0) ;
            free (ppp);
            ppp = ((void *)0) ;
        }
        if (((void *)0)  == ppp1->p)
        {
            printf ("\r\nem4 link end!!!");
            break;
        }
    }

    return (0);
}

int em4GetPrbsStateTest (int port)
{
    BOOL s = 0 ;
    DWORD cnt = 0;

    {if (125 <  port ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  port ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;

    CAH_EM4_GetPrbsState (0, port, &s);
    CAH_EM4_GetPrbsErrCount (0, port, &cnt);
    printf ("\r\n%s(): status (%d), cnt(%d)", __FUNCTION__, s, cnt);
    printf ("\r\n");

    return 0;
}


WORD
CAH_EM4_GetPrbsState (DWORD dwPos, BYTE byPortNo, BOOL * bPrbsSucc)
{
    void *base = (void *) 0;
    short u = 0;
    int port = SDD_126xE1IOPortConvert(byPortNo);

	{if (125 <  SDD_126xE1IOPortConvert(byPortNo) ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  SDD_126xE1IOPortConvert(byPortNo) ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;
	port = cah_em4_mapPort (SDD_126xE1IOPortConvert(byPortNo)) - 1;
    base = cah_em4_getEntityBase (0, SDD_126xE1IOPortConvert(byPortNo));
    cah_em4_wr (base, (0x05 << 10) | 0x20 , port & 0x003f);
    taskDelay (sysClkRateGet () / 10);
    u = cah_em4_rd (base, (0x05 << 10) | 0x20 );
	*bPrbsSucc = ((u & 0x8000) ? 1 : 0);

    return ((WORD)0x0) ;
}

void
cah_em4_getprbsname (int tempStatus, char *almType)
{
    switch (tempStatus)
    {
    case PRBS_STATUS_NA:
        (((char*) almType )[((int)(  4 + 1 ) <= 0) ? 0 : (  4 + 1 )-1] = '\0', strncpy( almType ,   "NONE" , ((int)(  4 + 1 ) <= 0) ? 0 : (  4 + 1 )-1)) ;
        break;
    case PRBS_STATUS_SYNCING:
        (((char*) almType )[((int)(  7 + 1 ) <= 0) ? 0 : (  7 + 1 )-1] = '\0', strncpy( almType ,   "SYNCING" , ((int)(  7 + 1 ) <= 0) ? 0 : (  7 + 1 )-1)) ;
        break;
    case PRBS_STATUS_SYNC_SUCC:
        (((char*) almType )[((int)(  4 + 1 ) <= 0) ? 0 : (  4 + 1 )-1] = '\0', strncpy( almType ,   "SUCC" , ((int)(  4 + 1 ) <= 0) ? 0 : (  4 + 1 )-1)) ;
        break;
    case PRBS_STATUS_SYNC_FAIL:
        (((char*) almType )[((int)(  4 + 1 ) <= 0) ? 0 : (  4 + 1 )-1] = '\0', strncpy( almType ,   "FAIL" , ((int)(  4 + 1 ) <= 0) ? 0 : (  4 + 1 )-1)) ;
        break;
    case PRBS_STATUS_SYNC_ERROR:
        (((char*) almType )[((int)(  7 + 1 ) <= 0) ? 0 : (  7 + 1 )-1] = '\0', strncpy( almType ,   "SYNCERR" , ((int)(  7 + 1 ) <= 0) ? 0 : (  7 + 1 )-1)) ;
        break;
    default:
        (((char*) almType )[((int)(  7 + 1 ) <= 0) ? 0 : (  7 + 1 )-1] = '\0', strncpy( almType ,   "UNKNOWN" , ((int)(  7 + 1 ) <= 0) ? 0 : (  7 + 1 )-1)) ;
        break;
    }

}



 








 








int
cah_em4_pohWrite (void *base, int port, unsigned short reg, unsigned short val)
{
    unsigned short u = 0x0000;

    u |= (port << 8);
    u |= reg;
    u |= 0x8000;                 
    u |= 0x4000;                 

    cah_em4_wr (base, (0x02 << 10) | 0x02 , val);
    cah_em4_wr (base, (0x02 << 10) | 0x01 , u);
    cah_em4_pollBit ((unsigned short *) base, (0x02 << 10) | 0x01 );

    return ((WORD)0x0) ;
}

 





unsigned short
cah_em4_pohRead (void *base, int port, unsigned short reg)
{
    unsigned short u = 0x0000;
    unsigned short result = 0x00000;

    u |= (port << 8);
    u |= reg;
    u |= 0x8000;                 
    u |= 0x0000;                 

    cah_em4_wr (base, (0x02 << 10) | 0x01 , u);
    cah_em4_pollBit ((unsigned short *) base, (0x02 << 10) | 0x01 );
    result = cah_em4_rd (base, (0x02 << 10) | 0x03 );

    return (result);
}

 



unsigned short
cah_em4_readDemapper (void *base, int port, unsigned short reg)
{
    unsigned short u = 0x0000;
    unsigned short result = 0x00000;

    u |= (port);
    u |= 0x8000;                 

    cah_em4_wr (base, (0x05 << 10) | 0x01 , u);
    cah_em4_pollBitDmapper ((unsigned short *) base, (0x05 << 10) | 0x01 );
    result = cah_em4_rd (base, reg);

    return (result);
}

 




CAH_EM4_ENTITY_DATA_T *
cah_em4_getEntity (ENTITY_T ent)
{
    int i = 0;
    CAH_EM4_ENTITY_DATA_T *p = (CAH_EM4_ENTITY_DATA_T *) 0;

    i = 0;
    p = gppCahEm4CfgVar[i];

    return p;
}

 





void *
cah_em4_getEntityBase (ENTITY_T ent, int port)
{
    CAH_EM4_ENTITY_DATA_T *p = (CAH_EM4_ENTITY_DATA_T *) 0;
    void *base = 0x0000;

    p = cah_em4_getEntity (ent);
    base = (void *) p->chip_var[cah_em4_port2chip (port) - 1].cfg.baseAddr;

    return base;
}

 


CAH_EM4_ENTITY_DATA_T *
cah_em4_OpenEx (void)
{
    int memSize = 0;
    CAH_EM4_ENTITY_DATA_T *p = ((void *)0) ;

     





	if (((void *)0)  != gppCahEm4CfgVar[0])
	{
		printf ("\r\n%s(): gppCahEm4CfgVar[0](%p) NOT NULL !!!", __FUNCTION__, gppCahEm4CfgVar[0]);
		return ((void *)0) ;
	}

    memSize = (sizeof (CAH_EM4_ENTITY_DATA_T) + sizeof (EM4_CHIP_VAR_T) * 1) * 2;

    p = (CAH_EM4_ENTITY_DATA_T *) malloc( memSize ); ;
    if (!p)
    {
        printf ("\r\n%s():\tFD malloc failed !!!!!!", __FUNCTION__);
        return ((void *)0) ;
    }








    gppCahEm4CfgVar[0] = p;      
    memset((INT1 *)( p ), (  0x00 ), (  memSize )) ;

    return p;
}


int
cah_em4_ent2fd (ENTITY_T ent)
{
    int i = 0;

    return (i);
}


CAH_EM4_ENTITY_DATA_T *
cah_em4_fd2entptr (int fd)
{
    return gppCahEm4CfgVar[fd];
}

int
cah_em4_fd2ent (int fd)
{
    return (gppCahEm4CfgVar[fd]->entity);
}

CAH_EM4_ENTITY_DATA_T *
cah_em4_getEntityPtr (ENTITY_T entity)
{
    return cah_em4_getEntity (entity);
}




 





int
cah_em4_ent2Id (ENTITY_T entity)
{
    int id = 0;

    if (((void *)0)  == g_pTransFunc)
    {
        printf ("\r\n%s:KEY translation function not registered!!!", __FUNCTION__);
        return -1;
    }

    id = (*g_pTransFunc) (entity);

    return id;
}




void
em4Mi (void)
{
    int fd = 0;

    for (fd = 0; fd < (((1) ) ); fd++)
    {
        printf ("\r\nfd(%2d) m-base(%p), status(%6s), liu-base(%p)",
                fd, cah_em4_getEntityBase (cah_em4_fd2ent (fd), 1),
                (eEm4EntAct == gppCahEm4CfgVar[fd]->state) ? "ACTIVE" : (eEm4EntInit ==
                                                                         gppCahEm4CfgVar[fd]->
                                                                         state ? "INIT" : "IDLE"),
                (void *) 0xffff   );
    }
    printf ("\r\n");
}




void
cah_em4Info (void)
{
    int i = 0;
    UINT32 entity;
    CAH_EM4_ENTITY_DATA_T *pEntity;

    for (i = 0; i < ((1) ) ; i++)
    {
        if (gppCahEm4CfgVar[i] == ((void *)0) )
        {
            continue;
        }

         
        if (gppCahEm4CfgVar[i]->state != eEm4EntAct)
        {
            continue;
        }

        entity = gppCahEm4CfgVar[i]->entity;

        pEntity = cah_em4_getEntityPtr (entity);

        printf ("\r\nentity(%d), base(0x%x)", entity, pEntity->chip_var[0].cfg.baseAddr);
    }

    printf ("\r\n");
}


void
em4AllInLoop (int flag)
{
    unsigned short u = 0x0000;
	int ent = 0;

    if (((void *)0)  == cah_em4_getEntity (ent))
    {
        printf ("\r\nent(%d) NOT active", ent);
        return;
    }


    u = cah_em4_rd (cah_em4_getEntityBase (ent, 1), (((0x00 << 10) | 0x01)) );
    if (flag)
    {
        u |= 0x0002;
    }
    else
    {
        u &= ~0x0002;
    }

    cah_em4_wr (cah_em4_getEntityBase (ent, 1), (((0x00 << 10) | 0x01)) , u);
    u = cah_em4_rd (cah_em4_getEntityBase (ent, 100), (((0x00 << 10) | 0x01)) );
    if (flag)
    {
        u |= 0x0002;
    }
    else
    {
        u &= ~0x0002;
    }

    cah_em4_wr (cah_em4_getEntityBase (ent, 100), (((0x00 << 10) | 0x01)) , u);
}


int
em4ShowIntMask (int ulPort)
{
    unsigned short u = 0x0000, uu = 0;
	int port = 0;

	{if (125 <  ulPort ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  ulPort ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;
	port = cah_em4_mapPort (ulPort) - 1;
    u = 	cah_em4_pohRead ((void *)(0x50000000) , port, 0x00 );
    uu = 	cah_em4_pohRead ((void *)(0x60000000) , port, 0x00 );
    printf ("\r\nbase\t(%p)(%p)", (void *)(0x50000000) , (void *)(0x60000000) );
    printf ("\r\nssf\t(%s)(%s), ", 	u & 0x4000 ? "ENABLE" : "DISABLE", 
									uu & 0x4000 ? "ENABLE" : "DISABLE");
    printf ("\r\nerdi\t(%s)(%s), ", u & 0x0200 ? "ENABLE" : "DISABLE", 
									uu & 0x0200 ? "ENABLE" : "DISABLE");
    printf ("\r\ntsl\t(%s)(%s), ", 	u & 0x0100 ? "ENABLE" : "DISABLE", 
									uu & 0x0100 ? "ENABLE" : "DISABLE");
    printf ("\r\ntti\t(%s)(%s), ", 	u & 0x0080 ? "ENABLE" : "DISABLE", 
									uu & 0x0080 ? "ENABLE" : "DISABLE");
    printf ("\r\nsf\t(%s)(%s), ", 	u & 0x0040 ? "ENABLE" : "DISABLE", 
									uu & 0x0040 ? "ENABLE" : "DISABLE");
    printf ("\r\nsd\t(%s)(%s), ", 	u & 0x0020 ? "ENABLE" : "DISABLE", 
									uu & 0x0020 ? "ENABLE" : "DISABLE");
    printf ("\r\nrdi\t(%s)(%s), ", 	u & 0x0010 ? "ENABLE" : "DISABLE", 
									uu & 0x0010 ? "ENABLE" : "DISABLE");
    printf ("\r\nuneq\t(%s)(%s), ", u & 0x0008 ? "ENABLE" : "DISABLE", 
									uu & 0x0008 ? "ENABLE" : "DISABLE");
    printf ("\r\nplm\t(%s)(%s), ", 	u & 0x0004 ? "ENABLE" : "DISABLE", 
									uu & 0x0004 ? "ENABLE" : "DISABLE");
    printf ("\r\ntiu\t(%s)(%s), ", 	u & 0x0002 ? "ENABLE" : "DISABLE", 
									uu & 0x0002 ? "ENABLE" : "DISABLE");
    printf ("\r\ntim\t(%s)(%s)", 	u & 0x0001 ? "ENABLE" : "DISABLE", 
									uu & 0x0001 ? "ENABLE" : "DISABLE");
    printf ("\r\n");
	return 0;
}



int
em4ShowCons (int port)
{
    unsigned short u = 0x0000, uu = 0;
	int ulPort = 0;

	{if (125 <  port ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  port ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;
	ulPort = cah_em4_mapPort (port) - 1;
    u = cah_em4_pohRead ((void *) (0x50000000) , ulPort, 0x01 );
    uu = cah_em4_pohRead ((void *) (0x60000000) , ulPort, 0x01 );
    printf ("\r\nbase       (%x)(%x)", (0x50000000) , (0x60000000) );
    printf ("\r\nuneqrdi    (%s)(%s), ", u & 0x0080 ? "ON" : "OFF", uu & 0x0080 ? "ON" : "OFF");
    printf ("\r\nplmrdi     (%s)(%s), ", u & 0x0040 ? "ON" : "OFF", uu & 0x0040 ? "ON" : "OFF");
    printf ("\r\nuneqais    (%s)(%s), ", u & 0x0020 ? "ON" : "OFF", uu & 0x0020 ? "ON" : "OFF");
    printf ("\r\nplmais     (%s)(%s), ", u & 0x0010 ? "ON" : "OFF", uu & 0x0010 ? "ON" : "OFF");
    printf ("\r\ntimrdi     (%s)(%s), ", u & 0x0008 ? "ON" : "OFF", uu & 0x0008 ? "ON" : "OFF");
    printf ("\r\ntimais     (%s)(%s), ", u & 0x0004 ? "ON" : "OFF", uu & 0x0004 ? "ON" : "OFF");
    printf ("\r\nttimode    (%s)(%s), ", u & 0x0001 ? "1-BYTEMODE" : "16-BYTEMODE", uu & 0x0001 ? "1-BYTEMODE" : "16-BYTEMODE");
    printf ("\r\n");
	return 0;
}



int
cah_em4_trace (int level, char *msg, ...)
{
    va_list argptr;
    int cnt = 0;

    if (level == gCahEm4DebugLevel)
    {
        printf ("\r\n");
        (__builtin_next_arg (  msg ), __builtin_memcpy ((  argptr  ), __builtin_saveregs (), sizeof(__gnuc_va_list)) ) ;
        cnt = vprintf (msg, argptr);
        ((void)0) ;
    }

    return (cnt);
}


int
em4ShowEnable (int ulPort)
{
    int ent = 0;
    unsigned short u = 0x0000, uu, u1 = 0, u0 = 0;
	int port = cah_em4_mapPort (ulPort) - 1;

	{if (125 <  ulPort ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  ulPort ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;
    u1 = em4MapRd (5, 0x100 + port, &u0, &u1);

    cah_em4_wr ((void *) (0x50000000) , (0x04 << 10) | 0x30 , port);
    u = em4Map1Rd (4, 0x40);

    cah_em4_wr ((void *) (0x60000000) , (0x04 << 10) | 0x30 , port);
    uu = em4Map2Rd (4, 0x40);
    printf ("\r\nentity(%d), port(%d), u(%x), uu(%x)", ent, port, u, uu);
    printf ("\r\nrdi_force     (%d)(%d)", u & 0x0001 ? 1 : 0, uu & 0x0001 ? 1 : 0);
    printf ("\r\nrdi_en        (%d)(%d)", u & 0x0002 ? 1 : 0, uu & 0x0002 ? 1 : 0);
    printf ("\r\nrei_force     (%d)(%d)", u & 0x0040 ? 1 : 0, uu & 0x0040 ? 1 : 0);
    printf ("\r\nrei_en        (%d)(%d)", u & 0x0080 ? 1 : 0, uu & 0x0080 ? 1 : 0);
    printf ("\r\nbip2_disable  (%d)(%d)", u & 0x0100 ? 1 : 0, uu & 0x0100 ? 1 : 0);
    printf ("\r\nerdi_en       (%d)(%d)", u & 0x0200 ? 1 : 0, uu & 0x0200 ? 1 : 0);
    printf ("\r\nerdi_force    (%d)(%d)", u & 0x0400 ? 1 : 0, uu & 0x0400 ? 1 : 0);
    printf ("\r\ntu12_aisforce (%d)(%d)", u & 0x8000 ? 1 : 0, uu & 0x8000 ? 1 : 0);
    printf ("\r\nrfi[force]    (%d)(%d)", u & 0x0020 ? 1 : 0, uu & 0x0020 ? 1 : 0);
    printf ("\r\nretiming      (%d)(%d)", u0 & 0x0001 ? 1 : 0, u1 & 0x0001 ? 1 : 0);
    printf ("\r\n");

	return 0;
}


void
em4ShowJ2Acc (int ent, int port)
{
    int i = 0;
    void *baseaddr = (void *) 0;
    unsigned char j2exp[66];

    if (((void *)0)  == cah_em4_getEntity (ent))
    {
        printf ("\r\nEnt(%d) NOT active", ent);
        return;
    }

    baseaddr = cah_em4_getEntityBase (ent, port);

    cah_em4_getJ2Acc (baseaddr, port, j2exp);

    printf ("\r\nj2: entity(%d), port(%d)", ent, port);
    for (i = 0; i <= 15; i++)
    {
        printf ("\r\nj2[%2d]= (0x%2x), char(%c)",
                i, j2exp[i], (j2exp[i] >= 0x20 && j2exp[i] <= 0x7e) ? j2exp[i] : 'Y');
    }
}


void
em4ShowPageAddr (void)
{
    printf ("\r\npage0x01<<10 = (0x400      * 2 = 0x0800)");
    printf ("\r\npage0x02<<10 = (0x800      * 2 = 0x1000)");
    printf ("\r\npage0x04<<10 = (0x1000     * 2 = 0x2000)");
    printf ("\r\npage0x05<<10 = (0x1400     * 2 = 0x2800)");
}



int 
em4ShowAlarms (int ulPort)
{
    int ent = 0;
    unsigned short u = 0, u1 = 0, u2 = 0, u3 = 0, u4 = 0;
    unsigned short mu = 0, mu1 = 0, mu2 = 0, mu3 = 0, mu4 = 0;
    void *baseaddr = (void *) 0;
    unsigned short uu = 0;
    unsigned short muu = 0;
    int regcnt = 0;
    CAH_EM4_ENTITY_DATA_T *pEntity = ((void *)0) ;
	int port = 0;

	{if (125 <  ulPort ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  ulPort ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;
	port = cah_em4_mapPort (ulPort) - 1;

    baseaddr = cah_em4_getEntityBase (ent, port + 1);
    printf ("\r\n%s(): base(%p)", __FUNCTION__, baseaddr);

 



    u = cah_em4_pohRead (baseaddr, port, 0x03 );
    mu = cah_em4_pohRead ((void *)(0x60000000) , port, 0x03 );

    u1 = cah_em4_pohRead (baseaddr, port, 0x04 );
    mu1 = cah_em4_pohRead ((void *)(0x60000000) , port, 0x04 );


 


    cah_em4_wr (baseaddr, ((0x01 << 10) | 0x03) , 0x8000 | port);
    regcnt = 0;
    while (1)
    {
        uu = cah_em4_rd (baseaddr, ((0x01 << 10) | 0x03) );
        if (!(0x8000 & uu))
        {
            break;
        }
        else
        {
            regcnt++;
            if (regcnt > 100)
            {
                printf ("\r\nsomething wrong when read_hardware entity(%d)", ent);
                break;
            }
        }
    }
    u2 = cah_em4_rd (baseaddr, ((0x01 << 10) | 0x10) );  

    regcnt = 0;
    cah_em4_wr ((void *)(0x60000000) , ((0x01 << 10) | 0x03) , 0x8000 | port);
    while (1)
    {
        muu = cah_em4_rd ((void *)(0x60000000) , ((0x01 << 10) | 0x03) );
        if (!(0x8000 & uu))
        {
            break;
        }
        else
        {
            regcnt++;
            if (regcnt > 100)
            {
                printf ("\r\nsomething wrong when read_hardware entity(%d)", ent);
                break;
            }
        }
    }
    mu2 = cah_em4_rd ((void *)(0x60000000) , ((0x01 << 10) | 0x10) );  
 


    pEntity = cah_em4_getEntity (ent);
    u3 = cah_em4_readPdhAlarm (baseaddr, port);
    mu3 = cah_em4_readPdhAlarm ((void *)(0x60000000) , port);

    printf ("\r\nent(%d), port(%d)", ent, port);
    printf ("\r\nSTATUS\t\t\t\tINTR");
    printf ("\r\n______________________________________________________+++");

    printf ("\r\nlop\t(%s)(%s)\t", (u2 & 0x0003) == 0x0001 ? "AIS-RISE" : ((u2 & 0x0003) == 0x0002 ? "LOP-RISE" : "NORMAL"),
				(mu2 & 0x0003) == 0x0001 ? "AIS-RISE" : ((mu2 & 0x0003) == 0x0002 ? "LOP-RISE" : "NORMAL"));

    printf ("\r\npi_ssf\t(%s)(%s)\t", (u & 0x4000) ? " RISE" : "CLEAR", (mu & 0x4000) ? " RISE" : "CLEAR");
    printf ("\tssf\t(%s)(%s)", (u1 & 0x4000) ? " RISE" : "CLEAR",
		(mu1 & 0x4000) ? " RISE" : "CLEAR");


    printf ("\r\ntsl_ais\t(%s)(%s)\t", (u & 0x0800) ? " RISE" : "CLEAR",
			(mu & 0x0800) ? " RISE" : "CLEAR");
    printf ("\ttslais\t(%s)(%s)", (u1 & 0x0800) ? " RISE" : "CLEAR",
			(mu1 & 0x0800) ? " RISE" : "CLEAR");

    printf ("\r\nsf\t(%s)(%s)\t", (u & 0x0040) ? " RISE" : "CLEAR", 
			(mu & 0x0040) ? " RISE" : "CLEAR");
    printf ("\tsf\t(%s)(%s)", (u1 & 0x0040) ? " RISE" : "CLEAR", 
			(mu1 & 0x0040) ? " RISE" : "CLEAR");

    printf ("\r\nsd\t(%s)(%s)\t", (u & 0x0020) ? " RISE" : "CLEAR", 
			(mu & 0x0020) ? " RISE" : "CLEAR");
    printf ("\tsd\t(%s)(%s)", (u1 & 0x0020) ? " RISE" : "CLEAR", 
			(mu1 & 0x0020) ? " RISE" : "CLEAR");

    printf ("\r\nrdi\t(%s)(%s)\t", (u & 0x0010) ? " RISE" : "CLEAR", 
			(mu & 0x0010) ? " RISE" : "CLEAR");
    printf ("\trdi\t(%s)(%s)", (u1 & 0x0010) ? " RISE" : "CLEAR", 
			(mu1 & 0x0010) ? " RISE" : "CLEAR");

    printf ("\r\nuneq\t(%s)(%s)\t", (u & 0x0008) ? " RISE" : "CLEAR", 
			(mu & 0x0008) ? " RISE" : "CLEAR");
    printf ("\tuneq\t(%s)(%s)", (u1 & 0x0008) ? " RISE" : "CLEAR", 
			(mu1 & 0x0008) ? " RISE" : "CLEAR");

    printf ("\r\nplm\t(%s)(%s)\t", (u & 0x0004) ? " RISE" : "CLEAR", 
			(mu & 0x0004) ? " RISE" : "CLEAR");
    printf ("\tplm\t(%s)(%s)", (u1 & 0x0004) ? " RISE" : "CLEAR", 
			(mu1 & 0x0004) ? " RISE" : "CLEAR");

    printf ("\r\ntiu\t(%s)(%s)\t", (u & 0x0002) ? " RISE" : "CLEAR", 
			(mu & 0x0002) ? " RISE" : "CLEAR");
    printf ("\ttiu\t(%s)(%s)", (u1 & 0x0002) ? " RISE" : "CLEAR", 
			(mu1 & 0x0002) ? " RISE" : "CLEAR");

    printf ("\r\ntim\t(%s)(%s)\t", (u & 0x0001) ? " RISE" : "CLEAR", 
			(mu & 0x0001) ? " RISE" : "CLEAR");
    printf ("\ttim\t(%s)(%s)", (u1 & 0x0001) ? " RISE" : "CLEAR", 
			(mu1 & 0x0001) ? " RISE" : "CLEAR");

 


    printf ("\r\ne1lof\t(%s)(%s)\t", (u3 & 0x0004) ? "RISE" : "CLEAR", 
			(mu3 & 0x0004) ? "RISE" : "CLEAR");
    printf ("\r\ne1lom\t(%s)(%s)\t", (u3 & 0x0002) ? "RISE" : "CLEAR", 
			(mu3 & 0x0002) ? "RISE" : "CLEAR");
    printf ("\r\ne1rdi\t(%s)(%s)\t", (u3 & 0x0001) ? "RISE" : "CLEAR", 
			(mu3 & 0x0001) ? "RISE" : "CLEAR");
    printf ("\r\ne1ais\t(%s)(%s)\t", (u3 & 0x0008) ? "RISE" : "CLEAR", 
			(mu3 & 0x0008) ? "RISE" : "CLEAR");


 


	u4 = em4Map1Rd (0, 0x12);
	mu4 = em4Map2Rd (0, 0x12);
    printf ("\r\ne1los\t(%x)(%x)\t", (u4), (mu4));

    printf ("\r\n______________________________________________________+++");
    printf ("\r\n");

	return 0;
}

char *
cah_em4_fid2name (int id, char *pname)
{
    char *name = pname;

    switch (id)
    {
    case 111:
        sprintf (pname, "%s", "EM4_EnableRetiming");
        break;
    case 1:
        sprintf (pname, "%s", "EM4_SetTransPsl");
        break;
    case 2:
        sprintf (pname, "%s", "EM4_SetExpPsl");
        break;
    case 3:
        sprintf (pname, "%s", "EM4_GetRcvPsl");
        break;
    case 4:
        sprintf (pname, "%s", "EM4_EnablePlm");
        break;
    case 5:
        sprintf (pname, "%s", "EM4_SetTransTti");
        break;
    case 6:
        sprintf (pname, "%s", "EM4_SetExpTti");
        break;
    case 7:
        sprintf (pname, "%s", "EM4_GetAccTti");
        break;
    case 8:
        sprintf (pname, "%s", "EM4_EnableTim");
        break;
    case 9:
        sprintf (pname, "%s", "EM4_SetTransTtiMode");
        break;
    case 10:
        sprintf (pname, "%s", "EM4_SetTransTti");
        break;
    case 11:
        sprintf (pname, "%s", "EM4_SetPdhPortMode");
        break;
    case 12:
        sprintf (pname, "%s", "EM4_GetPortType");
        break;
    case 13:
        sprintf (pname, "%s", "EM4_SetPortLoopback");
        break;


    case 14:
        sprintf (pname, "%s", "EM4_EnablePort");
        break;
    case 15:
        sprintf (pname, "%s", "EM4_GetPortState");
        break;

    case 16:
        sprintf (pname, "%s", "EM4_PrbsEnable");
        break;
    case 17:
        sprintf (pname, "%s", "EM4_SetPrbsMode");
        break;
    case 18:
        sprintf (pname, "%s", "EM4_GetPrbsMode");
        break;
    case 19:
        sprintf (pname, "%s", "EM4_GetPrbsErrCount");
        break;
    case 20:
        sprintf (pname, "%s", "EM4_ForceInsertAis");
        break;
    case 21:
        sprintf (pname, "%s", "EM4_ForceInsertRdi");
        break;

    case 24:
        sprintf (pname, "%s", "EM4_BlockAIS");
        break;


    case 25:
        sprintf (pname, "%s", "EM4_SelectFrame");
        break;
    case 26:
        sprintf (pname, "%s", "EM4_EnableLOMLOF");
        break;

    case 99:
        sprintf (pname, "%s", "EM4_SetRcvTtiMode");
        break;
    default:
        printf (pname, "%d", id);
        break;
    }

    return (name);
}


 


















char *
cah_em4_id2name (int id)
{
    if ((32  != id)
        && (34  != id)
        && (36  != id)
        && (37  != id)
        && (38  != id)
        && (42  != id)
        && (39  != id)
        && (69  != id)
        && (91  != id)
        && (92  != id)
        && (230  != id)
        && (231  != id)
        && (232  != id)
        && (233  != id) && (235  != id))
    {
        printf ("\r\ncah_em4_id2name: unknown id(%d)", id);
        if (g_fflag)
        {
            logBackN ("unkonwn id", 5);
            g_fflag = 0;
        }
        sprintf (g_aname, "%s", "unknown id");
        return g_aname;
    }

 








    switch (id)
    {
    case 91 :
        sprintf (g_aname, "%s", "ppi-nslip");
        break;
    case 92 :
        sprintf (g_aname, "%s", "ppi-pslip");
        break;
    case 32 :
        sprintf (g_aname, "%s", "tu-lop");
        break;
    case 34 :
        sprintf (g_aname, "%s", "tu-ais");
        break;
    case 36 :
        sprintf (g_aname, "%s", "lp-tim");
        break;
    case 37 :
        sprintf (g_aname, "%s", "lp-uneq");
        break;
    case 38 :
        sprintf (g_aname, "%s", "lp-rdi");
        break;
    case 42 :
        sprintf (g_aname, "%s", "lp-rfi");
        break;
    case 39 :
        sprintf (g_aname, "%s", "lp-plm");
        break;
    case 69 :
        sprintf (g_aname, "%s", "ppi-los");
        break;
         


    case 230 :
        sprintf (g_aname, "%s", "ppi-lof");
        break;
    case 231 :
        sprintf (g_aname, "%s", "ppi-lom");
        break;
    case 232 :
        sprintf (g_aname, "%s", "ppi-rdi");
        break;
    case 235 :
        sprintf (g_aname, "%s", "lpvc_tlct");
        break;
    case 233 :
        sprintf (g_aname, "%s", "ppi-crc");
        break;
    default:
        break;
    }
    return g_aname;
}


 


int
cah_em4_isPDHRiseOrClear (CAH_EM4_ENTITY_DATA_T * pEntity, UINT32 ulChip, UINT32 ulPort, int almNum)
{
    return (pEntity->chip_var[ulChip].pohAlm[ulPort].e1state[almNum] & 0x0001 );
}


 


int
cah_em4_isRiseOrClear (CAH_EM4_ENTITY_DATA_T * pEntity, UINT32 ulChip, UINT32 ulPort, int almNum)
{
    return (pEntity->chip_var[ulChip].pohAlm[ulPort].state[almNum] & 0x0001 );
}


int
cah_em4_isPDHAlmRPTNow (CAH_EM4_ENTITY_DATA_T * pEntity, UINT32 ulChip, UINT32 ulPort, int almNum)
{
    return (pEntity->chip_var[ulChip].pohAlm[ulPort].e1state[almNum] & 0x8000 );
}


int
cah_em4_isAlmRPTNow (CAH_EM4_ENTITY_DATA_T * pEntity, UINT32 ulChip, UINT32 ulPort, int almNum)
{
    return (pEntity->chip_var[ulChip].pohAlm[ulPort].state[almNum] & 0x8000 );
}

int
cah_em4_isAlmForced (CAH_EM4_ENTITY_DATA_T * pEntity, UINT32 ulChip, UINT32 ulPort)
{
    return (pEntity->chip_var[ulChip].forceRptAlm[ulPort] == 1 );
}


int
cah_em4_isPDHAlmForced (CAH_EM4_ENTITY_DATA_T * pEntity, UINT32 ulChip, UINT32 ulPort)
{
    return (pEntity->chip_var[ulChip].forceRptAlm[ulPort] == 1 );
}


void
cah_em4_clearAlmForced (CAH_EM4_ENTITY_DATA_T * pEntity, UINT32 ulChip, UINT32 ulPort)
{
    pEntity->chip_var[ulChip].forceRptAlm[ulPort] = 0 ;
}






BOOL
cah_em4_isPDHAlmSet (CAH_EM4_ENTITY_DATA_T * pEntity, UINT32 ulChip, UINT32 ulPort, int almNum)
{
    return (pEntity->chip_var[ulChip].pohAlm[ulPort].e1state[almNum] & 0x0001 );
}


BOOL
cah_em4_isAlmSet (CAH_EM4_ENTITY_DATA_T * pEntity, UINT32 ulChip, UINT32 ulPort, int almNum)
{
    return (pEntity->chip_var[ulChip].pohAlm[ulPort].state[almNum] & 0x0001 );
}

int
cah_em4_isEntLive (int fd)
{
    return (eEm4EntAct == gppCahEm4CfgVar[fd]->state) ? 1 : 0;
}




 


int
cah_em4_isCardOn (int instance)
{
    if (SDD_BOARD_PRESENT == SDD_GetBoardPresence ((CTD_SlotToInstance( instance )) ))
    {
        return 1;
    }
    else
    {
        if (33 == gCahEm4DebugLevel)
            printf ("\r\niscardon: inst(%d) FALL-OFF", instance);
        return 0;
    }
    return 1;
}




 

































unsigned short
cah_em4_getPlm (ALARM_REGISTER_T * alarmCtrlReg)
{
    return (alarmCtrlReg->alarmCtrlBit.plm);
}


unsigned short
cah_em4_getUneq (ALARM_REGISTER_T * alarmCtrlReg)
{
    return (alarmCtrlReg->alarmCtrlBit.uneq);
}

unsigned short
cah_em4_getTim (ALARM_REGISTER_T * alarmCtrlReg)
{
    return (alarmCtrlReg->alarmCtrlBit.tim);
}


unsigned short
cah_em4_getRdi (ALARM_REGISTER_T * alarmCtrlReg)
{
    return (alarmCtrlReg->alarmCtrlBit.rdi);
}

unsigned short
cah_em4_getRfi (ALARM_REGISTER_T * alarmCtrlReg)
{
    return (alarmCtrlReg->alarmCtrlBit.rfi);
}


PB_ERROR_CODE_T
cah_em4_GetSlip (int dwPos, UINT32 byPortNo, UINT32 * pPSlip, UINT32 * pNSlip)
{
    unsigned short slip = 0;
    void *base = 0;
    int ulPort = 0;

	{if (125 <  byPortNo ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  byPortNo ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;
	ulPort = cah_em4_mapPort (byPortNo) - 1;
       base = cah_em4_getEntityBase (0, byPortNo);

       slip = cah_em4_readDemapper (base, ulPort, (0x05 << 10) | 0X02 );
    *pPSlip = ((slip & 0xff00) >> 8);       
    *pNSlip = (slip & 0x00ff);      

    cah_em4_trace (21, "%s: entity(%d), port(%d), base(%x), reg(%x), val(%x)",
                   __FUNCTION__, 0, byPortNo, base, (0x05 << 10) | 0X02 , slip);

    return ((WORD)0x0) ;
}


int
cah_em4_simslip (ENTITY_T entity, UINT32 ulPort, int n, int flag)
{
    int i = 0;
    unsigned int pslip, nslip;

    if (0 == flag)
    {
        return 0;
    }

    for (i = 0; i < n; i++)
    {
        taskDelay (100);
        cah_em4_GetSlip (entity, ulPort, &pslip, &nslip);
        printf ("\r\nnslip(%d), pslip(%d)", nslip, pslip);
    }
    return 0;
}



BOOL
cah_em4_isTTI16Byte (CAH_EM4_ENTITY_DATA_T * pEntity, int ulChip, int ulPort)
{
    return (PbTIModeType_mode16Byte == pEntity->chip_var[ulChip].strRcvJ2[ulPort].J2Mode);

}


BOOL
cah_em4_isTimEnable (CAH_EM4_ENTITY_DATA_T * pEntity, int ulChip, int ulPort)
{
    return (pEntity->chip_var[ulChip].bTimEnable[ulPort]);
}




BOOL
cah_em4_isPLMEnable (CAH_EM4_ENTITY_DATA_T * pEntity, int ulChip, int ulPort)
{
    return (pEntity->chip_var[ulChip].bPlmEnable[ulPort]);
}

 


UINT16
cah_em4_getAlarmId (CAH_EM4_ENTITY_DATA_T * pEntity, UINT32 ulChip, UINT32 ulPort, int almNum)
{
    UINT16 almID;

    almID = pEntity->chip_var[ulChip].pohAlm[ulPort].almID[almNum];

    return almID;
}






BOOL
cah_em4_isPDHAlarmRised (UINT16 wTemp, CAH_EM4_ENTITY_DATA_T * pEntity, UINT32 ulChip,
                         UINT32 ulPort, int almNum)
{
    return (wTemp && (!cah_em4_isPDHAlmSet (pEntity, ulChip, ulPort, almNum)));
}


 






BOOL
cah_em4_isAlarmRised (UINT16 wTemp, CAH_EM4_ENTITY_DATA_T * pEntity, UINT32 ulChip, UINT32 ulPort,
                      int almNum)
{
    return (wTemp && (!cah_em4_isAlmSet (pEntity, ulChip, ulPort, almNum)));
}


BOOL
cah_em4_isAlarmCleared (UINT16 wTemp, CAH_EM4_ENTITY_DATA_T * pEntity, UINT32 ulChip, UINT32 ulPort,
                        int almNum)
{
    return ((!wTemp) && (cah_em4_isAlmSet (pEntity, ulChip, ulPort, almNum)));
}

BOOL
cah_em4_isPDHAlarmCleared (UINT16 wTemp, CAH_EM4_ENTITY_DATA_T * pEntity, UINT32 ulChip,
                           UINT32 ulPort, int almNum)
{
    return ((!wTemp) && (cah_em4_isPDHAlmSet (pEntity, ulChip, ulPort, almNum)));
}

int
cah_em4_getAlarmType (CAH_EM4_ENTITY_DATA_T * pEntity,
                      UINT32 ulChip, UINT32 ulPort, UINT16 almID, UINT8 * almType)
{

    memset((INT1 *)( almType ), (  0 ), (  sizeof (almType) )) ;
    switch (almID)
    {
    case 91 :
        (((char*) almType )[((int)(  9 + 1 ) <= 0) ? 0 : (  9 + 1 )-1] = '\0', strncpy( almType ,   "PPI-NSLIP" , ((int)(  9 + 1 ) <= 0) ? 0 : (  9 + 1 )-1)) ;
        break;
    case 92 :
        (((char*) almType )[((int)(  9 + 1 ) <= 0) ? 0 : (  9 + 1 )-1] = '\0', strncpy( almType ,   "PPI-PSLIP" , ((int)(  9 + 1 ) <= 0) ? 0 : (  9 + 1 )-1)) ;
        break;
    case 38 :
        (((char*) almType )[((int)(  6 + 1 ) <= 0) ? 0 : (  6 + 1 )-1] = '\0', strncpy( almType ,   "LP-RDI" , ((int)(  6 + 1 ) <= 0) ? 0 : (  6 + 1 )-1)) ;
        if (0)
            if (pEntity->chip_var[ulChip].bRestrainRDI[ulPort])
            {
                return -1;
            }
        (((char*) almType )[((int)(  6 + 1 ) <= 0) ? 0 : (  6 + 1 )-1] = '\0', strncpy( almType ,   "LP-RDI" , ((int)(  6 + 1 ) <= 0) ? 0 : (  6 + 1 )-1)) ;
        break;
    case 42 :
        (((char*) almType )[((int)(  6 + 1 ) <= 0) ? 0 : (  6 + 1 )-1] = '\0', strncpy( almType ,   "LP-RFI" , ((int)(  6 + 1 ) <= 0) ? 0 : (  6 + 1 )-1)) ;
        if (0)
            if (pEntity->chip_var[ulChip].bRestrainRDI[ulPort])
            {
                return -1;
            }
        (((char*) almType )[((int)(  6 + 1 ) <= 0) ? 0 : (  6 + 1 )-1] = '\0', strncpy( almType ,   "LP-RFI" , ((int)(  6 + 1 ) <= 0) ? 0 : (  6 + 1 )-1)) ;
        break;
    case 34 :
        (((char*) almType )[((int)(  6 + 1 ) <= 0) ? 0 : (  6 + 1 )-1] = '\0', strncpy( almType ,   "TU-AIS" , ((int)(  6 + 1 ) <= 0) ? 0 : (  6 + 1 )-1)) ;
        break;
    case 32 :
        (((char*) almType )[((int)(  6 + 1 ) <= 0) ? 0 : (  6 + 1 )-1] = '\0', strncpy( almType ,   "TU-LOP" , ((int)(  6 + 1 ) <= 0) ? 0 : (  6 + 1 )-1)) ;
        break;
    case 36 :
         





        (((char*) almType )[((int)(  6 + 1 ) <= 0) ? 0 : (  6 + 1 )-1] = '\0', strncpy( almType ,   "LP-TIM" , ((int)(  6 + 1 ) <= 0) ? 0 : (  6 + 1 )-1)) ;
        break;
    case 39 :
         





        (((char*) almType )[((int)(  6 + 1 ) <= 0) ? 0 : (  6 + 1 )-1] = '\0', strncpy( almType ,   "LP-PLM" , ((int)(  6 + 1 ) <= 0) ? 0 : (  6 + 1 )-1)) ;
        break;
    case 37 :
        (((char*) almType )[((int)(  8 + 1 ) <= 0) ? 0 : (  8 + 1 )-1] = '\0', strncpy( almType ,   "LP-UNREQ" , ((int)(  8 + 1 ) <= 0) ? 0 : (  8 + 1 )-1)) ;
        break;
    default:
        (((char*) almType )[((int)(  7 + 1 ) <= 0) ? 0 : (  7 + 1 )-1] = '\0', strncpy( almType ,   "UNKNOWN" , ((int)(  7 + 1 ) <= 0) ? 0 : (  7 + 1 )-1)) ;
        break;
    }

    return 0;
}


FMA_ALM_STATE
cah_em4_getPlmStatus (CAH_EM4_ENTITY_DATA_T * pEntity,
                      UINT32 ulChip, UINT32 ulPort, FMA_ALM_STATE state)
{
    if (0  == pEntity->chip_var[ulChip].bPlmEnable[ulPort])
    {
        return FMA_ALM_CLEAR;
    }

     


    return state;
}


FMA_ALM_STATE
cah_em4_getTimStatus (CAH_EM4_ENTITY_DATA_T * pEntity,
                      UINT32 ulChip, UINT32 ulPort, FMA_ALM_STATE state)
{
    if (0  == pEntity->chip_var[ulChip].bTimEnable[ulPort])
    {
        return FMA_ALM_CLEAR;
    }

    if (PbTIModeType_mode16Byte != pEntity->chip_var[ulChip].strRcvJ2[ulPort].J2Mode)
    {
        return FMA_ALM_CLEAR;
    }

     


    return state;
}


void
cah_em4_addSsfFc (ENTITY_T entity, int port)
{
    CAH_EM4_ENTITY_DATA_T *pEntity = ((void *)0) ;


    pEntity = cah_em4_getEntity (entity);
    pEntity->chip_var[0].pohAlm[port].e1ssfFc++;

}


void
cah_em4_Dpr ()
{
    unsigned int entity = 0;
    CAH_EM4_ENTITY_DATA_T *pEntity;
    int instance = 0;
    int fd = 0;

    while (1)
    {
         


        if (!gbCahEm4RunPollingTask[1 ])
        {
            taskDelay (100);
            printf ("\r\ngbCahEm4RunPollingTask[EM4_DPR_TASK_ID]");
            continue;
        }
        entity = gCahEm4TribVar.latchent;

        if ((( entity  >= ((1) ) )) )
        {
            printf ("\r\n**Error!  Entity= %d; File=%s; Line=%d  \r\n", entity, "cah_126e1.c", 5185);
            continue;
        }

        if (((void *)0)  == (pEntity = cah_em4_getEntityPtr (entity)))
        {
            printf ("\r\n**Error!  Entity= %d; File=%s; Line=%d  \r\n", entity, "cah_126e1.c", 5191);
            continue;
        }

        fd = cah_em4_ent2fd (entity);
        if (eEm4EntAct != pEntity->state)
        {
            printf ("\r\ncah_em4_Dpr!  entity(%d) NOT active", entity);
            continue;
        }

        instance = (CTD_SlotToInstance((  entity  ) )) ;

        if (EM4_ENTITY_DELATCH == gCahEm4TribVar.EM4LatchStatus[fd])
        {
            printf ("\r\n**Error!  Entity= %d; File=%s; Line=%d  \r\n", entity, "cah_126e1.c", 5206);
            continue;
        }
        else
        {
            printf ("\r\nset DELATCH");
            gCahEm4TribVar.EM4LatchStatus[fd] = EM4_ENTITY_DELATCH;
        }

        cah_em4_trace (20, "%s detach entity:%d status:%d !!! \r\n", __FUNCTION__, entity,
                       gCahEm4TribVar.EM4LatchStatus[fd   ]);
    }
}

int
pbFpgaIntrEnable (int handle)
{
    return 0 ;
}

int
pbFpgaIsrHookAdd (int fpga, int bank, int device, FPGA_HOOK_FUNC usrHookFunc,
                  FPGA_HOOK_ARG usrHookArg)
{
    return 0 ;
}

PB_ERROR_CODE_T
cah_em4_intConnect (ENTITY_T entity)
{
    CAH_EM4_ENTITY_DATA_T *pEntity;
     
    int fpga, bank, device;
    int fd = 0;


    if (((void *)0)  == (pEntity = cah_em4_getEntityPtr (entity)))
    {
         
        return PB_ERR_PARAM;
    }
     
    fd = cah_em4_ent2fd (entity);

    fpga = 1;
    bank = 0;
    device = ( entity )  - 1;
    gCahEm4TribVar.fpgaHanle[fd] =
        pbFpgaIsrHookAdd (fpga, bank, device, (FPGA_HOOK_FUNC) cah_em4_isrFunc, entity);

    if (((FPGA_HANDLE)(-1))  == gCahEm4TribVar.fpgaHanle[fd])
    {
        printf ("\r\n**Error!  Entity= %d; File=%s; Line=%d  \r\n", entity, "cah_126e1.c", 5258);
        return ((WORD)0x1) ;
    }
    printf ("\r\n126xe1rt entity(%d) interrupt handler installed ok", entity);
     
    if (0  != pbFpgaIntrEnable (gCahEm4TribVar.fpgaHanle[fd]))
    {
        printf ("\r\n**Error!  Entity= %d; File=%s; Line=%d  \r\n", entity, "cah_126e1.c", 5265);
        return ((WORD)0x1) ;
    }

    pbFpgaIsrEnable (fpga);

    return ((WORD)0x0) ;
}


void
cah_em4_init_nothing ()
{
    static int flag = 1;
    int i = 0;

    if (flag)
    {
        memset((INT1 *)( &gCahEm4TribVar ), (  0 ), (  sizeof (CAH_EM4_ENTITY_TRIB_T) )) ;
        for (i = 0; i < ((1) ) ; i++)
        {
            gppCahEm4CfgVar[i] = 0;
            printf ("\r\n%s(): set gppCahEm4CfgVar[%d] to 0", __FUNCTION__, i);
        }
        flag = 0;
    }
}

BOOL
cah_em4_IsLatchIntEnable (UINT32 entity)
{
    BOOL bEnable = 0 ;
    void *baseaddr = cah_em4_getEntityBase (entity, 100);
    unsigned short u = 0;

    cah_ReadRegister ((DWORD) baseaddr, (((0x00 << 10) | 0X09) ), &u, 0xffff, CAH_REG_ATTRBT_RO);



    if (0x0001 & u)
    {
        bEnable = 1 ;
    }
    else
    {
        bEnable = 0 ;
    }

    return bEnable;
}



void
cah_em4_enableLatchInt (UINT32 entity, BOOL Enable)
{
    void *baseAddr = cah_em4_getEntityBase (entity, 1);

    if (Enable)
    {
        cah_em4_enableLatchIntr (baseAddr, 1);
    }
    else
    {
        cah_em4_enableLatchIntr (baseAddr, 0);
    }
}


void
cah_em4_isrFunc (FPGA_HANDLE handle, FPGA_HOOK_ARG entity)
{
    int fd = 0;

    if ((( entity  >= ((1) ) )) )
    {
        return;
    }

    cah_em4_enableLatchInt (entity, 0 );

     



    fd = cah_em4_ent2fd (entity);
    gCahEm4TribVar.IntCount[fd   ]++;
    g_isrcount++;
    gCahEm4TribVar.latchent = entity;
    g_cah_em4entity = entity;
}


PB_ERROR_CODE_T
cah_em4_intUnConnect (ENTITY_T entity)
{
    CAH_EM4_ENTITY_DATA_T *pEntity;
     
    int ReturnValue;
    int fd = 0;


    if (((void *)0)  == (pEntity = cah_em4_getEntityPtr (entity)))
    {
         
        return PB_ERR_PARAM;
    }

     
    fd = cah_em4_ent2fd (entity);

    if (((FPGA_HANDLE)(-1))  == gCahEm4TribVar.fpgaHanle[fd])
    {
         
        return ((WORD)0x1) ;
    }

    ReturnValue = pbFpgaIntrDisable (gCahEm4TribVar.fpgaHanle[fd]);
    if (ReturnValue != 0 )
    {
         
        return ((WORD)0x1) ;
    }

    ReturnValue = pbFpgaIsrHookDel (gCahEm4TribVar.fpgaHanle[fd]);
    if (ReturnValue != 0 )
    {
         
        return ((WORD)0x1) ;
    }

    return ((WORD)0x0) ;
}



void
cah_em4_latch ()
{
    UINT8 fd   ;
    CAH_EM4_ENTITY_LATCH_T Status;
    CAH_EM4_ENTITY_DATA_T *pEntity = ((void *)0) ;
    UINT16 intCount;
    INT32 intLockRet;
    void *baseaddr = ((void *)0) ;
    int instance = 0;
    int fdd = 0;

    while (1)
    {
        taskDelay (100);

        if (!gbCahEm4RunPollingTask[2 ])
        {
            printf ("\r\ncah_em4_latch (): gbCahEm4RunPollingTask[EM4_EPG_TASK_ID] NULL");
            continue;
        }

        for (fd = 0; fd < ((1) ) ; fd++)
        {
            if (!cah_em4_isEntLive (fd))
            {
                cah_em4_trace (2, "FD(%2d), state NOT active, continue", fd);
                continue;
            }

            if (!cah_em4_isCardOn (( cah_em4_fd2ent (fd) ) ))
            {
                printf ("\r\nFD(%2d), card NOT on", fd);
                continue;
            }

             
            pEntity = cah_em4_fd2entptr (fd);
            cah_em4_trace (22, "%s, entity(%d)", __FUNCTION__, pEntity->entity);

            Status = CAH_EM4_getLatchStatus (pEntity->entity);
             
            fdd = cah_em4_ent2fd (pEntity->entity);
            baseaddr = cah_em4_getEntityBase (pEntity->entity, 100);
            instance = (CTD_SlotToInstance((  pEntity->entity  ) )) ;

            if (EM4_ENTITY_LATCH == Status)
            {
                if ((EM4_ENTITY_LATCH != gCahEm4TribVar.EM4LatchStatus[fdd   ])
                    || (gCahEm4TribVar.EM4LatchForceRpt[   fdd]))
                {
                    gCahEm4TribVar.EM4LatchStatus[   fdd] = EM4_ENTITY_LATCH;

                    printf ("\r\nEM4_EpgPoll fd %d Latch Attached! \r\n", fd);
                }

                if (gCahEm4TribVar.EM4LatchForceRpt[fdd   ])
                {
                    gCahEm4TribVar.EM4LatchForceRpt[fdd   ] = 0 ;
                }

                if (!cah_em4_IsLatchIntEnable (pEntity->entity))
                {
                     
                    cah_em4_enableLatchIntr (baseaddr, 1);
                }
            }
            else if (EM4_ENTITY_DELATCH == Status)
            {
                if (cah_em4_IsLatchIntEnable (pEntity->entity))
                {
                     
                    cah_em4_enableLatchIntr (baseaddr, 0);

                }

                if ((EM4_ENTITY_DELATCH != gCahEm4TribVar.EM4LatchStatus[fdd   ])
                    || (gCahEm4TribVar.EM4LatchForceRpt[   fdd]))
                {
                    gCahEm4TribVar.EM4LatchStatus[fdd   ] = EM4_ENTITY_DELATCH;
                    gCahEm4TribVar.EM4LatchForceRpt[fdd   ] = 0 ;

                    printf ("\r\nEM4_EpgPoll fd %d Latch Detached! \r\n", fd);
                }

                if (gCahEm4TribVar.EM4LatchForceRpt[fdd   ])
                {
                    gCahEm4TribVar.EM4LatchForceRpt[fdd   ] = 0 ;
                }
            }

            intLockRet = intLock ();
            intCount = gCahEm4TribVar.IntCount[fdd   ];

            if (intCount < 80 )
            {
                intLockRet = intLock ();
                gCahEm4TribVar.IntCount[fdd   ] = 0;
            }
            else
            {
                printf ("\r\n**Error!  Entity= %d; File=%s; Line=%d  \r\n", fd, "cah_126e1.c", 5502);
            }
        }
    }
}



 


int
CAH_EM4_enableLOMLOF (ENTITY_T entity, int chip, int port, int enable)
{
    CAH_EM4_ENTITY_DATA_T *pEntity = ((void *)0) ;
     


    cah_em4_trace (36, "%s: entity(%d), port(%d), enalbe(%d)", __FUNCTION__, entity, port, enable);

    if (0 > port || 62 < port)
    {
        printf ("\r\n%s: port(%d) overflow", __FUNCTION__, port);
        return ((WORD)0x1) ;
    }

    pEntity = cah_em4_getEntityPtr (entity);
    cah_em4_registerCall ((PMyFun) CAH_EM4_enableLOMLOF, port, enable, 0, 26, __FUNCTION__);

    if (pEntity->state != eEm4EntAct)
    {
        return PB_ERR_STATE;
    }


    cah_em4_trace (35, "%s: entity(%d), port(%d), enalbe(%d)", __FUNCTION__, entity, port, enable);
    pEntity->chip_var[chip].isRptLOM[port] = enable;
    pEntity->chip_var[chip].forceRptAlm[port] = 1 ;

    return ((WORD)0x0) ;
}




PB_ERROR_CODE_T
CAH_EM4_initModule ()
{
    return cah_em4_initModule ();
}

int cah_em4_initPortMap (void);
PB_ERROR_CODE_T
CAH_EM4_loadModule ()
{
    static int flag = 0;

    if (flag) return 0;
    flag = 1;
    cah_em4_init_nothing ();
    cah_em4_initPortMap ();
    return cah_em4_loadModule ();
}


PB_ERROR_CODE_T
CAH_EM4_ForceAIS (DWORD dwPos, int nport, eEM4SWITCH ais)
{



    void *base = ((void *)0) ;
    CAH_EM4_ENTITY_DATA_T *pEntity = ((void *)0) ;
    ENTITY_T entity = 0;
    int port = 0;

    port = cah_em4_mapPort (nport) - 1;;

    if (0 > port || 62 < port)
    {
        printf ("\r\nEM4_ForceAIS : port(%d) overflow", port);
        return (((WORD)0x1) );
    }

    base = cah_em4_getEntityBase (entity, port);
    if (gCahEm4SelectPort == port)
    {
        cah_em4_trace (40 , "\r\n%s(): entity(%d), port(%d), base(%p)", __FUNCTION__,
                       entity, port, base);
    }
    cah_em4_forceAis (base, port, ais);
    pEntity = cah_em4_getEntity (entity);

    pEntity->chip_var[0].isFrcais[port] = ais;

    return (((WORD)0x0) );


    return 0;

}

 





PB_ERROR_CODE_T
CAH_EM4_forceRDI (DWORD dwPos, int nport, eEM4SWITCH rdi)
{




    CAH_EM4_ENTITY_DATA_T *pEntity = ((void *)0) ;
    void *base = ((void *)0) ;
    ENTITY_T entity = 0;
    int port = 0;

    port = cah_em4_mapPort (nport) - 1;;

    base = cah_em4_getEntityBase (entity, port);
    cah_em4_trace (34, "\r\nentity(%d), port(%d), base(%p), rdi(%d)", entity, port, base, rdi);
    cah_em4_forceRdi (base, port, rdi);

    pEntity = cah_em4_getEntity (entity);
    pEntity->chip_var[0].isFrcrdi[port] = rdi;

    return (((WORD)0x0) );


    return 0;
}


WORD
CAH_EM4_EnableReTiming (DWORD dwPos, BYTE byPortNo, BOOL bEnable)
{




    void *base = ((void *)0) ;
    int ulPort = 0;

    {if (125 <  SDD_126xE1IOPortConvert(byPortNo) ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  SDD_126xE1IOPortConvert(byPortNo) ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;
    ulPort = cah_em4_mapPort (SDD_126xE1IOPortConvert(byPortNo)) - 1;
    base = cah_em4_getEntityBase (0, SDD_126xE1IOPortConvert(byPortNo));
    cah_em4_registerCall ((PMyFun) CAH_EM4_EnableReTiming, (int) SDD_126xE1IOPortConvert(byPortNo), (int) bEnable, 0, 111, __FUNCTION__);
    cah_em4_set_inloopretiming (base, ulPort, eEM4_DISABLE   ,
                                bEnable ? eEM4_ENABLE : eEM4_DISABLE);

    return ((WORD)0x0) ;

}

WORD cah_em4_getTimingRef (BYTE mid_port, BYTE *byPort, BOOL bEnable)
{
    return 0;
}

int em4_queryPortFromSlot(int slot);
int testgettiming (byclocknum)
{
    BYTE byPortNo = 0;
    BOOL bEnable = 0;

    CAH_EM4_GetTimingRef (0, byclocknum, &byPortNo, &bEnable);
    printf ("\r\n%s(): byclock(%d), byPort(%d), enable(%d)", __FUNCTION__, byclocknum, byPortNo, bEnable);
    return 0;
}

int g_testtiming = 0;
int g_testtiming1 = 0;

 
WORD
CAH_EM4_GetTimingRef (DWORD dwPos, BYTE byClockNum, BYTE * byPortNo, BOOL * bEnable)
{
    WORD   wRtn       = ((WORD)0x0) ;
    BYTE	wRegValue = 0x0;
    BYTE port = 0;  

    wRtn = cah_Read8Reg(0x70000000 , 0x1b  + byClockNum, &wRegValue, 0x0F, CAH_REG_ATTRBT_RW);
    port = (wRegValue & 0x7) + 1;
if (g_testtiming1)
printf ("\r\n%s(): port(%3d), wRegValue(%4x)", __FUNCTION__, port - 1, wRegValue);
    if(!(wRegValue & 0x08))
    {
		*bEnable = 1 ;	
    }
    else
    {
		*bEnable = 0 ;
		port = 0;
    }
 
    if (0 == port) 
    {
        *byPortNo = 0;
        return ((WORD)0x0) ;
    } else {
        *byPortNo = em4_queryPortFromSlot(port);
if (g_testtiming1)
        printf ("\r\n%s(): virtualport(%3d), realport(%3d)", __FUNCTION__, port, *byPortNo);
    }

    { { if (DBG_GetLevel(  gCahDbgModuleNo ,    CAH_DEBUG_LEVEL_CLOCK  )) {printf("[%s] %d: ", "cah_126e1.c", 5710); printf   ("\r\n CAH_S14_GetTimingRef: Port = [%d], clock = [%d], wRegValue = [0x%x], bEnable = [%d]", *byPortNo , byClockNum, wRegValue, *bEnable)  ;} if (DBG_NvGetLevel(  gCahDbgModuleNo ,    CAH_DEBUG_LEVEL_CLOCK  ))    ; } ; } ;    
 
    return ((WORD)0x0) ;
}

 


int em4_queryPortFromSlot(int slot)
{
    int port = 0;
    void * base = 0;
    unsigned short u = 0;

    if (4 >= slot)
    {
        base = cah_em4_getEntityBase (0, 1);     
        u = cah_em4_rd (base, ((0x05 << 10) | 0x200 ) + (slot-1) / 2);
        if ((slot) % 2)
        {
            if ((0x3f)  == (u & 0xff))
            {
                return 0;
            } else {
                return (u & 0xff);
            }
        } else {
            if ((0x3f)  == ((u & 0xff00)>>8))
            {
                return 0;
            } else {
                return ((u & 0xff00)>>8);
            }
        }
    } else {
        base = cah_em4_getEntityBase (0, 100);     
        u = cah_em4_rd (base, ((0x05 << 10) | 0x200 ) + (slot-1-4) / 2);
if (g_testtiming1)
printf ("\r\nbase(%p), u(%x), slot(%d),(slot-1-4)/2(%d)", base, u, slot, (slot-1-4)/2);
        if ((slot) % 2)
        {
            if ((0x3f)  == (u & 0xff))
            {
                return 0;
            } else {
                return (u & 0xff) + 63;
            }
        } else {
            if ((0x3f)  == ((u & 0xff00)>>8))
            {
                return 0;
            } else {
                return ((u & 0xff00)>>8) + 63;
            }
        }
    }

    return (port);
}

int g_timingVirtualSlot [8];

int em4_getSlotFrom126port (int port, int enable)
{
    int slot = 99;
    int n = 0;
    void * base = 0;
    unsigned short u = 0, u1 = 0;


    n = cah_em4_mapPort (port) - 1;
    base = cah_em4_getEntityBase (0, port);     
    u = cah_em4_rd (base, (0x05 << 10) | 0x200 );
    u1 = cah_em4_rd (base, ((0x05 << 10) | 0x200 ) + 1);
    if (g_testtiming) printf ("\r\n%s(): EM4_RCK_0_1_SEL(%x),EM4_RCK_0_1_SEL+1(%x)", __FUNCTION__, u, u1);

    
    if (0 <= port && 62 >= port)
    {
        if ((u & 0xff) == n) 
        {            
            if (g_testtiming) printf ("\r\n%s(): found: 0", __FUNCTION__);
            slot = 0;
            if (0 == enable)
            {
                g_timingVirtualSlot[0] = (0x3f) ;
                u &= 0xff00;
                u |= 0x00ff;
                cah_em4_wr (base, (0x05 << 10) | 0x200 , u);
            }
        }
        if (((u & 0xff00) >> 8) == n) 
        {
            if (g_testtiming) printf ("\r\n%s(): found: 1", __FUNCTION__);
            slot = 1;
            if (0 == enable)
            {
                g_timingVirtualSlot[1] = (0x3f) ;
                u &= 0x00ff;
                u |= 0xff00;
                cah_em4_wr (base, (0x05 << 10) | 0x200 , u);
            }
        }

        if ((u1 & 0xff) == n)         
        {
            if (g_testtiming) printf ("\r\n%s(): found: 2", __FUNCTION__);
            slot = 2;
            if (0 == enable)
            {
                g_timingVirtualSlot[2] = (0x3f) ;
                u1 &= 0xff00;
                u1 |= 0x00ff;
                cah_em4_wr (base, (((0x05 << 10) | 0x200 )+1), u1);
            }
        }
        if (((u1 & 0xff00) >> 8) == n)  
        { 
            if (g_testtiming) printf ("\r\n%s(): found: 3", __FUNCTION__);
            slot = 3;
            if (0 == enable)
            {
                g_timingVirtualSlot[3] = (0x3f) ;
                u1 &= 0x00ff;
                u1 |= 0xff00;
                cah_em4_wr (base, (((0x05 << 10) | 0x200 )+1), u1);
            }
        }
    } else {
        if ((u & 0xff) == n)
        {
            if (g_testtiming) printf ("\r\n%s(): found: 4", __FUNCTION__);
            slot = 4;
            if (0 == enable)
            {
                g_timingVirtualSlot[4] = (0x3f) ;
                u &= 0xff00;
                u |= 0x00ff;
                cah_em4_wr (base, ((0x05 << 10) | 0x200 ), u);
            }
        }
        if (((u & 0xff00) >> 8) == n)    
        {
            if (g_testtiming) printf ("\r\n%s(): found: 5", __FUNCTION__);
            slot = 5;
            if (0 == enable)
            {
                g_timingVirtualSlot[5] = (0x3f) ;
                u &= 0x00ff;
                u |= 0xff00;
                cah_em4_wr (base, ((0x05 << 10) | 0x200 ), u);
            }
        }
        if ((u1 & 0xff) == n)            
        {
            if (g_testtiming) printf ("\r\n%s(): found: 6", __FUNCTION__);
            slot = 6;
            if (0 == enable)
            {
                g_timingVirtualSlot[6] = (0x3f) ;
                u1 &= 0xff00;
                u1 |= 0x00ff;
                cah_em4_wr (base, (((0x05 << 10) | 0x200 ) + 1), u1);
            }
        }
        if (((u1 & 0xff00) >> 8) == n)   
        {
            if (g_testtiming) printf ("\r\n%s(): found: 7", __FUNCTION__);
            slot = 7;
            if (0 == enable)
            {
                g_timingVirtualSlot[7] = (0x3f) ;
                u1 &= 0x00ff;
                u1 |= 0xff00;
                cah_em4_wr (base, (((0x05 << 10) | 0x200 ) + 1), u1);
            }
        }
    }









     
    if (99 == slot)
    {
        if (0 <= port && 62 >= port)
        {
            if ((u & 0xff) == (0x3f) )
            {
                if (g_testtiming) printf ("\r\n%s(): alloc: 0", __FUNCTION__);
                u &= 0xff00;
                u |= n;
                slot = 0;
                cah_em4_wr (base, (0x05 << 10) | 0x200 , u);
                goto allocend;
            }
            if (((u & 0xff00)>>8) == (0x3f) )
            {
                if (g_testtiming) printf ("\r\n%s(): alloc: 1", __FUNCTION__);
                u &= 0xff;
                u |= (n << 8);
                slot = 1;
                cah_em4_wr (base, (0x05 << 10) | 0x200 , u);
                goto allocend;
            }
            if ((u1 & 0xff) == (0x3f) )
            {
                if (g_testtiming) printf ("\r\n%s(): alloc: 2", __FUNCTION__);
                u1 &= 0xff00;
                u1 |= n;
                slot = 2;
                cah_em4_wr (base, ((0x05 << 10) | 0x200 ) + 1, u1);
                goto allocend;
            }
            if (((u1 & 0xff00)>>8) == (0x3f) )
            {
                if (g_testtiming) printf ("\r\n%s(): alloc: 3", __FUNCTION__);
                u1 &= 0xff;
                u1 |= (n << 8);
                slot = 3;
                cah_em4_wr (base, ((0x05 << 10) | 0x200 ) + 1, u1);
                goto allocend;
            }
        } else {
            if ((u & 0xff) == (0x3f) )
            {
                if (g_testtiming) printf ("\r\n%s(): alloc: 4", __FUNCTION__);
                u &= 0xff00;
                u |= n;
                slot = 4;
                cah_em4_wr (base, (0x05 << 10) | 0x200 , u);
                goto allocend;
            }
            if (((u & 0xff00)>>8) == (0x3f) )
            {
                if (g_testtiming) printf ("\r\n%s(): alloc: 5", __FUNCTION__);
                u &= 0xff;
                u |= (n << 8);
                slot = 5;
                cah_em4_wr (base, (0x05 << 10) | 0x200 , u);
                goto allocend;
            }
            if ((u1 & 0xff) == (0x3f) )
            {
                if (g_testtiming) printf ("\r\n%s(): alloc: 6", __FUNCTION__);
                u1 &= 0xff00;
                u1 |= n;
                slot = 6;
                cah_em4_wr (base, ((0x05 << 10) | 0x200 ) + 1, u1);
                goto allocend;
            }
            if (((u1 & 0xff00)>>8) == (0x3f) )
            {
                if (g_testtiming) printf ("\r\n%s(): alloc: 7", __FUNCTION__);
                u1 &= 0xff;
                u1 |= (n << 8);
                slot = 7;
                cah_em4_wr (base, ((0x05 << 10) | 0x200 ) + 1, u1);
                goto allocend;
            }
        }
    }

allocend:
    return (slot + 1);
}

int g_timing = 0;

int cah_em4_setTimingRef84 (port_mid, byClockNum, bEnable)
{
    WORD   wRtn       = ((WORD)0x0) ;
    int byPortNo = port_mid;

if (g_timing) printf ("\r\n%s(): port_mid(%d)", __FUNCTION__, port_mid);

    if (bEnable)
    {
    	 
    	wRtn = cah_Write8Reg (0x70000000 ,                      0x1b  + byClockNum,                      byPortNo,                      0x07,                      CAH_REG_ATTRBT_RW);




	     
    	wRtn = cah_Write8Reg (0x70000000 ,                      0x1b  + byClockNum,                      0x0,                      0x08,                      CAH_REG_ATTRBT_RW);




	
    } else {
    	
    	wRtn = cah_Write8Reg (0x70000000 ,                      0x1b  + byClockNum,                      0x07,                      0x07,                      CAH_REG_ATTRBT_RW);




	 
    	wRtn = cah_Write8Reg (0x70000000 ,                      0x1b  + byClockNum,                       0x0,                       0x08 ,                       CAH_REG_ATTRBT_RW);




	
    }
     
    return wRtn;
}

void cah_em4_InitTiming (void)
{
    static int flag = 0;

    if (flag == 1)
    {   
        return ;
    }
   
    flag = 1;
 
    cah_em4_wr ((void *)(0x50000000) , (0x05 << 10) | 0x200 , (0x3f)  | ((0x3f)  << 8));
    cah_em4_wr ((void *)(0x50000000) , (0x05 << 10) | 0x201 , (0x3f)  | ((0x3f)  << 8));
    cah_em4_wr ((void *)(0x60000000) , (0x05 << 10) | 0x200 , (0x3f)  | ((0x3f)  << 8));
    cah_em4_wr ((void *)(0x60000000) , (0x05 << 10) | 0x201 , (0x3f)  | ((0x3f)  << 8));
}

int cah_em4_initPortMap (void)
{
    int i = 0;

    memset (g_phyportmap, 0, 4 * 130);
    for (i = 0; i < 130; i ++)
    {
        g_phyportmap[i] = i;
    }

    g_phyportmap[9] = 9;
    g_phyportmap[10] = 10;
    g_phyportmap[11] = 11;
    g_phyportmap[12] = 12;
    g_phyportmap[34] = 34;
    g_phyportmap[35] = 35;
    g_phyportmap[39] = 39;
    g_phyportmap[40] = 40;
    g_phyportmap[41] = 41;
    g_phyportmap[42] = 42;
    g_phyportmap[43] = 43;
    g_phyportmap[44] = 44;
    g_phyportmap[63] = 63;
    g_phyportmap[64] = 64;


    return 0;
}



unsigned short em4_bpc_wr (int page, int off, unsigned short val);
WORD
CAH_EM4_SetTimingRef (DWORD dwPos, BYTE byPort, BYTE byClockNum, BOOL bEnable)
{
    int port_mid = 0 , n = 0;
    void * base = ((void *)0) ;
    BYTE byPortCopy = SDD_126xE1IOPortConvert(byPort), realport = 0;
    BOOL status;
    unsigned short c1 = 0, c2 = 0, ccc = 0;
    unsigned char pt = 0;

     
    {if (125 <  SDD_126xE1IOPortConvert(byPort) ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  SDD_126xE1IOPortConvert(byPort) ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;
    cah_em4_registerCall ((PMyFun) CAH_EM4_SetTimingRef, (int) SDD_126xE1IOPortConvert(byPort), (int) byClockNum, bEnable, 1, __FUNCTION__);
    
    if (0 == bEnable)
    {
        CAH_EM4_GetTimingRef (0, byClockNum, &realport, &status);
        byPortCopy = realport;
        if (g_testtiming) printf ("\r\nGetRef() GOT: byClockNum(%d), realport(%03d)",byClockNum, realport); 
    }

    n = cah_em4_mapPort (SDD_126xE1IOPortConvert(byPort)) - 1;
    base = cah_em4_getEntityBase (0, byPortCopy);     

    port_mid = em4_getSlotFrom126port (byPortCopy, bEnable);
    if (g_testtiming) printf ("\r\n%s(): byPortCopy(%03d)(%03d), byClockNum(%d), en(%d), mid(%d)", __FUNCTION__, byPortCopy, byPort, byClockNum, bEnable, port_mid);
    printf ("\r\n%s(): byPortCopy(%03d)(%03d), byClockNum(%d), en(%d), mid(%d)", __FUNCTION__, byPortCopy, byPort, byClockNum, bEnable, port_mid);








 
    c1 = em4Map1Rd (5, 0x200);
    pt = (c1 & 0xff) + 1; if (pt > 129) return (((WORD)0x2) );
    ccc = (g_phyportmap[pt] - 1);
    c1 &= 0xff00;
    c1 |= ccc;

    pt = ((c1 & 0xff00)>>8) + 1; if (pt > 129) return (((WORD)0x2) );
    ccc = (g_phyportmap[pt] - 1);
    c1 &= 0xff;
    c1 |= ccc << 8;

 
    c2 = em4Map1Rd (5, 0x201);
    pt = (c2 & 0xff) + 1; if (pt > 129) return (((WORD)0x2) );
    ccc = (g_phyportmap[pt] - 1);
    c2 &= 0xff00;
    c2 |= ccc;

    pt = ((c2 & 0xff00)>>8) + 1; if (pt > 129) return (((WORD)0x2) );
    ccc = (g_phyportmap[pt] - 1);
    c2 &= 0xff;
    c2 |= ccc << 8;


    em4_bpc_wr (0x03, 0x07, c1);
    em4_bpc_wr (0x03, 0x08, c2);


 

 
    c1 = em4Map2Rd (5, 0x200);
    pt = (c1 & 0xff) + 1; if (pt > 129) return (((WORD)0x2) );
    ccc = (g_phyportmap[pt] - 1);
    c1 &= 0xff00;
    c1 |= ccc;

    pt = ((c1 & 0xff00)>>8) + 1; if (pt > 129) return (((WORD)0x2) );
    ccc = (g_phyportmap[pt] - 1);
    c1 &= 0xff;
    c1 |= ccc << 8;

 
    c2 = em4Map2Rd (5, 0x201);
    pt = (c2 & 0xff) + 1; if (pt > 129) return (((WORD)0x2) );
    ccc = (g_phyportmap[pt] - 1);
    c2 &= 0xff00;
    c2 |= ccc;

    pt = ((c2 & 0xff00)>>8) + 1; if (pt > 129) return (((WORD)0x2) );
    ccc = (g_phyportmap[pt] - 1);
    c2 &= 0xff;
    c2 |= ccc << 8;

    em4_bpc_wr (0x03, 0x09, c1);
    em4_bpc_wr (0x03, 0x0a, c2);




    cah_em4_setTimingRef84 (port_mid - 1, byClockNum, bEnable);

    return ((WORD)0x0) ;
}

PB_ERROR_CODE_T
CAH_EM4_setTransPsl (DWORD dwPos, UINT32 ulChip, UINT32 nulPort, UINT8 PSL)
{




    void *base = 0x0000;
    int ulPort = 0;

	{if (125 <  nulPort ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  nulPort ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;
     ulPort = cah_em4_mapPort (nulPort) - 1;
    cah_em4_registerCall ((PMyFun) CAH_EM4_setTransPsl, (int) nulPort, (int) PSL, 0, 1, __FUNCTION__);
    base = (void *) cah_em4_getEntityBase (0, nulPort);
   em4SetPsl2 (base, ulPort, PSL);
   

    return ((WORD)0x0) ;

}

 
WORD
CAH_EM4_SetRxExpLpPsl (DWORD dwPos, BYTE byPortNo, BYTE byC2Value)
{




    void *base = 0x00000;
    int ulPort = SDD_126xE1IOPortConvert(byPortNo);

	{if (125 <  SDD_126xE1IOPortConvert(byPortNo) ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  SDD_126xE1IOPortConvert(byPortNo) ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;
   ulPort = cah_em4_mapPort (SDD_126xE1IOPortConvert(byPortNo)) - 1;
    base = (void *) cah_em4_getEntityBase(0, SDD_126xE1IOPortConvert(byPortNo));
    cah_em4_registerCall ((PMyFun) CAH_EM4_SetRxExpLpPsl, (int) SDD_126xE1IOPortConvert(byPortNo), (int) byC2Value, 0, 2, __FUNCTION__);
    em4SetPslexp (base, ulPort, byC2Value);

    return ((WORD)0x0) ;

}

void
cah_em4_get_j2acc (void *baseaddr, int port, unsigned char *j2exp)
{
    unsigned short u = 0;
    int i = 0;

    for (i = 0; i < 16; i++)
    {
        cah_em4_wr (baseaddr, (0x02 << 10) | 0x01 , 0x8000 + (port << 8) + (0x10  + i));
        cah_em4_pollBit ((unsigned short *) baseaddr, (0x02 << 10) | 0x01 );
        u = cah_em4_rd (baseaddr, (0x02 << 10) | 0x03 );
        *(j2exp + i) = u & (0x00ff);
    }
}

int em4TtiTxTest (int port)
{
	{if (125 <  port ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  port ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;
	 
	CAH_EM4_SetTxLpTti (0, port, TTI_LEN_16BYTE, "f1234567890ABCDE");
	return 0;
}


int em4TtiRxTest (int n)
{
	unsigned char tti[16] ;

	{if (125 <  n ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  n ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;
	memset (tti, 0, 16);
	CAH_EM4_GetRxRcvLpTti (0, n, TTI_LEN_16BYTE, tti);
	tti[15] = '\0';
	printf ("%s(): tti(%s)", __FUNCTION__, tti);
	return 0;
}

 
WORD
CAH_EM4_GetRxRcvLpTti (DWORD dwPos, BYTE byPortNo, TTI_LEN_T eTtiMode, BYTE * pbyTtiValue)
{
	int entity = 0;
	int i = 0;
	int ulPort = 0;

	{if (125 <  SDD_126xE1IOPortConvert(byPortNo) ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  SDD_126xE1IOPortConvert(byPortNo) ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;
    if (!pbyTtiValue)
    {
        printf ("\r\nEM4_GetAccTti: entity(%d), file(%s) line(%d), tti is NULL!  \r\n", entity, "cah_126e1.c", 6279);
        return PB_ERR_PARAM;
    }
	
	ulPort = cah_em4_mapPort (SDD_126xE1IOPortConvert(byPortNo)) - 1;
	cah_em4_get_j2acc (cah_em4_getEntityBase (0, SDD_126xE1IOPortConvert(byPortNo)), ulPort, pbyTtiValue);
	if (TTI_LEN_16BYTE == eTtiMode)
	{
	} else if (TTI_LEN_FIXED1B == eTtiMode) {
		for (i = 1; i < 16; i ++)
		{
			pbyTtiValue[i] = pbyTtiValue[0];
		}
	}

    return ((WORD)0x0) ;
}

int em4SetExpPslTest (int port, int c2)
{
	{if (125 <  port ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  port ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;
	CAH_EM4_SetRxExpLpPsl (0, port, c2);
	printf ("\r\n%s(): write c2(%d)", __FUNCTION__, c2);
	return 0;
}

int em4GetExpPslTest (int port)
{
	unsigned char u = 0;

	{if (125 <  port ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  port ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;
	CAH_EM4_GetRxExpLpPsl (0, port, &u);
	printf ("\r\npsl(%x)", u);
	printf ("\r\n");
	return 0;
}

 
WORD
CAH_EM4_GetRxExpLpPsl (DWORD dwPos, BYTE byPortNo, BYTE * byC2Value)
{
    void *base = 0x00000;
    int ulPort = SDD_126xE1IOPortConvert(byPortNo);
	unsigned short u = 0;

	{if (125 <  SDD_126xE1IOPortConvert(byPortNo) ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  SDD_126xE1IOPortConvert(byPortNo) ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;
    ulPort = cah_em4_mapPort (SDD_126xE1IOPortConvert(byPortNo)) - 1;
    base = (void *) cah_em4_getEntityBase(0, SDD_126xE1IOPortConvert(byPortNo));
    cah_em4_registerCall ((PMyFun) CAH_EM4_SetRxExpLpPsl, (int) SDD_126xE1IOPortConvert(byPortNo), (int) byC2Value, 0, 2, __FUNCTION__);
    u = cah_em4_pohRead (base,  SDD_126xE1IOPortConvert(byPortNo), 0x00 );
	u = u & (0x3800);
	u = (u >> 11);
	*byC2Value = u;

    return ((WORD)0x0) ;
}

 
WORD
CAH_EM4_SetTxLpPsl (DWORD dwPos, BYTE byPortNo, BYTE byC2Value)
{
	return CAH_EM4_setTransPsl  (dwPos, 0, SDD_126xE1IOPortConvert(byPortNo), byC2Value);
}

 
WORD
CAH_EM4_SetRxTxLpPsl (DWORD dwPos, BYTE byPortNo, BYTE byC2Value)
{
	return CAH_EM4_setTransPsl  (dwPos, 0, SDD_126xE1IOPortConvert(byPortNo), byC2Value);
}

int em4GetRxRcvPslTest (int port)
{
	unsigned char c2 = 0;

	{if (125 <  port ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  port ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;
	CAH_EM4_GetRxRcvLpPsl (0, port, &c2);
	printf ("\r\nc2(%x)", c2);
	printf ("\r\n\r\n");
	return 0;
}

 
WORD
CAH_EM4_GetRxRcvLpPsl (DWORD dwPos, UINT32 byPortNo, BYTE * pbyC2Value)
{




    void *base = 0x0000;
    unsigned short u = 0x0000;
    int ulPort = SDD_126xE1IOPortConvert(byPortNo);
    int nulPort = SDD_126xE1IOPortConvert(byPortNo);

	{if (125 <  SDD_126xE1IOPortConvert(byPortNo) ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  SDD_126xE1IOPortConvert(byPortNo) ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;
    ulPort = cah_em4_mapPort (nulPort) - 1;

    if (!pbyC2Value)
    {
        printf ("\r\n%s(): pPSL is NULL!", __FUNCTION__);
        return ((WORD)0x1) ;
    }

    base = (void *) cah_em4_getEntityBase (0, SDD_126xE1IOPortConvert(byPortNo));
    cah_em4_getTslNow (base,SDD_126xE1IOPortConvert(byPortNo), &u);
    *pbyC2Value = u;
    return ((WORD)0x0) ;

}


 


void
em4_PollBit (DWORD dwPos, DWORD addrOffset, int byPortNo)
{
    WORD i = 0;
    WORD data = 0x0000;
    int chipno = cah_em4_port2chip (byPortNo);
    DWORD base = cah_em4_getChipBase (0, chipno);

    for (;;)
    {

         
        cah_ReadRegister (base, (addrOffset), &data, 0xFFFF, CAH_REG_ATTRBT_RW);
        if (data & 0x8000)
        {
            i = (WORD) (i + 1);
            if (i >= 100 )
            {
                 

                 

                break;
            }
        }
        else
        {
            break;
        }
    }
}

 
PB_ERROR_CODE_T
CAH_EM4_enablePlm (DWORD dwPos, UINT32 ulChip, UINT32 nulPort, BOOL bEnable)
{




    CAH_EM4_ENTITY_DATA_T *pEntity;
    void *baseaddr = ((void *)0) ;
    ENTITY_T entity = 0;
    int ulPort = 0;

	{if (125 <  nulPort ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  nulPort ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;
    pEntity = cah_em4_getEntityPtr (entity);
    ulPort = cah_em4_mapPort (nulPort) - 1;
    cah_em4_registerCall ((PMyFun) CAH_EM4_enablePlm, (int) nulPort, (int) bEnable, 0, 4, __FUNCTION__);

    baseaddr = cah_em4_getEntityBase (0, nulPort);
    cah_em4_enablePlm (baseaddr, 0, ulPort, bEnable);
    


    return ((WORD)0x0) ;

}


WORD
CAH_EM4_SetRxLpPslEnable (DWORD dwPos, BYTE byPortNo, BOOL bEnable)
{
    WORD data;

	data = 0;
	CAH_EM4_enablePlm (dwPos, 0, SDD_126xE1IOPortConvert(byPortNo), bEnable);

    return ((WORD)0x0) ;
}


 
WORD
CAH_EM4_SetTxLpTti (DWORD dwPos, UINT32 byPortNo, TTI_LEN_T eTtiMode, const BYTE * pbyTtiValue)
{





    void *base = 0x0000;
	int i = 0;
	unsigned char mytti[16];
    ENTITY_T entity = 0;
	int ulPort = 0;

	{if (125 <  SDD_126xE1IOPortConvert(byPortNo) ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  SDD_126xE1IOPortConvert(byPortNo) ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;
       ulPort = cah_em4_mapPort (SDD_126xE1IOPortConvert(byPortNo)) - 1;
	memset (mytti, 0, 16);

    cah_em4_registerCall ((PMyFun) CAH_EM4_SetTxLpTti, (int) SDD_126xE1IOPortConvert(byPortNo), (int) pbyTtiValue, 0, 5, __FUNCTION__);

    base = (void *) cah_em4_getEntityBase (entity, SDD_126xE1IOPortConvert(byPortNo));
	memcpy (mytti, pbyTtiValue, 16);
	if (TTI_LEN_FIXED1B == eTtiMode)
	{
		for (i = 0; i < 16; i ++) mytti[i] = pbyTtiValue[0];
	}
    cahem4setTxj2_2 (base,  ulPort, mytti);
   

    return ((WORD)0x0) ;

}


 
WORD
CAH_EM4_SetRxExpLpTti (DWORD dwPos, UINT32 byPortNo, TTI_LEN_T eTtiMode, const BYTE * pbyTtiValue)
{





    void *base = 0x0000;
    int ulPort = 0;
	char mytti[16];
	int i = 0;

	{if (125 <  SDD_126xE1IOPortConvert(byPortNo) ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  SDD_126xE1IOPortConvert(byPortNo) ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;
      ulPort = cah_em4_mapPort (SDD_126xE1IOPortConvert(byPortNo)) - 1;

	memset (mytti, 0, 16); memcpy (mytti, pbyTtiValue, 16);
    cah_em4_registerCall ((PMyFun) CAH_EM4_SetRxExpLpTti, (int) SDD_126xE1IOPortConvert(byPortNo), (int) pbyTtiValue, 0, 6, __FUNCTION__);
	
    base = (void *) cah_em4_getEntityBase (0, SDD_126xE1IOPortConvert(byPortNo));
	if (TTI_LEN_FIXED1B == eTtiMode)
	{
		 
		for (i = 0; i < 16; i ++) mytti[i] = pbyTtiValue[1];
	}
   cah_em4_set_j2exp (base, ulPort, mytti);
  

    return ((WORD)0x0) ;

}

int em4GetExpTtiTest (int port)
{
	unsigned char tti[16];
	int i = 0;

	memset (tti, 0, 16);
	CAH_EM4_GetRxExpLpTti (0, port, TTI_LEN_16BYTE, tti);
	tti[15] = '\0';
	printf ("\r\ntti(%s)", tti);
	printf ("\r\n\t");
	for (i = 0; i < 16; i ++)
	{
		printf ("(%x)", tti[i]);
	}
	printf ("\r\n");

	return 0;
}

int em4SetExpTtiTest (int port)
{
	{if (125 <  port ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  port ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;
	CAH_EM4_SetRxExpLpTti (0, port, TTI_LEN_16BYTE, "f0987654321abcde");
	return 0;
}

 
WORD
CAH_EM4_GetRxExpLpTti (DWORD dwPos, BYTE byPortNo, TTI_LEN_T eTtiMode, BYTE * pbyTtiValue)
{
	void * base = 0;
	int ulPort = 0;
	unsigned char mytti[16];

	{if (125 <  SDD_126xE1IOPortConvert(byPortNo) ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  SDD_126xE1IOPortConvert(byPortNo) ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;
	ulPort = cah_em4_mapPort (SDD_126xE1IOPortConvert(byPortNo)) - 1;
	base = cah_em4_getEntityBase (0, SDD_126xE1IOPortConvert(byPortNo));
       cah_em4_get_j2exp (base, ulPort, mytti);
      
	memcpy (pbyTtiValue, mytti, 16);
    return 0;
}

int cah_em4_ManualInsertPayloadAIS (int byPortNo, int flag )
{
     void * base = 0;
     int byte = 0;
      int ulPort = 0;
      int bit = 0;
      unsigned short val = 0;

       ulPort = cah_em4_mapPort (byPortNo) - 1;
	base = cah_em4_getEntityBase (0, byPortNo);
	byte = ulPort / 16;
	bit = ulPort % 16;
	

	val = cah_em4_rd (base, ((((0x00 << 10) | 0x20) ) + byte));
	if (flag == 1 )
	{
        val = val | (1 << bit);
	} else {
        val = val & (~(1 << bit));
	}

	cah_em4_wr (base, ((((0x00 << 10) | 0x20) ) + byte), val);

    return 0;
}
 










WORD
CAH_EM4_SetInsertAlm (DWORD dwPos, BYTE byPortNo, CTD_INSERT_ALM_TYPE_T eAlmType,
                      CTD_INSERT_ALM_DIR_T eInsAlmDir, BOOL bEnable)
{
	void * base = 0;
	int port = 0;
	unsigned short alm = 0;
	UINT8 byLoop = 0x0;

	{if (125 <  SDD_126xE1IOPortConvert(byPortNo) ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  SDD_126xE1IOPortConvert(byPortNo) ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;
    cah_em4_registerCall ((PMyFun) CAH_EM4_SetInsertAlm, (int) SDD_126xE1IOPortConvert(byPortNo), (int) eAlmType, bEnable, 8, __FUNCTION__);

	base = cah_em4_getEntityBase (0, SDD_126xE1IOPortConvert(byPortNo));
	port = cah_em4_mapPort (SDD_126xE1IOPortConvert(byPortNo)) - 1;
       cah_em4_wr (base, (0x04 << 10) | 0x30 , port);       
       
	alm = cah_em4_rd (base, (0x04 << 10) | 0x40 );

	if (CTD_INSERT_ALM_TYPE_TUAIS == eAlmType 
		&& CTD_INSERT_ALM_OUT_LASER == eInsAlmDir)
	{
		if (1  == bEnable)
		{
			alm |= 0x8000;
		} else {
			alm &= ~0x8000;
		}
              cah_em4_wr (base, (0x04 << 10) | 0x30 , port);       
		alm = cah_em4_wr (base, (0x04 << 10) | 0x40 , alm);
	}

	if (CTD_INSERT_ALM_TYPE_AIS == eAlmType 
		&& CTD_INSERT_ALM_OUT_LASER == eInsAlmDir)
	{
		if (1  == bEnable)
		{
		}
		else 
		{
            if (SDD_126xE1IOPortConvert(byPortNo) == 0)
            {
                for (byLoop=0;byLoop<126;byLoop++)
	                cah_em4_ManualInsertPayloadAIS(byLoop, 0 );
			}
		}
	}
	if (CTD_INSERT_ALM_TYPE_RDI == eAlmType
		&& CTD_INSERT_ALM_OUT_LASER == eInsAlmDir)
	{
		if (1  == bEnable)
		{
			alm |= 0x0001;
            alm &= ~0x0002;
		} else {
			alm &= ~0x0001;
            alm |= 0x0002;
		}
              cah_em4_wr (base, (0x04 << 10) | 0x30 , port);       
	      alm = cah_em4_wr (base, (0x04 << 10) | 0x40 , alm);
	}
	
    return ((WORD)0x0) ;
}



 
WORD
CAH_EM4_SetRxLpTtiAlmEnable (DWORD dwPos, BYTE byPortNo, BOOL bEnable)
{




    CAH_EM4_ENTITY_DATA_T *pEntity = ((void *)0) ;
    void *baseaddr = ((void *)0) ;
    int ulPort = 0;

    cah_em4_trace (15, "\r\n%s:, ulPort(%d) bEnable(%d)", __FUNCTION__, ulPort, bEnable);
    

    ulPort = cah_em4_mapPort (SDD_126xE1IOPortConvert(byPortNo)) - 1;
    pEntity = cah_em4_getEntityPtr (0);
    cah_em4_registerCall ((PMyFun) CAH_EM4_SetRxLpTtiAlmEnable, (int) SDD_126xE1IOPortConvert(byPortNo), (int) bEnable, 0, 8, __FUNCTION__);
    baseaddr = cah_em4_getEntityBase (0, SDD_126xE1IOPortConvert(byPortNo));
    cah_em4_enableTimRdi (baseaddr, 0, ulPort, bEnable);
    

    return ((WORD)0x0) ;

}

 
WORD
CAH_EM4_SetRxLpTtiAisEnable (DWORD dwPos, BYTE byPortNo, BOOL bEnable)
{




    CAH_EM4_ENTITY_DATA_T *pEntity = ((void *)0) ;
    void *baseaddr = ((void *)0) ;
    int ulPort = 0;

    cah_em4_trace (15, "\r\n%s:, ulPort(%d) bEnable(%d)", __FUNCTION__, ulPort, bEnable);
    
    ulPort = cah_em4_mapPort (SDD_126xE1IOPortConvert(byPortNo)) - 1;
    pEntity = cah_em4_getEntityPtr (0);
    cah_em4_registerCall ((PMyFun) CAH_EM4_SetRxLpTtiAlmEnable, (int) SDD_126xE1IOPortConvert(byPortNo), (int) bEnable, 0, 8, __FUNCTION__);
    baseaddr = cah_em4_getEntityBase (0, SDD_126xE1IOPortConvert(byPortNo));
    cah_em4_enableTimAis (baseaddr, 0, ulPort, bEnable);
    

    return ((WORD)0x0) ;

}

 
WORD
CAH_EM4_SetTxLpTtiMode (DWORD dwPos, UINT32 byPortNo, TTI_LEN_T eTtiMode)
{



    return ((WORD)0x0) ;

    return ((WORD)0x0) ;
}

UINT8
cah_em4_readChReg (CAH_EM4_ENTITY_DATA_T * pEntity, UINT32 ulChip, UINT32 ulPort, UINT32 addrOffset)
{
    UINT8 data = 0;
    UINT32 offset = (0x2000  + ulPort * 0x1000  + addrOffset);

    data = (*((volatile UINT8 *)( (pEntity->chip_var[ulChip].cfg.baseAddr) )+(  offset ))) ;

    return data;
}


void
cah_em4_writeChReg (CAH_EM4_ENTITY_DATA_T * pEntity, UINT32 ulChip, UINT32 ulPort,
                    UINT32 addrOffset, UINT8 data)
{
    UINT32 offset = (0x2000  + ulPort * 0x1000  + addrOffset);

    (*((volatile UINT8 *)( (pEntity->chip_var[ulChip].cfg.baseAddr) )+(  offset )))=(UINT8)(  data ) ;
}


 
WORD
CAH_EM4_SetRxLpTtiMode (DWORD dwPos, UINT32 byPortNo, TTI_LEN_T eTtiMode)
{




    return ((WORD)0x0) ;
}

PB_ERROR_CODE_T
CAH_EM4_setPdhPortMode (DWORD dwPos, UINT32 ulChip, UINT32 nulPort, PDH_PORT_MODE_T type)
{




    void *base = 0x0000;
    int port = 0;
    unsigned short u = 0x0000;
    CAH_EM4_ENTITY_DATA_T *pEntity = ((void *)0) ;
    ENTITY_T entity = 0;
    int ulPort = 0;

    ulPort = cah_em4_mapPort (nulPort);


    pEntity = cah_em4_getEntityPtr (entity);
    cah_em4_registerCall ((PMyFun) CAH_EM4_setPdhPortMode, (int) nulPort, (int) type, 0, 11, __FUNCTION__);

    if (pEntity->state != eEm4EntAct)
    {
         
        return PB_ERR_STATE;
    }
    base = (void *) cah_em4_getEntityBase (entity, ulPort);
    
   u = cah_em4_pohRead (base, port = ulPort, 0x00 );
   
    u &= ~0x000c;                
    cah_em4_pohWrite (base, port, 0x00 , u);
    

    return ((WORD)0x0) ;




    return 0;
}



 


PB_ERROR_CODE_T
CAH_EM4_getPortType (DWORD dwPos, UINT32 ulChip, UINT32 nulPort, PDH_PORT_MODE_T * pType)
{





    CAH_EM4_ENTITY_DATA_T *pEntity;
    ENTITY_T entity = 0;
    int ulPort = 0;

    ulPort = cah_em4_mapPort (nulPort);


    if ((((  entity   >= ((1) ) )) || ((   ulChip  )  >=  (1) ) || ((   ulPort  ) >= (63 ) ) ) )
    {
        printf ("\r\n**Error!  Entity= %d; File=%s; Line=%d  \r\n", entity, "cah_126e1.c", 6839);
        return PB_ERR_PARAM;
    }

    if (!pType)
    {
        printf ("\r\nEntity%d: %s %d EM4_GetPortType pType is NULL!  \r\n", entity, "cah_126e1.c",
                6846);
        return PB_ERR_PARAM;
    }

    pEntity = cah_em4_getEntityPtr (entity);
    if (pEntity->state == eEm4EntInit)
    {
        return ((WORD)0x0) ;
    }

    if (pEntity->state != eEm4EntAct)
    {
         
        return PB_ERR_STATE;
    }

   *pType = pEntity->chip_var[ulChip].portType[ulPort];
  


    return ((WORD)0x0) ;




    return 0;
}


 



PB_ERROR_CODE_T
CAH_EM4_enablePort (DWORD dwPos, UINT32 ulChip, UINT32 ulPort, PORT_STATE_T state)
{






    return ((WORD)0x0) ;





    return 0;
}



 



PB_ERROR_CODE_T
CAH_EM4_getPortState (DWORD dwPos, UINT32 ulChip, UINT32 nulPort, PORT_STATE_T * pState)
{




    CAH_EM4_ENTITY_DATA_T *pEntity;
    ENTITY_T entity = 0;
    int ulPort = 0;

    ulPort = cah_em4_mapPort (nulPort) - 1;


     if ((((  entity   >= ((1) ) )) || ((   ulChip  )  >=  (1) ) || ((   ulPort  ) >= (63 ) ) ) )     
    {
        printf ("\r\n**Error!  Entity= %d; File=%s; Line=%d  \r\n", entity, "cah_126e1.c", 6963);
        return PB_ERR_PARAM;
    }

    if (!pState)
    {
        printf ("\r\nEntity%d: %s %d EM4_GetPortState pState is NULL!  \r\n", entity, "cah_126e1.c",
                6970);
        return PB_ERR_PARAM;
    }

    pEntity = cah_em4_getEntityPtr (entity);
    if (pEntity->state == eEm4EntInit)
    {
        return ((WORD)0x0) ;
    }

    if (pEntity->state != eEm4EntAct)
    {
         
        return PB_ERR_STATE;
    }

   *pState = pEntity->chip_var[ulChip].adminState[ulPort];
  

    return ((WORD)0x0) ;




    return 0;
}


WORD
CAH_EM4_EnablePrbs (DWORD dwPos, UINT32 byPortNo, BOOL bEnable)
{




      int port = 0;
	void * base = 0;

	{if (125 <  SDD_126xE1IOPortConvert(byPortNo) ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  SDD_126xE1IOPortConvert(byPortNo) ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;
       port = cah_em4_mapPort (SDD_126xE1IOPortConvert(byPortNo)) - 1;
	base = cah_em4_getEntityBase (0, SDD_126xE1IOPortConvert(byPortNo));

    cah_em4_registerCall ((PMyFun) CAH_EM4_EnablePrbs, (int) SDD_126xE1IOPortConvert(byPortNo), (int) bEnable, 0, 17, __FUNCTION__);

    if (bEnable)
    {
        cah_em4_setPrbs2 (base, port, eEM4_ENABLE);
        
    }
    else
    {
        cah_em4_setPrbs2 (base, port, eEM4_DISABLE);
        
    }
    return ((WORD)0x0) ;

}

PB_ERROR_CODE_T
CAH_EM4_getPrbsMode (DWORD dwPos, UINT32 ulChip, UINT32 nulPort, PRBS_MODE_T * pMode)
{




    CAH_EM4_ENTITY_DATA_T *pEntity;
    ENTITY_T entity = 0;
    int ulPort = 0;

    ulPort = cah_em4_mapPort (nulPort);


    if ((((  entity   >= ((1) ) )) || ((   ulChip  )  >=  (1) ) || ((   ulPort  ) >= (63 ) ) ) )     
    {
        printf ("\r\n**Error!  Entity= %d; File=%s; Line=%d  \r\n", entity, "cah_126e1.c", 7044);
        return PB_ERR_PARAM;
    }

    if (!pMode)
    {
        printf ("\r\nEntity%d: %s %d EM4_GetPrbsMode pMode is NULL!  \r\n", entity, "cah_126e1.c",
                7051);
        return PB_ERR_PARAM;
    }

    pEntity = cah_em4_getEntityPtr (entity);
    if (pEntity->state == eEm4EntInit)
    {
        return ((WORD)0x0) ;
    }

    if (pEntity->state != eEm4EntAct)
    {
         
        return PB_ERR_STATE;
    }

    *pMode = pEntity->chip_var[ulChip].prbsCfg[ulPort].prbsMode;    
    return ((WORD)0x0) ;





    return 0;
}






int em4GetPrbsErrTest (int port)
{
    DWORD cnt = 0;

    {if (125 <  port ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  port ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;

    CAH_EM4_GetPrbsErrCount (0, port, &cnt);
    printf ("\r\n%s(): cnt(%d)", __FUNCTION__, cnt);
    printf ("\r\n");
    return 0;
}
 


WORD
CAH_EM4_GetPrbsErrCount (DWORD dwPos, UINT32 byPortNo, DWORD * dwPrbsCnt)
{




    int ulPort = 0;
    int nulPort = SDD_126xE1IOPortConvert(byPortNo);
	void * base = 0;
	unsigned short c1 = 0, c2 = 0;

	{if (125 <  SDD_126xE1IOPortConvert(byPortNo) ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  SDD_126xE1IOPortConvert(byPortNo) ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;
       ulPort = cah_em4_mapPort (nulPort) - 1;
	base = cah_em4_getEntityBase (0, SDD_126xE1IOPortConvert(byPortNo));

     












	
    cah_em4_wr (base, (0x05 << 10) | 0x20 , ulPort & 0x003f);    
    c2 = cah_em4_rd (base, (0x05 << 10) | 0x22 );
    c1 = cah_em4_rd (base, (0x05 << 10) | 0x21 );
	*dwPrbsCnt = (c2 + (c1 << 16));
    return ((WORD)0x0) ;

}

PB_ERROR_CODE_T
CAH_EM4_forceRptDefect (DWORD dwPos, UINT32 ulChip, UINT32 nulPort)
{





    CAH_EM4_ENTITY_DATA_T *pEntity;
    ENTITY_T entity = 0;
    int ulPort = 0;

    ulPort = cah_em4_mapPort (nulPort);


    if ((((  entity   >= ((1) ) )) || ((   ulChip  )  >=  (1) ) || ((   ulPort  ) >= (63 ) ) ) )  
    {
        printf ("\r\n**Error!  Entity= %d; File=%s; Line=%d  \r\n", entity, "cah_126e1.c", 7219);
        return PB_ERR_PARAM;
    }

    pEntity = cah_em4_getEntityPtr (entity);
    if (pEntity->state != eEm4EntAct)
    {
        printf ("\r\n**Error!  Entity= %d; File=%s; Line=%d  \r\n", entity, "cah_126e1.c", 7226);
        return PB_ERR_STATE;
    }

    pEntity->chip_var[ulChip].forceRptAlm[ulPort] = 1 ;    

    return ((WORD)0x0) ;





    return 0;
}

PB_ERROR_CODE_T
CAH_EM4_forceReportEpg (DWORD dwPos)
{




    UINT8 chipNo;
    ENTITY_T entity = 0;

    chipNo = cah_em4_ent2chipno (entity);

    gCahEm4TribVar.EM4LatchForceRpt[chipNo] = 1 ;

    return ((WORD)0x0) ;

    return 0;
}



 


PB_ERROR_CODE_T
CAH_EM4_forceInsertAis (DWORD dwPos, UINT32 ulChip, UINT32 nulPort, ALARM_DIRECTION_T dir,
                        BOOL bEnable)
{




    int ulPort = 0;

    ulPort = cah_em4_mapPort (nulPort);
    return ((WORD)0x0) ;


    return 0;
}

 


PB_ERROR_CODE_T
CAH_EM4_forceInsertRdi (DWORD dwPos, UINT32 ulChip, UINT32 nulPort, BOOL bEnable)
{




    CAH_EM4_ENTITY_DATA_T *pEntity;
    void *base = 0x0000;
    int port = 0;
    unsigned short u = 0x0000;
    ENTITY_T entity = 0;
    int ulPort = 0;
    __EXAR_INSERT_CTRL_T insertCtrlReg;
    UINT8 G1 = 0;

    ulPort = cah_em4_mapPort (nulPort);

     



    if (1)
        return ((WORD)0x0) ;

    if ((((  entity   >= ((1) ) )) || ((   ulChip  )  >=  (1) ) || ((   ulPort  ) >= (63 ) ) ) )    
    {
        printf ("\r\n**Error!  Entity= %d; File=%s; Line=%d  \r\n", entity, "cah_126e1.c", 7312);
        return PB_ERR_PARAM;
    }

    pEntity = cah_em4_getEntityPtr (entity);

    cah_em4_registerCall ((PMyFun) CAH_EM4_forceInsertRdi, (int) nulPort, (int) bEnable, 0, 21, __FUNCTION__);

     



    memset((INT1 *)( &insertCtrlReg ), (  0 ), (  sizeof (insertCtrlReg) )) ;

    base = (void *) cah_em4_getEntityBase (entity, port);
    cah_em4_wr (base, (0x04 << 10) | 0x30 , port);       
    taskDelay (5);
    u = cah_em4_rd (base, (0x04 << 10) | 0x40 );
    insertCtrlReg.insertCtrlBit.rdi = ((u & 0x00ff) & 0x0001) ? 1 : 0;

    if (bEnable)
    {
        insertCtrlReg.insertCtrlBit.rdi = 0x01;
        G1 = 0x08;
         
         pEntity->chip_var[ulChip].frdiMode[nulPort] = EM4_UP_FORCE;
    }
    else
    {
        insertCtrlReg.insertCtrlBit.rdi = 0x00;
        G1 = 0;
         
         pEntity->chip_var[ulChip].frdiMode[nulPort] = EM4_NONE_FORCE;
    }

 


     


    if (insertCtrlReg.insertCtrlBit.rdi)
    {
        u |= 0x0003;
    }
    else
    {
        u &= ~0x0001;
    }
    u |= 0x0002;
    u &= ~0x0020;
    cah_em4_wr (base, (0x04 << 10) | 0x40 , u);
    taskDelay (5);

    return ((WORD)0x0) ;


    return 0;
}

int em4GetPpiBipTest (int port)
{
    DWORD bip = 0, rei = 0;

    {if (125 <  port ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  port ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;
    CAH_EM4_GetPpiBipCount (0, port, &bip, &rei);
    printf ("%s(): bip(%d), rei(%d)", __FUNCTION__, bip, rei);
    printf ("\r\n");

    return 0;
}



WORD
CAH_EM4_GetPpiBipCount (DWORD dwPos, BYTE byPortNo, DWORD * pPpiBip, DWORD * pPpiFebe)
{
	int port = 0;
	void * base = 0;
	unsigned short remote = 0;
	unsigned short near = 0, err = 0;

	{if (125 <  SDD_126xE1IOPortConvert(byPortNo) ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  SDD_126xE1IOPortConvert(byPortNo) ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;
	port = cah_em4_mapPort (SDD_126xE1IOPortConvert(byPortNo)) - 1;
	base = cah_em4_getEntityBase (0, SDD_126xE1IOPortConvert(byPortNo));





	err = cah_em4_readCrc4RemoteReg (base, port, &near, &remote);	

	
	*pPpiBip = near;
	*pPpiFebe = remote;

    return ((WORD)0x0) ;
}

int em4GetBipTest (int port)
{
    DWORD bip = 0, rei = 0;

    {if (125 <  port ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  port ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;
    CAH_EM4_GetLpBipCount (0, port, &bip, &rei);
    printf ("%s(): bip(%d), rei(%d)", __FUNCTION__, bip, rei);
    printf ("\r\n");

    return 0;
}


WORD
CAH_EM4_GetLpBipCount (DWORD dwPos, BYTE byPortNo, DWORD * pLpBip, DWORD * pLpRei)
{
	void * base = 0;
	int port = 0;
	unsigned short bip2 = 0;
	unsigned short rei = 0;

	{if (125 <  SDD_126xE1IOPortConvert(byPortNo) ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  SDD_126xE1IOPortConvert(byPortNo) ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;

	port = cah_em4_mapPort (SDD_126xE1IOPortConvert(byPortNo)) - 1;
	base = cah_em4_getEntityBase (0, SDD_126xE1IOPortConvert(byPortNo));

	bip2 = cah_em4_pohRead (base, port, 0x05 );
	rei  = cah_em4_pohRead (base, port, 0x06 );	
	*pLpBip = bip2;
	*pLpRei = rei;

    return ((WORD)0x0) ;
}

PB_ERROR_CODE_T
CAH_EM4_getLpPmPara (DWORD dwPos, UINT32 ulChip, UINT32 nulPort, MSHPLP_PMPARA_T * pPmPara)
{





    CAH_EM4_ENTITY_DATA_T *pEntity = ((void *)0) ;
    UINT32 data = 0;
    UINT32 temp = 0;
    unsigned int d1 = 0, d2 = 0;
    MSHPLP_PMPARA_T pmParm;
    void *base = 0x0000;
    int port = 0;
    unsigned short u = 0x0000;
    ENTITY_T entity = 0;
    int ulPort = 0;

    ulPort = cah_em4_mapPort (nulPort);


    if ((((  entity   >= ((1) ) )) || ((   ulChip  )  >=  (1) ) || ((   ulPort  ) >= (63 ) ) ) )  
    {
        printf ("\r\n**Error!  Entity= %d; File=%s; Line=%d  \r\n", entity, "cah_126e1.c", 7488);
        return PB_ERR_PARAM;
    }

    if (!pPmPara)
    {
        printf ("\r\nEntity%d: %s %d EM4_GetLpPmPara pPmPara is NULL!  \r\n", entity, "cah_126e1.c",
                7495);
        return PB_ERR_PARAM;
    }

    if (((void *)0)  == (pEntity = cah_em4_getEntityPtr (entity)))
    {
        printf ("\r\nlppm: entity(%d) NULL", entity);
        return PB_ERR_PARAM;
    }

    if (pEntity->state == eEm4EntInit)
    {
        return ((WORD)0x0) ;
    }

    if (eEm4EntAct != pEntity->state)
    {
        printf ("\r\ngetpm: entity(%d), not active", entity);
        return PB_ERR_STATE;
    }

    memset((INT1 *)( &pmParm ), (  0 ), (  sizeof (MSHPLP_PMPARA_T) )) ;
     
     


    base = (void *) cah_em4_getEntityBase (entity, ulPort);
   
    u = port = ulPort;
    temp = cah_em4_pohRead (base, port, 0x05 );    
    d1 = data = temp;

    pmParm.bip = data;

    data = 0;


    base = (void *) cah_em4_getEntityBase (entity, ulPort);    
    u = port = ulPort;
    temp = cah_em4_pohRead (base, port, 0x06 );    
    d2 = data = (temp);

    pmParm.rei = data;


    if (pEntity->chip_var[ulChip].pohAlm[ulPort].ssf   )
    {
        pmParm.bip = 0;
        pmParm.rei = 0;
        pmParm.fefc = 0;
         
        pmParm.fc = 1 + pEntity->chip_var[ulChip].pohAlm[nulPort].ssfFc;
    }
    else
    {
        pmParm.fc = 0;
        if (pEntity->chip_var[ulChip].pohAlm[ulPort].rdi
              )
        {
            pmParm.fefc = 1
                + pEntity->chip_var[ulChip].pohAlm[ulPort].rdiFc
                + pEntity->chip_var[ulChip].pohAlm[ulPort].rfiFc;             
            pmParm.rei = 0;
        }                        



        else
        {
            pmParm.fefc = 0;
        }
    }

    if (pEntity->chip_var[ulChip].pohAlm[ulPort].ssf == 0x0100 )
    {
        pEntity->chip_var[ulChip].pohAlm[ulPort].ssf = 0;
    }
    pEntity->chip_var[ulChip].pohAlm[ulPort].ssfFc = 0;

    if (pEntity->chip_var[ulChip].pohAlm[ulPort].rdi == 0x0100 )
    {
        pEntity->chip_var[ulChip].pohAlm[ulPort].rdi = 0;
    }
    pEntity->chip_var[ulChip].pohAlm[ulPort].rdiFc = 0;
    if (pEntity->chip_var[ulChip].pohAlm[ulPort].rfi == 0x0100 )
    {
        pEntity->chip_var[ulChip].pohAlm[ulPort].rfi = 0;
    }
    pEntity->chip_var[ulChip].pohAlm[ulPort].rfiFc = 0;
    
    

    memcpy((INT1 *)( pPmPara ), (INT1 *)(  &pmParm ), (  sizeof (pmParm) )) ;

    cah_em4_trace (18, "ent(%d), port(%d), bip(%d:%d), rei(%d:%d), fc(%d), fefc(%d), ssf(%x)",
                   entity, ulPort, pPmPara->bip, d1, pPmPara->rei, d2, pPmPara->fc, pPmPara->fefc,
                   pEntity->chip_var[ulChip].pohAlm[ulPort].ssf);
    
    
    return ((WORD)0x0) ;








    return 0;
}


WORD
CAH_EM4_DetectCardState (DWORD dwPos, BOOL * pbActive)
{




    CAH_EM4_ENTITY_DATA_T *p= ((void *)0) ;
    PB_ERROR_CODE_T ret;

    if (!pbActive)
    {
        printf ("\r\n%s(): pbActive is NULL!  \r\n", __FUNCTION__);
        return PB_ERR_PARAM;
    }

    ret = cah_em4_detectCardStateEx (p, pbActive);

    return ret;

}

PB_ERROR_CODE_T
CAH_EM4_blockAIS (DWORD dwPos, BOOL bEnable)
{





    CAH_EM4_ENTITY_DATA_T *pEntity = ((void *)0) ;
    UINT32 ulChip = 0;
    UINT32 ulPort = 0;
    ENTITY_T entity = 0;

    pEntity = cah_em4_getEntityPtr (entity);

    cah_em4_registerCall ((PMyFun) CAH_EM4_blockAIS, 0, 0, bEnable, 24, __FUNCTION__);

    if (pEntity->state != eEm4EntAct)
    {
         
        return PB_ERR_STATE;
    }


    for (ulChip = 0; ulChip < pEntity->chipNum; ulChip++)
    {
        for (ulPort = 0; ulPort < (63 ) ; ulPort++)
        {
            if (bEnable)
            {
                pEntity->chip_var[ulChip].bBlockAis[ulPort] = 1 ;
                cah_em4_insertUpAis (entity, ulChip, ulPort, 0 );
            }
            else
            {
                pEntity->chip_var[ulChip].bBlockAis[ulPort] = 0 ;
            }
        }
    }

    return ((WORD)0x0) ;




    return 0;
}










WORD
CAH_EM4_Initialize (DWORD dwPos)
{
    printf ("\r\n%s():\t called dwPos(%d)", __FUNCTION__, dwPos);

	CAH_EM4_activateEntity (0, 0 );
    return ((WORD)0x0) ;
}



 





WORD
CAH_EM4_GetInnerB1Err (DWORD dwPos, BYTE byPortNo, DWORD *pdwB1Err)
{
    return ((WORD)0x0) ;
}



 





WORD
CAH_EM4_GetTdmLinkErr (DWORD dwPos, DWORD *pdwTdmErr)
{
    return ((WORD)0x0) ;
}


 




WORD
CAH_EM4_Get8KClkState (DWORD dwPos, BOOL *pbActive)
{
    return ((WORD)0x0) ;
}

 





WORD
CAH_EM4_Get19MClkState (DWORD dwPos, BOOL *pbActive)
{
    return ((WORD)0x0) ;
}

 




WORD
CAH_EM4_GetPllState (DWORD dwPos, BOOL * pbPllLock)
{
    unsigned char * p = (unsigned char *)0x70000110 ;

    *pbPllLock = ((*p) & 0x02) ? 1  : 0 ;

    return ((WORD)0x0) ;
}



 

































WORD
CAH_EM4_InitEntity (ENTITY_T etEntity, DWORD dwPos, CTD_MODE_TYPE_T eporttype)
{




    CAH_EM4_ENTITY_DATA_T *pEntity;
	int ulChip = 0, ulPort = 0, i = 0;

    cah_em4_showbuild ();
    CAH_EM4_loadModule ();

    printf ("\r\n%s():\tentity(%d),\tdwPos(%d),\tporttype(%d)", __FUNCTION__, etEntity, dwPos, eporttype);
    cah_em4_trace (1 , "%s: File(%s) Line(%d)", __FUNCTION__, "cah_126e1.c", 7832);

    if (((void *)0)  == (pEntity = cah_em4_OpenEx ()))
    {
        printf ("\r\n%s(): cah_em4_OpenEx() CANNOT GET FD!!!", __FUNCTION__);
        return ((WORD)0x1) ;
    }

    cah_em4_printf ("\r\n126xe1rt: pEntity(%p)", pEntity);

     


    pEntity->entity = 0;
    pEntity->dwPos = 0;
    pEntity->chipNum = 2;
    pEntity->state = eEm4EntInit;
    pEntity->chip_var[0].cfg.baseAddr = (0x50000000) ;
    pEntity->chip_var[1].cfg.baseAddr = (0x60000000) ;
    pEntity->chip_var[0].su_id = 0;
    pEntity->chip_var[1].su_id = 0;

    cah_em4_initVars (pEntity, 2);
    for (i = 0; i < 8; i ++) g_timingVirtualSlot[i] = 0;

    for (ulChip = 0; ulChip < (int)pEntity->chipNum; ulChip++)
    {
        for (ulPort = 0; ulPort < (63 ) ; ulPort++)
        {
             


            pEntity->chip_var[ulChip].forceRptAlm[ulPort] = 1 ;
            pEntity->chip_var[ulChip].prbsCfg[ulPort].bForceRpt = 1 ;
            pEntity->chip_var[ulChip].nPrbsDelayCount[ulPort] = 0;
        }
    }
    return ((WORD)0x0) ;

    return 0;
}


CAH_EM4_CHIP_CONFIG_T g_cahEm4ChipCfg[2];
CAH_EM4_CALLBACKS_T g_callback;

typedef struct
{
    UINT32[TTT] address;
    unsigned short value;
}
CAH_EM4_REG_CONF;

 























 























extern struct _GlobalParams *pGlobalParams;

extern void sysHardDelayUs(UINT32 us);
extern void InitGlobalParams(void);

UINT GetBootProperties(void);
int GetBoardStyle(void);
int GetCardFunction(void);
UINT GetBoardProperties(void);
UINT GetBoardRev(void);
UINT GetChassisRev(void);

int GetFlashSize (void);
int GetRamSize (void);
int GetFlashType(void);
int GetSysFlashAddr (void);

BOOL GetBoardFlashBoot(void);
BOOL GetBoardFlashStorage(void);

UCHAR *GetBoardMacAddr(void);

UINT8 GetSlotNumber(void);

UCHAR *GetBootVersion(void);
UCHAR *GetBootDate(void);

u_long GetMainIP(void);

UINT32 GetBootHostAddress(void);
 
UINT32 ppcTBLfreq(void);
UINT32 ppcTBLrd(void);
UINT32 ppcTBUrd(void);

void ppcTBLwr(UINT32);
void ppcTBUwr(UINT32);

UINT8 sysModck13Get(void);
int sysClkRateGet(void);

void enablePrintProcess(void);
void disablePrintProcess(void);

int GetBoardSStatus(void);
void ClearBoardSStatus(int value);
void SetBoardSStatus(int value);
int GetBoardUStatus(void);
void SetBoardUStatus(int value);

UINT32 GetBpSerialNumber(char * buffer, UINT32 bufLen);
UINT32 GetBpManDate(char * buffer, UINT32 bufLen);


UINT32 GetSlotSerialNumber(PbSlotNumberType_Tval slot, char * buffer, UINT32 bufLen);
UINT32 GetSlotManDate(PbSlotNumberType_Tval slot, char * buffer, UINT32 bufLen);
UINT32 GetSlotPbCode(PbSlotNumberType_Tval slot, char * buffer, UINT32 bufLen);
UINT32 GetSlotSiProductNumber(PbSlotNumberType_Tval slot,char * buffer, UINT32 bufLen);
UINT32 GetSlotOEMProductNumber(PbSlotNumberType_Tval slot, char * buffer, UINT32 bufLen);
int GetSlotCardFunction(PbSlotNumberType_Tval slot);
int GetSlotBoardStyle(PbSlotNumberType_Tval slot);
UINT GetSlotBoardRev(PbSlotNumberType_Tval slot);
UINT GetSlotConfigOption(PbSlotNumberType_Tval slot);
void setFusionMisc(void);
UINT8 GetFusionMisc(void);
UINT8 scFpgaByteRead(int addr, BOOL readClear, const char * func, int line );
INT32 scFpgaByteWrite(int addr, UINT8 value, BOOL writeClear, const char * func, int line );
UINT8 scFpgaBitRead(int addr, UINT8 mask, BOOL readClear, const char * func, int line );
INT32 scFpgaBitWrite(int addr, UINT8 value, UINT8 mask, BOOL writeClear, const char * func, int line );


int slowJobAdd(FUNCPTR routine, int param1, int param2, int param3, int param4);

void RomWriteEnable(void);
void RomWriteDisable(void);
void setBootFlashVpp(int );
    














 




 































	

























     

     






    typedef enum {
        FPGA_CTRL_OK[TTT] = 0,
        FPGA_CTRL_ERROR = -1,
        FPGA_UNDEFINE_BOARDSTYLE = 101,
        FPGA_SETDABDL_FAIL,
        FPGA_SETDABACCESS_FAIL,
        FPGA_SETOFFLINE_FAIL,
        FPGA_SETCLOCK_FAIL,
        FPGA_RESETCARD_FAIL,
        FPGA_DLFPGA_FAIL,
        FPGA_INVALID_PARAM,
        FPGA_BOARD_REV_ERROR,
        FPGA_GLUE_TEST_ERROR
    }FPGA_DLFPGA_T;
     


     
    int fpga_InitCard ( int slot, BOOL bDLFPGA );






 
































void em4SetTbLoop (void)
{
	unsigned short u = 0;

	u = em4Map1Rd (0, 1);
	u |= 0x0002;
	em4Map1Wr (0, 1, u);

	u = em4Map2Rd (0, 1);
	u |= 0x0002;
	em4Map2Wr (0, 1, u);
	cah_em4_printf ("\r\n%s(): bpc loop set !!!", __FUNCTION__);
cah_em4_printf ("\r\n");
cah_em4_printf ("\r\n");
cah_em4_printf ("\r\n");
cah_em4_printf ("\r\n");
cah_em4_printf ("\r\n");
cah_em4_printf ("\r\n");
}



int wydact (void);
int
wydinit ()
{
    printf ("\r\n%s(): downloading fpga for slot 25...", __FUNCTION__);
    fpga_InitCard (GetSlotNumber (), 1);
printf ("\r\n");
printf ("\r\n");
printf ("\r\n");
printf ("\r\n");
printf ("\r\n");
printf ("\r\n");
    printf ("\r\n%s(): wait for 3 seconds between donwloading fpga and initialize procedure ...", __FUNCTION__);
    taskDelay (sysClkRateGet () * 3);
    memset (&g_cahEm4ChipCfg, 0, sizeof (CAH_EM4_CHIP_CONFIG_T));
    memset (&g_callback, 0, sizeof (CAH_EM4_CALLBACKS_T));
    if (((WORD)0x1)  == CAH_EM4_InitEntity (0, 0, 2))
	{
		printf ("\r\nCAH_EM4_InitEntity () error, abort !!!");
		return 0;
	}

    wydact ();
	taskDelay (sysClkRateGet () * 3);
	em4SetTbLoop ();
    return 0;
}


unsigned short
em4Map2Wr (int page, int off, unsigned short val)
{
    unsigned short u = 0;


    cah_em4_wr ((void *) (0x60000000) , ((page << 10) + off), val);
    return u;
}


unsigned short
em4Map1Wr (int page, int off, unsigned short val)
{
    unsigned short u = 0;


    cah_em4_wr ((void *) (0x50000000) , ((page << 10) + off), val);
    return u;
}

unsigned short
em4MapRd (int page, int off, unsigned short *pU1, unsigned short *pU2)
{
    unsigned short u2 = 0;
    unsigned short u1 = 0;
    *pU1 = u1 = cah_em4_rd ((void *) (0x50000000) , ((page << 10) + off));
    *pU2 = u2 = cah_em4_rd ((void *) (0x60000000) , ((page << 10) + off));

    return u1;
}

unsigned short
em4Map2Rd (int page, int off)
{
    unsigned short u1 = 0;
    u1 = cah_em4_rd ((void *) (0x60000000) , ((page << 10) + off));

    return u1;
}


unsigned short
em4Map1Rd (int page, int off)
{
    unsigned short u1 = 0;
    u1 = cah_em4_rd ((void *) (0x50000000) , ((page << 10) + off));

    return u1;
}

unsigned short
em4_bpc_wr (int page, int off, unsigned short val)
{
    unsigned short u = 0;


    cah_em4_wr ((void *) (0x80000000) , ((page << 10) + off), val);
    return u;
}

unsigned short
em4_fus_rd (void)
{
    unsigned short u = 0;
    u = cah_em4_rd ((void *) 0x70000010, 0);

    return u;
}

unsigned short
em4_bpc_rd (int page, int off)
{
    unsigned short u = 0;
    u = cah_em4_rd ((void *) (0x80000000) , ((page << 10) + off));

    return u;
}

static void
bpc_mgt_wps (void)
{
    unsigned short u = 0;

    u = em4_bpc_rd (1, 0x001);
    if (u & 0x8000)
    {
        printf ("\r\npage(1)off(0x001):\twork channel select");
    }
    else
    {
        printf ("\r\npage(1)off(0x001):\tprotect channel select");
    }
}

void
bpc_dcm_rst_al (void)
{
    unsigned short u = 0;

    printf ("\r\npage(4)off(0x000):\treset all dcm");
    em4_bpc_wr (4, 0x000, 0x007);
     
    u = 1;
    return;
}

void
bpc_dcm_st (void)
{
    unsigned short u1 = em4_bpc_rd (4, 0x010);
    unsigned short u2 = em4_bpc_rd (4, 0x011);

    printf ("\r\npage(4)off(0x010):\tclk77m locked: (%x)", u1);
    printf ("\r\npage(4)off(0x011):\tclk93m locked: (%x)", u2);

    return;
}

void
bpc_rst (void)
{
    em4_bpc_wr (0, 0x003, 0x0001);
     
    taskDelay (10);
    em4_bpc_wr (0, 0x003, 0x0000);
}

void
mgt_pwr (int flag)
{
    if (flag)
    {
        em4_bpc_wr (1, 0x20, 0);
        em4_bpc_wr (1, 0x30, 0);
    }
    else
    {
        em4_bpc_wr (1, 0x20, 1);
        em4_bpc_wr (1, 0x30, 1);
    }
}

void
bpc_mgt_descram (int ch, int en)
{
    unsigned short u = 0;

    if (ch)
    {
        cah_em4_printf ("\r\npage(1)off(0x34):\tprotect channel");
        u = em4_bpc_rd (1, 0x034);
    }
    else
    {
        cah_em4_printf ("\r\npage(1)off0x024):\twork channel");
        u = em4_bpc_rd (1, 0x024);
    }

    if (en)
    {
        cah_em4_printf ("(enable)");
        u = u | 0x0020;
    }
    else
    {
        cah_em4_printf ("(disable)");
        u = u & 0xffdf;
    }

    if (ch)
    {
        em4_bpc_wr (1, 0x034, u);
    }
    else
    {
        em4_bpc_wr (1, 0x024, u);
    }
}


void
bpc_mgt_up_scram (int en)
{
    unsigned short u = 0;

    u = em4_bpc_rd (1, 0x003);
    if (en)
    {
        cah_em4_printf ("\r\npage(1)off(0x003):\tmgt up scram enable");
        em4_bpc_wr (1, 0x003, u | 0x0001);
    }
    else
    {
        cah_em4_printf ("\r\npage(1)off(0x003):\tmgt up scram disable");
        em4_bpc_wr (1, 0x003, u & 0xfffe);
    }
}

 
















 
void
bpc_rst_mgt_fifo (void)
{
    unsigned short u = 0;

    cah_em4_printf ("\r\npage(1)off(0x020/0x030):\treset mgt tx/rx fifo ...");
    
     
    u = em4_bpc_rd (1, 0x003);
    em4_bpc_wr (1,  0x003, u | 0x0010);
     
    
    u = em4_bpc_rd (1, 0x020);
    em4_bpc_wr (1, 0x020, u | 0x0060);
    u = em4_bpc_rd (1, 0x030);
    em4_bpc_wr (1, 0x030, u | 0x0060);
    
    taskDelay (10);
    
      
    u = em4_bpc_rd (1, 0x003);
    em4_bpc_wr (1,  0x003, u & 0xFFEF);
     
    
    u = em4_bpc_rd (1, 0x020);
    em4_bpc_wr (1, 0x020, u & 0xff9f);
    u = em4_bpc_rd (1, 0x030);
    em4_bpc_wr (1, 0x030, u & 0xff9f);
    cah_em4_printf ("           (done)");
}

void
bpc_mgt_8k_mon_w (void)
{
    unsigned short dly8k_now = 0;
    unsigned short row_now = 0;
    unsigned short col_now = 0;
    unsigned short cyc_now = 0;

    unsigned short dly8k = 0;
    unsigned short cyc = 0;
    unsigned short col = 0;
    unsigned short row = 0;

    dly8k_now = em4_bpc_rd (1, 0x002);
    row_now = (dly8k_now & 0xf000) >> 12;
    col_now = (dly8k_now & 0x0ff8) >> 3;
    cyc_now = (dly8k_now & 0x0003);
    cah_em4_printf ("\r\npage(1)off(0x002):\tmgt c1 delay set now : row %d ; col %d ; cyc %d", row_now,
            col_now, cyc_now);

    cah_em4_printf ("\r\npage(1)off(0x026):\tRead out work channel phase ofset is : ");
    dly8k = em4_bpc_rd (1, 0x026);
    cyc = dly8k - ((dly8k / 4) * 4);
    col = dly8k / 4 - dly8k / (270 * 4) * 270;
    row = dly8k / (4 * 270);
    cah_em4_printf ("row : %d ; col : %d ; cyc : %d", row, col, cyc);

}


void
bpc_mgt_8k_mon_p (void)
{
    unsigned short dly8k_now = 0;
    unsigned short row_now = 0;
    unsigned short col_now = 0;
    unsigned short cyc_now = 0;

    unsigned short dly8k = 0;
    unsigned short cyc = 0;
    unsigned short col = 0;
    unsigned short row = 0;


    dly8k_now = em4_bpc_rd (1, 0x002);
    row_now = (dly8k_now & 0xf000) >> 12;
    col_now = (dly8k_now & 0x0ff8) >> 3;
    cyc_now = (dly8k_now & 0x003);
    cah_em4_printf ("\r\npage(1)off(0x002):\tmgt c1 delay set now : row %d ; col %d ; cyc %d", row_now,
            col_now, cyc_now);

    cah_em4_printf ("\r\npage(1)off(0x036):\tRead out work channel phase ofset is : ");
    dly8k = em4_bpc_rd (1, 0x036);
    cyc = dly8k - ((dly8k / 4) * 4);
    col = dly8k / 4 - dly8k / (270 * 4) * 270;
    row = dly8k / (4 * 270);
    cah_em4_printf ("row : %d ; col : %d ; cyc : %d", row, col, cyc);

}

void
set_c1j1_a (unsigned short row, unsigned short col, unsigned short cyc)
{
    em4_bpc_wr (2, 3, (row << 12) + (col << 3) + cyc);
}

void
set_c1j1_b (unsigned short row, unsigned short col, unsigned short cyc)
{
    em4_bpc_wr (2, 4, (row << 12) + (col << 3) + cyc);
}

int
em4MapShow ()
{
    unsigned short u1 = 0, u2 = 0;


    printf ("\r\n--- 126xE1 Mapper Fpga Chip ---");
    printf ("\r\n[page 0]");
    em4MapRd (0, 0, &u1, &u2);
    printf ("\r\noffset(0x00),\tval(0x%x)(0x%x): \tdevice version", u1, u2);


    em4MapRd (0, 0x01, &u1, &u2);
    printf ("\r\noffset(0x01),\tval(0x%x)(0x%x): \ttb_out_edge, tb_out_loop", u1, u2);

    em4MapRd (0, 0x02, &u1, &u2);
    printf ("\r\noffset(0x02),\tval(0x%x)(0x%x): \tdevice id", u1, u2);

    em4MapRd (0, 0x03, &u1, &u2);
    printf ("\r\noffset(0x03),\tval(0x%x)(0x%x): \tcontrol c1 add/drop", u1, u2);

    em4MapRd (0, 0x05, &u1, &u2);
    printf ("\r\noffset(0x05),\tval(0x%x)(0x%x): \tirq in", u1, u2);


    em4MapRd (0, 0x09, &u1, &u2);
    printf ("\r\noffset(0x09),\tval(0x%x)(0x%x): \tmask", u1, u2);

    em4MapRd (0, 0x0a, &u1, &u2);
    printf ("\r\noffset(0x0a),\tval(0x%x)(0x%x): \tdcm_locked/reset_cnt", u1, u2);

    em4MapRd (0, 0x0b, &u1, &u2);
    printf ("\r\noffset(0x0b),\tval(0x%x)(0x%x): \ttimeing_sel1", u1, u2);
    em4MapRd (0, 0x10, &u1, &u2);
    printf ("\r\noffset(0x10),\tval(0x%x)(0x%x): \ttest_reg", u1, u2);

    em4MapRd (0, 0x12, &u1, &u2);
    printf ("\r\noffset(0x12),\tval(0x%x)(0x%x): \te1_los", u1, u2);

    printf ("\r\n[page 0]");

    em4MapRd (1, 0x00, &u1, &u2);
    printf ("\r\noffset(0x00),\tval(0x%x)(0x%x): \th4_lom", u1, u2);

    em4MapRd (1, 0x01, &u1, &u2);
    printf ("\r\noffset(0x01),\tval(0x%x)(0x%x): \th4_lom_d", u1, u2);

    em4MapRd (1, 0x02, &u1, &u2);
    printf ("\r\noffset(0x02),\tval(0x%x)(0x%x): \th4_lom_m", u1, u2);

    em4MapRd (1, 0x03, &u1, &u2);
    printf ("\r\noffset(0x03),\tval(0x%x)(0x%x): \tlopi_vc12", u1, u2);

    em4MapRd (1, 0x04, &u1, &u2);
    printf ("\r\noffset(0x04),\tval(0x%x)(0x%x): \tlop_v1/v2", u1, u2);

    em4MapRd (1, 0x10, &u1, &u2);
    printf ("\r\noffset(0x10),\tval(0x%x)(0x%x): \tlopi_state", u1, u2);


    printf ("\r\n[page 2]: POH Monitor");

    printf ("\r\n");

    printf ("\r\n[page 4]: POH Monitor");

    em4MapRd (4, 0x000, &u1, &u2);
    printf ("\r\noffset(0x000),\tval(0x%x)(0x%x): \tc1_unstable/c1_delay/edge/rst", u1, u2);


    em4MapRd (4, 0x001, &u1, &u2);
    printf ("\r\noffset(0x001),\tval(0x%x)(0x%x): \tthresh_high/low", u1, u2);

    em4MapRd (4, 0x00c, &u1, &u2);
    printf ("\r\noffset(0x00c),\tval(0x%x)(0x%x): \tcfg_vc12_pdh", u1, u2);
    em4MapRd (4, 0x00d, &u1, &u2);
    printf ("\r\noffset(0x00d),\tval(0x%x)(0x%x): \tcfg_vc12_pdh", u1, u2);
    em4MapRd (4, 0x00e, &u1, &u2);
    printf ("\r\noffset(0x00e),\tval(0x%x)(0x%x): \tcfg_vc12_pdh", u1, u2);
    em4MapRd (4, 0x00f, &u1, &u2);
    printf ("\r\noffset(0x00f),\tval(0x%x)(0x%x): \tcfg_vc12_pdh", u1, u2);

    em4MapRd (4, 0x010, &u1, &u2);
    printf ("\r\noffset(0x010),\tval(0x%x)(0x%x): \te1_outloop", u1, u2);
    em4MapRd (4, 0x011, &u1, &u2);
    printf ("\r\noffset(0x011),\tval(0x%x)(0x%x): \te1_outloop", u1, u2);
    em4MapRd (4, 0x012, &u1, &u2);
    printf ("\r\noffset(0x012),\tval(0x%x)(0x%x): \te1_outloop", u1, u2);
    em4MapRd (4, 0x013, &u1, &u2);
    printf ("\r\noffset(0x013),\tval(0x%x)(0x%x): \te1_outloop", u1, u2);

    printf ("\r\n");
    return 0;
}

int
em4BpcShow ()
{
    printf ("\r\n--- Back Plane Converter ---");
    printf ("\r\n[page 0]");
    printf ("\r\noffset(0x00),\tval(0x%x): \tmajor &minor version", em4_bpc_rd (0, 0));
    printf ("\r\noffset(0x01),\tval(0x%x): \ttest_reg", em4_bpc_rd (0, 1));
    printf ("\r\noffset(0x03),\tval(0x%x): \tsw_rst", em4_bpc_rd (0, 3));
    printf ("\r\noffset(0x04),\tval(0x%x): \tref8k", em4_bpc_rd (0, 4));
    printf ("\r\n[page 1]");
    printf ("\r\noffset(0x00),\tval(0x%x): \ttest_reg", em4_bpc_rd (1, 0));
    printf ("\r\noffset(0x01),\tval(0x%x): \twpsel", em4_bpc_rd (1, 1));
    printf ("\r\noffset(0x02),\tval(0x%x): \tc1delay", em4_bpc_rd (1, 2));
    printf ("\r\noffset(0x03),\tval(0x%x): \tc1delay", em4_bpc_rd (1, 3));
    printf ("\r\noffset(0x04),\tval(0x%x): \tfrm_up_haps", em4_bpc_rd (1, 4));
    printf ("\r\noffset(0x05),\tval(0x%x): \tfrm_up_haps", em4_bpc_rd (1, 5));
    printf ("\r\noffset(0x06),\tval(0x%x): \tfrm_up_haps", em4_bpc_rd (1, 6));



    printf ("\r\noffset(0x20),\tval(0x%x): \tmgt", em4_bpc_rd (1, 0x20));
    printf ("\r\noffset(0x21),\tval(0x%x): \tmgt", em4_bpc_rd (1, 0x21));
    printf ("\r\noffset(0x22),\tval(0x%x): \tauto_mgt_tx_rst_cnt", em4_bpc_rd (1, 0x22));
    printf ("\r\noffset(0x23),\tval(0x%x): \tfrm_ds_b1_cnt", em4_bpc_rd (1, 0x23));
    printf ("\r\noffset(0x24),\tval(0x%x): \tfrm_ds", em4_bpc_rd (1, 0x24));
    printf ("\r\noffset(0x25),\tval(0x%x): \tdbg_edge/data_sel", em4_bpc_rd (1, 0x25));
    printf ("\r\noffset(0x26),\tval(0x%x): \tfp8k_mon", em4_bpc_rd (1, 0x26));
    printf ("\r\noffset(0x27),\tval(0x%x): \tmgt_tx/rx_center", em4_bpc_rd (1, 0x27));
    printf ("\r\noffset(0x28),\tval(0x%x): \tline c1 realtime mon", em4_bpc_rd (1, 0x28));
    printf ("\r\noffset(0x29),\tval(0x%x): \tlof_cnt", em4_bpc_rd (1, 0x29));
    printf ("\r\n\"Port 1(protection channel) configuration/status ");
    printf ("\r\n0x30, 0x31, 0x32, 0x33,0x34,0x35,0x36,0x37\"");
    printf ("\r\n[page 2]");

    printf ("\r\noffset(0x00),\tval(0x%x): \ttest_reg", em4_bpc_rd (2, 0x0));
    printf ("\r\noffset(0x01),\tval(0x%x): \ttbi_19m_out/inloop", em4_bpc_rd (2, 0x1));
    printf ("\r\noffset(0x02),\tval(0x%x): \tadd_19m_c1delay_row/col", em4_bpc_rd (2, 0x2));
    printf ("\r\noffset(0x03),\tval(0x%x): \ttbi_add_a_c1delay_row/col", em4_bpc_rd (2, 0x3));
    printf ("\r\noffset(0x04),\tval(0x%x): \ttbi_add_b_c1delay_row/col", em4_bpc_rd (2, 0x4));


    printf ("\r\n[page 3]");
    printf ("\r\noffset(0x000),\tval(0x%x): \ttest_reg", em4_bpc_rd (3, 0x000));
    printf ("\r\noffset(0x004),\tval(0x%x): \tepg_alarm_a/b_fall_edge_en", em4_bpc_rd (3, 0x004));
    printf ("\r\noffset(0x005),\tval(0x%x): \tepg_alarm_a/b_even_err_msk", em4_bpc_rd (3, 0x005));
    printf ("\r\noffset(0x007),\tval(0x%x): \tlos_num_a0/1", em4_bpc_rd (3, 0x007));
    printf ("\r\noffset(0x008),\tval(0x%x): \tlos_num_a2/3", em4_bpc_rd (3, 0x008));
    printf ("\r\noffset(0x009),\tval(0x%x): \tlos_num_b0/1", em4_bpc_rd (3, 0x009));
    printf ("\r\noffset(0x00a),\tval(0x%x): \tlos_num_b2/3", em4_bpc_rd (3, 0x00a));
    printf ("\r\n[page 4]");

    printf ("\r\noffset(0x000),\tval(0x%x): \tintr,cpu_dcm_all_rst", em4_bpc_rd (4, 0x000));
    printf ("\r\noffset(0x005),\tval(0x%x): \ttest_reg", em4_bpc_rd (4, 0x005));
    printf ("\r\noffset(0x010),\tval(0x%x): \tint_dcm_rst_cnt_77m", em4_bpc_rd (4, 0x010));
    printf ("\r\noffset(0x011),\tval(0x%x): \tint_dcm_rst_cnt_93m", em4_bpc_rd (4, 0x011));
    printf ("\r\noffset(0x012),\tval(0x%x): \tint_dcm_rst_cnt_19m", em4_bpc_rd (4, 0x012));



    printf ("\r\n");

    return 0;
}

int
cah_em4_initFusion (void)
{





  
    return 0;
}



int buffer_reset (void)
{
    unsigned short u = 0;
    
    u = em4_bpc_rd (1, 0x003);
    u |= 0x0011;
    em4_bpc_wr (1, 0x003, u);    

    printf ("\r\nwaiting for clear ...");
    taskDelay (1);
    u &= ~0x0010;
    em4_bpc_wr (1, 0x003, u);    
    
    return 0;
}
void  cah_em4_initCpu  (void)
{

    ((UINT32)(*(volatile UINT32*)( 0xf0000120 )))  = 0x70000401;    
    ((UINT32)(*(volatile UINT32*)( 0xf0000124 )))  = 0xffff0e3e;
    
    ((UINT32)(*(volatile UINT32*)( 0xf0000110 )))  = 0x50000801;  
    ((UINT32)(*(volatile UINT32*)( 0xf0000114  )))  =0xff00014a;  
       
    ((UINT32)(*(volatile UINT32*)( 0xf0000118 )))  = 0x60000801;  
    ((UINT32)(*(volatile UINT32*)( 0xf000011c )))  = 0xff00014a ;      
}

void cah_em4_init_fus (void)
{
  UINT8 u=0;

    ((UINT8)(*(volatile UINT8*)( (0x70000000)  +0x0102 )))  =0x02;
   taskDelay(10);
   ((UINT8)(*(volatile UINT8*)( (0x70000000)  +0x0102 )))  =0x06;
   taskDelay(10);
    ((UINT8)(*(volatile UINT8*)( (0x70000000)  + 0x04 )))  = 0x00;

   u= ((UINT8)(*(volatile UINT8*)( (0x70000000)  + 0x02 ))) ;
   u=u&0x02;
   if (u == 0x02)
   {
   	  printf ("\r\ncah_em4_init_fus:Select work CC!");
   }
   else
   {
        printf ("\r\ncah_em4_init_fus:Select protect CC!!");
   }
    
   ((UINT8)(*(volatile UINT8*)( (0x70000000)  +0x03 )))  = 0x00;
   ((UINT8)(*(volatile UINT8*)( (0x70000000)  +0x04 )))  = 0x00;
   ((UINT8)(*(volatile UINT8*)( (0x70000000)  +0x05 )))  = 0x00;
   ((UINT8)(*(volatile UINT8*)( (0x70000000)  +0x06  )))  = 0x00;

   
  ((UINT8)(*(volatile UINT8*)( (0x70000000)  +0x000b )))  = 0x00;
  ((UINT8)(*(volatile UINT8*)( (0x70000000)  +0x000d )))  = 0x00;
  ((UINT8)(*(volatile UINT8*)( (0x70000000)  +0x000f )))  = 0x00;
  ((UINT8)(*(volatile UINT8*)( (0x70000000)  +0x0011 )))  = 0x00;
  ((UINT8)(*(volatile UINT8*)( (0x70000000)  +0x0013 )))  = 0x16;
  ((UINT8)(*(volatile UINT8*)( (0x70000000)  +0x0015 )))  =0x16;
 
  
 ((UINT8)(*(volatile UINT8*)( (0x70000000)  + 0x001b )))  =  0x00;
  ((UINT8)(*(volatile UINT8*)( (0x70000000)  +0x001c )))  =  0x00;
  ((UINT8)(*(volatile UINT8*)( (0x70000000)  +0x001d )))  =  0x03;
  ((UINT8)(*(volatile UINT8*)( (0x70000000)  +0x001e )))  =  0x03; 
 printf ("\r\ncah_em4_init_fus:fusion initializtion is ok!");
    
} 
int cah_em4_initBpc (void)
{
    printf ("\r\n<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<");
     





    cah_em4_printf ("\r\n%s(): init BackPlane Converter at base(%x)", __FUNCTION__, (0x80000000) );
    cah_em4_printf ("\r\n%s(): The version register(%x)", __FUNCTION__, (em4_bpc_rd (0, 0)));
    cah_em4_printf ("\r\n%s(): The major version is (%x)", __FUNCTION__, (em4_bpc_rd (0, 0) >> 8));
    cah_em4_printf ("\r\n%s(): The minor version is (%x)", __FUNCTION__, (em4_bpc_rd (0, 0) & 0xff));
    cah_em4_printf ("\r\n%s(): The micro version is (%x)", __FUNCTION__, em4_bpc_rd (0, 1));
    bpc_mgt_wps ();

    bpc_dcm_rst_al ();
     
    taskDelay(10);
    
    bpc_dcm_st ();
    printf ("\r\npage(0)off(0x003):\tsoftware reset");
    bpc_rst ();


    buffer_reset ();     
    taskDelay (10);


    cah_em4_printf ("\r\npage(1)off(0x20/0x30):\tinitialize mgt");
    mgt_pwr (1);
     
    taskDelay (10);

    cah_em4_printf ("\r\nscram enable");
    bpc_mgt_descram (0, 1);
    bpc_mgt_descram (1, 1);
    bpc_mgt_up_scram (1);

    cah_em4_printf ("\r\npage(1)off(0x002):\tset bpc rx 8k delay");
    em4_bpc_wr (1, 0x002, 0x87b0);
    
    cah_em4_printf ("\r\nFIFO reset");
     
    taskDelay (50);
    bpc_rst_mgt_fifo ();

    taskDelay (10);
    bpc_mgt_8k_mon_w ();
    bpc_mgt_8k_mon_p ();

    printf ("\r\npage(2)off(1):\tinitialize the TBI");

    em4_bpc_wr (2, 1, 0x0000);
    
    cah_em4_printf ("\r\npage(2)off(3/4):\t set c1j1 a/b");
    set_c1j1_a (0, 2, 0);
    set_c1j1_b (0, 2, 0);
    
    cah_em4_printf ("\r\npage(3)off(0x4):\t  set  epg alarm page ");
    em4_bpc_wr (3, 0x04, 0x0000);
    
    printf ("\r\n126xE1 bpc initialization complete");
    printf ("\r\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");

    return 0;
}




 


PB_ERROR_CODE_T
CAH_EM4_activateEntity (DWORD dwPos, BOOL b_warm)
{




    CAH_EM4_ENTITY_DATA_T *pEntity = 0;
    ENTITY_T entity = 0;

    cah_em4_trace (1 , "\r\n(%s): Enter EM4_activateEntity File=%s; Line=%d  ", __FUNCTION__, "cah_126e1.c", 8639);

    if (!b_warm)
    {
         


         
        printf ("\r\n%s(): cah_em4_initCpu ()", __FUNCTION__);
         
         
         
         
        printf ("\r\n%s(): cah_em4_initChip", __FUNCTION__);
        cah_em4_initBpc();
         
         
         
        printf ("\r\n%s(): BPC initialized @0x80000000", __FUNCTION__);
        
        printf ("\r\n[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[");
        if (((WORD)0x0)  != cah_em4_initChip (entity))
        {
            printf ("\r\EM4_activateEntity: **Error!  Entity= %d; File=%s; Line=%d  ", entity, "cah_126e1.c", 8662);
    		printf ("\r\n]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]");
            return ((WORD)0x1) ;
        }





    }
    printf ("\r\n]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]");

    gCahEm4TribVar.bEM4Running = 1 ;
    pEntity->state = eEm4EntAct;
      
     
     
      

    return ((WORD)0x0) ;
}


int
wydact (void)
{
    CAH_EM4_activateEntity (0, 0);
    return 0;
}



PB_ERROR_CODE_T
CAH_EM4_deActEntity (DWORD dwPos)
{




    CAH_EM4_ENTITY_DATA_T *pEntity = ((void *)0) ;
    ENTITY_T entity = 0;

    printf ("\r\nEM4_DEACTENTITY: ENTITY(%d) DEACTIVE", entity);

    if (((void *)0)  == (pEntity = cah_em4_getEntityPtr (entity)))
    {
        printf ("\r\nEM4_DeactEntity:  entity(%d) ptr NULL, File(%s), line(%d)", entity, "cah_126e1.c", 8708);
        return PB_ERR_PARAM;
    }

    if (eEm4EntAct != pEntity->state)
    {
        printf ("\r\nEM4_DeactEntity: entity(%d) status error, file(%s), line(%d)", entity, "cah_126e1.c", 8714);
        return PB_ERR_STATE;
    }

    pEntity->state = eEm4EntInit;
    printf ("\r\nEM4_DeactEntity : entity(%d) intUnconnected", entity);

    return ((WORD)0x0) ;

}



WORD
CAH_EM4_DeInitEntity (DWORD dwPos)
{




	CAH_EM4_ENTITY_DATA_T *p = ((void *)0) ;
    printf ("\r\n%s(): enter function ", __FUNCTION__);

	p = cah_em4_getEntityPtr (0);
    cah_em4_revise (0);

	if (!p)
	{
		printf ("\r\n%s(): pointer gppCahEm4CfgVar[0] NULL ", __FUNCTION__);
		return ((WORD)0x1) ;
	}

	if (p->state)
	{
		printf ("\r\n%s(): card state(%d) error", __FUNCTION__, gppCahEm4CfgVar[0]->state);
		return ((WORD)0x1) ;
	}

   	{ if( p ) { free((void*) p );  p  = ((void *)0) ; }} ;
    gppCahEm4CfgVar[0] = ((void *)0) ;

    return ((WORD)0x0) ;

}





void
CAH_EM4_setTransFunc (CahEm4pTransFunc pfunc)
{



    g_pTransFunc = pfunc;


    return;
}



WORD
CAH_EM4_GetSlip (DWORD dwPos, BYTE byPortNo, DWORD * pdwPSlip, DWORD * pdwNSlip)
{
    cah_em4_GetSlip (dwPos, SDD_126xE1IOPortConvert(byPortNo), pdwPSlip, pdwNSlip);
    return 0;
}

WORD
CAH_EM4_getLatchStatus (DWORD dwPos)
{




    CAH_EM4_ENTITY_LATCH_T ret = EM4_ENTITY_UNKNOWN;
    void *baseaddr = ((void *)0) ;
    unsigned short status = 0;
    CAH_EM4_ENTITY_DATA_T *pEntity;
    ENTITY_T entity = 0;

    baseaddr = cah_em4_getEntityBase (entity, 100);
    pEntity = cah_em4_getEntityPtr (entity);
    status = cah_em4_rd (baseaddr, ((0x00 << 10) | 0x05) );
    if (status & 0x01)
    {
        ret = EM4_ENTITY_DELATCH;
    } else {
        ret = EM4_ENTITY_LATCH;
    }
    return ret;

}


WORD
CAH_EM4_GetTuAlmState (DWORD dwPos, UINT8 byPortNo, CTD_TU_ALARM_T * psTuAlarm)
{

     int ulPort = 0;
	unsigned short uu = 0, u = 0;
	void * base = 0;
	int regcnt = 0;

	{if (125 <  SDD_126xE1IOPortConvert(byPortNo) ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  SDD_126xE1IOPortConvert(byPortNo) ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;
	base = cah_em4_getEntityBase (0, SDD_126xE1IOPortConvert(byPortNo));
      ulPort = cah_em4_mapPort (SDD_126xE1IOPortConvert(byPortNo)) - 1;

	 
     cah_em4_wr (base, ((0x01 << 10) | 0x03) , ulPort | 0x8000);
     

    regcnt = 0;
    while (1)
    {
        uu = cah_em4_rd (base, ((0x01 << 10) | 0x03) );
        if (!(0x8000 & uu))
        {
            break;
        }
        else
        {
            regcnt++;
            if (regcnt > 100)
            {
				printf ("\r\n%s(): fpga read error ", __FUNCTION__);
                break;
            }
        }
    }

    u = cah_em4_rd (base, ((0x01 << 10) | 0x10) ) & 0x0003;
    psTuAlarm->ais = (0x0001 == u) ? 1 : 0;
    psTuAlarm->lop = (0x0002 == u) ? 1 : 0;

    return ((WORD)0x0) ;
}



WORD
CAH_EM4_GetLpAlmState (DWORD dwPos, UINT8 byPortNo, CTD_LP_ALARM_T * psLpAlarm)
{
     int ulPort = 0; 
	void * base = 0;
	unsigned short u = 0;

	{if (125 <  SDD_126xE1IOPortConvert(byPortNo) ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  SDD_126xE1IOPortConvert(byPortNo) ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;
	base = cah_em4_getEntityBase (0, SDD_126xE1IOPortConvert(byPortNo));
       ulPort = cah_em4_mapPort (SDD_126xE1IOPortConvert(byPortNo)) - 1;
	 u = cah_em4_pohRead (base, ulPort, 0x03 );
	

    psLpAlarm->tim 	= ((u & 0x0001) ? 1 : 0);
    psLpAlarm->plm 	= ((u & 0x0004) ? 1 : 0);
    psLpAlarm->uneq = ((u & 0x0008) ? 1 : 0);
    psLpAlarm->rdi 	= ((u & 0x0010) ? 1 : 0);
    psLpAlarm->rfi 	= ((u & 0x0080) ? 1 : 0);
    
	return ((WORD)0x0) ;
}

int g_mon = 0;
int g_monport = 0;

int cah_em4_readPortSchemeLos (int groupport , int group)
{
    int phyport = 0;
    UINT16 reg = 0;
    int los = 0;

    if (0 > groupport || 71 < groupport)
    {
        printf ("(%s): port number(%d) overflow", "cah_126e1.c", groupport);
        return -1;
    }

    phyport = g_phyportmap [groupport + 1] - 1;
    reg = em4_bpc_rd (3, (phyport/16)+((!group) ? ((0x021) ):0x26));
    if (g_mon && g_monport == groupport)
    {
            printf ("group(%d)phyport(%2d)reg(%4x)off(%4x)\r\n", group, phyport, reg,   (phyport/16)+((!group) ? ((0x021) ):0x26) );
    }
    los = (reg & (0x0001 << ((phyport) % 16))) ? 1 : 0;

    return los;
}


WORD
cah_em4_getPhyLos (DWORD dwPos, UINT8 byPortNo, CTD_PPI_ALARM_T * psPpiAlarm)
{
    ENTITY_T entity = 0;
    int ulPort = 0;
    CAH_EM4_ENTITY_DATA_T *pEntity;
	void * base = 0;
    int schemePort = 0;

	{if (125 <  byPortNo ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  byPortNo ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;

    pEntity = cah_em4_getEntityPtr (entity);
    ulPort = cah_em4_mapPort (byPortNo) - 1;
    base = cah_em4_getEntityBase (0, byPortNo);

    schemePort = g_phyportmap [ulPort + 1] - 1;
    
     psPpiAlarm->los = cah_em4_readPortSchemeLos (ulPort, byPortNo / 63);
     



    return psPpiAlarm->los;
}

 


static int
isIOAbsent(int port, unsigned char *pIO)
{
    int absent = 0;
    unsigned short val = 0;
    int io = 0;

    io = 0;

    if (port >= 0 && port <=20){
        val = em4Map1Rd (0, 0x12);
        absent = (val & 0x02) ? 1 : 0;
        *pIO = 5;    
    } else if (21 <= port && port <= 41){
        val = em4Map1Rd (0, 0x12);
        absent = (val & 0x04) ? 1 : 0;
        *pIO = 3; 
    } else if (42 <= port && port <= 62){
        val = em4Map1Rd (0, 0x12);
        absent = (val & 0x08) ? 1 : 0;
        *pIO = 1; 
    } else if ((0 + 63) <= port && port <= (20 + 63)){
        val = em4Map2Rd (0, 0x12);
        absent = (val & 0x02) ? 1 : 0;
        *pIO = 6; 
    } else if ((21 + 63) <= port && port <= (41 + 63)) {
        val = em4Map2Rd (0, 0x12);
        absent = (val & 0x04) ? 1 : 0;
        *pIO = 4; 
    } else if ((42 + 63) <= port && port <= (62 + 63)) {
        val = em4Map2Rd (0, 0x12);
        absent = (val & 0x08) ? 1 : 0;
        *pIO = 2; 
    }
   
    return (absent);
}




 


int clr_payload_ais (int port)
{
	void * base = 0;
    unsigned short val = 0;
    int byte = 0, bit = 0;

    byte = port / 16;
    bit = port % 16;
    
    val = cah_em4_rd (base, ((((0x00 << 10) | 0x20) ) + byte));
    
    if (val & (0x01 << bit)) 
    {
         


        val &= ~(0x01 << bit);
        cah_em4_wr (base, ((((0x00 << 10) | 0x20) ) + byte), val);
    } else {
    }

    return 0;

}


 


int set_payload_ais (int port)
{
	void * base = 0;
    unsigned short val = 0;
    int byte = 0, bit = 0;

    byte = port / 16;
    bit = port % 16;
    
    val = cah_em4_rd (base, ((((0x00 << 10) | 0x20) ) + byte));
    
    if (val & (0x01 << bit)) 
    {
    } else {
        val |= (0x01 << bit);
        cah_em4_wr (base, ((((0x00 << 10) | 0x20) ) + byte), val);
    }

    return 0;
}


int set_ioN_ais (int io)
{
    int firstport = 0, lastport = 0;
    int i = 0;

    sdd_get_ioN_port (io, &firstport, &lastport);

    for (i = firstport; i <= lastport; i ++);
    {
        set_payload_ais (i);
    }
    
    return 0;
}





int clear_IO_payload_si (io)
{
    int firstport = 0, lastport = 0;
    int i = 0;

    sdd_get_ioN_port (io, &firstport, &lastport);

    for (i = firstport; i <= lastport; i ++);
    {
        clr_payload_ais (i);
    }
    
    return 0;
}




int g_ioabsent = 0;





WORD
CAH_EM4_GetPpiAlmState (DWORD dwPos, UINT8 byPortNo, CTD_PPI_ALARM_T * psPpiAlarm)
{
    ENTITY_T entity = 0;
    int ulPort = 0;
    CAH_EM4_ENTITY_DATA_T *pEntity;
	unsigned short u = 0;
	void * base = 0;
    int isloop = 0;
    CTD_PPI_ALARM_T alm;
    unsigned short val = 0;
    unsigned char io = 0;

    val = 0;

	{if (125 <  SDD_126xE1IOPortConvert(byPortNo) ) { printf ("\r\n%s(): port(%d) overflow", __FUNCTION__,  SDD_126xE1IOPortConvert(byPortNo) ); printf ("\r\n\r\n\r\n"); return ((WORD)0x1) ; } } ;
    memset (&alm, 0, sizeof (CTD_PPI_ALARM_T));

    pEntity = cah_em4_getEntityPtr (entity);
    ulPort = cah_em4_mapPort (SDD_126xE1IOPortConvert(byPortNo)) - 1;
	base = cah_em4_getEntityBase (0, SDD_126xE1IOPortConvert(byPortNo));
    if (byPortNo == g_ulport)
    {
        printf ("\r\nCAH_EM4_GetPpiAlmState: ulport(%d)", ulPort); 
    }
    u = cah_em4_readPdhAlarm (base, ulPort);
    
    isloop = cah_em4_gete1outloop (base, ulPort);

    psPpiAlarm->lom = (u & 0x0002) ? 1 : 0;
    psPpiAlarm->ais = (u & 0x0008) ? 1 : 0;  
    psPpiAlarm->rdi = (u & 0x0001) ? 1 : 0;
    psPpiAlarm->lof = (u & 0x0004) ? 1 : 0;

     


    psPpiAlarm->los = cah_em4_getPhyLos (dwPos, SDD_126xE1IOPortConvert(byPortNo), &alm);

     


    if (isloop) psPpiAlarm->los = 0;



     




    if (isIOAbsent(SDD_126xE1IOPortConvert(byPortNo), &io))
    {
        if ((SDD_126xE1IOPortConvert(byPortNo) == 13 || SDD_126xE1IOPortConvert(byPortNo) == 120) && g_ioabsent)
        {
            printf ("\r\nport(%d)'s IO is absent , skip it", SDD_126xE1IOPortConvert(byPortNo));
        }
        psPpiAlarm->los = 1;
         



        clear_IO_payload_si (io);

    } else {
        if (psPpiAlarm->los)
        {
            cah_em4_ManualInsertPayloadAIS (SDD_126xE1IOPortConvert(byPortNo), 1 );
        }
        else
        {
            cah_em4_ManualInsertPayloadAIS (SDD_126xE1IOPortConvert(byPortNo), 0 );
        }
    }

     
    return ((WORD)0x0) ;
}

WORD
CAH_EM4_GetFpgaVersion (DWORD dwPos, char *pucFpgaVer)
{
	unsigned short version = 0, v1 = 0;

	version = em4Map1Rd (0, 0);
    v1 = em4_bpc_rd (0, 0);
	 
    sprintf (pucFpgaVer, "V%d.%d, V%d.%d", 
        (version & 0xff00) >> 8, (version & 0xff),
        (v1 && 0xff00) >> 8, (v1 && 0x00ff));
    return (((WORD)0x0) );
}


WORD
CAH_EM4_GetTxLpTti (DWORD dwPos, BYTE byPortNo, TTI_LEN_T eTtiMode, BYTE * pbyTtiValue)
{
    return ((WORD)0x0) ;
}




int
pbFpgaIsrHookDel (int handle)
{
    return 0 ;
}

int
pbFpgaIsrEnable (int chip)
{
    return 0 ;
}

int
pbFpgaIntrDisable (int handle)
{
    return 0 ;
}

 





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































 








=======
 














 
















 
























 

 

 





















































 




















 

 
 








 

























 

 

 












 













































 

 

 








 


















 










 

 

 








 





























































 













 

 










 
































































































































































































 



















 

 

 



























 




































































 

 

 































	
 



 


 

















 






 
































 






typedef	unsigned int	_RType<s(0)(0)(0)>[&];(D1:_RType:1)[[TYPENAME:_RType]]		 







































 

 

 
























 









 



















 
































 










 














 








 



 

 

























 

 
 




































 

 





































   































































 















 











 

 

 










 













































 

 

 



















 






















 







 

 




 


 





 




 





 


















 





 

 





















typedef int ptrdiff_t<s(0)(0)(0)>[&];(D1:ptrdiff_t:1)[[TYPENAME:ptrdiff_t]]









 




 

 


































typedef unsigned int size_t<s(0)(0)(0)>[&];(D1:size_t:1)[[TYPENAME:size_t]]






















 




 





























 


























typedef short unsigned int wchar_t<s(0)(0)(0)>[&];(D1:wchar_t:1)[[TYPENAME:wchar_t]]
























typedef unsigned int  wint_t<s(0)(0)(0)>[&];(D1:wint_t:1)[[TYPENAME:wint_t]]




 

 





 













 









 






struct __timer<s(1)(0)(1)>[&];































































 






 




















 










































































 






















































































































 






 









































typedef int ssize_t<s(0)(0)(0)>[&] ;(D1:ssize_t:1)[[TYPENAME:ssize_t]]




typedef unsigned long time_t<s(0)(0)(0)>[&] ;(D1:time_t:1)[[TYPENAME:time_t]]




typedef long fpos_t<s(0)(0)(0)>[&] ;(D1:fpos_t:1)[[TYPENAME:fpos_t]]




typedef signed char int8_t<s(0)(0)(0)>[&] ;(D1:int8_t:1)[[TYPENAME:int8_t]]




typedef unsigned char uint8_t<s(0)(0)(0)>[&] ;(D1:uint8_t:1)[[TYPENAME:uint8_t]]




typedef short int16_t<s(0)(0)(0)>[&] ;(D1:int16_t:1)[[TYPENAME:int16_t]]




typedef unsigned short uint16_t<s(0)(0)(0)>[&] ;(D1:uint16_t:1)[[TYPENAME:uint16_t]]




typedef long int32_t<s(0)(0)(0)>[&] ;(D1:int32_t:1)[[TYPENAME:int32_t]]




typedef unsigned long uint32_t<s(0)(0)(0)>[&] ;(D1:uint32_t:1)[[TYPENAME:uint32_t]]




typedef long long int64_t<s(0)(0)(0)>[&] ;(D1:int64_t:1)[[TYPENAME:int64_t]]




typedef unsigned long long uint64_t<s(0)(0)(0)>[&] ;(D1:uint64_t:1)[[TYPENAME:uint64_t]]



 

typedef unsigned char	uchar_t<s(0)(0)(0)>[&];(D1:uchar_t:1)[[TYPENAME:uchar_t]]
typedef unsigned short	ushort_t<s(0)(0)(0)>[&];(D1:ushort_t:1)[[TYPENAME:ushort_t]]
typedef unsigned int	uint_t<s(0)(0)(0)>[&];(D1:uint_t:1)[[TYPENAME:uint_t]]
typedef unsigned long	ulong_t<s(0)(0)(0)>[&];(D1:ulong_t:1)[[TYPENAME:ulong_t]]

typedef	struct	_quad<s(1)(0)(1)>[&] { long val<s(1)(1)(0)>[&][2]; } quad<s(0)(0)(0)>[&];(D1:quad:1)[[TYPENAME:quad]]
typedef	long	daddr_t<s(0)(0)(0)>[&];(D1:daddr_t:1)[[TYPENAME:daddr_t]]
typedef	char *	caddr_t<s(0)(0)(0)>[&];(D1:caddr_t:1)[[TYPENAME:caddr_t]]
typedef	char *	addr_t<s(0)(0)(0)>[&];(D1:addr_t:1)[[TYPENAME:addr_t]]
typedef	long	swblk_t<s(0)(0)(0)>[&];(D1:swblk_t:1)[[TYPENAME:swblk_t]]

 

typedef short		dev_t<s(0)(0)(0)>[&];(D1:dev_t:1)[[TYPENAME:dev_t]]
typedef unsigned short	gid_t<s(0)(0)(0)>[&];(D1:gid_t:1)[[TYPENAME:gid_t]]
typedef	unsigned long	ino_t<s(0)(0)(0)>[&];(D1:ino_t:1)[[TYPENAME:ino_t]]
typedef int		mode_t<s(0)(0)(0)>[&];(D1:mode_t:1)[[TYPENAME:mode_t]]
typedef unsigned long	nlink_t<s(0)(0)(0)>[&];(D1:nlink_t:1)[[TYPENAME:nlink_t]]
typedef long		off_t<s(0)(0)(0)>[&];(D1:off_t:1)[[TYPENAME:off_t]]
typedef int		pid_t<s(0)(0)(0)>[&];(D1:pid_t:1)[[TYPENAME:pid_t]]
typedef unsigned short	uid_t<s(0)(0)(0)>[&];(D1:uid_t:1)[[TYPENAME:uid_t]]















 

typedef	char		INT8<s(0)(0)(0)>[&];(D1:INT8:1)[[TYPENAME:INT8]]
typedef	short		INT16<s(0)(0)(0)>[&];(D1:INT16:1)[[TYPENAME:INT16]]
typedef	int		INT32<s(0)(0)(0)>[&];(D1:INT32:1)[[TYPENAME:INT32]]
typedef	long long	INT64<s(0)(0)(0)>[&];(D1:INT64:1)[[TYPENAME:INT64]]

typedef	unsigned char	UINT8<s(0)(0)(0)>[&];(D1:UINT8:1)[[TYPENAME:UINT8]]
typedef	unsigned short	UINT16<s(0)(0)(0)>[&];(D1:UINT16:1)[[TYPENAME:UINT16]]
typedef	unsigned int	UINT32<s(0)(0)(0)>[&];(D1:UINT32:1)[[TYPENAME:UINT32]]
typedef	unsigned long long UINT64<s(0)(0)(0)>[&];(D1:UINT64:1)[[TYPENAME:UINT64]]

typedef	unsigned char	UCHAR<s(0)(0)(0)>[&];(D1:UCHAR:1)[[TYPENAME:UCHAR]]
typedef unsigned short	USHORT<s(0)(0)(0)>[&];(D1:USHORT:1)[[TYPENAME:USHORT]]
typedef	unsigned int	UINT<s(0)(0)(0)>[&];(D1:UINT:1)[[TYPENAME:UINT]]
typedef unsigned long	ULONG<s(0)(0)(0)>[&];(D1:ULONG:1)[[TYPENAME:ULONG]]

typedef	int		BOOL<s(0)(0)(0)>[&];(D1:BOOL:1)[[TYPENAME:BOOL]]
typedef	int		STATUS<s(0)(0)(0)>[&];(D1:STATUS:1)[[TYPENAME:STATUS]]
typedef int 		ARGINT<s(0)(0)(0)>[&];(D1:ARGINT:1)[[TYPENAME:ARGINT]]

typedef void		VOID<s(0)(0)(0)>[&];(D1:VOID:1)[[TYPENAME:VOID]]







typedef int 		(*FUNCPTR<s(0)(0)(0)>[&])TYPENAME:FUNC:(FUNCPTR) ();(D1:FUNCPTR:0)	    
typedef void 		(*VOIDFUNCPTR<s(0)(0)(0)>[&])TYPENAME:FUNC:(VOIDFUNCPTR) ();(D1:VOIDFUNCPTR:0)  
typedef double 		(*DBLFUNCPTR<s(0)(0)(0)>[&])TYPENAME:FUNC:(DBLFUNCPTR) ();(D1:DBLFUNCPTR:0)   
typedef float 		(*FLTFUNCPTR<s(0)(0)(0)>[&])TYPENAME:FUNC:(FLTFUNCPTR) ();(D1:FLTFUNCPTR:0)   



 




typedef union
    {
    long pm_int<s(1)(1)(0)>[&];
    void *pm_v<s(1)(1)(0)>[&];
    const void *pm_cv<s(1)(1)(0)>[&];
    char *pm_c<s(1)(1)(0)>[&];
    unsigned char *pm_uc<s(1)(1)(0)>[&];

    signed char *pm_sc<s(1)(1)(0)>[&];
    const char *pm_cc<s(1)(1)(0)>[&];
    const unsigned char *pm_cuc<s(1)(1)(0)>[&];
    const signed char *pm_csc<s(1)(1)(0)>[&];
    short *pm_s<s(1)(1)(0)>[&];
    ushort_t<s(1)(1)(0)>[T] *pm_us<s(1)(1)(0)>[&];
    const short *pm_cs<s(1)(1)(0)>[&];
    const ushort_t<s(1)(1)(0)>[T] *pm_cus<s(1)(1)(0)>[&];
    int *pm_i<s(1)(1)(0)>[&];
    uint_t<s(1)(1)(0)>[T] *pm_ui<s(1)(1)(0)>[&];
    const int *pm_ci<s(1)(1)(0)>[&];
    const uint_t<s(1)(1)(0)>[T] *pm_cui<s(1)(1)(0)>[&];
    long *pm_l<s(1)(1)(0)>[&];
    ulong_t<s(1)(1)(0)>[T] *pm_ul<s(1)(1)(0)>[&];
    const long *pm_cl<s(1)(1)(0)>[&];
    const ulong_t<s(1)(1)(0)>[T] *pm_cul<s(1)(1)(0)>[&];

    int8_t<s(1)(1)(0)>[T] *pm_i8<s(1)(1)(0)>[&];
    uint8_t<s(1)(1)(0)>[T] *pm_ui8<s(1)(1)(0)>[&];
    const int8_t<s(1)(1)(0)>[T] *pm_ci8<s(1)(1)(0)>[&];
    const uint8_t<s(1)(1)(0)>[T] *pm_cui8<s(1)(1)(0)>[&];
    int16_t<s(1)(1)(0)>[T] *pm_i16<s(1)(1)(0)>[&];
    uint16_t<s(1)(1)(0)>[T] *pm_ui16<s(1)(1)(0)>[&];
    const int16_t<s(1)(1)(0)>[T] *pm_ci16<s(1)(1)(0)>[&];
    const uint16_t<s(1)(1)(0)>[T] *pm_cui16<s(1)(1)(0)>[&];
    int32_t<s(1)(1)(0)>[T] *pm_i32<s(1)(1)(0)>[&];
    uint32_t<s(1)(1)(0)>[T] *pm_ui32<s(1)(1)(0)>[&];
    const int32_t<s(1)(1)(0)>[T] *pm_ci32<s(1)(1)(0)>[&];
    const uint32_t<s(1)(1)(0)>[T] *pm_cui32<s(1)(1)(0)>[&];








    } pointer_mix_t<s(0)(0)(0)>[&];(D1:pointer_mix_t:1)[[TYPENAME:pointer_mix_t]]













 





 














typedef long	fd_mask<s(0)(0)(0)>[&];(D1:fd_mask:1)[[TYPENAME:fd_mask]]





typedef	struct fd_set<s(1)(0)(1)>[&]
    {
    fd_mask<s(1)(1)(0)>[T]	fds_bits<s(1)(1)(0)>[&][((unsigned int)((( 2048  )+((  (sizeof(fd_mask<s(1)(1)(0)>[T]) * 8 )  )-1)))/(unsigned int)(  (sizeof(fd_mask<s(1)(1)(0)>[T]) * 8 )  )) ];
    } fd_set<s(0)(0)(0)>[&];(D1:fd_set:1)[[TYPENAME:fd_set]]







 

typedef	unsigned char	u_char<s(0)(0)(0)>[&];(D1:u_char:1)[[TYPENAME:u_char]]
typedef	unsigned short	u_short<s(0)(0)(0)>[&];(D1:u_short:1)[[TYPENAME:u_short]]
typedef	unsigned int	u_int<s(0)(0)(0)>[&];(D1:u_int:1)[[TYPENAME:u_int]]
typedef	unsigned long	u_long<s(0)(0)(0)>[&];(D1:u_long:1)[[TYPENAME:u_long]]
typedef	unsigned short	ushort<s(0)(0)(0)>[&];(D1:ushort:1)[[TYPENAME:ushort]]


 

typedef char		TBOOL<s(0)(0)(0)>[&];(D1:TBOOL:1)[[TYPENAME:TBOOL]]		 


 
























typedef unsigned long INSTR<s(0)(0)(0)>[&];(D1:INSTR:1)[[TYPENAME:INSTR]]             
















 
















typedef unsigned int HANDLE<s(0)(0)(0)>[&];(D1:HANDLE:1)[[TYPENAME:HANDLE]]


 



typedef unsigned char UINT1<s(0)(0)(0)>[&];(D1:UINT1:1)[[TYPENAME:UINT1]]

typedef char INT1<s(0)(0)(0)>[&];(D1:INT1:1)[[TYPENAME:INT1]]

typedef unsigned short UINT2<s(0)(0)(0)>[&];(D1:UINT2:1)[[TYPENAME:UINT2]]

typedef short INT2<s(0)(0)(0)>[&];(D1:INT2:1)[[TYPENAME:INT2]]

typedef unsigned long UINT4<s(0)(0)(0)>[&];(D1:UINT4:1)[[TYPENAME:UINT4]]

typedef long INT4<s(0)(0)(0)>[&];(D1:INT4:1)[[TYPENAME:INT4]]

typedef unsigned short BOOLEAN<s(0)(0)(0)>[&];(D1:BOOLEAN:1)[[TYPENAME:BOOLEAN]]






 





typedef enum 
{
    DEV_NOT_INIT<s(0)(0)(0)>[&],
    DEV_FAIL<s(0)(0)(0)>[&],
    DEV_OK<s(0)(0)(0)>[&],
    DEV_MAX<s(0)(0)(0)>[&]
}DEVICE_STATUS_Tval<s(0)(0)(0)>[&];(D1:DEVICE_STATUS_Tval:1)[[TYPENAME:DEVICE_STATUS_Tval]]





 
typedef UINT32<s(0)(0)(0)>[T] INSTANCE_T<s(0)(0)(0)>[&];(D1:INSTANCE_T:1)[[TYPENAME:INSTANCE_T]] 

 

 














































typedef enum
{
    SLOT_NUMBER_NONE<s(0)(0)(0)>[&]    = 0,
    SLOT_NUMBER_LC1<s(0)(0)(0)>[&]     = 1,
    SLOT_NUMBER_LC2<s(0)(0)(0)>[&]     = 2,
    SLOT_NUMBER_LC3<s(0)(0)(0)>[&]     = 3,
    SLOT_NUMBER_LC4<s(0)(0)(0)>[&]     = 4,
    SLOT_NUMBER_LC5<s(0)(0)(0)>[&]     = 5,
    SLOT_NUMBER_LC6<s(0)(0)(0)>[&]     = 6,
    SLOT_NUMBER_HOCC1<s(0)(0)(0)>[&]   = 7,
    SLOT_NUMBER_HOCC2<s(0)(0)(0)>[&]   = 8,
    SLOT_NUMBER_SFC1<s(0)(0)(0)>[&]    = 9,
    SLOT_NUMBER_SFC2<s(0)(0)(0)>[&]    = 10,
    SLOT_NUMBER_CE1<s(0)(0)(0)>[&]     = 11,
    SLOT_NUMBER_CE2<s(0)(0)(0)>[&]     = 12,
    SLOT_NUMBER_CE3<s(0)(0)(0)>[&]     = 13,
    SLOT_NUMBER_CE4<s(0)(0)(0)>[&]     = 14,
    SLOT_NUMBER_CE5<s(0)(0)(0)>[&]     = 15,
    SLOT_NUMBER_CE6<s(0)(0)(0)>[&]     = 16,
    SLOT_NUMBER_SC1<s(0)(0)(0)>[&]     = 17,
    SLOT_NUMBER_SC2<s(0)(0)(0)>[&]     = 18,  
    SLOT_NUMBER_SI<s(0)(0)(0)>[&]      = 19,
    SLOT_NUMBER_SFM1<s(0)(0)(0)>[&]    = 20,
    SLOT_NUMBER_SFM2<s(0)(0)(0)>[&]    = 21,
    SLOT_NUMBER_IO1<s(0)(0)(0)>[&]     = 22,
    SLOT_NUMBER_IO2<s(0)(0)(0)>[&]     = 23,
    SLOT_NUMBER_IO3<s(0)(0)(0)>[&]     = 24,
    SLOT_NUMBER_IO4<s(0)(0)(0)>[&]     = 25,
    SLOT_NUMBER_IO5<s(0)(0)(0)>[&]     = 26,
    SLOT_NUMBER_IO6<s(0)(0)(0)>[&]     = 27,
    SLOT_NUMBER_IO7<s(0)(0)(0)>[&]     = 28,
    SLOT_NUMBER_IO8<s(0)(0)(0)>[&]     = 29,
    SLOT_NUMBER_IO9<s(0)(0)(0)>[&]     = 30,
    SLOT_NUMBER_IO10<s(0)(0)(0)>[&]    = 31,
    SLOT_NUMBER_IO11<s(0)(0)(0)>[&]    = 32,
    SLOT_NUMBER_IO12<s(0)(0)(0)>[&]    = 33,
    SLOT_NUMBER_IO13<s(0)(0)(0)>[&]    = 34,
    SLOT_NUMBER_IO14<s(0)(0)(0)>[&]    = 35,
    SLOT_NUMBER_IO15<s(0)(0)(0)>[&]    = 36,
    SLOT_NUMBER_PWR1<s(0)(0)(0)>[&]    = 37,
    SLOT_NUMBER_PWR2<s(0)(0)(0)>[&]    = 38,
    SLOT_NUMBER_FAN1<s(0)(0)(0)>[&]    = 39,
    SLOT_NUMBER_FAN2<s(0)(0)(0)>[&]    = 40,

    SLOT_NUMBER_MAX<s(0)(0)(0)>[&]     = 40
}SLOT_NUMBER_T<s(0)(0)(0)>[&];(D1:SLOT_NUMBER_T:1)[[TYPENAME:SLOT_NUMBER_T]]

 




 




 




 




 




typedef enum 
{
    CARDTYPE_UNKNOWN<s(0)(0)(0)>[&] = 0,
    
     
    CARDTYPE_SI<s(0)(0)(0)>[&],              
    CARDTYPE_SC<s(0)(0)(0)>[&],              
    CARDTYPE_HOCC<s(0)(0)(0)>[&],            
    CARDTYPE_LOCC<s(0)(0)(0)>[&],            
    CARDTYPE_LOCC_PMC<s(0)(0)(0)>[&],        
    CARDTYPE_LOCC_FPGA<s(0)(0)(0)>[&],       
    CARDTYPE_1_STM256<s(0)(0)(0)>[&],        
    CARDTYPE_2_STM64<s(0)(0)(0)>[&],         
     

    CARDTYPE_1_STM64<s(0)(0)(0)>[&],         
    CARDTYPE_8_STM16<s(0)(0)(0)>[&],         
    CARDTYPE_4_STM16<s(0)(0)(0)>[&],         
    CARDTYPE_2_STM16<s(0)(0)(0)>[&],         
    CARDTYPE_8_STM4<s(0)(0)(0)>[&],          
    CARDTYPE_8_STM1O<s(0)(0)(0)>[&],         
    CARDTYPE_8_STM1E_FUNC<s(0)(0)(0)>[&],    
    CARDTYPE_8_STM1E_CONN<s(0)(0)(0)>[&],    
    CARDTYPE_2_STM64M<s(0)(0)(0)>[&],        
    CARDTYPE_8_STM16M<s(0)(0)(0)>[&],        
    CARDTYPE_16_STM4M<s(0)(0)(0)>[&],        
    CARDTYPE_16_STM1EM<s(0)(0)(0)>[&],       
    CARDTYPE_16_STM1E_CONN<s(0)(0)(0)>[&],   
    CARDTYPE_12_E3DS3_FUNC<s(0)(0)(0)>[&],   
    CARDTYPE_12_E3DS3_CONN<s(0)(0)(0)>[&],   
    CARDTYPE_126_E1_FUNC<s(0)(0)(0)>[&],     
    CARDTYPE_126_E1_CONN<s(0)(0)(0)>[&],     
    CARDTYPE_13DBM_OA<s(0)(0)(0)>[&],        
    CARDTYPE_15DBM_OA<s(0)(0)(0)>[&],        
    CARDTYPE_18DBM_OA<s(0)(0)(0)>[&],        
    CARDTYPE_20DB_OA<s(0)(0)(0)>[&],         
    CARDTYPE_2_OTU<s(0)(0)(0)>[&],           
    CARDTYPE_1_OTU2<s(0)(0)(0)>[&],          
    
    CARDTYPE_SDH<s(0)(0)(0)>[&],             
    CARDTYPE_PDH<s(0)(0)(0)>[&],             
    CARDTYPE_CC<s(0)(0)(0)>[&],              
    CARDTYPE_DATA<s(0)(0)(0)>[&],            
    CARDTYPE_DATA_L2<s(0)(0)(0)>[&],         
    CARDTYPE_RPR<s(0)(0)(0)>[&],             
    CARDTYPE_OA<s(0)(0)(0)>[&],              
    CARDTYPE_OTU<s(0)(0)(0)>[&],             
    CARDTYPE_MAGUS<s(0)(0)(0)>[&],           
    
    CARDTYPE_FAN<s(0)(0)(0)>[&],             
    CARDTYPE_PWR<s(0)(0)(0)>[&],             
    
    CARD_TYPE_MAX<s(0)(0)(0)>[&]
} CARDTYPE_T<s(0)(0)(0)>[&];(D1:CARDTYPE_T:1)[[TYPENAME:CARDTYPE_T]]

typedef UINT32<s(0)(0)(0)>[T] ENTITY_T<s(0)(0)(0)>[&];(D1:ENTITY_T:1)[[TYPENAME:ENTITY_T]]

typedef enum
{
    ENTITY_STATE_EMPTY<s(0)(0)(0)>[&]  = 0,
    ENTITY_STATE_INIT<s(0)(0)(0)>[&]   = 1,
    ENTITY_STATE_ACTIVE<s(0)(0)(0)>[&] = 2
} ENTITY_STATE_T<s(0)(0)(0)>[&];(D1:ENTITY_STATE_T:1)[[TYPENAME:ENTITY_STATE_T]]

typedef struct
{
    ENTITY_T<s(1)(1)(0)>[T]   entity<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T]       bPresent<s(1)(1)(0)>[&];
    CARDTYPE_T<s(1)(1)(0)>[T] cardType<s(1)(1)(0)>[&];
}ENTITY_INFO_T<s(0)(0)(0)>[&];(D1:ENTITY_INFO_T:1)[[TYPENAME:ENTITY_INFO_T]]

typedef int BOARD_OPTION_T<s(0)(0)(0)>[&];(D1:BOARD_OPTION_T:1)[[TYPENAME:BOARD_OPTION_T]]

 



 











 




 
























 


























































































 

























typedef enum 
{
    PB_OK<s(0)(0)(0)>[&] = 0,                       
    PB_ERROR<s(0)(0)(0)>[&],                
    PB_ERR_PARAM<s(0)(0)(0)>[&],            
    PB_ERR_NAPPL<s(0)(0)(0)>[&],            
    PB_ERR_NOTIMP<s(0)(0)(0)>[&],           
    PB_ERR_CONFLICT<s(0)(0)(0)>[&],         
    PB_ERR_TIMEOUT<s(0)(0)(0)>[&],          
    PB_ERR_TOOBIG<s(0)(0)(0)>[&],           
    PB_ERR_TOOMUCH<s(0)(0)(0)>[&],          
    PB_ERR_WRONGCALL<s(0)(0)(0)>[&],        
    PB_ERR_VERSION<s(0)(0)(0)>[&],          
    PB_ERR_NOSUCH<s(0)(0)(0)>[&],           
    PB_ERR_HARDWARE<s(0)(0)(0)>[&],         
    PB_ERR_MEMORY<s(0)(0)(0)>[&],           
    PB_ERR_BUSY<s(0)(0)(0)>[&],             
    PB_ERR_DRIVER_ERROR<s(0)(0)(0)>[&],     
    PB_ERR_HANDLE<s(0)(0)(0)>[&],           
    PB_ERR_BLOCK<s(0)(0)(0)>[&],            
    PB_ERR_STATE<s(0)(0)(0)>[&],            
    PB_ERR_COMM<s(0)(0)(0)>[&],             
    PB_ERR_MAX<s(0)(0)(0)>[&]
} PB_ERROR_CODE_T<s(0)(0)(0)>[&];(D1:PB_ERROR_CODE_T:1)[[TYPENAME:PB_ERROR_CODE_T]]

 

 
static __inline const char *CTD_StrError<s(0)(0)(0)>[&](int code<s(0)(0)(0)>[&])
{
    switch (code<s(0)(0)(0)>[&])
    {
        case PB_OK<s(0)(0)(0)>[&]:                    
            return "No error";
            
        case PB_ERROR<s(0)(0)(0)>[&]:                
            return "Unknown Error";
            
        case PB_ERR_PARAM<s(0)(0)(0)>[&]:            
            return "Incorrect Parameter";
            
        case PB_ERR_NAPPL<s(0)(0)(0)>[&]:            
            return "Not applicable";
            
        case PB_ERR_NOTIMP<s(0)(0)(0)>[&]:            
            return "Not Implemented";
            
        case PB_ERR_CONFLICT<s(0)(0)(0)>[&]:        
            return "Conflict to Exist Element";
            
        case PB_ERR_TIMEOUT<s(0)(0)(0)>[&]:        
            return "Operation Timeout";
            
        case PB_ERR_TOOBIG<s(0)(0)(0)>[&]:            
            return "Too Big";
            
        case PB_ERR_TOOMUCH<s(0)(0)(0)>[&]:        
            return "Too Many Elements";
            
        case PB_ERR_WRONGCALL<s(0)(0)(0)>[&]:        
            return "Incorrect Call";
            
        case PB_ERR_VERSION<s(0)(0)(0)>[&]:        
            return "version Mismatch";
            
        case PB_ERR_NOSUCH<s(0)(0)(0)>[&]:            
            return "No Such Element";
            
        case PB_ERR_HARDWARE<s(0)(0)(0)>[&]:        
            return "Hardware Error";
            
        case PB_ERR_MEMORY<s(0)(0)(0)>[&]:            
            return "Out of Memory";
            
        case PB_ERR_BUSY<s(0)(0)(0)>[&]:            
            return "Busy";
            
        case PB_ERR_DRIVER_ERROR<s(0)(0)(0)>[&]:    
            return "Driver Error";
            
        case PB_ERR_HANDLE<s(0)(0)(0)>[&]:            
            return "Invalid Handle";
            
        case PB_ERR_BLOCK<s(0)(0)(0)>[&]:            
            return "Blocked";
            
        case PB_ERR_STATE<s(0)(0)(0)>[&]:            
            return "Invalid state/status";
            
        case PB_ERR_COMM<s(0)(0)(0)>[&]:            
            return "Communication error";
            
        default: 
            return "Unknown error";
    }
}







 
















 






















 























 















































 

 

 




































 

 

 










































































 




 




 





 




 





 









 







 






 




























 

























 












 





 

 

 

 


















 









 
















 



















 

 

 

































































































 












































































































































 












 






 











 

typedef enum		 
    {
    SEM_EMPTY<s(0)(0)(0)>[&],			 
    SEM_FULL<s(0)(0)(0)>[&]			 
    } SEM_B_STATE<s(0)(0)(0)>[&];(D1:SEM_B_STATE:1)[[TYPENAME:SEM_B_STATE]]

typedef struct semaphore<s(1)(0)(1)>[&] *SEM_ID<s(0)(0)(0)>[&];(D1:SEM_ID:1)[[TYPENAME:SEM_ID]]

 



extern STATUS<s(0)(0)(0)>[T] 	semGive<s(0)(0)(0)>[&] (SEM_ID<s(0)(0)(0)>[T] semId<s(0)(0)(0)>[&]);(D1:semId:0)
extern STATUS<s(0)(0)(0)>[T] 	semTake<s(0)(0)(0)>[&] (SEM_ID<s(0)(0)(0)>[T] semId<s(0)(0)(0)>[&], int timeout<s(0)(0)(0)>[&]);(D1:timeout:0)
extern STATUS<s(0)(0)(0)>[T] 	semFlush<s(0)(0)(0)>[&] (SEM_ID<s(0)(0)(0)>[T] semId<s(0)(0)(0)>[&]);(D1:semId:0)
extern STATUS<s(0)(0)(0)>[T] 	semDelete<s(0)(0)(0)>[&] (SEM_ID<s(0)(0)(0)>[T] semId<s(0)(0)(0)>[&]);(D1:semId:0)
extern int 	semInfo<s(0)(0)(0)>[&] (SEM_ID<s(0)(0)(0)>[T] semId<s(0)(0)(0)>[&], int idList<s(0)(0)(0)>[&][], int maxTasks<s(0)(0)(0)>[&]);(D1:maxTasks:0)
extern STATUS<s(0)(0)(0)>[T] 	semBLibInit<s(0)(0)(0)>[&] (void);(D1:semBLibInit:0)
extern SEM_ID<s(0)(0)(0)>[T] 	semBCreate<s(0)(0)(0)>[&] (int options<s(0)(0)(0)>[&], SEM_B_STATE<s(0)(0)(0)>[T] initialState<s(0)(0)(0)>[&]);(D1:initialState:0)
extern STATUS<s(0)(0)(0)>[T] 	semCLibInit<s(0)(0)(0)>[&] (void);(D1:semCLibInit:0)
extern SEM_ID<s(0)(0)(0)>[T] 	semCCreate<s(0)(0)(0)>[&] (int options<s(0)(0)(0)>[&], int initialCount<s(0)(0)(0)>[&]);(D1:initialCount:0)
extern STATUS<s(0)(0)(0)>[T] 	semMLibInit<s(0)(0)(0)>[&] (void);(D1:semMLibInit:0)
extern SEM_ID<s(0)(0)(0)>[T] 	semMCreate<s(0)(0)(0)>[&] (int options<s(0)(0)(0)>[&]);(D1:options:0)
extern STATUS<s(0)(0)(0)>[T]   semMGiveForce<s(0)(0)(0)>[&] (SEM_ID<s(0)(0)(0)>[T] semId<s(0)(0)(0)>[&]);(D1:semId:0)
extern STATUS<s(0)(0)(0)>[T] 	semOLibInit<s(0)(0)(0)>[&] (void);(D1:semOLibInit:0)
extern SEM_ID<s(0)(0)(0)>[T] 	semCreate<s(0)(0)(0)>[&] (void);(D1:semCreate:0)
extern void 	semShowInit<s(0)(0)(0)>[&] (void);(D1:semShowInit:0)
extern STATUS<s(0)(0)(0)>[T] 	semShow<s(0)(0)(0)>[&] (SEM_ID<s(0)(0)(0)>[T] semId<s(0)(0)(0)>[&], int level<s(0)(0)(0)>[&]);(D1:level:0)














 



 
 




















 



 





 










 



 
 
    typedef struct {
        unsigned int flags<s(1)(1)(0)>[&][4];   
    } MIB_Flags_t<s(0)(0)(0)>[&];(D1:MIB_Flags_t:1)[[TYPENAME:MIB_Flags_t]]


 
    typedef struct {
        int oid_length<s(1)(1)(0)>[&];
        int oid_data<s(1)(1)(0)>[&][30 ];
    } OIDValue<s(0)(0)(0)>[&];(D1:OIDValue:1)[[TYPENAME:OIDValue]]

 
    typedef struct {
        int index<s(1)(1)(0)>[&];               
        int oid_length<s(1)(1)(0)>[&];
        int oid_data<s(1)(1)(0)>[&][30 ];    
    } MIBDid_t<s(0)(0)(0)>[&];(D1:MIBDid_t:1)[[TYPENAME:MIBDid_t]]
    typedef MIBDid_t<s(0)(0)(0)>[T] *MIBDID<s(0)(0)(0)>[&];(D1:MIBDID:1)[[TYPENAME:MIBDID]]    

 
    typedef struct {
        unsigned short year<s(1)(1)(0)>[&];
        unsigned char month<s(1)(1)(0)>[&];
        unsigned char day<s(1)(1)(0)>[&];
        unsigned char hour<s(1)(1)(0)>[&];
        unsigned char min<s(1)(1)(0)>[&];
        unsigned char sec<s(1)(1)(0)>[&];
        unsigned char dec_sec<s(1)(1)(0)>[&];
        unsigned char dir_utc<s(1)(1)(0)>[&];
        unsigned char hrs_utc<s(1)(1)(0)>[&];
        unsigned char min_utc<s(1)(1)(0)>[&];
        unsigned char padd<s(1)(1)(0)>[&];      
    } DateTime<s(0)(0)(0)>[&];(D1:DateTime:1)[[TYPENAME:DateTime]]


 



 





















 





















 
    void MibRegisterCallback<s(0)(0)(0)>[&](MIBDID<s(0)(0)(0)>[T] did<s(0)(0)(0)>[&], int (*fptr<s(0)(0)(0)>[&]) (MIBDID<s(0)(0)(0)>[T], void *, int, void *));(D1:MIBDID:0)
    void MibRegisterCallbackCheck<s(0)(0)(0)>[&](MIBDID<s(0)(0)(0)>[T] did<s(0)(0)(0)>[&], int (*fptr_check<s(0)(0)(0)>[&]) (MIBDID<s(0)(0)(0)>[T], void *, int, void *));(D1:MIBDID:0)
    void MibRegisterCallbackPartial<s(0)(0)(0)>[&](MIBDID<s(0)(0)(0)>[T] did<s(0)(0)(0)>[&], int (*fptr_partial<s(0)(0)(0)>[&]) (MIBDID<s(0)(0)(0)>[T], void *, int, void *), MIB_Flags_t<s(0)(0)(0)>[T]);(D1:MIB_Flags_t:0)

 
    void MibUnRegisterCallback<s(0)(0)(0)>[&](MIBDID<s(0)(0)(0)>[T] did<s(0)(0)(0)>[&], int (*fptr<s(0)(0)(0)>[&]) (MIBDID<s(0)(0)(0)>[T], void *, int, void *));(D1:MIBDID:0)
    void MibUnRegisterCallbackCheck<s(0)(0)(0)>[&](MIBDID<s(0)(0)(0)>[T] did<s(0)(0)(0)>[&], int (*fptr_check<s(0)(0)(0)>[&]) (MIBDID<s(0)(0)(0)>[T], void *, int, void *));(D1:MIBDID:0)
    void MibUnRegisterCallbackPartial<s(0)(0)(0)>[&](MIBDID<s(0)(0)(0)>[T] did<s(0)(0)(0)>[&], int (*fptr_partial<s(0)(0)(0)>[&]) (MIBDID<s(0)(0)(0)>[T], void *, int, void *));(D1:MIBDID:0)

 
    int MibLoadAFileByDid<s(0)(0)(0)>[&](MIBDID<s(0)(0)(0)>[T] did<s(0)(0)(0)>[&]);(D1:did:0)

 
    int MibLoadTablesSequence<s(0)(0)(0)>[&](MIBDID<s(0)(0)(0)>[T] * list<s(0)(0)(0)>[&], int num_entries<s(0)(0)(0)>[&]);(D1:num_entries:0)

 
    void MibTableChangedFlag<s(0)(0)(0)>[&](MIBDID<s(0)(0)(0)>[T] did<s(0)(0)(0)>[&]);(D1:did:0)
    void MibTblGrpChanged<s(0)(0)(0)>[&](MIBDID<s(0)(0)(0)>[T] did<s(0)(0)(0)>[&], void *row<s(0)(0)(0)>[&], int type<s(0)(0)(0)>[&]);(D1:type:0)
	void MibTblGrpChangedMirrored<s(0)(0)(0)>[&](MIBDID<s(0)(0)(0)>[T] did<s(0)(0)(0)>[&], void *row<s(0)(0)(0)>[&], int type<s(0)(0)(0)>[&], int saveFlag<s(0)(0)(0)>[&]);(D1:saveFlag:0)

 
    int MibGroupRegisterSema<s(0)(0)(0)>[&](MIBDID<s(0)(0)(0)>[T] did<s(0)(0)(0)>[&], SEM_ID<s(0)(0)(0)>[T] sema<s(0)(0)(0)>[&]);(D1:sema:0)

 
    int MibGroupRegisterRemote<s(0)(0)(0)>[&](MIBDID<s(0)(0)(0)>[T] did<s(0)(0)(0)>[&], int (*fptr<s(0)(0)(0)>[&]) (MIBDID<s(0)(0)(0)>[T] did<s(0)(0)(0)>[&], void *row<s(0)(0)(0)>[&], int type<s(0)(0)(0)>[&], MIB_Flags_t<s(0)(0)(0)>[T] flags<s(0)(0)(0)>[&]));(D1:flags:0)

 
    int MibRegisterSlotFunc<s(0)(0)(0)>[&](MIBDID<s(0)(0)(0)>[T] did<s(0)(0)(0)>[&], int (*fptr<s(0)(0)(0)>[&]) (MIBDID<s(0)(0)(0)>[T] did<s(0)(0)(0)>[&], void *row<s(0)(0)(0)>[&]), int distributed<s(0)(0)(0)>[&], int phys_log<s(0)(0)(0)>[&]);(D1:phys_log:0)

 
 
    int MibSetRemoteIntegerData<s(0)(0)(0)>[&](MIBDID<s(0)(0)(0)>[T] did<s(0)(0)(0)>[&], int value<s(0)(0)(0)>[&]);(D1:value:0)
    int MibGetRemoteIntegerData<s(0)(0)(0)>[&](MIBDID<s(0)(0)(0)>[T] did<s(0)(0)(0)>[&]);(D1:did:0)

    int MibSetRemoteChildData<s(0)(0)(0)>[&](MIBDID<s(0)(0)(0)>[T] did<s(0)(0)(0)>[&], int oid<s(0)(0)(0)>[&], int value<s(0)(0)(0)>[&]);(D1:value:0)
    int MibGetRemoteChildData<s(0)(0)(0)>[&](MIBDID<s(0)(0)(0)>[T] did<s(0)(0)(0)>[&], int oid<s(0)(0)(0)>[&]);(D1:oid:0)

 
    int MibAccessHandle<s(0)(0)(0)>[&](int type<s(0)(0)(0)>[&], MIBDID<s(0)(0)(0)>[T] did<s(0)(0)(0)>[&], void *row<s(0)(0)(0)>[&], int row_len<s(0)(0)(0)>[&], MIB_Flags_t<s(0)(0)(0)>[T] flags<s(0)(0)(0)>[&], int slot<s(0)(0)(0)>[&]);(D1:slot:0)
    int MibAccessHandle_NCB<s(0)(0)(0)>[&](int type<s(0)(0)(0)>[&], MIBDID<s(0)(0)(0)>[T] did<s(0)(0)(0)>[&], void *row<s(0)(0)(0)>[&], int row_len<s(0)(0)(0)>[&], MIB_Flags_t<s(0)(0)(0)>[T] flags<s(0)(0)(0)>[&], int slot<s(0)(0)(0)>[&]);(D1:slot:0)
 
void setMibIdApplNo<s(0)(0)(0)>[&](int mibIdBef<s(0)(0)(0)>[&],  int applNumberBef<s(0)(0)(0)>[&], int type<s(0)(0)(0)>[&]);(D1:type:0)
void clrMibIdApplNo<s(0)(0)(0)>[&](int mibIdAft<s(0)(0)(0)>[&], int applNumberAft<s(0)(0)(0)>[&],   int type<s(0)(0)(0)>[&]);(D1:type:0)

int MibFlagsCheck<s(0)(0)(0)>[&](MIB_Flags_t<s(0)(0)(0)>[T] flags_setpartial<s(0)(0)(0)>[&], MIB_Flags_t<s(0)(0)(0)>[T] flags_callback<s(0)(0)(0)>[&]);(D1:flags_callback:0)

int MibSetCleanFlagToFlash<s(0)(0)(0)>[&](int TLVtype<s(0)(0)(0)>[&], int delFlag<s(0)(0)(0)>[&]);(D1:delFlag:0)

 
int MibGetActiveScSlotNumber<s(0)(0)(0)>[&](int *pSlotNumber<s(0)(0)(0)>[&]);(D1:pSlotNumber:0)

    extern MIB_Flags_t<s(0)(0)(0)>[T] mibDefFlags<s(0)(0)(0)>[&];(D1:mibDefFlags:0)









typedef enum {
	PbApplState_initial<s(0)(0)(0)>[&] = 0,
	PbApplState_ready<s(0)(0)(0)>[&] = 1,
	PbApplState_active<s(0)(0)(0)>[&] = 2,
	PbApplState_standby<s(0)(0)(0)>[&] = 3,
	PbApplState_failed<s(0)(0)(0)>[&] = 4,
	PbApplState_diagnostic<s(0)(0)(0)>[&] = 5
} PbApplState_Tval<s(0)(0)(0)>[&];(D1:PbApplState_Tval:1)[[TYPENAME:PbApplState_Tval]]

typedef enum {
	PbSNCPSwitchReason_clearcmd<s(0)(0)(0)>[&] = 1,
	PbSNCPSwitchReason_lpcmd<s(0)(0)(0)>[&] = 2,
	PbSNCPSwitchReason_forcedswitch<s(0)(0)(0)>[&] = 3,
	PbSNCPSwitchReason_manualswitch<s(0)(0)(0)>[&] = 4,
	PbSNCPSwitchReason_signalfail<s(0)(0)(0)>[&] = 5,
	PbSNCPSwitchReason_signalfailclear<s(0)(0)(0)>[&] = 6,
	PbSNCPSwitchReason_noswitch<s(0)(0)(0)>[&] = 7,
	PbSNCPSwitchReason_signaldeg<s(0)(0)(0)>[&] = 8,
	PbSNCPSwitchReason_signalnormal<s(0)(0)(0)>[&] = 9
} PbSNCPSwitchReason_Tval<s(0)(0)(0)>[&];(D1:PbSNCPSwitchReason_Tval:1)[[TYPENAME:PbSNCPSwitchReason_Tval]]

typedef enum {
	PbTMSSquelchMode_clear<s(0)(0)(0)>[&] = 0,
	PbTMSSquelchMode_forceAIS<s(0)(0)(0)>[&] = 1,
	PbTMSSquelchMode_forceDNU<s(0)(0)(0)>[&] = 2,
	PbTMSSquelchMode_forceShutdown<s(0)(0)(0)>[&] = 3
} PbTMSSquelchMode_Tval<s(0)(0)(0)>[&];(D1:PbTMSSquelchMode_Tval:1)[[TYPENAME:PbTMSSquelchMode_Tval]]

typedef enum {
	EventCategory_management<s(0)(0)(0)>[&] = 1,
	EventCategory_software<s(0)(0)(0)>[&] = 2,
	EventCategory_hardware<s(0)(0)(0)>[&] = 3,
	EventCategory_indeterminate<s(0)(0)(0)>[&] = 4
} EventCategory_Tval<s(0)(0)(0)>[&];(D1:EventCategory_Tval:1)[[TYPENAME:EventCategory_Tval]]

typedef enum {
	PbXcFrom_cli<s(0)(0)(0)>[&] = 1,
	PbXcFrom_ems<s(0)(0)(0)>[&] = 2,
	PbXcFrom_snm<s(0)(0)(0)>[&] = 3,
	PbXcFrom_gmpls<s(0)(0)(0)>[&] = 4,
	PbXcFrom_rpr<s(0)(0)(0)>[&] = 5,
	PbXcFrom_sncp<s(0)(0)(0)>[&] = 6
} PbXcFrom_Tval<s(0)(0)(0)>[&];(D1:PbXcFrom_Tval:1)[[TYPENAME:PbXcFrom_Tval]]

typedef enum {
	RprTpNumberType_hex11110000<s(0)(0)(0)>[&] = 286326784,
	RprTpNumberType_hex11120000<s(0)(0)(0)>[&] = 286392320,
	RprTpNumberType_hex11130000<s(0)(0)(0)>[&] = 286457856,
	RprTpNumberType_hex11140000<s(0)(0)(0)>[&] = 286523392,
	RprTpNumberType_hex11210000<s(0)(0)(0)>[&] = 287375360,
	RprTpNumberType_hex11220000<s(0)(0)(0)>[&] = 287440896,
	RprTpNumberType_hex11230000<s(0)(0)(0)>[&] = 287506432,
	RprTpNumberType_hex11240000<s(0)(0)(0)>[&] = 287571968,
	RprTpNumberType_hex11310000<s(0)(0)(0)>[&] = 288423936,
	RprTpNumberType_hex11320000<s(0)(0)(0)>[&] = 288489472,
	RprTpNumberType_hex11330000<s(0)(0)(0)>[&] = 288555008,
	RprTpNumberType_hex11340000<s(0)(0)(0)>[&] = 288620544,
	RprTpNumberType_hex11410000<s(0)(0)(0)>[&] = 289472512,
	RprTpNumberType_hex11420000<s(0)(0)(0)>[&] = 289538048,
	RprTpNumberType_hex11430000<s(0)(0)(0)>[&] = 289603584,
	RprTpNumberType_hex11440000<s(0)(0)(0)>[&] = 289669120
} RprTpNumberType_Tval<s(0)(0)(0)>[&];(D1:RprTpNumberType_Tval:1)[[TYPENAME:RprTpNumberType_Tval]]

typedef enum {
	RprSvcFailReason_noerr<s(0)(0)(0)>[&] = 0,
	RprSvcFailReason_flowlimit<s(0)(0)(0)>[&] = 1,
	RprSvcFailReason_cannotadd<s(0)(0)(0)>[&] = 2,
	RprSvcFailReason_cannotdel<s(0)(0)(0)>[&] = 3,
	RprSvcFailReason_cannotreach<s(0)(0)(0)>[&] = 4,
	RprSvcFailReason_bandwidth<s(0)(0)(0)>[&] = 5,
	RprSvcFailReason_svctypeconflict<s(0)(0)(0)>[&] = 6,
	RprSvcFailReason_macconflict<s(0)(0)(0)>[&] = 7,
	RprSvcFailReason_cosconflict<s(0)(0)(0)>[&] = 8,
	RprSvcFailReason_autoringenconflict<s(0)(0)(0)>[&] = 9,
	RprSvcFailReason_ringselconflict<s(0)(0)(0)>[&] = 10,
	RprSvcFailReason_wrapenconflict<s(0)(0)(0)>[&] = 11,
	RprSvcFailReason_svcmodeconflict<s(0)(0)(0)>[&] = 12,
	RprSvcFailReason_ttlmodeconflict<s(0)(0)(0)>[&] = 13,
	RprSvcFailReason_manttlvalueconflict<s(0)(0)(0)>[&] = 14,
	RprSvcFailReason_activeconflict<s(0)(0)(0)>[&] = 15,
	RprSvcFailReason_inactive<s(0)(0)(0)>[&] = 16,
	RprSvcFailReason_other<s(0)(0)(0)>[&] = 17
} RprSvcFailReason_Tval<s(0)(0)(0)>[&];(D1:RprSvcFailReason_Tval:1)[[TYPENAME:RprSvcFailReason_Tval]]

typedef enum {
	PbMsspAgentState_init<s(0)(0)(0)>[&] = 0,
	PbMsspAgentState_ready<s(0)(0)(0)>[&] = 1,
	PbMsspAgentState_suspend<s(0)(0)(0)>[&] = 2
} PbMsspAgentState_Tval<s(0)(0)(0)>[&];(D1:PbMsspAgentState_Tval:1)[[TYPENAME:PbMsspAgentState_Tval]]

typedef enum {
	PbPmReportResp_noerr<s(0)(0)(0)>[&] = 0,
	PbPmReportResp_resource<s(0)(0)(0)>[&] = 1,
	PbPmReportResp_invalid<s(0)(0)(0)>[&] = 2,
	PbPmReportResp_conflict<s(0)(0)(0)>[&] = 3
} PbPmReportResp_Tval<s(0)(0)(0)>[&];(D1:PbPmReportResp_Tval:1)[[TYPENAME:PbPmReportResp_Tval]]

typedef enum {
	PbMsspLineRequest_signalDegradeRing<s(0)(0)(0)>[&] = 8,
	PbMsspLineRequest_signalFailRing<s(0)(0)(0)>[&] = 11,
	PbMsspLineRequest_clear<s(0)(0)(0)>[&] = 21
} PbMsspLineRequest_Tval<s(0)(0)(0)>[&];(D1:PbMsspLineRequest_Tval:1)[[TYPENAME:PbMsspLineRequest_Tval]]

typedef enum {
	PbEthInterfaceType_lan<s(0)(0)(0)>[&] = 1,
	PbEthInterfaceType_wan<s(0)(0)(0)>[&] = 2,
	PbEthInterfaceType_trunk<s(0)(0)(0)>[&] = 3
} PbEthInterfaceType_Tval<s(0)(0)(0)>[&];(D1:PbEthInterfaceType_Tval:1)[[TYPENAME:PbEthInterfaceType_Tval]]

typedef enum {
	PbTMSSetSa_sa4<s(0)(0)(0)>[&] = 4,
	PbTMSSetSa_sa5<s(0)(0)(0)>[&] = 5,
	PbTMSSetSa_sa6<s(0)(0)(0)>[&] = 6,
	PbTMSSetSa_sa7<s(0)(0)(0)>[&] = 7,
	PbTMSSetSa_sa8<s(0)(0)(0)>[&] = 8
} PbTMSSetSa_Tval<s(0)(0)(0)>[&];(D1:PbTMSSetSa_Tval:1)[[TYPENAME:PbTMSSetSa_Tval]]

typedef enum {
	RprSpan_east<s(0)(0)(0)>[&] = 1,
	RprSpan_west<s(0)(0)(0)>[&] = 2
} RprSpan_Tval<s(0)(0)(0)>[&];(D1:RprSpan_Tval:1)[[TYPENAME:RprSpan_Tval]]

typedef enum {
	PbLedColor_off<s(0)(0)(0)>[&] = 0,
	PbLedColor_green<s(0)(0)(0)>[&] = 1,
	PbLedColor_yellow<s(0)(0)(0)>[&] = 2,
	PbLedColor_red<s(0)(0)(0)>[&] = 3,
	PbLedColor_orange<s(0)(0)(0)>[&] = 4,
	PbLedColor_blinkingGreen<s(0)(0)(0)>[&] = 5,
	PbLedColor_blinkingYellow<s(0)(0)(0)>[&] = 6,
	PbLedColor_blinkingRed<s(0)(0)(0)>[&] = 7,
	PbLedColor_blinkingOrange<s(0)(0)(0)>[&] = 8
} PbLedColor_Tval<s(0)(0)(0)>[&];(D1:PbLedColor_Tval:1)[[TYPENAME:PbLedColor_Tval]]

typedef enum {
	PbSdhHpSignalLabel_unequipped<s(0)(0)(0)>[&] = 0,
	PbSdhHpSignalLabel_reserved<s(0)(0)(0)>[&] = 1,
	PbSdhHpSignalLabel_tugstructure<s(0)(0)(0)>[&] = 2,
	PbSdhHpSignalLabel_lockedtu<s(0)(0)(0)>[&] = 3,
	PbSdhHpSignalLabel_asynchronousvc3<s(0)(0)(0)>[&] = 4,
	PbSdhHpSignalLabel_asynchronousvc4<s(0)(0)(0)>[&] = 18,
	PbSdhHpSignalLabel_atm<s(0)(0)(0)>[&] = 19,
	PbSdhHpSignalLabel_mandqdb<s(0)(0)(0)>[&] = 20,
	PbSdhHpSignalLabel_fddi<s(0)(0)(0)>[&] = 21,
	PbSdhHpSignalLabel_hdlcppp<s(0)(0)(0)>[&] = 22,
	PbSdhHpSignalLabel_sdlsss<s(0)(0)(0)>[&] = 23,
	PbSdhHpSignalLabel_hdlclaps<s(0)(0)(0)>[&] = 24,
	PbSdhHpSignalLabel_sdlsrs<s(0)(0)(0)>[&] = 25,
	PbSdhHpSignalLabel_gig10<s(0)(0)(0)>[&] = 26,
	PbSdhHpSignalLabel_gfp<s(0)(0)(0)>[&] = 27,
	PbSdhHpSignalLabel_test<s(0)(0)(0)>[&] = 254,
	PbSdhHpSignalLabel_ais<s(0)(0)(0)>[&] = 255
} PbSdhHpSignalLabel_Tval<s(0)(0)(0)>[&];(D1:PbSdhHpSignalLabel_Tval:1)[[TYPENAME:PbSdhHpSignalLabel_Tval]]

typedef enum {
	PbTMSQLMode_passThrough<s(0)(0)(0)>[&] = 1,
	PbTMSQLMode_overWrite<s(0)(0)(0)>[&] = 2
} PbTMSQLMode_Tval<s(0)(0)(0)>[&];(D1:PbTMSQLMode_Tval:1)[[TYPENAME:PbTMSQLMode_Tval]]

typedef enum {
	PbTMSSignalStatus_normal<s(0)(0)(0)>[&] = 1,
	PbTMSSignalStatus_failed<s(0)(0)(0)>[&] = 2,
	PbTMSSignalStatus_na<s(0)(0)(0)>[&] = 3,
	PbTMSSignalStatus_holdoff<s(0)(0)(0)>[&] = 4,
	PbTMSSignalStatus_waitToRestore<s(0)(0)(0)>[&] = 5
} PbTMSSignalStatus_Tval<s(0)(0)(0)>[&];(D1:PbTMSSignalStatus_Tval:1)[[TYPENAME:PbTMSSignalStatus_Tval]]

typedef enum {
	AlarmSeverity_notInAlarm<s(0)(0)(0)>[&] = 0,
	AlarmSeverity_warning<s(0)(0)(0)>[&] = 1,
	AlarmSeverity_minor<s(0)(0)(0)>[&] = 2,
	AlarmSeverity_major<s(0)(0)(0)>[&] = 3,
	AlarmSeverity_critical<s(0)(0)(0)>[&] = 4,
	AlarmSeverity_indeterminate<s(0)(0)(0)>[&] = 5
} AlarmSeverity_Tval<s(0)(0)(0)>[&];(D1:AlarmSeverity_Tval:1)[[TYPENAME:AlarmSeverity_Tval]]

typedef enum {
	PbTpSegment_pm<s(0)(0)(0)>[&] = 0,
	PbTpSegment_tcm1<s(0)(0)(0)>[&] = 1,
	PbTpSegment_tcm2<s(0)(0)(0)>[&] = 2,
	PbTpSegment_tcm3<s(0)(0)(0)>[&] = 3,
	PbTpSegment_tcm4<s(0)(0)(0)>[&] = 4,
	PbTpSegment_tcm5<s(0)(0)(0)>[&] = 5,
	PbTpSegment_tcm6<s(0)(0)(0)>[&] = 6,
	PbTpSegment_sm<s(0)(0)(0)>[&] = 7,
	PbTpSegment_total<s(0)(0)(0)>[&] = 8
} PbTpSegment_Tval<s(0)(0)(0)>[&];(D1:PbTpSegment_Tval:1)[[TYPENAME:PbTpSegment_Tval]]

typedef enum {
	PbRspType_failed<s(0)(0)(0)>[&] = 1,
	PbRspType_okay<s(0)(0)(0)>[&] = 2
} PbRspType_Tval<s(0)(0)(0)>[&];(D1:PbRspType_Tval:1)[[TYPENAME:PbRspType_Tval]]

typedef enum {
	PbCpgCardStatus_none<s(0)(0)(0)>[&] = 0,
	PbCpgCardStatus_normal<s(0)(0)(0)>[&] = 1,
	PbCpgCardStatus_fail<s(0)(0)(0)>[&] = 2,
	PbCpgCardStatus_absent<s(0)(0)(0)>[&] = 3
} PbCpgCardStatus_Tval<s(0)(0)(0)>[&];(D1:PbCpgCardStatus_Tval:1)[[TYPENAME:PbCpgCardStatus_Tval]]

typedef enum {
	PbOnOff_on<s(0)(0)(0)>[&] = 1,
	PbOnOff_off<s(0)(0)(0)>[&] = 2
} PbOnOff_Tval<s(0)(0)(0)>[&];(D1:PbOnOff_Tval:1)[[TYPENAME:PbOnOff_Tval]]

typedef enum {
	IANAifType_other<s(0)(0)(0)>[&] = 1,
	IANAifType_regular1822<s(0)(0)(0)>[&] = 2,
	IANAifType_hdh1822<s(0)(0)(0)>[&] = 3,
	IANAifType_ddnX25<s(0)(0)(0)>[&] = 4,
	IANAifType_rfc877x25<s(0)(0)(0)>[&] = 5,
	IANAifType_ethernetCsmacd<s(0)(0)(0)>[&] = 6,
	IANAifType_iso88023Csmacd<s(0)(0)(0)>[&] = 7,
	IANAifType_iso88024TokenBus<s(0)(0)(0)>[&] = 8,
	IANAifType_iso88025TokenRing<s(0)(0)(0)>[&] = 9,
	IANAifType_iso88026Man<s(0)(0)(0)>[&] = 10,
	IANAifType_starLan<s(0)(0)(0)>[&] = 11,
	IANAifType_proteon10Mbit<s(0)(0)(0)>[&] = 12,
	IANAifType_proteon80Mbit<s(0)(0)(0)>[&] = 13,
	IANAifType_hyperchannel<s(0)(0)(0)>[&] = 14,
	IANAifType_fddi<s(0)(0)(0)>[&] = 15,
	IANAifType_lapb<s(0)(0)(0)>[&] = 16,
	IANAifType_sdlc<s(0)(0)(0)>[&] = 17,
	IANAifType_ds1<s(0)(0)(0)>[&] = 18,
	IANAifType_e1<s(0)(0)(0)>[&] = 19,
	IANAifType_basicISDN<s(0)(0)(0)>[&] = 20,
	IANAifType_primaryISDN<s(0)(0)(0)>[&] = 21,
	IANAifType_propPointToPointSerial<s(0)(0)(0)>[&] = 22,
	IANAifType_ppp<s(0)(0)(0)>[&] = 23,
	IANAifType_softwareLoopback<s(0)(0)(0)>[&] = 24,
	IANAifType_eon<s(0)(0)(0)>[&] = 25,
	IANAifType_ethernet3Mbit<s(0)(0)(0)>[&] = 26,
	IANAifType_nsip<s(0)(0)(0)>[&] = 27,
	IANAifType_slip<s(0)(0)(0)>[&] = 28,
	IANAifType_ultra<s(0)(0)(0)>[&] = 29,
	IANAifType_ds3<s(0)(0)(0)>[&] = 30,
	IANAifType_sip<s(0)(0)(0)>[&] = 31,
	IANAifType_frameRelay<s(0)(0)(0)>[&] = 32,
	IANAifType_rs232<s(0)(0)(0)>[&] = 33,
	IANAifType_para<s(0)(0)(0)>[&] = 34,
	IANAifType_arcnet<s(0)(0)(0)>[&] = 35,
	IANAifType_arcnetPlus<s(0)(0)(0)>[&] = 36,
	IANAifType_atm<s(0)(0)(0)>[&] = 37,
	IANAifType_miox25<s(0)(0)(0)>[&] = 38,
	IANAifType_sonet<s(0)(0)(0)>[&] = 39,
	IANAifType_x25ple<s(0)(0)(0)>[&] = 40,
	IANAifType_iso88022llc<s(0)(0)(0)>[&] = 41,
	IANAifType_localTalk<s(0)(0)(0)>[&] = 42,
	IANAifType_smdsDxi<s(0)(0)(0)>[&] = 43,
	IANAifType_frameRelayService<s(0)(0)(0)>[&] = 44,
	IANAifType_v35<s(0)(0)(0)>[&] = 45,
	IANAifType_hssi<s(0)(0)(0)>[&] = 46,
	IANAifType_hippi<s(0)(0)(0)>[&] = 47,
	IANAifType_modem<s(0)(0)(0)>[&] = 48,
	IANAifType_aal5<s(0)(0)(0)>[&] = 49,
	IANAifType_sonetPath<s(0)(0)(0)>[&] = 50,
	IANAifType_sonetVT<s(0)(0)(0)>[&] = 51,
	IANAifType_smdsIcip<s(0)(0)(0)>[&] = 52,
	IANAifType_propVirtual<s(0)(0)(0)>[&] = 53,
	IANAifType_propMultiplexor<s(0)(0)(0)>[&] = 54,
	IANAifType_ieee80212<s(0)(0)(0)>[&] = 55,
	IANAifType_fibreChannel<s(0)(0)(0)>[&] = 56,
	IANAifType_hippiInterface<s(0)(0)(0)>[&] = 57,
	IANAifType_frameRelayInterconnect<s(0)(0)(0)>[&] = 58,
	IANAifType_aflane8023<s(0)(0)(0)>[&] = 59,
	IANAifType_aflane8025<s(0)(0)(0)>[&] = 60,
	IANAifType_cctEmul<s(0)(0)(0)>[&] = 61,
	IANAifType_fastEther<s(0)(0)(0)>[&] = 62,
	IANAifType_isdn<s(0)(0)(0)>[&] = 63,
	IANAifType_v11<s(0)(0)(0)>[&] = 64,
	IANAifType_v36<s(0)(0)(0)>[&] = 65,
	IANAifType_g703at64k<s(0)(0)(0)>[&] = 66,
	IANAifType_g703at2mb<s(0)(0)(0)>[&] = 67,
	IANAifType_qllc<s(0)(0)(0)>[&] = 68,
	IANAifType_fastEtherFX<s(0)(0)(0)>[&] = 69,
	IANAifType_channel<s(0)(0)(0)>[&] = 70,
	IANAifType_ieee80211<s(0)(0)(0)>[&] = 71,
	IANAifType_ibm370parChan<s(0)(0)(0)>[&] = 72,
	IANAifType_escon<s(0)(0)(0)>[&] = 73,
	IANAifType_dlsw<s(0)(0)(0)>[&] = 74,
	IANAifType_isdns<s(0)(0)(0)>[&] = 75,
	IANAifType_isdnu<s(0)(0)(0)>[&] = 76,
	IANAifType_lapd<s(0)(0)(0)>[&] = 77,
	IANAifType_ipSwitch<s(0)(0)(0)>[&] = 78,
	IANAifType_rsrb<s(0)(0)(0)>[&] = 79,
	IANAifType_atmLogical<s(0)(0)(0)>[&] = 80,
	IANAifType_ds0<s(0)(0)(0)>[&] = 81,
	IANAifType_ds0Bundle<s(0)(0)(0)>[&] = 82,
	IANAifType_bsc<s(0)(0)(0)>[&] = 83,
	IANAifType_async<s(0)(0)(0)>[&] = 84,
	IANAifType_cnr<s(0)(0)(0)>[&] = 85,
	IANAifType_iso88025Dtr<s(0)(0)(0)>[&] = 86,
	IANAifType_eplrs<s(0)(0)(0)>[&] = 87,
	IANAifType_arap<s(0)(0)(0)>[&] = 88,
	IANAifType_propCnls<s(0)(0)(0)>[&] = 89,
	IANAifType_hostPad<s(0)(0)(0)>[&] = 90,
	IANAifType_termPad<s(0)(0)(0)>[&] = 91,
	IANAifType_frameRelayMPI<s(0)(0)(0)>[&] = 92,
	IANAifType_x213<s(0)(0)(0)>[&] = 93,
	IANAifType_adsl<s(0)(0)(0)>[&] = 94,
	IANAifType_radsl<s(0)(0)(0)>[&] = 95,
	IANAifType_sdsl<s(0)(0)(0)>[&] = 96,
	IANAifType_vdsl<s(0)(0)(0)>[&] = 97,
	IANAifType_iso88025CRFPInt<s(0)(0)(0)>[&] = 98,
	IANAifType_myrinet<s(0)(0)(0)>[&] = 99,
	IANAifType_voiceEM<s(0)(0)(0)>[&] = 100,
	IANAifType_voiceFXO<s(0)(0)(0)>[&] = 101,
	IANAifType_voiceFXS<s(0)(0)(0)>[&] = 102,
	IANAifType_voiceEncap<s(0)(0)(0)>[&] = 103,
	IANAifType_voiceOverIp<s(0)(0)(0)>[&] = 104,
	IANAifType_atmDxi<s(0)(0)(0)>[&] = 105,
	IANAifType_atmFuni<s(0)(0)(0)>[&] = 106,
	IANAifType_atmIma<s(0)(0)(0)>[&] = 107,
	IANAifType_pppMultilinkBundle<s(0)(0)(0)>[&] = 108,
	IANAifType_ipOverCdlc<s(0)(0)(0)>[&] = 109,
	IANAifType_ipOverClaw<s(0)(0)(0)>[&] = 110,
	IANAifType_stackToStack<s(0)(0)(0)>[&] = 111,
	IANAifType_virtualIpAddress<s(0)(0)(0)>[&] = 112,
	IANAifType_mpc<s(0)(0)(0)>[&] = 113,
	IANAifType_ipOverAtm<s(0)(0)(0)>[&] = 114,
	IANAifType_iso88025Fiber<s(0)(0)(0)>[&] = 115,
	IANAifType_tdlc<s(0)(0)(0)>[&] = 116,
	IANAifType_gigabitEthernet<s(0)(0)(0)>[&] = 117,
	IANAifType_hdlc<s(0)(0)(0)>[&] = 118,
	IANAifType_lapf<s(0)(0)(0)>[&] = 119,
	IANAifType_v37<s(0)(0)(0)>[&] = 120,
	IANAifType_x25mlp<s(0)(0)(0)>[&] = 121,
	IANAifType_x25huntGroup<s(0)(0)(0)>[&] = 122,
	IANAifType_transpHdlc<s(0)(0)(0)>[&] = 123,
	IANAifType_interleave<s(0)(0)(0)>[&] = 124,
	IANAifType_fast<s(0)(0)(0)>[&] = 125,
	IANAifType_ip<s(0)(0)(0)>[&] = 126,
	IANAifType_docsCableMaclayer<s(0)(0)(0)>[&] = 127,
	IANAifType_docsCableDownstream<s(0)(0)(0)>[&] = 128,
	IANAifType_docsCableUpstream<s(0)(0)(0)>[&] = 129,
	IANAifType_a12MppSwitch<s(0)(0)(0)>[&] = 130,
	IANAifType_tunnel<s(0)(0)(0)>[&] = 131,
	IANAifType_coffee<s(0)(0)(0)>[&] = 132,
	IANAifType_ces<s(0)(0)(0)>[&] = 133,
	IANAifType_atmSubInterface<s(0)(0)(0)>[&] = 134,
	IANAifType_l2vlan<s(0)(0)(0)>[&] = 135,
	IANAifType_l3ipvlan<s(0)(0)(0)>[&] = 136,
	IANAifType_l3ipxvlan<s(0)(0)(0)>[&] = 137,
	IANAifType_digitalPowerline<s(0)(0)(0)>[&] = 138,
	IANAifType_mediaMailOverIp<s(0)(0)(0)>[&] = 139,
	IANAifType_dtm<s(0)(0)(0)>[&] = 140,
	IANAifType_dcn<s(0)(0)(0)>[&] = 141,
	IANAifType_ipForward<s(0)(0)(0)>[&] = 142,
	IANAifType_msdsl<s(0)(0)(0)>[&] = 143,
	IANAifType_ieee1394<s(0)(0)(0)>[&] = 144,
	IANAifType_if_gsn<s(0)(0)(0)>[&] = 145,
	IANAifType_dvbRccMacLayer<s(0)(0)(0)>[&] = 146,
	IANAifType_dvbRccDownstream<s(0)(0)(0)>[&] = 147,
	IANAifType_dvbRccUpstream<s(0)(0)(0)>[&] = 148,
	IANAifType_atmVirtual<s(0)(0)(0)>[&] = 149,
	IANAifType_mplsTunnel<s(0)(0)(0)>[&] = 150,
	IANAifType_srp<s(0)(0)(0)>[&] = 151,
	IANAifType_voiceOverAtm<s(0)(0)(0)>[&] = 152,
	IANAifType_voiceOverFrameRelay<s(0)(0)(0)>[&] = 153,
	IANAifType_idsl<s(0)(0)(0)>[&] = 154,
	IANAifType_compositeLink<s(0)(0)(0)>[&] = 155,
	IANAifType_ss7SigLink<s(0)(0)(0)>[&] = 156,
	IANAifType_propWirelessP2P<s(0)(0)(0)>[&] = 157,
	IANAifType_frForward<s(0)(0)(0)>[&] = 158,
	IANAifType_rfc1483<s(0)(0)(0)>[&] = 159,
	IANAifType_usb<s(0)(0)(0)>[&] = 160,
	IANAifType_ieee8023adLag<s(0)(0)(0)>[&] = 161,
	IANAifType_bgppolicyaccounting<s(0)(0)(0)>[&] = 162,
	IANAifType_frf16MfrBundle<s(0)(0)(0)>[&] = 163,
	IANAifType_h323Gatekeeper<s(0)(0)(0)>[&] = 164,
	IANAifType_h323Proxy<s(0)(0)(0)>[&] = 165,
	IANAifType_mpls<s(0)(0)(0)>[&] = 166,
	IANAifType_mfSigLink<s(0)(0)(0)>[&] = 167,
	IANAifType_hdsl2<s(0)(0)(0)>[&] = 168,
	IANAifType_shdsl<s(0)(0)(0)>[&] = 169,
	IANAifType_ds1FDL<s(0)(0)(0)>[&] = 170,
	IANAifType_pos<s(0)(0)(0)>[&] = 171,
	IANAifType_dvbAsiIn<s(0)(0)(0)>[&] = 172,
	IANAifType_dvbAsiOut<s(0)(0)(0)>[&] = 173,
	IANAifType_plc<s(0)(0)(0)>[&] = 174,
	IANAifType_nfas<s(0)(0)(0)>[&] = 175,
	IANAifType_tr008<s(0)(0)(0)>[&] = 176,
	IANAifType_gr303RDT<s(0)(0)(0)>[&] = 177,
	IANAifType_gr303IDT<s(0)(0)(0)>[&] = 178,
	IANAifType_isup<s(0)(0)(0)>[&] = 179,
	IANAifType_propDocsWirelessMaclayer<s(0)(0)(0)>[&] = 180,
	IANAifType_propDocsWirelessDownstream<s(0)(0)(0)>[&] = 181,
	IANAifType_propDocsWirelessUpstream<s(0)(0)(0)>[&] = 182,
	IANAifType_hiperlan2<s(0)(0)(0)>[&] = 183,
	IANAifType_propBWAp2Mp<s(0)(0)(0)>[&] = 184,
	IANAifType_sonetOverheadChannel<s(0)(0)(0)>[&] = 185,
	IANAifType_digitalWrapperOverheadChannel<s(0)(0)(0)>[&] = 186,
	IANAifType_aal2<s(0)(0)(0)>[&] = 187,
	IANAifType_radioMAC<s(0)(0)(0)>[&] = 188,
	IANAifType_atmRadio<s(0)(0)(0)>[&] = 189,
	IANAifType_imt<s(0)(0)(0)>[&] = 190,
	IANAifType_mvl<s(0)(0)(0)>[&] = 191,
	IANAifType_reachDSL<s(0)(0)(0)>[&] = 192,
	IANAifType_frDlciEndPt<s(0)(0)(0)>[&] = 193,
	IANAifType_atmVciEndPt<s(0)(0)(0)>[&] = 194,
	IANAifType_opticalChannel<s(0)(0)(0)>[&] = 195,
	IANAifType_opticalTransport<s(0)(0)(0)>[&] = 196,
	IANAifType_propAtm<s(0)(0)(0)>[&] = 197,
	IANAifType_voiceOverCable<s(0)(0)(0)>[&] = 198,
	IANAifType_infiniband<s(0)(0)(0)>[&] = 199,
	IANAifType_teLink<s(0)(0)(0)>[&] = 200,
	IANAifType_q2931<s(0)(0)(0)>[&] = 201,
	IANAifType_virtualTg<s(0)(0)(0)>[&] = 202,
	IANAifType_sipTg<s(0)(0)(0)>[&] = 203,
	IANAifType_sipSig<s(0)(0)(0)>[&] = 204,
	IANAifType_docsCableUpstreamChannel<s(0)(0)(0)>[&] = 205,
	IANAifType_econet<s(0)(0)(0)>[&] = 206,
	IANAifType_pon155<s(0)(0)(0)>[&] = 207,
	IANAifType_pon622<s(0)(0)(0)>[&] = 208,
	IANAifType_bridge<s(0)(0)(0)>[&] = 209,
	IANAifType_linegroup<s(0)(0)(0)>[&] = 210,
	IANAifType_voiceEMFGD<s(0)(0)(0)>[&] = 211,
	IANAifType_voiceFGDEANA<s(0)(0)(0)>[&] = 212,
	IANAifType_voiceDID<s(0)(0)(0)>[&] = 213,
	IANAifType_mpegTransport<s(0)(0)(0)>[&] = 214,
	IANAifType_sixToFour<s(0)(0)(0)>[&] = 215,
	IANAifType_gtp<s(0)(0)(0)>[&] = 216,
	IANAifType_pdnEtherLoop1<s(0)(0)(0)>[&] = 217,
	IANAifType_pdnEtherLoop2<s(0)(0)(0)>[&] = 218,
	IANAifType_opticalChannelGroup<s(0)(0)(0)>[&] = 219,
	IANAifType_homepna<s(0)(0)(0)>[&] = 220,
	IANAifType_gfp<s(0)(0)(0)>[&] = 221,
	IANAifType_ciscoISLvlan<s(0)(0)(0)>[&] = 222,
	IANAifType_actelisMetaLOOP<s(0)(0)(0)>[&] = 223,
	IANAifType_fcipLink<s(0)(0)(0)>[&] = 224,
	IANAifType_rpr<s(0)(0)(0)>[&] = 225,
	IANAifType_qam<s(0)(0)(0)>[&] = 226,
	IANAifType_lmp<s(0)(0)(0)>[&] = 227,
	IANAifType_cblVectaStar<s(0)(0)(0)>[&] = 228,
	IANAifType_docsCableMCmtsDownstream<s(0)(0)(0)>[&] = 229,
	IANAifType_adsl2<s(0)(0)(0)>[&] = 230,
	IANAifType_macSecControlledIF<s(0)(0)(0)>[&] = 231,
	IANAifType_macSecUncontrolledIF<s(0)(0)(0)>[&] = 232,
	IANAifType_aviciOpticalEther<s(0)(0)(0)>[&] = 233,
	IANAifType_atmbond<s(0)(0)(0)>[&] = 234,
	IANAifType_voiceFGDOS<s(0)(0)(0)>[&] = 235,
	IANAifType_mocaVersion1<s(0)(0)(0)>[&] = 236,
	IANAifType_ieee80216WMAN<s(0)(0)(0)>[&] = 237,
	IANAifType_adsl2plus<s(0)(0)(0)>[&] = 238,
	IANAifType_dvbRcsMacLayer<s(0)(0)(0)>[&] = 239,
	IANAifType_dvbTdm<s(0)(0)(0)>[&] = 240,
	IANAifType_dvbRcsTdma<s(0)(0)(0)>[&] = 241,
	IANAifType_x86Laps<s(0)(0)(0)>[&] = 242,
	IANAifType_wwanPP<s(0)(0)(0)>[&] = 243,
	IANAifType_wwanPP2<s(0)(0)(0)>[&] = 244,
	IANAifType_voiceEBS<s(0)(0)(0)>[&] = 245,
	IANAifType_ifPwType<s(0)(0)(0)>[&] = 246,
	IANAifType_ilan<s(0)(0)(0)>[&] = 247,
	IANAifType_pip<s(0)(0)(0)>[&] = 248,
	IANAifType_aluELP<s(0)(0)(0)>[&] = 249
} IANAifType_Tval<s(0)(0)(0)>[&];(D1:IANAifType_Tval:1)[[TYPENAME:IANAifType_Tval]]

typedef enum {
	PbMsspSwitchStatus_idle<s(0)(0)(0)>[&] = 0,
	PbMsspSwitchStatus_bridge<s(0)(0)(0)>[&] = 1,
	PbMsspSwitchStatus_bridgeAndSwitch<s(0)(0)(0)>[&] = 2,
	PbMsspSwitchStatus_passthough<s(0)(0)(0)>[&] = 3
} PbMsspSwitchStatus_Tval<s(0)(0)(0)>[&];(D1:PbMsspSwitchStatus_Tval:1)[[TYPENAME:PbMsspSwitchStatus_Tval]]

typedef enum {
	PbMSPRestoreMode_revertive<s(0)(0)(0)>[&] = 1,
	PbMSPRestoreMode_nonrevertive<s(0)(0)(0)>[&] = 2
} PbMSPRestoreMode_Tval<s(0)(0)(0)>[&];(D1:PbMSPRestoreMode_Tval:1)[[TYPENAME:PbMSPRestoreMode_Tval]]

typedef enum {
	PbXcAction_up<s(0)(0)(0)>[&] = 0,
	PbXcAction_down<s(0)(0)(0)>[&] = 1,
	PbXcAction_delete<s(0)(0)(0)>[&] = 2
} PbXcAction_Tval<s(0)(0)(0)>[&];(D1:PbXcAction_Tval:1)[[TYPENAME:PbXcAction_Tval]]

typedef enum {
	PbSdhLpSignalLabel_unequipped<s(0)(0)(0)>[&] = 0,
	PbSdhLpSignalLabel_reserved<s(0)(0)(0)>[&] = 1,
	PbSdhLpSignalLabel_async<s(0)(0)(0)>[&] = 2,
	PbSdhLpSignalLabel_bitsync<s(0)(0)(0)>[&] = 3,
	PbSdhLpSignalLabel_bytesync<s(0)(0)(0)>[&] = 4,
	PbSdhLpSignalLabel_ext<s(0)(0)(0)>[&] = 5,
	PbSdhLpSignalLabel_test<s(0)(0)(0)>[&] = 6,
	PbSdhLpSignalLabel_ais<s(0)(0)(0)>[&] = 7
} PbSdhLpSignalLabel_Tval<s(0)(0)(0)>[&];(D1:PbSdhLpSignalLabel_Tval:1)[[TYPENAME:PbSdhLpSignalLabel_Tval]]

typedef enum {
	PbPortOperationStatus_up<s(0)(0)(0)>[&] = 1,
	PbPortOperationStatus_down<s(0)(0)(0)>[&] = 2,
	PbPortOperationStatus_absent<s(0)(0)(0)>[&] = 3,
	PbPortOperationStatus_na<s(0)(0)(0)>[&] = 4
} PbPortOperationStatus_Tval<s(0)(0)(0)>[&];(D1:PbPortOperationStatus_Tval:1)[[TYPENAME:PbPortOperationStatus_Tval]]

typedef enum {
	PbLacpPortClass_lAN<s(0)(0)(0)>[&] = 0,
	PbLacpPortClass_wAN<s(0)(0)(0)>[&] = 1
} PbLacpPortClass_Tval<s(0)(0)(0)>[&];(D1:PbLacpPortClass_Tval:1)[[TYPENAME:PbLacpPortClass_Tval]]

typedef enum {
	RprXcTableClass_oldTable<s(0)(0)(0)>[&] = 0,
	RprXcTableClass_newTable<s(0)(0)(0)>[&] = 1
} RprXcTableClass_Tval<s(0)(0)(0)>[&];(D1:RprXcTableClass_Tval:1)[[TYPENAME:RprXcTableClass_Tval]]

typedef enum {
	PbAlarmGroupType_psuA<s(0)(0)(0)>[&] = 1,
	PbAlarmGroupType_psuB<s(0)(0)(0)>[&] = 2,
	PbAlarmGroupType_fan1<s(0)(0)(0)>[&] = 3,
	PbAlarmGroupType_fan2<s(0)(0)(0)>[&] = 4,
	PbAlarmGroupType_tms_slot_a1<s(0)(0)(0)>[&] = 5,
	PbAlarmGroupType_tms_slot_a2<s(0)(0)(0)>[&] = 6,
	PbAlarmGroupType_almevt_logger<s(0)(0)(0)>[&] = 7,
	PbAlarmGroupType_slot_statistics<s(0)(0)(0)>[&] = 8,
	PbAlarmGroupType_ds3<s(0)(0)(0)>[&] = 9,
	PbAlarmGroupType_sonet_line<s(0)(0)(0)>[&] = 10,
	PbAlarmGroupType_sonet_path<s(0)(0)(0)>[&] = 11,
	PbAlarmGroupType_fdr<s(0)(0)(0)>[&] = 12,
	PbAlarmGroupType_node<s(0)(0)(0)>[&] = 13,
	PbAlarmGroupType_dget_agent<s(0)(0)(0)>[&] = 14,
	PbAlarmGroupType_dget_mgr<s(0)(0)(0)>[&] = 15,
	PbAlarmGroupType_fan3<s(0)(0)(0)>[&] = 16,
	PbAlarmGroupType_optics<s(0)(0)(0)>[&] = 17,
	PbAlarmGroupType_slot_intf<s(0)(0)(0)>[&] = 18,
	PbAlarmGroupType_path_aps<s(0)(0)(0)>[&] = 19,
	PbAlarmGroupType_power_circuit<s(0)(0)(0)>[&] = 20,
	PbAlarmGroupType_line_aps<s(0)(0)(0)>[&] = 21,
	PbAlarmGroupType_optical_signaling<s(0)(0)(0)>[&] = 22
} PbAlarmGroupType_Tval<s(0)(0)(0)>[&];(D1:PbAlarmGroupType_Tval:1)[[TYPENAME:PbAlarmGroupType_Tval]]

typedef enum {
	PBSNCPIntrusive_sncp_i<s(0)(0)(0)>[&] = 0,
	PBSNCPIntrusive_sncp_n<s(0)(0)(0)>[&] = 1
} PBSNCPIntrusive_Tval<s(0)(0)(0)>[&];(D1:PBSNCPIntrusive_Tval:1)[[TYPENAME:PBSNCPIntrusive_Tval]]

typedef enum {
	PbSNCPRestoreMode_revertive<s(0)(0)(0)>[&] = 1,
	PbSNCPRestoreMode_nonrevertive<s(0)(0)(0)>[&] = 2
} PbSNCPRestoreMode_Tval<s(0)(0)(0)>[&];(D1:PbSNCPRestoreMode_Tval:1)[[TYPENAME:PbSNCPRestoreMode_Tval]]

typedef enum {
	PbXcType_add<s(0)(0)(0)>[&] = 1,
	PbXcType_drop<s(0)(0)(0)>[&] = 2,
	PbXcType_passthrough<s(0)(0)(0)>[&] = 3
} PbXcType_Tval<s(0)(0)(0)>[&];(D1:PbXcType_Tval:1)[[TYPENAME:PbXcType_Tval]]

typedef enum {
	PbUpDown_up<s(0)(0)(0)>[&] = 1,
	PbUpDown_down<s(0)(0)(0)>[&] = 2
} PbUpDown_Tval<s(0)(0)(0)>[&];(D1:PbUpDown_Tval:1)[[TYPENAME:PbUpDown_Tval]]

typedef enum {
	PbMsspTrafficOrder_none<s(0)(0)(0)>[&] = 0,
	PbMsspTrafficOrder_high<s(0)(0)(0)>[&] = 1,
	PbMsspTrafficOrder_low<s(0)(0)(0)>[&] = 2
} PbMsspTrafficOrder_Tval<s(0)(0)(0)>[&];(D1:PbMsspTrafficOrder_Tval:1)[[TYPENAME:PbMsspTrafficOrder_Tval]]

typedef enum {
	PbXcFailReason_noerr<s(0)(0)(0)>[&] = 0,
	PbXcFailReason_resource<s(0)(0)(0)>[&] = 1,
	PbXcFailReason_block<s(0)(0)(0)>[&] = 2,
	PbXcFailReason_invalid<s(0)(0)(0)>[&] = 3,
	PbXcFailReason_conflict<s(0)(0)(0)>[&] = 4,
	PbXcFailReason_map<s(0)(0)(0)>[&] = 5,
	PbXcFailReason_interface<s(0)(0)(0)>[&] = 6,
	PbXcFailReason_locc<s(0)(0)(0)>[&] = 7
} PbXcFailReason_Tval<s(0)(0)(0)>[&];(D1:PbXcFailReason_Tval:1)[[TYPENAME:PbXcFailReason_Tval]]

typedef enum {
	IANAtunnelType_other<s(0)(0)(0)>[&] = 1,
	IANAtunnelType_direct<s(0)(0)(0)>[&] = 2,
	IANAtunnelType_gre<s(0)(0)(0)>[&] = 3,
	IANAtunnelType_minimal<s(0)(0)(0)>[&] = 4,
	IANAtunnelType_l2tp<s(0)(0)(0)>[&] = 5,
	IANAtunnelType_pptp<s(0)(0)(0)>[&] = 6,
	IANAtunnelType_l2f<s(0)(0)(0)>[&] = 7,
	IANAtunnelType_udp<s(0)(0)(0)>[&] = 8,
	IANAtunnelType_atmp<s(0)(0)(0)>[&] = 9,
	IANAtunnelType_msdp<s(0)(0)(0)>[&] = 10,
	IANAtunnelType_sixToFour<s(0)(0)(0)>[&] = 11,
	IANAtunnelType_sixOverFour<s(0)(0)(0)>[&] = 12,
	IANAtunnelType_isatap<s(0)(0)(0)>[&] = 13,
	IANAtunnelType_teredo<s(0)(0)(0)>[&] = 14
} IANAtunnelType_Tval<s(0)(0)(0)>[&];(D1:IANAtunnelType_Tval:1)[[TYPENAME:IANAtunnelType_Tval]]

typedef enum {
	PbEpgFunctionCardStatus_unknown<s(0)(0)(0)>[&] = 0,
	PbEpgFunctionCardStatus_latchoff<s(0)(0)(0)>[&] = 1,
	PbEpgFunctionCardStatus_latchon<s(0)(0)(0)>[&] = 2,
	PbEpgFunctionCardStatus_cardfail<s(0)(0)(0)>[&] = 3
} PbEpgFunctionCardStatus_Tval<s(0)(0)(0)>[&];(D1:PbEpgFunctionCardStatus_Tval:1)[[TYPENAME:PbEpgFunctionCardStatus_Tval]]

typedef enum {
	RouteStatus_inactive<s(0)(0)(0)>[&] = 1,
	RouteStatus_active<s(0)(0)(0)>[&] = 2,
	RouteStatus_invalid<s(0)(0)(0)>[&] = 3
} RouteStatus_Tval<s(0)(0)(0)>[&];(D1:RouteStatus_Tval:1)[[TYPENAME:RouteStatus_Tval]]

typedef enum {
	PbTMSMonitorMode_auto<s(0)(0)(0)>[&] = 0,
	PbTMSMonitorMode_yes<s(0)(0)(0)>[&] = 1,
	PbTMSMonitorMode_no<s(0)(0)(0)>[&] = 2
} PbTMSMonitorMode_Tval<s(0)(0)(0)>[&];(D1:PbTMSMonitorMode_Tval:1)[[TYPENAME:PbTMSMonitorMode_Tval]]

typedef enum {
	RprXcFailReason_noerr<s(0)(0)(0)>[&] = 0,
	RprXcFailReason_resource<s(0)(0)(0)>[&] = 1,
	RprXcFailReason_block<s(0)(0)(0)>[&] = 2,
	RprXcFailReason_invalid<s(0)(0)(0)>[&] = 3,
	RprXcFailReason_conflict<s(0)(0)(0)>[&] = 4,
	RprXcFailReason_map<s(0)(0)(0)>[&] = 5,
	RprXcFailReason_interface<s(0)(0)(0)>[&] = 6,
	RprXcFailReason_locc<s(0)(0)(0)>[&] = 7
} RprXcFailReason_Tval<s(0)(0)(0)>[&];(D1:RprXcFailReason_Tval:1)[[TYPENAME:RprXcFailReason_Tval]]

typedef enum {
	PbActualPortType_none<s(0)(0)(0)>[&] = 0,
	PbActualPortType_e1<s(0)(0)(0)>[&] = 1,
	PbActualPortType_ds1<s(0)(0)(0)>[&] = 2,
	PbActualPortType_e3<s(0)(0)(0)>[&] = 3,
	PbActualPortType_ds3<s(0)(0)(0)>[&] = 4,
	PbActualPortType_stm1<s(0)(0)(0)>[&] = 5,
	PbActualPortType_stm4<s(0)(0)(0)>[&] = 6
} PbActualPortType_Tval<s(0)(0)(0)>[&];(D1:PbActualPortType_Tval:1)[[TYPENAME:PbActualPortType_Tval]]

typedef enum {
	TruthValue_true<s(0)(0)(0)>[&] = 1,
	TruthValue_false<s(0)(0)(0)>[&] = 2
} TruthValue_Tval<s(0)(0)(0)>[&];(D1:TruthValue_Tval:1)[[TYPENAME:TruthValue_Tval]]

typedef enum {
	RprRingletID_ringlet0<s(0)(0)(0)>[&] = 0,
	RprRingletID_ringlet1<s(0)(0)(0)>[&] = 1
} RprRingletID_Tval<s(0)(0)(0)>[&];(D1:RprRingletID_Tval:1)[[TYPENAME:RprRingletID_Tval]]

typedef enum {
	PbMsspExternalCommand_exerciseRing<s(0)(0)(0)>[&] = 3,
	PbMsspExternalCommand_manualSwitchRing<s(0)(0)(0)>[&] = 6,
	PbMsspExternalCommand_forcedSwitchRing<s(0)(0)(0)>[&] = 13,
	PbMsspExternalCommand_lockoutProtection<s(0)(0)(0)>[&] = 15,
	PbMsspExternalCommand_clear<s(0)(0)(0)>[&] = 21,
	PbMsspExternalCommand_noCommand<s(0)(0)(0)>[&] = 23
} PbMsspExternalCommand_Tval<s(0)(0)(0)>[&];(D1:PbMsspExternalCommand_Tval:1)[[TYPENAME:PbMsspExternalCommand_Tval]]

typedef enum {
	PbPmMonitor_notMonitored<s(0)(0)(0)>[&] = 1,
	PbPmMonitor_monitored<s(0)(0)(0)>[&] = 2,
	PbPmMonitor_autoReport<s(0)(0)(0)>[&] = 3
} PbPmMonitor_Tval<s(0)(0)(0)>[&];(D1:PbPmMonitor_Tval:1)[[TYPENAME:PbPmMonitor_Tval]]

typedef enum {
	PbOkNotOk_failed<s(0)(0)(0)>[&] = 1,
	PbOkNotOk_okay<s(0)(0)(0)>[&] = 2
} PbOkNotOk_Tval<s(0)(0)(0)>[&];(D1:PbOkNotOk_Tval:1)[[TYPENAME:PbOkNotOk_Tval]]

typedef enum {
	PbMspChNumberType_nullchannel<s(0)(0)(0)>[&] = 0,
	PbMspChNumberType_workchannel1<s(0)(0)(0)>[&] = 1,
	PbMspChNumberType_workchannel2<s(0)(0)(0)>[&] = 2,
	PbMspChNumberType_workchannel3<s(0)(0)(0)>[&] = 3,
	PbMspChNumberType_workchannel4<s(0)(0)(0)>[&] = 4,
	PbMspChNumberType_workchannel5<s(0)(0)(0)>[&] = 5,
	PbMspChNumberType_workchannel6<s(0)(0)(0)>[&] = 6,
	PbMspChNumberType_workchannel7<s(0)(0)(0)>[&] = 7,
	PbMspChNumberType_workchannel8<s(0)(0)(0)>[&] = 8,
	PbMspChNumberType_workchannel9<s(0)(0)(0)>[&] = 9,
	PbMspChNumberType_workchannel10<s(0)(0)(0)>[&] = 10,
	PbMspChNumberType_workchannel11<s(0)(0)(0)>[&] = 11,
	PbMspChNumberType_workchannel12<s(0)(0)(0)>[&] = 12,
	PbMspChNumberType_workchannel13<s(0)(0)(0)>[&] = 13,
	PbMspChNumberType_workchannel14<s(0)(0)(0)>[&] = 14,
	PbMspChNumberType_extrafficchannel<s(0)(0)(0)>[&] = 15
} PbMspChNumberType_Tval<s(0)(0)(0)>[&];(D1:PbMspChNumberType_Tval:1)[[TYPENAME:PbMspChNumberType_Tval]]

typedef enum {
	PbMSPExCmdRslt_cmdRsltSucc<s(0)(0)(0)>[&] = 1,
	PbMSPExCmdRslt_cmdRsltLowPriority<s(0)(0)(0)>[&] = 2,
	PbMSPExCmdRslt_cmdRsltSwithToActive<s(0)(0)(0)>[&] = 3,
	PbMSPExCmdRslt_cmdSwitchFail<s(0)(0)(0)>[&] = 4
} PbMSPExCmdRslt_Tval<s(0)(0)(0)>[&];(D1:PbMSPExCmdRslt_Tval:1)[[TYPENAME:PbMSPExCmdRslt_Tval]]

typedef enum {
	PbTMSOutActType_auto<s(0)(0)(0)>[&] = 0,
	PbTMSOutActType_squelch<s(0)(0)(0)>[&] = 1
} PbTMSOutActType_Tval<s(0)(0)(0)>[&];(D1:PbTMSOutActType_Tval:1)[[TYPENAME:PbTMSOutActType_Tval]]

typedef enum {
	PBMSPChPriState_unknown<s(0)(0)(0)>[&] = 0,
	PBMSPChPriState_prihigh<s(0)(0)(0)>[&] = 1,
	PBMSPChPriState_prilow<s(0)(0)(0)>[&] = 2
} PBMSPChPriState_Tval<s(0)(0)(0)>[&];(D1:PBMSPChPriState_Tval:1)[[TYPENAME:PBMSPChPriState_Tval]]

typedef enum {
	PbPmTpStatusType_active<s(0)(0)(0)>[&] = 1,
	PbPmTpStatusType_inactive<s(0)(0)(0)>[&] = 2
} PbPmTpStatusType_Tval<s(0)(0)(0)>[&];(D1:PbPmTpStatusType_Tval:1)[[TYPENAME:PbPmTpStatusType_Tval]]

typedef enum {
	PbSncpFrom_cli<s(0)(0)(0)>[&] = 1,
	PbSncpFrom_ems<s(0)(0)(0)>[&] = 2,
	PbSncpFrom_snm<s(0)(0)(0)>[&] = 3,
	PbSncpFrom_gmpls<s(0)(0)(0)>[&] = 4
} PbSncpFrom_Tval<s(0)(0)(0)>[&];(D1:PbSncpFrom_Tval:1)[[TYPENAME:PbSncpFrom_Tval]]

typedef enum {
	RprXcMsgStatus_removed<s(0)(0)(0)>[&] = 0,
	RprXcMsgStatus_disabled<s(0)(0)(0)>[&] = 1,
	RprXcMsgStatus_ok<s(0)(0)(0)>[&] = 2,
	RprXcMsgStatus_failed<s(0)(0)(0)>[&] = 3
} RprXcMsgStatus_Tval<s(0)(0)(0)>[&];(D1:RprXcMsgStatus_Tval:1)[[TYPENAME:RprXcMsgStatus_Tval]]

typedef enum {
	PbUserAccessLevel_superUser<s(0)(0)(0)>[&] = 1,
	PbUserAccessLevel_administrative<s(0)(0)(0)>[&] = 2,
	PbUserAccessLevel_readOnly<s(0)(0)(0)>[&] = 3
} PbUserAccessLevel_Tval<s(0)(0)(0)>[&];(D1:PbUserAccessLevel_Tval:1)[[TYPENAME:PbUserAccessLevel_Tval]]

typedef enum {
	PbXcCapacity_vc11<s(0)(0)(0)>[&] = 1,
	PbXcCapacity_vc12<s(0)(0)(0)>[&] = 2,
	PbXcCapacity_vc2<s(0)(0)(0)>[&] = 3,
	PbXcCapacity_vc3<s(0)(0)(0)>[&] = 4,
	PbXcCapacity_vc4<s(0)(0)(0)>[&] = 5,
	PbXcCapacity_vc44c<s(0)(0)(0)>[&] = 6,
	PbXcCapacity_vc416c<s(0)(0)(0)>[&] = 7,
	PbXcCapacity_vc464c<s(0)(0)(0)>[&] = 8,
	PbXcCapacity_e1<s(0)(0)(0)>[&] = 9
} PbXcCapacity_Tval<s(0)(0)(0)>[&];(D1:PbXcCapacity_Tval:1)[[TYPENAME:PbXcCapacity_Tval]]

typedef enum {
	PbPortStatus_up<s(0)(0)(0)>[&] = 1,
	PbPortStatus_down<s(0)(0)(0)>[&] = 2
} PbPortStatus_Tval<s(0)(0)(0)>[&];(D1:PbPortStatus_Tval:1)[[TYPENAME:PbPortStatus_Tval]]

typedef enum {
	TypeMibUpDownLoadStatus_inactive<s(0)(0)(0)>[&] = 0,
	TypeMibUpDownLoadStatus_uploadPreparing<s(0)(0)(0)>[&] = 1,
	TypeMibUpDownLoadStatus_uploadPrepared<s(0)(0)(0)>[&] = 2,
	TypeMibUpDownLoadStatus_uploadPrepareFailed<s(0)(0)(0)>[&] = 3,
	TypeMibUpDownLoadStatus_uploadPrepareTimeout<s(0)(0)(0)>[&] = 4,
	TypeMibUpDownLoadStatus_uploading<s(0)(0)(0)>[&] = 5,
	TypeMibUpDownLoadStatus_uploaded<s(0)(0)(0)>[&] = 6,
	TypeMibUpDownLoadStatus_uploadCanceled<s(0)(0)(0)>[&] = 7,
	TypeMibUpDownLoadStatus_uploadingTimeout<s(0)(0)(0)>[&] = 8,
	TypeMibUpDownLoadStatus_uploadingFailed<s(0)(0)(0)>[&] = 9,
	TypeMibUpDownLoadStatus_downloadPreparing<s(0)(0)(0)>[&] = 21,
	TypeMibUpDownLoadStatus_downloadPrepared<s(0)(0)(0)>[&] = 22,
	TypeMibUpDownLoadStatus_downloadPrepareFailed<s(0)(0)(0)>[&] = 23,
	TypeMibUpDownLoadStatus_downloadPrepareTimeout<s(0)(0)(0)>[&] = 24,
	TypeMibUpDownLoadStatus_downloading<s(0)(0)(0)>[&] = 25,
	TypeMibUpDownLoadStatus_downloaded<s(0)(0)(0)>[&] = 26,
	TypeMibUpDownLoadStatus_downloadCanceled<s(0)(0)(0)>[&] = 27,
	TypeMibUpDownLoadStatus_downloadingTimeout<s(0)(0)(0)>[&] = 28,
	TypeMibUpDownLoadStatus_downloadingFailed<s(0)(0)(0)>[&] = 29
} TypeMibUpDownLoadStatus_Tval<s(0)(0)(0)>[&];(D1:TypeMibUpDownLoadStatus_Tval:1)[[TYPENAME:TypeMibUpDownLoadStatus_Tval]]

typedef enum {
	PbMsspNodeState_idle<s(0)(0)(0)>[&] = 0,
	PbMsspNodeState_passthough<s(0)(0)(0)>[&] = 1,
	PbMsspNodeState_switching<s(0)(0)(0)>[&] = 2,
	PbMsspNodeState_isolated<s(0)(0)(0)>[&] = 3
} PbMsspNodeState_Tval<s(0)(0)(0)>[&];(D1:PbMsspNodeState_Tval:1)[[TYPENAME:PbMsspNodeState_Tval]]

typedef enum {
	PbSNCPExCmdRslt_cmdRsltSucc<s(0)(0)(0)>[&] = 1,
	PbSNCPExCmdRslt_cmdRsltLowPriority<s(0)(0)(0)>[&] = 2,
	PbSNCPExCmdRslt_cmdRsltSwithToActive<s(0)(0)(0)>[&] = 3,
	PbSNCPExCmdRslt_cmdSwitchFail<s(0)(0)(0)>[&] = 4,
	PbSNCPExCmdRslt_cmdSwitchTimeout<s(0)(0)(0)>[&] = 5,
	PbSNCPExCmdRslt_cmdWaitCcRsp<s(0)(0)(0)>[&] = 6,
	PbSNCPExCmdRslt_cmdBadCommand<s(0)(0)(0)>[&] = 7
} PbSNCPExCmdRslt_Tval<s(0)(0)(0)>[&];(D1:PbSNCPExCmdRslt_Tval:1)[[TYPENAME:PbSNCPExCmdRslt_Tval]]

typedef enum {
	AlarmTypeID_spi_los<s(0)(0)(0)>[&] = 1,
	AlarmTypeID_rs_oof<s(0)(0)(0)>[&] = 2,
	AlarmTypeID_rs_lof<s(0)(0)(0)>[&] = 3,
	AlarmTypeID_rs_deg<s(0)(0)(0)>[&] = 4,
	AlarmTypeID_rs_tim<s(0)(0)(0)>[&] = 5,
	AlarmTypeID_rs_exc<s(0)(0)(0)>[&] = 6,
	AlarmTypeID_rs_dcf<s(0)(0)(0)>[&] = 7,
	AlarmTypeID_rs_tca<s(0)(0)(0)>[&] = 8,
	AlarmTypeID_ms_rdi<s(0)(0)(0)>[&] = 9,
	AlarmTypeID_ms_rei<s(0)(0)(0)>[&] = 10,
	AlarmTypeID_ms_ais<s(0)(0)(0)>[&] = 11,
	AlarmTypeID_ms_deg<s(0)(0)(0)>[&] = 12,
	AlarmTypeID_ms_exc<s(0)(0)(0)>[&] = 13,
	AlarmTypeID_ms_dcf<s(0)(0)(0)>[&] = 14,
	AlarmTypeID_ms_fop<s(0)(0)(0)>[&] = 15,
	AlarmTypeID_ms_tca<s(0)(0)(0)>[&] = 17,
	AlarmTypeID_au_lop<s(0)(0)(0)>[&] = 18,
	AlarmTypeID_au_ais<s(0)(0)(0)>[&] = 19,
	AlarmTypeID_au_tca<s(0)(0)(0)>[&] = 20,
	AlarmTypeID_hp_tim<s(0)(0)(0)>[&] = 21,
	AlarmTypeID_hp_uneq<s(0)(0)(0)>[&] = 22,
	AlarmTypeID_hp_rdi<s(0)(0)(0)>[&] = 23,
	AlarmTypeID_hp_plm<s(0)(0)(0)>[&] = 24,
	AlarmTypeID_hp_deg<s(0)(0)(0)>[&] = 25,
	AlarmTypeID_hp_lom<s(0)(0)(0)>[&] = 26,
	AlarmTypeID_hp_exc<s(0)(0)(0)>[&] = 27,
	AlarmTypeID_hp_tca<s(0)(0)(0)>[&] = 28,
	AlarmTypeID_hpv_lom<s(0)(0)(0)>[&] = 29,
	AlarmTypeID_hpv_sqm<s(0)(0)(0)>[&] = 30,
	AlarmTypeID_hpv_loa<s(0)(0)(0)>[&] = 31,
	AlarmTypeID_tu_lop<s(0)(0)(0)>[&] = 32,
	AlarmTypeID_tu_lom<s(0)(0)(0)>[&] = 33,
	AlarmTypeID_tu_ais<s(0)(0)(0)>[&] = 34,
	AlarmTypeID_tu_tca<s(0)(0)(0)>[&] = 35,
	AlarmTypeID_lp_tim<s(0)(0)(0)>[&] = 36,
	AlarmTypeID_lp_uneq<s(0)(0)(0)>[&] = 37,
	AlarmTypeID_lp_rdi<s(0)(0)(0)>[&] = 38,
	AlarmTypeID_lp_plm<s(0)(0)(0)>[&] = 39,
	AlarmTypeID_lp_deg<s(0)(0)(0)>[&] = 40,
	AlarmTypeID_lp_exc<s(0)(0)(0)>[&] = 41,
	AlarmTypeID_lp_rfi<s(0)(0)(0)>[&] = 42,
	AlarmTypeID_lpv_lom<s(0)(0)(0)>[&] = 43,
	AlarmTypeID_lpv_sqm<s(0)(0)(0)>[&] = 44,
	AlarmTypeID_lpv_loa<s(0)(0)(0)>[&] = 45,
	AlarmTypeID_lan_los<s(0)(0)(0)>[&] = 46,
	AlarmTypeID_lan_bbr<s(0)(0)(0)>[&] = 47,
	AlarmTypeID_lan_bpr<s(0)(0)(0)>[&] = 48,
	AlarmTypeID_set_lti<s(0)(0)(0)>[&] = 49,
	AlarmTypeID_set_lto<s(0)(0)(0)>[&] = 50,
	AlarmTypeID_set_trf<s(0)(0)(0)>[&] = 51,
	AlarmTypeID_set_deg<s(0)(0)(0)>[&] = 52,
	AlarmTypeID_set_ssmbm<s(0)(0)(0)>[&] = 53,
	AlarmTypeID_env_mdi<s(0)(0)(0)>[&] = 54,
	AlarmTypeID_env_oh<s(0)(0)(0)>[&] = 55,
	AlarmTypeID_eqp_uf<s(0)(0)(0)>[&] = 56,
	AlarmTypeID_eqp_ur<s(0)(0)(0)>[&] = 57,
	AlarmTypeID_eqp_pf<s(0)(0)(0)>[&] = 58,
	AlarmTypeID_wan_los<s(0)(0)(0)>[&] = 59,
	AlarmTypeID_wan_bbr<s(0)(0)(0)>[&] = 60,
	AlarmTypeID_wan_bpr<s(0)(0)(0)>[&] = 61,
	AlarmTypeID_tc_lcd<s(0)(0)(0)>[&] = 62,
	AlarmTypeID_vp_ais<s(0)(0)(0)>[&] = 63,
	AlarmTypeID_vp_rdi<s(0)(0)(0)>[&] = 64,
	AlarmTypeID_vp_loc<s(0)(0)(0)>[&] = 65,
	AlarmTypeID_vc_ais<s(0)(0)(0)>[&] = 66,
	AlarmTypeID_vc_rdi<s(0)(0)(0)>[&] = 67,
	AlarmTypeID_vc_loc<s(0)(0)(0)>[&] = 68,
	AlarmTypeID_ppi_los<s(0)(0)(0)>[&] = 69,
	AlarmTypeID_spi_dcf<s(0)(0)(0)>[&] = 70,
	AlarmTypeID_in_cer<s(0)(0)(0)>[&] = 71,
	AlarmTypeID_in_clr<s(0)(0)(0)>[&] = 72,
	AlarmTypeID_out_cer<s(0)(0)(0)>[&] = 73,
	AlarmTypeID_out_clr<s(0)(0)(0)>[&] = 74,
	AlarmTypeID_lp_tca<s(0)(0)(0)>[&] = 75,
	AlarmTypeID_set_scf<s(0)(0)(0)>[&] = 76,
	AlarmTypeID_eqp_ff<s(0)(0)(0)>[&] = 77,
	AlarmTypeID_spi_oop_tca<s(0)(0)(0)>[&] = 78,
	AlarmTypeID_spi_iop_tca<s(0)(0)(0)>[&] = 79,
	AlarmTypeID_spi_lb_tca<s(0)(0)(0)>[&] = 80,
	AlarmTypeID_spi_lt_tca<s(0)(0)(0)>[&] = 81,
	AlarmTypeID_spi_ta<s(0)(0)(0)>[&] = 82,
	AlarmTypeID_eqp_utm<s(0)(0)(0)>[&] = 83,
	AlarmTypeID_spi_lcd_slow<s(0)(0)(0)>[&] = 84,
	AlarmTypeID_spi_lcd_fast<s(0)(0)(0)>[&] = 85,
	AlarmTypeID_hpv_csf<s(0)(0)(0)>[&] = 86,
	AlarmTypeID_hpv_lfd<s(0)(0)(0)>[&] = 87,
	AlarmTypeID_lpv_csf<s(0)(0)(0)>[&] = 88,
	AlarmTypeID_lpv_lfd<s(0)(0)(0)>[&] = 89,
	AlarmTypeID_ppi_tca<s(0)(0)(0)>[&] = 90,
	AlarmTypeID_ppi_nslip<s(0)(0)(0)>[&] = 91,
	AlarmTypeID_ppi_pslip<s(0)(0)(0)>[&] = 92,
	AlarmTypeID_rs_tca_es15m<s(0)(0)(0)>[&] = 93,
	AlarmTypeID_rs_tca_es24h<s(0)(0)(0)>[&] = 94,
	AlarmTypeID_rs_tca_bbe15m<s(0)(0)(0)>[&] = 95,
	AlarmTypeID_rs_tca_bbe24h<s(0)(0)(0)>[&] = 96,
	AlarmTypeID_rs_tca_ses15m<s(0)(0)(0)>[&] = 97,
	AlarmTypeID_rs_tca_ses24h<s(0)(0)(0)>[&] = 98,
	AlarmTypeID_rs_tca_uas15m<s(0)(0)(0)>[&] = 99,
	AlarmTypeID_rs_tca_uas24h<s(0)(0)(0)>[&] = 100,
	AlarmTypeID_rs_tca_uap15m<s(0)(0)(0)>[&] = 101,
	AlarmTypeID_rs_tca_uap24h<s(0)(0)(0)>[&] = 102,
	AlarmTypeID_rs_tca_cses15m<s(0)(0)(0)>[&] = 103,
	AlarmTypeID_rs_tca_cses24h<s(0)(0)(0)>[&] = 104,
	AlarmTypeID_rs_tca_ofs15m<s(0)(0)(0)>[&] = 105,
	AlarmTypeID_rs_tca_ofs24h<s(0)(0)(0)>[&] = 106,
	AlarmTypeID_ms_tca_es15mn<s(0)(0)(0)>[&] = 107,
	AlarmTypeID_ms_tca_es15mf<s(0)(0)(0)>[&] = 108,
	AlarmTypeID_ms_tca_es24hn<s(0)(0)(0)>[&] = 109,
	AlarmTypeID_ms_tca_es24hf<s(0)(0)(0)>[&] = 110,
	AlarmTypeID_ms_tca_bbe15mn<s(0)(0)(0)>[&] = 111,
	AlarmTypeID_ms_tca_bbe15mf<s(0)(0)(0)>[&] = 112,
	AlarmTypeID_ms_tca_bbe24hn<s(0)(0)(0)>[&] = 113,
	AlarmTypeID_ms_tca_bbe24hf<s(0)(0)(0)>[&] = 114,
	AlarmTypeID_ms_tca_ses15mn<s(0)(0)(0)>[&] = 115,
	AlarmTypeID_ms_tca_ses15mf<s(0)(0)(0)>[&] = 116,
	AlarmTypeID_ms_tca_ses24hn<s(0)(0)(0)>[&] = 117,
	AlarmTypeID_ms_tca_ses24hf<s(0)(0)(0)>[&] = 118,
	AlarmTypeID_ms_tca_uas15mn<s(0)(0)(0)>[&] = 119,
	AlarmTypeID_ms_tca_uas15mf<s(0)(0)(0)>[&] = 120,
	AlarmTypeID_ms_tca_uas24hn<s(0)(0)(0)>[&] = 121,
	AlarmTypeID_ms_tca_uas24hf<s(0)(0)(0)>[&] = 122,
	AlarmTypeID_ms_tca_uap15mn<s(0)(0)(0)>[&] = 123,
	AlarmTypeID_ms_tca_uap15mf<s(0)(0)(0)>[&] = 124,
	AlarmTypeID_ms_tca_uap24hn<s(0)(0)(0)>[&] = 125,
	AlarmTypeID_ms_tca_uap24hf<s(0)(0)(0)>[&] = 126,
	AlarmTypeID_ms_tca_cses15mn<s(0)(0)(0)>[&] = 127,
	AlarmTypeID_ms_tca_cses15mf<s(0)(0)(0)>[&] = 128,
	AlarmTypeID_ms_tca_cses24hn<s(0)(0)(0)>[&] = 129,
	AlarmTypeID_ms_tca_cses24hf<s(0)(0)(0)>[&] = 130,
	AlarmTypeID_hp_tca_es15mn<s(0)(0)(0)>[&] = 131,
	AlarmTypeID_hp_tca_es15mf<s(0)(0)(0)>[&] = 132,
	AlarmTypeID_hp_tca_es24hn<s(0)(0)(0)>[&] = 133,
	AlarmTypeID_hp_tca_es24hf<s(0)(0)(0)>[&] = 134,
	AlarmTypeID_hp_tca_bbe15mn<s(0)(0)(0)>[&] = 135,
	AlarmTypeID_hp_tca_bbe15mf<s(0)(0)(0)>[&] = 136,
	AlarmTypeID_hp_tca_bbe24hn<s(0)(0)(0)>[&] = 137,
	AlarmTypeID_hp_tca_bbe24hf<s(0)(0)(0)>[&] = 138,
	AlarmTypeID_hp_tca_ses15mn<s(0)(0)(0)>[&] = 139,
	AlarmTypeID_hp_tca_ses15mf<s(0)(0)(0)>[&] = 140,
	AlarmTypeID_hp_tca_ses24hn<s(0)(0)(0)>[&] = 141,
	AlarmTypeID_hp_tca_ses24hf<s(0)(0)(0)>[&] = 142,
	AlarmTypeID_hp_tca_uas15mn<s(0)(0)(0)>[&] = 143,
	AlarmTypeID_hp_tca_uas15mf<s(0)(0)(0)>[&] = 144,
	AlarmTypeID_hp_tca_uas24hn<s(0)(0)(0)>[&] = 145,
	AlarmTypeID_hp_tca_uas24hf<s(0)(0)(0)>[&] = 146,
	AlarmTypeID_hp_tca_uap15mn<s(0)(0)(0)>[&] = 147,
	AlarmTypeID_hp_tca_uap15mf<s(0)(0)(0)>[&] = 148,
	AlarmTypeID_hp_tca_uap24hn<s(0)(0)(0)>[&] = 149,
	AlarmTypeID_hp_tca_uap24hf<s(0)(0)(0)>[&] = 150,
	AlarmTypeID_hp_tca_cses15mn<s(0)(0)(0)>[&] = 151,
	AlarmTypeID_hp_tca_cses15mf<s(0)(0)(0)>[&] = 152,
	AlarmTypeID_hp_tca_cses24hn<s(0)(0)(0)>[&] = 153,
	AlarmTypeID_hp_tca_cses24hf<s(0)(0)(0)>[&] = 154,
	AlarmTypeID_hp_tca_pjcp15m<s(0)(0)(0)>[&] = 155,
	AlarmTypeID_hp_tca_pjcp24h<s(0)(0)(0)>[&] = 156,
	AlarmTypeID_hp_tca_pjcn15m<s(0)(0)(0)>[&] = 157,
	AlarmTypeID_hp_tca_pjcn24h<s(0)(0)(0)>[&] = 158,
	AlarmTypeID_lp_tca_es15mn<s(0)(0)(0)>[&] = 159,
	AlarmTypeID_lp_tca_es15mf<s(0)(0)(0)>[&] = 160,
	AlarmTypeID_lp_tca_es24hn<s(0)(0)(0)>[&] = 161,
	AlarmTypeID_lp_tca_es24hf<s(0)(0)(0)>[&] = 162,
	AlarmTypeID_lp_tca_bbe15mn<s(0)(0)(0)>[&] = 163,
	AlarmTypeID_lp_tca_bbe15mf<s(0)(0)(0)>[&] = 164,
	AlarmTypeID_lp_tca_bbe24hn<s(0)(0)(0)>[&] = 165,
	AlarmTypeID_lp_tca_bbe24hf<s(0)(0)(0)>[&] = 166,
	AlarmTypeID_lp_tca_ses15mn<s(0)(0)(0)>[&] = 167,
	AlarmTypeID_lp_tca_ses15mf<s(0)(0)(0)>[&] = 168,
	AlarmTypeID_lp_tca_ses24hn<s(0)(0)(0)>[&] = 169,
	AlarmTypeID_lp_tca_ses24hf<s(0)(0)(0)>[&] = 170,
	AlarmTypeID_lp_tca_uas15mn<s(0)(0)(0)>[&] = 171,
	AlarmTypeID_lp_tca_uas15mf<s(0)(0)(0)>[&] = 172,
	AlarmTypeID_lp_tca_uas24hn<s(0)(0)(0)>[&] = 173,
	AlarmTypeID_lp_tca_uas24hf<s(0)(0)(0)>[&] = 174,
	AlarmTypeID_lp_tca_uap15mn<s(0)(0)(0)>[&] = 175,
	AlarmTypeID_lp_tca_uap15mf<s(0)(0)(0)>[&] = 176,
	AlarmTypeID_lp_tca_uap24hn<s(0)(0)(0)>[&] = 177,
	AlarmTypeID_lp_tca_uap24hf<s(0)(0)(0)>[&] = 178,
	AlarmTypeID_lp_tca_cses15mn<s(0)(0)(0)>[&] = 179,
	AlarmTypeID_lp_tca_cses15mf<s(0)(0)(0)>[&] = 180,
	AlarmTypeID_lp_tca_cses24hn<s(0)(0)(0)>[&] = 181,
	AlarmTypeID_lp_tca_cses24hf<s(0)(0)(0)>[&] = 182,
	AlarmTypeID_lp_tca_pjcp15m<s(0)(0)(0)>[&] = 183,
	AlarmTypeID_lp_tca_pjcp24h<s(0)(0)(0)>[&] = 184,
	AlarmTypeID_lp_tca_pjcn15m<s(0)(0)(0)>[&] = 185,
	AlarmTypeID_lp_tca_pjcn24h<s(0)(0)(0)>[&] = 186,
	AlarmTypeID_env_mdi1<s(0)(0)(0)>[&] = 187,
	AlarmTypeID_env_mdi2<s(0)(0)(0)>[&] = 188,
	AlarmTypeID_env_mdi3<s(0)(0)(0)>[&] = 189,
	AlarmTypeID_env_mdi4<s(0)(0)(0)>[&] = 190,
	AlarmTypeID_rpr_katoe<s(0)(0)(0)>[&] = 191,
	AlarmTypeID_rpr_katow<s(0)(0)(0)>[&] = 192,
	AlarmTypeID_rpr_dmac<s(0)(0)(0)>[&] = 193,
	AlarmTypeID_rpr_eres0<s(0)(0)(0)>[&] = 194,
	AlarmTypeID_rpr_eres1<s(0)(0)(0)>[&] = 195,
	AlarmTypeID_rpr_lrnc<s(0)(0)(0)>[&] = 196,
	AlarmTypeID_rpr_mmac<s(0)(0)(0)>[&] = 197,
	AlarmTypeID_rpr_mstn<s(0)(0)(0)>[&] = 198,
	AlarmTypeID_rpr_mscbe<s(0)(0)(0)>[&] = 199,
	AlarmTypeID_rpr_mscbw<s(0)(0)(0)>[&] = 200,
	AlarmTypeID_rpr_pmcfg<s(0)(0)(0)>[&] = 201,
	AlarmTypeID_rpr_tpincs<s(0)(0)(0)>[&] = 202,
	AlarmTypeID_rpr_tpinst<s(0)(0)(0)>[&] = 203,
	AlarmTypeID_oa_tf<s(0)(0)(0)>[&] = 211,
	AlarmTypeID_oa_los<s(0)(0)(0)>[&] = 212,
	AlarmTypeID_oa_bias<s(0)(0)(0)>[&] = 214,
	AlarmTypeID_oa_lth<s(0)(0)(0)>[&] = 215,
	AlarmTypeID_eqp_mismatch<s(0)(0)(0)>[&] = 216,
	AlarmTypeID_neg_slip_tca_15m<s(0)(0)(0)>[&] = 217,
	AlarmTypeID_neg_slip_tca_24h<s(0)(0)(0)>[&] = 218,
	AlarmTypeID_pos_slip_tca_15m<s(0)(0)(0)>[&] = 219,
	AlarmTypeID_pos_slip_tca_24h<s(0)(0)(0)>[&] = 220,
	AlarmTypeID_set_timedeg<s(0)(0)(0)>[&] = 221,
	AlarmTypeID_sfp_failure<s(0)(0)(0)>[&] = 222,
	AlarmTypeID_ecc1_failure<s(0)(0)(0)>[&] = 223,
	AlarmTypeID_sfp_mismatch<s(0)(0)(0)>[&] = 224,
	AlarmTypeID_ppi_ais<s(0)(0)(0)>[&] = 225,
	AlarmTypeID_oa_output_power_high<s(0)(0)(0)>[&] = 226,
	AlarmTypeID_oa_gain_high<s(0)(0)(0)>[&] = 227,
	AlarmTypeID_ecc2_failure<s(0)(0)(0)>[&] = 228,
	AlarmTypeID_memory_card_failure<s(0)(0)(0)>[&] = 229,
	AlarmTypeID_ppi_lof<s(0)(0)(0)>[&] = 230,
	AlarmTypeID_ppi_lom<s(0)(0)(0)>[&] = 231,
	AlarmTypeID_ppi_rdi<s(0)(0)(0)>[&] = 232,
	AlarmTypeID_hpvc_tlct<s(0)(0)(0)>[&] = 234,
	AlarmTypeID_lpvc_tlct<s(0)(0)(0)>[&] = 235,
	AlarmTypeID_ppi_tca_es15mn<s(0)(0)(0)>[&] = 236,
	AlarmTypeID_ppi_tca_es15mf<s(0)(0)(0)>[&] = 237,
	AlarmTypeID_ppi_tca_es24hn<s(0)(0)(0)>[&] = 238,
	AlarmTypeID_ppi_tca_es24hf<s(0)(0)(0)>[&] = 239,
	AlarmTypeID_ppi_tca_bbe15mn<s(0)(0)(0)>[&] = 240,
	AlarmTypeID_ppi_tca_bbe15mf<s(0)(0)(0)>[&] = 241,
	AlarmTypeID_ppi_tca_bbe24hn<s(0)(0)(0)>[&] = 242,
	AlarmTypeID_ppi_tca_bbe24hf<s(0)(0)(0)>[&] = 243,
	AlarmTypeID_ppi_tca_ses15mn<s(0)(0)(0)>[&] = 244,
	AlarmTypeID_ppi_tca_ses15mf<s(0)(0)(0)>[&] = 245,
	AlarmTypeID_ppi_tca_ses24hn<s(0)(0)(0)>[&] = 246,
	AlarmTypeID_ppi_tca_ses24hf<s(0)(0)(0)>[&] = 247,
	AlarmTypeID_ppi_tca_uas15mn<s(0)(0)(0)>[&] = 248,
	AlarmTypeID_ppi_tca_uas15mf<s(0)(0)(0)>[&] = 249,
	AlarmTypeID_ppi_tca_uas24hn<s(0)(0)(0)>[&] = 250,
	AlarmTypeID_ppi_tca_uas24hf<s(0)(0)(0)>[&] = 251,
	AlarmTypeID_loss_of_power_input<s(0)(0)(0)>[&] = 253,
	AlarmTypeID_env_mdi5<s(0)(0)(0)>[&] = 254,
	AlarmTypeID_env_mdi6<s(0)(0)(0)>[&] = 255,
	AlarmTypeID_env_mdi7<s(0)(0)(0)>[&] = 256,
	AlarmTypeID_env_mdi8<s(0)(0)(0)>[&] = 257,
	AlarmTypeID_sfp_absent<s(0)(0)(0)>[&] = 258,
	AlarmTypeID_memory_card_absent<s(0)(0)(0)>[&] = 259,
	AlarmTypeID_oa_pf<s(0)(0)(0)>[&] = 260,
	AlarmTypeID_sc_sw_version_mismatch<s(0)(0)(0)>[&] = 286,
	AlarmTypeID_hcoc9_dcf<s(0)(0)(0)>[&] = 287,
	AlarmTypeID_hcoc27_dcf<s(0)(0)(0)>[&] = 288,
	AlarmTypeID_unsuccessful_logins_exceeded<s(0)(0)(0)>[&] = 289,
	AlarmTypeID_log_occupancy_threshold<s(0)(0)(0)>[&] = 290,
	AlarmTypeID_log_is_full<s(0)(0)(0)>[&] = 291,
	AlarmTypeID_unauthorized_access<s(0)(0)(0)>[&] = 292,
	AlarmTypeID_communication_failure<s(0)(0)(0)>[&] = 293,
	AlarmTypeID_no_free_low_order_capacity<s(0)(0)(0)>[&] = 294,
	AlarmTypeID_low_order_capacity_mismatch<s(0)(0)(0)>[&] = 295,
	AlarmTypeID_pll_unlock<s(0)(0)(0)>[&] = 296,
	AlarmTypeID_account_expired_disabled<s(0)(0)(0)>[&] = 297,
	AlarmTypeID_vcxo_failure<s(0)(0)(0)>[&] = 298,
	AlarmTypeID_eq_fal<s(0)(0)(0)>[&] = 299,
	AlarmTypeID_tr_cim<s(0)(0)(0)>[&] = 300,
	AlarmTypeID_otu_lfa<s(0)(0)(0)>[&] = 301,
	AlarmTypeID_otu_lma<s(0)(0)(0)>[&] = 302,
	AlarmTypeID_sm_tim<s(0)(0)(0)>[&] = 303,
	AlarmTypeID_sm_iae<s(0)(0)(0)>[&] = 304,
	AlarmTypeID_sm_bdi<s(0)(0)(0)>[&] = 305,
	AlarmTypeID_opu_ptm<s(0)(0)(0)>[&] = 306,
	AlarmTypeID_loss_of_optical_input<s(0)(0)(0)>[&] = 307,
	AlarmTypeID_ld_fail<s(0)(0)(0)>[&] = 308,
	AlarmTypeID_optical_output_fail<s(0)(0)(0)>[&] = 309,
	AlarmTypeID_wavelength_control<s(0)(0)(0)>[&] = 310,
	AlarmTypeID_dcn_2m_los<s(0)(0)(0)>[&] = 311,
	AlarmTypeID_flash_util_over<s(0)(0)(0)>[&] = 312,
	AlarmTypeID_cfcard_util_over<s(0)(0)(0)>[&] = 313,
	AlarmTypeID_signal_error_fail<s(0)(0)(0)>[&] = 314,
	AlarmTypeID_latch_open<s(0)(0)(0)>[&] = 315,
	AlarmTypeID_otu_deg<s(0)(0)(0)>[&] = 316,
	AlarmTypeID_odu2_loflom<s(0)(0)(0)>[&] = 317,
	AlarmTypeID_odu2_ais<s(0)(0)(0)>[&] = 318,
	AlarmTypeID_odu2_lck<s(0)(0)(0)>[&] = 319,
	AlarmTypeID_odu2_oci<s(0)(0)(0)>[&] = 320,
	AlarmTypeID_odu2_tim<s(0)(0)(0)>[&] = 321,
	AlarmTypeID_odu2_bdi<s(0)(0)(0)>[&] = 322,
	AlarmTypeID_odu2_deg<s(0)(0)(0)>[&] = 323,
	AlarmTypeID_odu2_plm<s(0)(0)(0)>[&] = 324,
	AlarmTypeID_odu2_msim<s(0)(0)(0)>[&] = 325,
	AlarmTypeID_odu1_loflom<s(0)(0)(0)>[&] = 326,
	AlarmTypeID_odu1_ais<s(0)(0)(0)>[&] = 327,
	AlarmTypeID_odu1_lck<s(0)(0)(0)>[&] = 328,
	AlarmTypeID_odu1_oci<s(0)(0)(0)>[&] = 329,
	AlarmTypeID_odu1_tim<s(0)(0)(0)>[&] = 330,
	AlarmTypeID_odu1_bdi<s(0)(0)(0)>[&] = 331,
	AlarmTypeID_odu1_deg<s(0)(0)(0)>[&] = 332,
	AlarmTypeID_odu1_plm<s(0)(0)(0)>[&] = 333,
	AlarmTypeID_hpvc_plct<s(0)(0)(0)>[&] = 334,
	AlarmTypeID_lpvc_plct<s(0)(0)(0)>[&] = 335,
	AlarmTypeID_hpvc_plcr<s(0)(0)(0)>[&] = 336,
	AlarmTypeID_lpvc_plcr<s(0)(0)(0)>[&] = 337,
	AlarmTypeID_eqp_fan_failure<s(0)(0)(0)>[&] = 338
} AlarmTypeID_Tval<s(0)(0)(0)>[&];(D1:AlarmTypeID_Tval:1)[[TYPENAME:AlarmTypeID_Tval]]

typedef enum {
	RprXcCapacity_vc11<s(0)(0)(0)>[&] = 1,
	RprXcCapacity_vc12<s(0)(0)(0)>[&] = 2,
	RprXcCapacity_vc2<s(0)(0)(0)>[&] = 3,
	RprXcCapacity_vc3<s(0)(0)(0)>[&] = 4,
	RprXcCapacity_vc4<s(0)(0)(0)>[&] = 5,
	RprXcCapacity_vc44c<s(0)(0)(0)>[&] = 6,
	RprXcCapacity_vc416c<s(0)(0)(0)>[&] = 7,
	RprXcCapacity_vc464c<s(0)(0)(0)>[&] = 8,
	RprXcCapacity_e1<s(0)(0)(0)>[&] = 9
} RprXcCapacity_Tval<s(0)(0)(0)>[&];(D1:RprXcCapacity_Tval:1)[[TYPENAME:RprXcCapacity_Tval]]

typedef enum {
	PbTimeZone_eniwetok<s(0)(0)(0)>[&] = 0,
	PbTimeZone_midwayIsland<s(0)(0)(0)>[&] = 1,
	PbTimeZone_hawaii<s(0)(0)(0)>[&] = 2,
	PbTimeZone_alaska<s(0)(0)(0)>[&] = 3,
	PbTimeZone_pacificTime<s(0)(0)(0)>[&] = 4,
	PbTimeZone_arizona<s(0)(0)(0)>[&] = 5,
	PbTimeZone_mountainTime<s(0)(0)(0)>[&] = 10,
	PbTimeZone_centralAmerica<s(0)(0)(0)>[&] = 15,
	PbTimeZone_centralTime<s(0)(0)(0)>[&] = 20,
	PbTimeZone_mexico<s(0)(0)(0)>[&] = 25,
	PbTimeZone_saskatchewan<s(0)(0)(0)>[&] = 30,
	PbTimeZone_bogota<s(0)(0)(0)>[&] = 35,
	PbTimeZone_easternTime<s(0)(0)(0)>[&] = 40,
	PbTimeZone_indiana<s(0)(0)(0)>[&] = 45,
	PbTimeZone_atlantic<s(0)(0)(0)>[&] = 50,
	PbTimeZone_caracas<s(0)(0)(0)>[&] = 55,
	PbTimeZone_santiago<s(0)(0)(0)>[&] = 56,
	PbTimeZone_newfoundland<s(0)(0)(0)>[&] = 60,
	PbTimeZone_brasilia<s(0)(0)(0)>[&] = 65,
	PbTimeZone_buenosAires<s(0)(0)(0)>[&] = 70,
	PbTimeZone_greenland<s(0)(0)(0)>[&] = 73,
	PbTimeZone_midAtlantic<s(0)(0)(0)>[&] = 75,
	PbTimeZone_azores<s(0)(0)(0)>[&] = 80,
	PbTimeZone_capeVerdeIslands<s(0)(0)(0)>[&] = 83,
	PbTimeZone_casablanca<s(0)(0)(0)>[&] = 85,
	PbTimeZone_greenwich<s(0)(0)(0)>[&] = 90,
	PbTimeZone_amsterdam<s(0)(0)(0)>[&] = 95,
	PbTimeZone_belgrade<s(0)(0)(0)>[&] = 100,
	PbTimeZone_brussels<s(0)(0)(0)>[&] = 105,
	PbTimeZone_sarajevo<s(0)(0)(0)>[&] = 110,
	PbTimeZone_westCentralAfrica<s(0)(0)(0)>[&] = 115,
	PbTimeZone_athens<s(0)(0)(0)>[&] = 120,
	PbTimeZone_bucharest<s(0)(0)(0)>[&] = 125,
	PbTimeZone_cairo<s(0)(0)(0)>[&] = 130,
	PbTimeZone_harare<s(0)(0)(0)>[&] = 135,
	PbTimeZone_helsinki<s(0)(0)(0)>[&] = 140,
	PbTimeZone_jerusalem<s(0)(0)(0)>[&] = 145,
	PbTimeZone_baghdad<s(0)(0)(0)>[&] = 150,
	PbTimeZone_kuwait<s(0)(0)(0)>[&] = 155,
	PbTimeZone_moscow<s(0)(0)(0)>[&] = 158,
	PbTimeZone_nairobi<s(0)(0)(0)>[&] = 160,
	PbTimeZone_tehran<s(0)(0)(0)>[&] = 165,
	PbTimeZone_abuDhabi<s(0)(0)(0)>[&] = 170,
	PbTimeZone_baku<s(0)(0)(0)>[&] = 175,
	PbTimeZone_kabul<s(0)(0)(0)>[&] = 180,
	PbTimeZone_ekaterinburg<s(0)(0)(0)>[&] = 185,
	PbTimeZone_islamabad<s(0)(0)(0)>[&] = 190,
	PbTimeZone_calcutta<s(0)(0)(0)>[&] = 195,
	PbTimeZone_kathmandu<s(0)(0)(0)>[&] = 198,
	PbTimeZone_almaty<s(0)(0)(0)>[&] = 200,
	PbTimeZone_astana<s(0)(0)(0)>[&] = 201,
	PbTimeZone_sri<s(0)(0)(0)>[&] = 202,
	PbTimeZone_rangoony<s(0)(0)(0)>[&] = 205,
	PbTimeZone_bangkok<s(0)(0)(0)>[&] = 207,
	PbTimeZone_krasnoyarsk<s(0)(0)(0)>[&] = 208,
	PbTimeZone_beijing<s(0)(0)(0)>[&] = 210,
	PbTimeZone_irkutsk<s(0)(0)(0)>[&] = 212,
	PbTimeZone_kualaLumpur<s(0)(0)(0)>[&] = 215,
	PbTimeZone_perth<s(0)(0)(0)>[&] = 220,
	PbTimeZone_taipei<s(0)(0)(0)>[&] = 225,
	PbTimeZone_osaka<s(0)(0)(0)>[&] = 230,
	PbTimeZone_seoulr<s(0)(0)(0)>[&] = 235,
	PbTimeZone_yakutsk<s(0)(0)(0)>[&] = 240,
	PbTimeZone_adelaidei<s(0)(0)(0)>[&] = 245,
	PbTimeZone_darwin<s(0)(0)(0)>[&] = 250,
	PbTimeZone_brisbane<s(0)(0)(0)>[&] = 255,
	PbTimeZone_canberra<s(0)(0)(0)>[&] = 260,
	PbTimeZone_guam<s(0)(0)(0)>[&] = 265,
	PbTimeZone_hobart<s(0)(0)(0)>[&] = 270,
	PbTimeZone_vladivostok<s(0)(0)(0)>[&] = 275,
	PbTimeZone_magadan<s(0)(0)(0)>[&] = 280,
	PbTimeZone_auckland<s(0)(0)(0)>[&] = 285,
	PbTimeZone_fujiIslands<s(0)(0)(0)>[&] = 290,
	PbTimeZone_nuku<s(0)(0)(0)>[&] = 300
} PbTimeZone_Tval<s(0)(0)(0)>[&];(D1:PbTimeZone_Tval:1)[[TYPENAME:PbTimeZone_Tval]]

typedef enum {
	PbSecondaryStatus_none<s(0)(0)(0)>[&] = 1,
	PbSecondaryStatus_bsl_down<s(0)(0)(0)>[&] = 2,
	PbSecondaryStatus_bsl_adminDown<s(0)(0)(0)>[&] = 3,
	PbSecondaryStatus_bsl_HW_adminDown<s(0)(0)(0)>[&] = 4,
	PbSecondaryStatus_bsl_HW_adminTest<s(0)(0)(0)>[&] = 5,
	PbSecondaryStatus_bsl_HW_down<s(0)(0)(0)>[&] = 6,
	PbSecondaryStatus_bsl_notPresent<s(0)(0)(0)>[&] = 7,
	PbSecondaryStatus_sl_adminDown<s(0)(0)(0)>[&] = 8,
	PbSecondaryStatus_sl_adminTest<s(0)(0)(0)>[&] = 9,
	PbSecondaryStatus_hw_adminDown<s(0)(0)(0)>[&] = 10,
	PbSecondaryStatus_hw_adminTest<s(0)(0)(0)>[&] = 11,
	PbSecondaryStatus_hw_down<s(0)(0)(0)>[&] = 12,
	PbSecondaryStatus_nc_HW_removed<s(0)(0)(0)>[&] = 13,
	PbSecondaryStatus_nc_HW_adminDown<s(0)(0)(0)>[&] = 14,
	PbSecondaryStatus_nc_HW_adminTest<s(0)(0)(0)>[&] = 15,
	PbSecondaryStatus_nc_HW_down<s(0)(0)(0)>[&] = 16,
	PbSecondaryStatus_nc_SL_adminDown<s(0)(0)(0)>[&] = 17,
	PbSecondaryStatus_nc_SL_adminTest<s(0)(0)(0)>[&] = 18,
	PbSecondaryStatus_nc_SL_down<s(0)(0)(0)>[&] = 19,
	PbSecondaryStatus_nc_funcAdminDown<s(0)(0)(0)>[&] = 20,
	PbSecondaryStatus_hw_inactive<s(0)(0)(0)>[&] = 21
} PbSecondaryStatus_Tval<s(0)(0)(0)>[&];(D1:PbSecondaryStatus_Tval:1)[[TYPENAME:PbSecondaryStatus_Tval]]

typedef enum {
	PbLatchState_on<s(0)(0)(0)>[&] = 1,
	PbLatchState_off<s(0)(0)(0)>[&] = 2
} PbLatchState_Tval<s(0)(0)(0)>[&];(D1:PbLatchState_Tval:1)[[TYPENAME:PbLatchState_Tval]]

typedef enum {
	PbTMSOutState_normal<s(0)(0)(0)>[&] = 0,
	PbTMSOutState_ais<s(0)(0)(0)>[&] = 1,
	PbTMSOutState_dnu<s(0)(0)(0)>[&] = 2,
	PbTMSOutState_shutdown<s(0)(0)(0)>[&] = 3,
	PbTMSOutState_na<s(0)(0)(0)>[&] = 4
} PbTMSOutState_Tval<s(0)(0)(0)>[&];(D1:PbTMSOutState_Tval:1)[[TYPENAME:PbTMSOutState_Tval]]

typedef enum {
	RprProtectionStatus_noRequest<s(0)(0)(0)>[&] = 1,
	RprProtectionStatus_waitToRestore<s(0)(0)(0)>[&] = 2,
	RprProtectionStatus_manualSwitch<s(0)(0)(0)>[&] = 4,
	RprProtectionStatus_signalDegraded<s(0)(0)(0)>[&] = 8,
	RprProtectionStatus_signalFailed<s(0)(0)(0)>[&] = 16,
	RprProtectionStatus_forcedSwitch<s(0)(0)(0)>[&] = 32
} RprProtectionStatus_Tval<s(0)(0)(0)>[&];(D1:RprProtectionStatus_Tval:1)[[TYPENAME:RprProtectionStatus_Tval]]

typedef enum {
	PbSlotNumberType_none<s(0)(0)(0)>[&] = 0,
	PbSlotNumberType_lc1<s(0)(0)(0)>[&] = 1,
	PbSlotNumberType_lc2<s(0)(0)(0)>[&] = 2,
	PbSlotNumberType_lc3<s(0)(0)(0)>[&] = 3,
	PbSlotNumberType_lc4<s(0)(0)(0)>[&] = 4,
	PbSlotNumberType_lc5<s(0)(0)(0)>[&] = 5,
	PbSlotNumberType_lc6<s(0)(0)(0)>[&] = 6,
	PbSlotNumberType_hocc1<s(0)(0)(0)>[&] = 7,
	PbSlotNumberType_hocc2<s(0)(0)(0)>[&] = 8,
	PbSlotNumberType_sfc1<s(0)(0)(0)>[&] = 9,
	PbSlotNumberType_sfc2<s(0)(0)(0)>[&] = 10,
	PbSlotNumberType_ce1<s(0)(0)(0)>[&] = 11,
	PbSlotNumberType_ce2<s(0)(0)(0)>[&] = 12,
	PbSlotNumberType_ce3<s(0)(0)(0)>[&] = 13,
	PbSlotNumberType_ce4<s(0)(0)(0)>[&] = 14,
	PbSlotNumberType_ce5<s(0)(0)(0)>[&] = 15,
	PbSlotNumberType_ce6<s(0)(0)(0)>[&] = 16,
	PbSlotNumberType_sc1<s(0)(0)(0)>[&] = 17,
	PbSlotNumberType_sc2<s(0)(0)(0)>[&] = 18,
	PbSlotNumberType_si<s(0)(0)(0)>[&] = 19,
	PbSlotNumberType_sfm1<s(0)(0)(0)>[&] = 20,
	PbSlotNumberType_sfm2<s(0)(0)(0)>[&] = 21,
	PbSlotNumberType_io1<s(0)(0)(0)>[&] = 22,
	PbSlotNumberType_io2<s(0)(0)(0)>[&] = 23,
	PbSlotNumberType_io3<s(0)(0)(0)>[&] = 24,
	PbSlotNumberType_io4<s(0)(0)(0)>[&] = 25,
	PbSlotNumberType_io5<s(0)(0)(0)>[&] = 26,
	PbSlotNumberType_io6<s(0)(0)(0)>[&] = 27,
	PbSlotNumberType_io7<s(0)(0)(0)>[&] = 28,
	PbSlotNumberType_io8<s(0)(0)(0)>[&] = 29,
	PbSlotNumberType_io9<s(0)(0)(0)>[&] = 30,
	PbSlotNumberType_io10<s(0)(0)(0)>[&] = 31,
	PbSlotNumberType_io11<s(0)(0)(0)>[&] = 32,
	PbSlotNumberType_io12<s(0)(0)(0)>[&] = 33,
	PbSlotNumberType_io13<s(0)(0)(0)>[&] = 34,
	PbSlotNumberType_io14<s(0)(0)(0)>[&] = 35,
	PbSlotNumberType_io15<s(0)(0)(0)>[&] = 36,
	PbSlotNumberType_power1<s(0)(0)(0)>[&] = 37,
	PbSlotNumberType_power2<s(0)(0)(0)>[&] = 38,
	PbSlotNumberType_fan1<s(0)(0)(0)>[&] = 39,
	PbSlotNumberType_fan2<s(0)(0)(0)>[&] = 40
} PbSlotNumberType_Tval<s(0)(0)(0)>[&];(D1:PbSlotNumberType_Tval:1)[[TYPENAME:PbSlotNumberType_Tval]]

typedef enum {
	PbMsspNodeSide_west<s(0)(0)(0)>[&] = 0,
	PbMsspNodeSide_east<s(0)(0)(0)>[&] = 1
} PbMsspNodeSide_Tval<s(0)(0)(0)>[&];(D1:PbMsspNodeSide_Tval:1)[[TYPENAME:PbMsspNodeSide_Tval]]

typedef enum {
	PbSNCPChannelState_active<s(0)(0)(0)>[&] = 1,
	PbSNCPChannelState_standby<s(0)(0)(0)>[&] = 2
} PbSNCPChannelState_Tval<s(0)(0)(0)>[&];(D1:PbSNCPChannelState_Tval:1)[[TYPENAME:PbSNCPChannelState_Tval]]

typedef enum {
	SdhFtpCmndLastState_notApplicable<s(0)(0)(0)>[&] = 1,
	SdhFtpCmndLastState_success<s(0)(0)(0)>[&] = 2,
	SdhFtpCmndLastState_failed<s(0)(0)(0)>[&] = 3,
	SdhFtpCmndLastState_inProgress<s(0)(0)(0)>[&] = 4
} SdhFtpCmndLastState_Tval<s(0)(0)(0)>[&];(D1:SdhFtpCmndLastState_Tval:1)[[TYPENAME:SdhFtpCmndLastState_Tval]]

typedef enum {
	PbLinkGeneralType_networkLink<s(0)(0)(0)>[&] = 1,
	PbLinkGeneralType_offNetworkLink<s(0)(0)(0)>[&] = 2
} PbLinkGeneralType_Tval<s(0)(0)(0)>[&];(D1:PbLinkGeneralType_Tval:1)[[TYPENAME:PbLinkGeneralType_Tval]]

typedef enum {
	PbBoardFunction_none<s(0)(0)(0)>[&] = 0,
	PbBoardFunction_empty<s(0)(0)(0)>[&] = 1,
	PbBoardFunction_main<s(0)(0)(0)>[&] = 2305,
	PbBoardFunction_hocc<s(0)(0)(0)>[&] = 2306,
	PbBoardFunction_locc<s(0)(0)(0)>[&] = 2307,
	PbBoardFunction_e1x126<s(0)(0)(0)>[&] = 2308,
	PbBoardFunction_e1x63<s(0)(0)(0)>[&] = 2309,
	PbBoardFunction_stm_1ex8<s(0)(0)(0)>[&] = 2310,
	PbBoardFunction_e3ds3x12<s(0)(0)(0)>[&] = 2312,
	PbBoardFunction_stm_41x8<s(0)(0)(0)>[&] = 2320,
	PbBoardFunction_stm_1x8<s(0)(0)(0)>[&] = 2321,
	PbBoardFunction_stm_16x4<s(0)(0)(0)>[&] = 2322,
	PbBoardFunction_stm_16x8<s(0)(0)(0)>[&] = 2323,
	PbBoardFunction_e3ds3px12<s(0)(0)(0)>[&] = 2324,
	PbBoardFunction_stm_64x2<s(0)(0)(0)>[&] = 2325,
	PbBoardFunction_stm_64x1<s(0)(0)(0)>[&] = 2326,
	PbBoardFunction_oaBooster13dbm<s(0)(0)(0)>[&] = 2336,
	PbBoardFunction_oaBooster15dbm<s(0)(0)(0)>[&] = 2337,
	PbBoardFunction_oaBooster18dbm<s(0)(0)(0)>[&] = 2338,
	PbBoardFunction_oaPreamp20db<s(0)(0)(0)>[&] = 2340,
	PbBoardFunction_tengetx1<s(0)(0)(0)>[&] = 2342,
	PbBoardFunction_tengetx1_geax46<s(0)(0)(0)>[&] = 2343,
	PbBoardFunction_getx8<s(0)(0)(0)>[&] = 2344,
	PbBoardFunction_gex6_fegeax4<s(0)(0)(0)>[&] = 2345,
	PbBoardFunction_gex2_ferprx12<s(0)(0)(0)>[&] = 2352,
	PbBoardFunction_gex4_feax12<s(0)(0)(0)>[&] = 2353,
	PbBoardFunction_fetx12<s(0)(0)(0)>[&] = 2354,
	PbBoardFunction_fc2gx8<s(0)(0)(0)>[&] = 2355,
	PbBoardFunction_stm_256x1<s(0)(0)(0)>[&] = 2357,
	PbBoardFunction_fan<s(0)(0)(0)>[&] = 2358,
	PbBoardFunction_si_without_eow<s(0)(0)(0)>[&] = 2368,
	PbBoardFunction_stm_16x2<s(0)(0)(0)>[&] = 2369,
	PbBoardFunction_otu_2x1<s(0)(0)(0)>[&] = 2400,
	PbBoardFunction_tengex1_gex10l2<s(0)(0)(0)>[&] = 2440,
	PbBoardFunction_stm_16x8m<s(0)(0)(0)>[&] = 2441,
	PbBoardFunction_stm_41x16m<s(0)(0)(0)>[&] = 2448,
	PbBoardFunction_stm_64x2m<s(0)(0)(0)>[&] = 2449,
	PbBoardFunction_otu_2x2<s(0)(0)(0)>[&] = 2450,
	PbBoardFunction_chassis<s(0)(0)(0)>[&] = 4232,
	PbBoardFunction_cc<s(0)(0)(0)>[&] = 4240,
	PbBoardFunction_dataFabric_controller<s(0)(0)(0)>[&] = 4241,
	PbBoardFunction_dataFabric<s(0)(0)(0)>[&] = 4242,
	PbBoardFunction_si<s(0)(0)(0)>[&] = 4243,
	PbBoardFunction_power<s(0)(0)(0)>[&] = 4244,
	PbBoardFunction_chassis_fan_airFilter<s(0)(0)(0)>[&] = 4245,
	PbBoardFunction_fanTray<s(0)(0)(0)>[&] = 4246,
	PbBoardFunction_fanCircuitBoard<s(0)(0)(0)>[&] = 4247,
	PbBoardFunction_backplane<s(0)(0)(0)>[&] = 4248,
	PbBoardFunction_e1x21p_75<s(0)(0)(0)>[&] = 4352,
	PbBoardFunction_e1x21p_120<s(0)(0)(0)>[&] = 4353,
	PbBoardFunction_stm_1ex16<s(0)(0)(0)>[&] = 4354,
	PbBoardFunction_stm_1ex8p<s(0)(0)(0)>[&] = 4356,
	PbBoardFunction_e3ds3x6p<s(0)(0)(0)>[&] = 4358,
	PbBoardFunction_gex20<s(0)(0)(0)>[&] = 4359,
	PbBoardFunction_tengex2<s(0)(0)(0)>[&] = 4360,
	PbBoardFunction_gex10_eos<s(0)(0)(0)>[&] = 4361,
	PbBoardFunction_tengex2_eos<s(0)(0)(0)>[&] = 4368,
	PbBoardFunction_gmpls_load<s(0)(0)(0)>[&] = 983040
} PbBoardFunction_Tval<s(0)(0)(0)>[&];(D1:PbBoardFunction_Tval:1)[[TYPENAME:PbBoardFunction_Tval]]

typedef enum {
	PbYesNo_yes<s(0)(0)(0)>[&] = 1,
	PbYesNo_no<s(0)(0)(0)>[&] = 2
} PbYesNo_Tval<s(0)(0)(0)>[&];(D1:PbYesNo_Tval:1)[[TYPENAME:PbYesNo_Tval]]

typedef enum {
	PBMSPSignalState_signalunknown<s(0)(0)(0)>[&] = 0,
	PBMSPSignalState_signalfailhigh<s(0)(0)(0)>[&] = 1,
	PBMSPSignalState_signalfaillow<s(0)(0)(0)>[&] = 2,
	PBMSPSignalState_signaldeglhigh<s(0)(0)(0)>[&] = 3,
	PBMSPSignalState_signaldeglow<s(0)(0)(0)>[&] = 4,
	PBMSPSignalState_signalnormal<s(0)(0)(0)>[&] = 5
} PBMSPSignalState_Tval<s(0)(0)(0)>[&];(D1:PBMSPSignalState_Tval:1)[[TYPENAME:PBMSPSignalState_Tval]]

typedef enum {
	PbMSPSignalDirection_unidirection<s(0)(0)(0)>[&] = 1,
	PbMSPSignalDirection_bidirection<s(0)(0)(0)>[&] = 2
} PbMSPSignalDirection_Tval<s(0)(0)(0)>[&];(D1:PbMSPSignalDirection_Tval:1)[[TYPENAME:PbMSPSignalDirection_Tval]]

typedef enum {
	PbEpgCmdResult_ok<s(0)(0)(0)>[&] = 0,
	PbEpgCmdResult_failed<s(0)(0)(0)>[&] = 1
} PbEpgCmdResult_Tval<s(0)(0)(0)>[&];(D1:PbEpgCmdResult_Tval:1)[[TYPENAME:PbEpgCmdResult_Tval]]

typedef enum {
	TMSIfSdhQlType_sdh<s(0)(0)(0)>[&] = 1,
	TMSIfSdhQlType_sonet<s(0)(0)(0)>[&] = 2
} TMSIfSdhQlType_Tval<s(0)(0)(0)>[&];(D1:TMSIfSdhQlType_Tval:1)[[TYPENAME:TMSIfSdhQlType_Tval]]

typedef enum {
	PbChassisType_mw863<s(0)(0)(0)>[&] = 1,
	PbChassisType_mw808<s(0)(0)(0)>[&] = 2,
	PbChassisType_mw8100<s(0)(0)(0)>[&] = 3,
	PbChassisType_mw801<s(0)(0)(0)>[&] = 4,
	PbChassisType_hiT7035<s(0)(0)(0)>[&] = 5,
	PbChassisType_hiT7080<s(0)(0)(0)>[&] = 7,
	PbChassisType_hiT7065<s(0)(0)(0)>[&] = 8,
	PbChassisType_all<s(0)(0)(0)>[&] = 255
} PbChassisType_Tval<s(0)(0)(0)>[&];(D1:PbChassisType_Tval:1)[[TYPENAME:PbChassisType_Tval]]

typedef enum {
	PbMsspSwStatus_idle<s(0)(0)(0)>[&] = 0,
	PbMsspSwStatus_bridge<s(0)(0)(0)>[&] = 1,
	PbMsspSwStatus_bridgeAndSwitch<s(0)(0)(0)>[&] = 2,
	PbMsspSwStatus_passthough<s(0)(0)(0)>[&] = 3
} PbMsspSwStatus_Tval<s(0)(0)(0)>[&];(D1:PbMsspSwStatus_Tval:1)[[TYPENAME:PbMsspSwStatus_Tval]]

typedef enum {
	PbTMSQl_inv0<s(0)(0)(0)>[&] = 0,
	PbTMSQl_inv1<s(0)(0)(0)>[&] = 1,
	PbTMSQl_prc<s(0)(0)(0)>[&] = 2,
	PbTMSQl_inv3<s(0)(0)(0)>[&] = 3,
	PbTMSQl_ssut<s(0)(0)(0)>[&] = 4,
	PbTMSQl_inv5<s(0)(0)(0)>[&] = 5,
	PbTMSQl_inv6<s(0)(0)(0)>[&] = 6,
	PbTMSQl_inv7<s(0)(0)(0)>[&] = 7,
	PbTMSQl_ssul<s(0)(0)(0)>[&] = 8,
	PbTMSQl_inv9<s(0)(0)(0)>[&] = 9,
	PbTMSQl_inv10<s(0)(0)(0)>[&] = 10,
	PbTMSQl_sec<s(0)(0)(0)>[&] = 11,
	PbTMSQl_inv12<s(0)(0)(0)>[&] = 12,
	PbTMSQl_inv13<s(0)(0)(0)>[&] = 13,
	PbTMSQl_inv14<s(0)(0)(0)>[&] = 14,
	PbTMSQl_dnu<s(0)(0)(0)>[&] = 15,
	PbTMSQl_failed<s(0)(0)(0)>[&] = 16,
	PbTMSQl_nsupp<s(0)(0)(0)>[&] = 17,
	PbTMSQl_unc<s(0)(0)(0)>[&] = 18
} PbTMSQl_Tval<s(0)(0)(0)>[&];(D1:PbTMSQl_Tval:1)[[TYPENAME:PbTMSQl_Tval]]

typedef enum {
	TypeMibUpgFailedIndex_noError<s(0)(0)(0)>[&] = 0,
	TypeMibUpgFailedIndex_unKnown<s(0)(0)(0)>[&] = 1,
	TypeMibUpgFailedIndex_writeFlashFailed<s(0)(0)(0)>[&] = 2,
	TypeMibUpgFailedIndex_readFlashFailed<s(0)(0)(0)>[&] = 3,
	TypeMibUpgFailedIndex_flashFull<s(0)(0)(0)>[&] = 4,
	TypeMibUpgFailedIndex_flashError<s(0)(0)(0)>[&] = 5,
	TypeMibUpgFailedIndex_writeCfFailed<s(0)(0)(0)>[&] = 6,
	TypeMibUpgFailedIndex_readCfFailed<s(0)(0)(0)>[&] = 7,
	TypeMibUpgFailedIndex_cfFull<s(0)(0)(0)>[&] = 8,
	TypeMibUpgFailedIndex_cfError<s(0)(0)(0)>[&] = 9,
	TypeMibUpgFailedIndex_copyAscFlashFailed<s(0)(0)(0)>[&] = 10,
	TypeMibUpgFailedIndex_copyAscCfFailed<s(0)(0)(0)>[&] = 11,
	TypeMibUpgFailedIndex_copySscFlashFailed<s(0)(0)(0)>[&] = 12,
	TypeMibUpgFailedIndex_copySscCfFailed<s(0)(0)(0)>[&] = 13,
	TypeMibUpgFailedIndex_spawnTaskFailed<s(0)(0)(0)>[&] = 14,
	TypeMibUpgFailedIndex_paraInvalid<s(0)(0)(0)>[&] = 15,
	TypeMibUpgFailedIndex_writeRamdscFailed<s(0)(0)(0)>[&] = 16,
	TypeMibUpgFailedIndex_readRamdscFailed<s(0)(0)(0)>[&] = 17,
	TypeMibUpgFailedIndex_setMibFailed<s(0)(0)(0)>[&] = 18,
	TypeMibUpgFailedIndex_getMibFailed<s(0)(0)(0)>[&] = 19,
	TypeMibUpgFailedIndex_openDirFailed<s(0)(0)(0)>[&] = 20,
	TypeMibUpgFailedIndex_createDirFailed<s(0)(0)(0)>[&] = 21,
	TypeMibUpgFailedIndex_peerScOnline<s(0)(0)(0)>[&] = 22,
	TypeMibUpgFailedIndex_peerScOffline<s(0)(0)(0)>[&] = 23,
	TypeMibUpgFailedIndex_synRamdscFailed<s(0)(0)(0)>[&] = 24,
	TypeMibUpgFailedIndex_synFlashFailed<s(0)(0)(0)>[&] = 25,
	TypeMibUpgFailedIndex_synCfFailed<s(0)(0)(0)>[&] = 26,
	TypeMibUpgFailedIndex_msgCreateFailed<s(0)(0)(0)>[&] = 27,
	TypeMibUpgFailedIndex_msgSendFailed<s(0)(0)(0)>[&] = 28,
	TypeMibUpgFailedIndex_cmndStatusInvalid<s(0)(0)(0)>[&] = 29,
	TypeMibUpgFailedIndex_sscCopyTimeout<s(0)(0)(0)>[&] = 30,
	TypeMibUpgFailedIndex_createSemFailed<s(0)(0)(0)>[&] = 31,
	TypeMibUpgFailedIndex_mibHeadFileInvalid<s(0)(0)(0)>[&] = 32,
	TypeMibUpgFailedIndex_mibNeFileCheckSumInvalid<s(0)(0)(0)>[&] = 33,
	TypeMibUpgFailedIndex_mibGmFileCheckSumInvalid<s(0)(0)(0)>[&] = 34,
	TypeMibUpgFailedIndex_lcsFileInvalid<s(0)(0)(0)>[&] = 35,
	TypeMibUpgFailedIndex_dirCopyFailed<s(0)(0)(0)>[&] = 36,
	TypeMibUpgFailedIndex_dirDelFailed<s(0)(0)(0)>[&] = 37,
	TypeMibUpgFailedIndex_zipFileNotExist<s(0)(0)(0)>[&] = 38,
	TypeMibUpgFailedIndex_tarFileFailed<s(0)(0)(0)>[&] = 39,
	TypeMibUpgFailedIndex_zipFileFailed<s(0)(0)(0)>[&] = 40,
	TypeMibUpgFailedIndex_unzipFileFailed<s(0)(0)(0)>[&] = 41,
	TypeMibUpgFailedIndex_gsemTakeFailed<s(0)(0)(0)>[&] = 42,
	TypeMibUpgFailedIndex_gSaveFlagSetFailed<s(0)(0)(0)>[&] = 43,
	TypeMibUpgFailedIndex_dirRnameLoadTmpFailed<s(0)(0)(0)>[&] = 44,
	TypeMibUpgFailedIndex_dirRnameTmpLoadFailed<s(0)(0)(0)>[&] = 45,
	TypeMibUpgFailedIndex_dirRnameTmpBkupFailed<s(0)(0)(0)>[&] = 46,
	TypeMibUpgFailedIndex_dirRnameBkupActFailed<s(0)(0)(0)>[&] = 47,
	TypeMibUpgFailedIndex_mibIncSaveFailed<s(0)(0)(0)>[&] = 48,
	TypeMibUpgFailedIndex_mibAllSaveFailed<s(0)(0)(0)>[&] = 49,
	TypeMibUpgFailedIndex_mibSaveSwitchSetFailed<s(0)(0)(0)>[&] = 50,
	TypeMibUpgFailedIndex_scSwitch<s(0)(0)(0)>[&] = 51,
	TypeMibUpgFailedIndex_upgCommandRunning<s(0)(0)(0)>[&] = 52,
	TypeMibUpgFailedIndex_cfaSoftCopying<s(0)(0)(0)>[&] = 53,
	TypeMibUpgFailedIndex_psmMibCheckingFuncInvalid<s(0)(0)(0)>[&] = 54,
	TypeMibUpgFailedIndex_lcmMibCheckingFuncInvalid<s(0)(0)(0)>[&] = 55,
	TypeMibUpgFailedIndex_globleHeadFileInvalid<s(0)(0)(0)>[&] = 56,
	TypeMibUpgFailedIndex_neHeadfileFlagSetFailed<s(0)(0)(0)>[&] = 57,
	TypeMibUpgFailedIndex_psmHeadfileFlagSetFailed<s(0)(0)(0)>[&] = 58,
	TypeMibUpgFailedIndex_uploadPrepareTimeout<s(0)(0)(0)>[&] = 71,
	TypeMibUpgFailedIndex_uploadPrepareFailed<s(0)(0)(0)>[&] = 72,
	TypeMibUpgFailedIndex_uploadMidTimeout<s(0)(0)(0)>[&] = 73,
	TypeMibUpgFailedIndex_uploadMidFailed<s(0)(0)(0)>[&] = 74,
	TypeMibUpgFailedIndex_uploadCanceled<s(0)(0)(0)>[&] = 75,
	TypeMibUpgFailedIndex_downloadPrepareTimeout<s(0)(0)(0)>[&] = 81,
	TypeMibUpgFailedIndex_downloadPrepareFailed<s(0)(0)(0)>[&] = 82,
	TypeMibUpgFailedIndex_downloadMidTimeout<s(0)(0)(0)>[&] = 83,
	TypeMibUpgFailedIndex_downloadMidFailed<s(0)(0)(0)>[&] = 84,
	TypeMibUpgFailedIndex_downloadCanceled<s(0)(0)(0)>[&] = 85,
	TypeMibUpgFailedIndex_switchAscTimeout<s(0)(0)(0)>[&] = 91,
	TypeMibUpgFailedIndex_switchAscFailed<s(0)(0)(0)>[&] = 92,
	TypeMibUpgFailedIndex_switchAscCfFailed<s(0)(0)(0)>[&] = 93,
	TypeMibUpgFailedIndex_synTimeout<s(0)(0)(0)>[&] = 101,
	TypeMibUpgFailedIndex_synCanceled<s(0)(0)(0)>[&] = 102,
	TypeMibUpgFailedIndex_synFailed<s(0)(0)(0)>[&] = 103,
	TypeMibUpgFailedIndex_clearTimeout<s(0)(0)(0)>[&] = 111,
	TypeMibUpgFailedIndex_clearFailed<s(0)(0)(0)>[&] = 112,
	TypeMibUpgFailedIndex_ascMibClearSetFailed<s(0)(0)(0)>[&] = 113,
	TypeMibUpgFailedIndex_sscMibClearSetFailed<s(0)(0)(0)>[&] = 114,
	TypeMibUpgFailedIndex_mibCopyTimeout<s(0)(0)(0)>[&] = 121,
	TypeMibUpgFailedIndex_mibCopyFailed<s(0)(0)(0)>[&] = 122,
	TypeMibUpgFailedIndex_gmplsCopyFailed<s(0)(0)(0)>[&] = 123,
	TypeMibUpgFailedIndex_lcsynTimeout<s(0)(0)(0)>[&] = 131,
	TypeMibUpgFailedIndex_lcsSynFailed<s(0)(0)(0)>[&] = 132,
	TypeMibUpgFailedIndex_lcsDownTimeout<s(0)(0)(0)>[&] = 141,
	TypeMibUpgFailedIndex_lcsDownFailed<s(0)(0)(0)>[&] = 142
} TypeMibUpgFailedIndex_Tval<s(0)(0)(0)>[&];(D1:TypeMibUpgFailedIndex_Tval:1)[[TYPENAME:TypeMibUpgFailedIndex_Tval]]

typedef enum {
	PBSNCPAction_normal<s(0)(0)(0)>[&] = 0,
	PBSNCPAction_recfgw<s(0)(0)(0)>[&] = 1,
	PBSNCPAction_recfgp<s(0)(0)(0)>[&] = 2,
	PBSNCPAction_setmib<s(0)(0)(0)>[&] = 3
} PBSNCPAction_Tval<s(0)(0)(0)>[&];(D1:PBSNCPAction_Tval:1)[[TYPENAME:PBSNCPAction_Tval]]

typedef enum {
	PBMSPType_msponevsn<s(0)(0)(0)>[&] = 1,
	PBMSPType_msponeplusone<s(0)(0)(0)>[&] = 2
} PBMSPType_Tval<s(0)(0)(0)>[&];(D1:PBMSPType_Tval:1)[[TYPENAME:PBMSPType_Tval]]

typedef enum {
	PbAlmClassType_ne<s(0)(0)(0)>[&] = 1,
	PbAlmClassType_slot<s(0)(0)(0)>[&] = 2,
	PbAlmClassType_port<s(0)(0)(0)>[&] = 3,
	PbAlmClassType_tp<s(0)(0)(0)>[&] = 4
} PbAlmClassType_Tval<s(0)(0)(0)>[&];(D1:PbAlmClassType_Tval:1)[[TYPENAME:PbAlmClassType_Tval]]

typedef enum {
	RprSvcStatus_ok<s(0)(0)(0)>[&] = 0,
	RprSvcStatus_failed<s(0)(0)(0)>[&] = 1,
	RprSvcStatus_removed<s(0)(0)(0)>[&] = 2
} RprSvcStatus_Tval<s(0)(0)(0)>[&];(D1:RprSvcStatus_Tval:1)[[TYPENAME:RprSvcStatus_Tval]]

typedef enum {
	PbLowHigh_low<s(0)(0)(0)>[&] = 1,
	PbLowHigh_high<s(0)(0)(0)>[&] = 2
} PbLowHigh_Tval<s(0)(0)(0)>[&];(D1:PbLowHigh_Tval:1)[[TYPENAME:PbLowHigh_Tval]]

typedef enum {
	PBSNCPSignalState_normal<s(0)(0)(0)>[&] = 1,
	PBSNCPSignalState_failed<s(0)(0)(0)>[&] = 2,
	PBSNCPSignalState_degard<s(0)(0)(0)>[&] = 3
} PBSNCPSignalState_Tval<s(0)(0)(0)>[&];(D1:PBSNCPSignalState_Tval:1)[[TYPENAME:PBSNCPSignalState_Tval]]

typedef enum {
	PbSNCPSignalDirection_source<s(0)(0)(0)>[&] = 1,
	PbSNCPSignalDirection_sink<s(0)(0)(0)>[&] = 2
} PbSNCPSignalDirection_Tval<s(0)(0)(0)>[&];(D1:PbSNCPSignalDirection_Tval:1)[[TYPENAME:PbSNCPSignalDirection_Tval]]

typedef enum {
	PbCircuitDirection_bidirection<s(0)(0)(0)>[&] = 1,
	PbCircuitDirection_unidirection<s(0)(0)(0)>[&] = 2,
	PbCircuitDirection_multicast<s(0)(0)(0)>[&] = 3
} PbCircuitDirection_Tval<s(0)(0)(0)>[&];(D1:PbCircuitDirection_Tval:1)[[TYPENAME:PbCircuitDirection_Tval]]

typedef enum {
	RprRingType_closedRing<s(0)(0)(0)>[&] = 1,
	RprRingType_openRing<s(0)(0)(0)>[&] = 2
} RprRingType_Tval<s(0)(0)(0)>[&];(D1:RprRingType_Tval:1)[[TYPENAME:RprRingType_Tval]]

typedef enum {
	RprOamRinglet_default<s(0)(0)(0)>[&] = 1,
	RprOamRinglet_ringlet0<s(0)(0)(0)>[&] = 2,
	RprOamRinglet_ringlet1<s(0)(0)(0)>[&] = 3,
	RprOamRinglet_reverseRinglet<s(0)(0)(0)>[&] = 4
} RprOamRinglet_Tval<s(0)(0)(0)>[&];(D1:RprOamRinglet_Tval:1)[[TYPENAME:RprOamRinglet_Tval]]

typedef enum {
	PbColdRebootNodeState_false<s(0)(0)(0)>[&] = 0,
	PbColdRebootNodeState_truewithfpga<s(0)(0)(0)>[&] = 1,
	PbColdRebootNodeState_truewithoutfpga<s(0)(0)(0)>[&] = 2
} PbColdRebootNodeState_Tval<s(0)(0)(0)>[&];(D1:PbColdRebootNodeState_Tval:1)[[TYPENAME:PbColdRebootNodeState_Tval]]

typedef enum {
	RprServiceType_p2p<s(0)(0)(0)>[&] = 1,
	RprServiceType_mp2mp<s(0)(0)(0)>[&] = 2,
	RprServiceType_local<s(0)(0)(0)>[&] = 3
} RprServiceType_Tval<s(0)(0)(0)>[&];(D1:RprServiceType_Tval:1)[[TYPENAME:RprServiceType_Tval]]

typedef enum {
	TypeSoftUpgFailedIndex_noError<s(0)(0)(0)>[&] = 0,
	TypeSoftUpgFailedIndex_unKnown<s(0)(0)(0)>[&] = 1,
	TypeSoftUpgFailedIndex_commandTimeout<s(0)(0)(0)>[&] = 2,
	TypeSoftUpgFailedIndex_wrongNodeType<s(0)(0)(0)>[&] = 3,
	TypeSoftUpgFailedIndex_redunLoadError<s(0)(0)(0)>[&] = 4,
	TypeSoftUpgFailedIndex_writeFlashFailed<s(0)(0)(0)>[&] = 5,
	TypeSoftUpgFailedIndex_readFlashFailed<s(0)(0)(0)>[&] = 6,
	TypeSoftUpgFailedIndex_flashFull<s(0)(0)(0)>[&] = 7,
	TypeSoftUpgFailedIndex_flashError<s(0)(0)(0)>[&] = 8,
	TypeSoftUpgFailedIndex_writeCfFailed<s(0)(0)(0)>[&] = 9,
	TypeSoftUpgFailedIndex_readCfFailed<s(0)(0)(0)>[&] = 10,
	TypeSoftUpgFailedIndex_cfFull<s(0)(0)(0)>[&] = 11,
	TypeSoftUpgFailedIndex_cfError<s(0)(0)(0)>[&] = 12,
	TypeSoftUpgFailedIndex_copyAscFlashFailed<s(0)(0)(0)>[&] = 13,
	TypeSoftUpgFailedIndex_copyAscCfFailed<s(0)(0)(0)>[&] = 14,
	TypeSoftUpgFailedIndex_copySscFlashFailed<s(0)(0)(0)>[&] = 15,
	TypeSoftUpgFailedIndex_copySscCfFailed<s(0)(0)(0)>[&] = 16,
	TypeSoftUpgFailedIndex_spawnTaskFailed<s(0)(0)(0)>[&] = 17,
	TypeSoftUpgFailedIndex_parameterInvalid<s(0)(0)(0)>[&] = 18,
	TypeSoftUpgFailedIndex_writeRamdscFailed<s(0)(0)(0)>[&] = 19,
	TypeSoftUpgFailedIndex_readRamdscFailed<s(0)(0)(0)>[&] = 20,
	TypeSoftUpgFailedIndex_setUpgMibFailed<s(0)(0)(0)>[&] = 21,
	TypeSoftUpgFailedIndex_getUpgMibFailed<s(0)(0)(0)>[&] = 22,
	TypeSoftUpgFailedIndex_openUpgDirFailed<s(0)(0)(0)>[&] = 23,
	TypeSoftUpgFailedIndex_createUpgDirFailed<s(0)(0)(0)>[&] = 24,
	TypeSoftUpgFailedIndex_peerScOnline<s(0)(0)(0)>[&] = 25,
	TypeSoftUpgFailedIndex_peerScOffline<s(0)(0)(0)>[&] = 26,
	TypeSoftUpgFailedIndex_synRamdscFailed<s(0)(0)(0)>[&] = 27,
	TypeSoftUpgFailedIndex_synFlashFailed<s(0)(0)(0)>[&] = 28,
	TypeSoftUpgFailedIndex_synCfFailed<s(0)(0)(0)>[&] = 29,
	TypeSoftUpgFailedIndex_msgCreateFailed<s(0)(0)(0)>[&] = 30,
	TypeSoftUpgFailedIndex_msgSendFailed<s(0)(0)(0)>[&] = 31,
	TypeSoftUpgFailedIndex_cmndStatusInvalid<s(0)(0)(0)>[&] = 32,
	TypeSoftUpgFailedIndex_sscCopyTimeout<s(0)(0)(0)>[&] = 33,
	TypeSoftUpgFailedIndex_softInvalid<s(0)(0)(0)>[&] = 34,
	TypeSoftUpgFailedIndex_downRamFailed<s(0)(0)(0)>[&] = 35,
	TypeSoftUpgFailedIndex_downCfFailed<s(0)(0)(0)>[&] = 36,
	TypeSoftUpgFailedIndex_dirRnameLoadTmpFailed<s(0)(0)(0)>[&] = 37,
	TypeSoftUpgFailedIndex_dirRnameTmpLoadFailed<s(0)(0)(0)>[&] = 38,
	TypeSoftUpgFailedIndex_dirRnameTmpBkupFailed<s(0)(0)(0)>[&] = 39,
	TypeSoftUpgFailedIndex_dirRnameBkupActFailed<s(0)(0)(0)>[&] = 40,
	TypeSoftUpgFailedIndex_cfUnSurported<s(0)(0)(0)>[&] = 41,
	TypeSoftUpgFailedIndex_ramUnSurported<s(0)(0)(0)>[&] = 42,
	TypeSoftUpgFailedIndex_delDirFailed<s(0)(0)(0)>[&] = 43,
	TypeSoftUpgFailedIndex_copyDirFailed<s(0)(0)(0)>[&] = 44,
	TypeSoftUpgFailedIndex_copyFileFailed<s(0)(0)(0)>[&] = 45,
	TypeSoftUpgFailedIndex_openFileFailed<s(0)(0)(0)>[&] = 46,
	TypeSoftUpgFailedIndex_scSwitch<s(0)(0)(0)>[&] = 47,
	TypeSoftUpgFailedIndex_srootFileInvalid<s(0)(0)(0)>[&] = 48,
	TypeSoftUpgFailedIndex_crootFileInvalid<s(0)(0)(0)>[&] = 49,
	TypeSoftUpgFailedIndex_lrootFileInvalid<s(0)(0)(0)>[&] = 50,
	TypeSoftUpgFailedIndex_addHostServerFailed<s(0)(0)(0)>[&] = 51,
	TypeSoftUpgFailedIndex_delHostServerFailed<s(0)(0)(0)>[&] = 52,
	TypeSoftUpgFailedIndex_dirNameParseFailed<s(0)(0)(0)>[&] = 53,
	TypeSoftUpgFailedIndex_softVersionInvalid<s(0)(0)(0)>[&] = 54,
	TypeSoftUpgFailedIndex_createConnectFailed<s(0)(0)(0)>[&] = 55,
	TypeSoftUpgFailedIndex_openDataPipeFailed<s(0)(0)(0)>[&] = 56,
	TypeSoftUpgFailedIndex_headFileStructureInvalid<s(0)(0)(0)>[&] = 57,
	TypeSoftUpgFailedIndex_fileTypeInvalid<s(0)(0)(0)>[&] = 58,
	TypeSoftUpgFailedIndex_getReleaseDataFailed<s(0)(0)(0)>[&] = 59,
	TypeSoftUpgFailedIndex_diskStatusInvalid<s(0)(0)(0)>[&] = 60,
	TypeSoftUpgFailedIndex_diskSpaceNotEnough<s(0)(0)(0)>[&] = 61,
	TypeSoftUpgFailedIndex_getFileSizeFailed<s(0)(0)(0)>[&] = 62,
	TypeSoftUpgFailedIndex_createFileFailed<s(0)(0)(0)>[&] = 63,
	TypeSoftUpgFailedIndex_writeFileFailed<s(0)(0)(0)>[&] = 64,
	TypeSoftUpgFailedIndex_fileWithoutCrc<s(0)(0)(0)>[&] = 65,
	TypeSoftUpgFailedIndex_getFileNameFailed<s(0)(0)(0)>[&] = 66,
	TypeSoftUpgFailedIndex_crcBufferInvalid<s(0)(0)(0)>[&] = 67,
	TypeSoftUpgFailedIndex_crcChecksumInvalid<s(0)(0)(0)>[&] = 68,
	TypeSoftUpgFailedIndex_extractFileFailed<s(0)(0)(0)>[&] = 69,
	TypeSoftUpgFailedIndex_getTransDataFailed<s(0)(0)(0)>[&] = 70,
	TypeSoftUpgFailedIndex_writeTransDataFailed<s(0)(0)(0)>[&] = 71,
	TypeSoftUpgFailedIndex_mfmCommandRunning<s(0)(0)(0)>[&] = 72,
	TypeSoftUpgFailedIndex_cfaSoftCopying<s(0)(0)(0)>[&] = 73,
	TypeSoftUpgFailedIndex_versionQueryFailed<s(0)(0)(0)>[&] = 74,
	TypeSoftUpgFailedIndex_fileNotExiste<s(0)(0)(0)>[&] = 75,
	TypeSoftUpgFailedIndex_ftpConnectionFailed<s(0)(0)(0)>[&] = 101,
	TypeSoftUpgFailedIndex_ftpConnectionTimeout<s(0)(0)(0)>[&] = 102,
	TypeSoftUpgFailedIndex_downloadTimeout<s(0)(0)(0)>[&] = 103,
	TypeSoftUpgFailedIndex_downloadCanceled<s(0)(0)(0)>[&] = 104,
	TypeSoftUpgFailedIndex_downloadFailed<s(0)(0)(0)>[&] = 105,
	TypeSoftUpgFailedIndex_backupTimeout<s(0)(0)(0)>[&] = 111,
	TypeSoftUpgFailedIndex_backupCanceled<s(0)(0)(0)>[&] = 112,
	TypeSoftUpgFailedIndex_backupFailed<s(0)(0)(0)>[&] = 113,
	TypeSoftUpgFailedIndex_synchronizeTimeout<s(0)(0)(0)>[&] = 121,
	TypeSoftUpgFailedIndex_synchronizeCanceled<s(0)(0)(0)>[&] = 122,
	TypeSoftUpgFailedIndex_synchronizeFailed<s(0)(0)(0)>[&] = 123,
	TypeSoftUpgFailedIndex_switchTimeout<s(0)(0)(0)>[&] = 131,
	TypeSoftUpgFailedIndex_switchFailed<s(0)(0)(0)>[&] = 132,
	TypeSoftUpgFailedIndex_switchCfFailed<s(0)(0)(0)>[&] = 133
} TypeSoftUpgFailedIndex_Tval<s(0)(0)(0)>[&];(D1:TypeSoftUpgFailedIndex_Tval:1)[[TYPENAME:TypeSoftUpgFailedIndex_Tval]]

typedef enum {
	PbEpgSwitchRequest_clear<s(0)(0)(0)>[&] = 1,
	PbEpgSwitchRequest_lp<s(0)(0)(0)>[&] = 2,
	PbEpgSwitchRequest_fs_w<s(0)(0)(0)>[&] = 3,
	PbEpgSwitchRequest_fs_p<s(0)(0)(0)>[&] = 4,
	PbEpgSwitchRequest_uf_p<s(0)(0)(0)>[&] = 5,
	PbEpgSwitchRequest_uf_w<s(0)(0)(0)>[&] = 6,
	PbEpgSwitchRequest_lis_w<s(0)(0)(0)>[&] = 7,
	PbEpgSwitchRequest_lis_p<s(0)(0)(0)>[&] = 8,
	PbEpgSwitchRequest_ms_w<s(0)(0)(0)>[&] = 9,
	PbEpgSwitchRequest_ms_p<s(0)(0)(0)>[&] = 10,
	PbEpgSwitchRequest_wtr<s(0)(0)(0)>[&] = 11,
	PbEpgSwitchRequest_nr<s(0)(0)(0)>[&] = 12
} PbEpgSwitchRequest_Tval<s(0)(0)(0)>[&];(D1:PbEpgSwitchRequest_Tval:1)[[TYPENAME:PbEpgSwitchRequest_Tval]]

typedef enum {
	PbTMSStClkType_twoMHz<s(0)(0)(0)>[&] = 1,
	PbTMSStClkType_twoMbUnFramed<s(0)(0)(0)>[&] = 2,
	PbTMSStClkType_twoMbFramed<s(0)(0)(0)>[&] = 3
} PbTMSStClkType_Tval<s(0)(0)(0)>[&];(D1:PbTMSStClkType_Tval:1)[[TYPENAME:PbTMSStClkType_Tval]]

typedef enum {
	PbInSignalType_normal<s(0)(0)(0)>[&] = 1,
	PbInSignalType_ais<s(0)(0)(0)>[&] = 3
} PbInSignalType_Tval<s(0)(0)(0)>[&];(D1:PbInSignalType_Tval:1)[[TYPENAME:PbInSignalType_Tval]]

typedef enum {
	PbGmplsSncpDirection_forward<s(0)(0)(0)>[&] = 1,
	PbGmplsSncpDirection_reverse<s(0)(0)(0)>[&] = 2
} PbGmplsSncpDirection_Tval<s(0)(0)(0)>[&];(D1:PbGmplsSncpDirection_Tval:1)[[TYPENAME:PbGmplsSncpDirection_Tval]]

typedef enum {
	RprServiceCos_classC<s(0)(0)(0)>[&] = 0,
	RprServiceCos_classBEir<s(0)(0)(0)>[&] = 1,
	RprServiceCos_classBCir<s(0)(0)(0)>[&] = 2,
	RprServiceCos_classA<s(0)(0)(0)>[&] = 3
} RprServiceCos_Tval<s(0)(0)(0)>[&];(D1:RprServiceCos_Tval:1)[[TYPENAME:RprServiceCos_Tval]]

typedef enum {
	AlarmCategory_communication<s(0)(0)(0)>[&] = 1,
	AlarmCategory_qos<s(0)(0)(0)>[&] = 2,
	AlarmCategory_equipment<s(0)(0)(0)>[&] = 3,
	AlarmCategory_processerror<s(0)(0)(0)>[&] = 4,
	AlarmCategory_environment<s(0)(0)(0)>[&] = 5,
	AlarmCategory_security<s(0)(0)(0)>[&] = 6
} AlarmCategory_Tval<s(0)(0)(0)>[&];(D1:AlarmCategory_Tval:1)[[TYPENAME:AlarmCategory_Tval]]

typedef enum {
	RprXcRowStatus_free<s(0)(0)(0)>[&] = 0,
	RprXcRowStatus_used<s(0)(0)(0)>[&] = 1
} RprXcRowStatus_Tval<s(0)(0)(0)>[&];(D1:RprXcRowStatus_Tval:1)[[TYPENAME:RprXcRowStatus_Tval]]

typedef enum {
	PbUsageStatus_free<s(0)(0)(0)>[&] = 0,
	PbUsageStatus_sdh_occupied<s(0)(0)(0)>[&] = 1,
	PbUsageStatus_pdh_data_occupied<s(0)(0)(0)>[&] = 2,
	PbUsageStatus_gmpls_reserved<s(0)(0)(0)>[&] = 3,
	PbUsageStatus_unavailable<s(0)(0)(0)>[&] = 4
} PbUsageStatus_Tval<s(0)(0)(0)>[&];(D1:PbUsageStatus_Tval:1)[[TYPENAME:PbUsageStatus_Tval]]

typedef enum {
	PbBoardStyle_empty<s(0)(0)(0)>[&] = 0,
	PbBoardStyle_unknown<s(0)(0)(0)>[&] = 1,
	PbBoardStyle_main<s(0)(0)(0)>[&] = 2305,
	PbBoardStyle_hocc<s(0)(0)(0)>[&] = 2306,
	PbBoardStyle_locc_pmc<s(0)(0)(0)>[&] = 2307,
	PbBoardStyle_e1x126<s(0)(0)(0)>[&] = 2308,
	PbBoardStyle_e1px63<s(0)(0)(0)>[&] = 2309,
	PbBoardStyle_stm_1ex8<s(0)(0)(0)>[&] = 2310,
	PbBoardStyle_e3ds3x12<s(0)(0)(0)>[&] = 2312,
	PbBoardStyle_stm_41x8<s(0)(0)(0)>[&] = 2320,
	PbBoardStyle_stm_1x8<s(0)(0)(0)>[&] = 2321,
	PbBoardStyle_stm_16x4<s(0)(0)(0)>[&] = 2322,
	PbBoardStyle_stm_16x8<s(0)(0)(0)>[&] = 2323,
	PbBoardStyle_e3ds3px12<s(0)(0)(0)>[&] = 2324,
	PbBoardStyle_stm_64x2<s(0)(0)(0)>[&] = 2325,
	PbBoardStyle_stm_64x1<s(0)(0)(0)>[&] = 2326,
	PbBoardStyle_oaBooster13dbm<s(0)(0)(0)>[&] = 2336,
	PbBoardStyle_oaBooster15dbm<s(0)(0)(0)>[&] = 2337,
	PbBoardStyle_oaBooster18dbm<s(0)(0)(0)>[&] = 2338,
	PbBoardStyle_oaPreamp20db<s(0)(0)(0)>[&] = 2340,
	PbBoardStyle_tengetx1<s(0)(0)(0)>[&] = 2342,
	PbBoardStyle_tengetx1_geax46<s(0)(0)(0)>[&] = 2343,
	PbBoardStyle_getx8<s(0)(0)(0)>[&] = 2344,
	PbBoardStyle_gex6_fegeax4<s(0)(0)(0)>[&] = 2345,
	PbBoardStyle_gex2_ferprx12<s(0)(0)(0)>[&] = 2352,
	PbBoardStyle_gex4_feax12<s(0)(0)(0)>[&] = 2353,
	PbBoardStyle_fetx12<s(0)(0)(0)>[&] = 2354,
	PbBoardStyle_fc2gx8<s(0)(0)(0)>[&] = 2355,
	PbBoardStyle_locc<s(0)(0)(0)>[&] = 2356,
	PbBoardStyle_stm_256x1<s(0)(0)(0)>[&] = 2357,
	PbBoardStyle_fan<s(0)(0)(0)>[&] = 2358,
	PbBoardStyle_si_without_eow<s(0)(0)(0)>[&] = 2368,
	PbBoardStyle_stm_16x2<s(0)(0)(0)>[&] = 2369,
	PbBoardStyle_otu_2x1<s(0)(0)(0)>[&] = 2400,
	PbBoardStyle_tengex1_gex10l2<s(0)(0)(0)>[&] = 2440,
	PbBoardStyle_stm_16x8m<s(0)(0)(0)>[&] = 2441,
	PbBoardStyle_stm_41x16m<s(0)(0)(0)>[&] = 2448,
	PbBoardStyle_stm_64x2m<s(0)(0)(0)>[&] = 2449,
	PbBoardStyle_otu_2x2<s(0)(0)(0)>[&] = 2450,
	PbBoardStyle_chassis<s(0)(0)(0)>[&] = 4232,
	PbBoardStyle_cc<s(0)(0)(0)>[&] = 4240,
	PbBoardStyle_dataFabric_controller<s(0)(0)(0)>[&] = 4241,
	PbBoardStyle_dataFabric<s(0)(0)(0)>[&] = 4242,
	PbBoardStyle_si<s(0)(0)(0)>[&] = 4243,
	PbBoardStyle_power<s(0)(0)(0)>[&] = 4244,
	PbBoardStyle_chassis_fan_airFilter<s(0)(0)(0)>[&] = 4245,
	PbBoardStyle_fanTray<s(0)(0)(0)>[&] = 4246,
	PbBoardStyle_fanCircuitBoard<s(0)(0)(0)>[&] = 4247,
	PbBoardStyle_backplane<s(0)(0)(0)>[&] = 4248,
	PbBoardStyle_e1x21p_75<s(0)(0)(0)>[&] = 4352,
	PbBoardStyle_e1x21p_120<s(0)(0)(0)>[&] = 4353,
	PbBoardStyle_stm_1ex16<s(0)(0)(0)>[&] = 4354,
	PbBoardStyle_stm_1ex8p<s(0)(0)(0)>[&] = 4356,
	PbBoardStyle_e3ds3x6p<s(0)(0)(0)>[&] = 4358,
	PbBoardStyle_gex20<s(0)(0)(0)>[&] = 4359,
	PbBoardStyle_tengex2<s(0)(0)(0)>[&] = 4360,
	PbBoardStyle_gex10_eos<s(0)(0)(0)>[&] = 4361,
	PbBoardStyle_tengex2_eos<s(0)(0)(0)>[&] = 4368,
	PbBoardStyle_gmpls_load<s(0)(0)(0)>[&] = 983040
} PbBoardStyle_Tval<s(0)(0)(0)>[&];(D1:PbBoardStyle_Tval:1)[[TYPENAME:PbBoardStyle_Tval]]

typedef enum {
	TypeUpgradeCmnd_inactive<s(0)(0)(0)>[&] = 0,
	TypeUpgradeCmnd_activeScDownload<s(0)(0)(0)>[&] = 1,
	TypeUpgradeCmnd_activeScSwitch<s(0)(0)(0)>[&] = 2,
	TypeUpgradeCmnd_activeScBackup<s(0)(0)(0)>[&] = 3,
	TypeUpgradeCmnd_synchronizeBackup<s(0)(0)(0)>[&] = 4,
	TypeUpgradeCmnd_standbyScSwitch<s(0)(0)(0)>[&] = 5
} TypeUpgradeCmnd_Tval<s(0)(0)(0)>[&];(D1:TypeUpgradeCmnd_Tval:1)[[TYPENAME:TypeUpgradeCmnd_Tval]]

typedef enum {
	PbMSPCurrentReq_reqlockout<s(0)(0)(0)>[&] = 1,
	PbMSPCurrentReq_reqforcedswitch<s(0)(0)(0)>[&] = 2,
	PbMSPCurrentReq_reqsfhigh<s(0)(0)(0)>[&] = 3,
	PbMSPCurrentReq_reqsflow<s(0)(0)(0)>[&] = 4,
	PbMSPCurrentReq_reqsdhigh<s(0)(0)(0)>[&] = 5,
	PbMSPCurrentReq_reqsdlow<s(0)(0)(0)>[&] = 6,
	PbMSPCurrentReq_reqmannualswitch<s(0)(0)(0)>[&] = 7,
	PbMSPCurrentReq_reqwaittorestore<s(0)(0)(0)>[&] = 8,
	PbMSPCurrentReq_reqexercise<s(0)(0)(0)>[&] = 9,
	PbMSPCurrentReq_reqreverse<s(0)(0)(0)>[&] = 10,
	PbMSPCurrentReq_reqnorevert<s(0)(0)(0)>[&] = 11,
	PbMSPCurrentReq_reqnorequest<s(0)(0)(0)>[&] = 12
} PbMSPCurrentReq_Tval<s(0)(0)(0)>[&];(D1:PbMSPCurrentReq_Tval:1)[[TYPENAME:PbMSPCurrentReq_Tval]]

typedef enum {
	PbEnableDisable_enable<s(0)(0)(0)>[&] = 1,
	PbEnableDisable_disable<s(0)(0)(0)>[&] = 2
} PbEnableDisable_Tval<s(0)(0)(0)>[&];(D1:PbEnableDisable_Tval:1)[[TYPENAME:PbEnableDisable_Tval]]

typedef enum {
	Mssp4fLineRequest_signalDegradeRing<s(0)(0)(0)>[&] = 8,
	Mssp4fLineRequest_signalFailRing<s(0)(0)(0)>[&] = 11,
	Mssp4fLineRequest_clear<s(0)(0)(0)>[&] = 21
} Mssp4fLineRequest_Tval<s(0)(0)(0)>[&];(D1:Mssp4fLineRequest_Tval:1)[[TYPENAME:Mssp4fLineRequest_Tval]]

typedef enum {
	Mssp4fSwitchCommand_noRequest<s(0)(0)(0)>[&] = 0,
	Mssp4fSwitchCommand_reverseRequestRing<s(0)(0)(0)>[&] = 1,
	Mssp4fSwitchCommand_reverseRequestSpan<s(0)(0)(0)>[&] = 2,
	Mssp4fSwitchCommand_exerciserRing<s(0)(0)(0)>[&] = 3,
	Mssp4fSwitchCommand_exerciserSpan<s(0)(0)(0)>[&] = 4,
	Mssp4fSwitchCommand_waitToRestore<s(0)(0)(0)>[&] = 5,
	Mssp4fSwitchCommand_manualSwitchRing<s(0)(0)(0)>[&] = 6,
	Mssp4fSwitchCommand_manualSwitchSpan<s(0)(0)(0)>[&] = 7,
	Mssp4fSwitchCommand_signalDegradeRing<s(0)(0)(0)>[&] = 8,
	Mssp4fSwitchCommand_signalDegradeSpan<s(0)(0)(0)>[&] = 9,
	Mssp4fSwitchCommand_signalDegradeProtection<s(0)(0)(0)>[&] = 10,
	Mssp4fSwitchCommand_signalFailRing<s(0)(0)(0)>[&] = 11,
	Mssp4fSwitchCommand_signalFailSpan<s(0)(0)(0)>[&] = 12,
	Mssp4fSwitchCommand_forcedSwitchRing<s(0)(0)(0)>[&] = 13,
	Mssp4fSwitchCommand_forcedSwitchSpan<s(0)(0)(0)>[&] = 14,
	Mssp4fSwitchCommand_lockoutProtection<s(0)(0)(0)>[&] = 15
} Mssp4fSwitchCommand_Tval<s(0)(0)(0)>[&];(D1:Mssp4fSwitchCommand_Tval:1)[[TYPENAME:Mssp4fSwitchCommand_Tval]]

typedef enum {
	PbEthPortClass_lAN<s(0)(0)(0)>[&] = 1,
	PbEthPortClass_wAN<s(0)(0)(0)>[&] = 2,
	PbEthPortClass_tRUNK<s(0)(0)(0)>[&] = 3
} PbEthPortClass_Tval<s(0)(0)(0)>[&];(D1:PbEthPortClass_Tval:1)[[TYPENAME:PbEthPortClass_Tval]]

typedef enum {
	AlarmState_set<s(0)(0)(0)>[&] = 1,
	AlarmState_clear<s(0)(0)(0)>[&] = 2
} AlarmState_Tval<s(0)(0)(0)>[&];(D1:AlarmState_Tval:1)[[TYPENAME:AlarmState_Tval]]

typedef enum {
	SnmpSecurityLevel_noAuthNoPriv<s(0)(0)(0)>[&] = 1,
	SnmpSecurityLevel_authNoPriv<s(0)(0)(0)>[&] = 2,
	SnmpSecurityLevel_authPriv<s(0)(0)(0)>[&] = 3
} SnmpSecurityLevel_Tval<s(0)(0)(0)>[&];(D1:SnmpSecurityLevel_Tval:1)[[TYPENAME:SnmpSecurityLevel_Tval]]

typedef enum {
	PbMsspRequestSource_kByte<s(0)(0)(0)>[&] = 0,
	PbMsspRequestSource_line<s(0)(0)(0)>[&] = 1,
	PbMsspRequestSource_external<s(0)(0)(0)>[&] = 2
} PbMsspRequestSource_Tval<s(0)(0)(0)>[&];(D1:PbMsspRequestSource_Tval:1)[[TYPENAME:PbMsspRequestSource_Tval]]

typedef enum {
	PbSNCPCurrentReq_reqClear<s(0)(0)(0)>[&] = 1,
	PbSNCPCurrentReq_reqlockout<s(0)(0)(0)>[&] = 2,
	PbSNCPCurrentReq_reqforcedswitchtop<s(0)(0)(0)>[&] = 3,
	PbSNCPCurrentReq_reqforcedswitchtow<s(0)(0)(0)>[&] = 4,
	PbSNCPCurrentReq_reqsignalfail<s(0)(0)(0)>[&] = 5,
	PbSNCPCurrentReq_reqmannualswitchtop<s(0)(0)(0)>[&] = 6,
	PbSNCPCurrentReq_reqmannualswitchtow<s(0)(0)(0)>[&] = 7,
	PbSNCPCurrentReq_reqwaittorestore<s(0)(0)(0)>[&] = 8,
	PbSNCPCurrentReq_reqnorequest<s(0)(0)(0)>[&] = 9,
	PbSNCPCurrentReq_reqsignalDeg<s(0)(0)(0)>[&] = 10
} PbSNCPCurrentReq_Tval<s(0)(0)(0)>[&];(D1:PbSNCPCurrentReq_Tval:1)[[TYPENAME:PbSNCPCurrentReq_Tval]]

typedef enum {
	PbXcStatus_removed<s(0)(0)(0)>[&] = 0,
	PbXcStatus_disabled<s(0)(0)(0)>[&] = 1,
	PbXcStatus_ok<s(0)(0)(0)>[&] = 2,
	PbXcStatus_failed<s(0)(0)(0)>[&] = 3
} PbXcStatus_Tval<s(0)(0)(0)>[&];(D1:PbXcStatus_Tval:1)[[TYPENAME:PbXcStatus_Tval]]

typedef enum {
	EventTypeID_usr_login<s(0)(0)(0)>[&] = 1,
	EventTypeID_usr_logout<s(0)(0)(0)>[&] = 2,
	EventTypeID_usr_autologout<s(0)(0)(0)>[&] = 3,
	EventTypeID_usr_pwd_change<s(0)(0)(0)>[&] = 4,
	EventTypeID_unauthorized_login<s(0)(0)(0)>[&] = 5,
	EventTypeID_alarm_log_cleared<s(0)(0)(0)>[&] = 6,
	EventTypeID_event_log_cleared<s(0)(0)(0)>[&] = 7,
	EventTypeID_auto_acceptance<s(0)(0)(0)>[&] = 8,
	EventTypeID_card_booted<s(0)(0)(0)>[&] = 9,
	EventTypeID_card_reset<s(0)(0)(0)>[&] = 10,
	EventTypeID_card_disabled<s(0)(0)(0)>[&] = 11,
	EventTypeID_card_removed<s(0)(0)(0)>[&] = 12,
	EventTypeID_sfp_changed<s(0)(0)(0)>[&] = 13,
	EventTypeID_protection_switch_completed<s(0)(0)(0)>[&] = 14,
	EventTypeID_protection_switch_back_completed<s(0)(0)(0)>[&] = 15,
	EventTypeID_software_download_started<s(0)(0)(0)>[&] = 16,
	EventTypeID_software_download_completed<s(0)(0)(0)>[&] = 17,
	EventTypeID_software_upgrade_started<s(0)(0)(0)>[&] = 18,
	EventTypeID_software_upgrade_completed<s(0)(0)(0)>[&] = 19,
	EventTypeID_mib_upload_started<s(0)(0)(0)>[&] = 20,
	EventTypeID_mib_upload_completed<s(0)(0)(0)>[&] = 21,
	EventTypeID_mib_download_started<s(0)(0)(0)>[&] = 22,
	EventTypeID_mib_download_completed<s(0)(0)(0)>[&] = 23,
	EventTypeID_mib_backup_started<s(0)(0)(0)>[&] = 24,
	EventTypeID_mib_backup_completed<s(0)(0)(0)>[&] = 25,
	EventTypeID_mib_restore_started<s(0)(0)(0)>[&] = 26,
	EventTypeID_mib_restore_completed<s(0)(0)(0)>[&] = 27,
	EventTypeID_system_reset<s(0)(0)(0)>[&] = 28,
	EventTypeID_system_start<s(0)(0)(0)>[&] = 29,
	EventTypeID_tms_status<s(0)(0)(0)>[&] = 30,
	EventTypeID_tms_config<s(0)(0)(0)>[&] = 31,
	EventTypeID_port_down<s(0)(0)(0)>[&] = 32,
	EventTypeID_port_up<s(0)(0)(0)>[&] = 33,
	EventTypeID_msspring_state_change<s(0)(0)(0)>[&] = 34,
	EventTypeID_msspring_squelch<s(0)(0)(0)>[&] = 35,
	EventTypeID_cc_switch<s(0)(0)(0)>[&] = 36,
	EventTypeID_tca<s(0)(0)(0)>[&] = 37,
	EventTypeID_flash_full<s(0)(0)(0)>[&] = 38,
	EventTypeID_dcc_dll_status<s(0)(0)(0)>[&] = 39,
	EventTypeID_mib_check_failed<s(0)(0)(0)>[&] = 40,
	EventTypeID_mib_illegal_operation<s(0)(0)(0)>[&] = 41,
	EventTypeID_system_memory_usage<s(0)(0)(0)>[&] = 42,
	EventTypeID_sncp_switch_to_protect<s(0)(0)(0)>[&] = 43,
	EventTypeID_sncp_switch_to_work<s(0)(0)(0)>[&] = 44,
	EventTypeID_card_deleted<s(0)(0)(0)>[&] = 45,
	EventTypeID_system_time_changed<s(0)(0)(0)>[&] = 46,
	EventTypeID_positive_bit_slip<s(0)(0)(0)>[&] = 47,
	EventTypeID_negative_bit_slip<s(0)(0)(0)>[&] = 48,
	EventTypeID_latch_switch_opened<s(0)(0)(0)>[&] = 49,
	EventTypeID_sncp_switch<s(0)(0)(0)>[&] = 50,
	EventTypeID_tms_systiming_status<s(0)(0)(0)>[&] = 51,
	EventTypeID_tms_systiming_config<s(0)(0)(0)>[&] = 52,
	EventTypeID_epg_protectstate_change<s(0)(0)(0)>[&] = 53,
	EventTypeID_rpr_topo_changed<s(0)(0)(0)>[&] = 54,
	EventTypeID_mib_clear_started<s(0)(0)(0)>[&] = 57,
	EventTypeID_mib_clear_completed<s(0)(0)(0)>[&] = 58,
	EventTypeID_boot_image_is_not_identical<s(0)(0)(0)>[&] = 60,
	EventTypeID_rstp_topology_changed<s(0)(0)(0)>[&] = 61,
	EventTypeID_rstp_enabled<s(0)(0)(0)>[&] = 62,
	EventTypeID_rstp_disabled<s(0)(0)(0)>[&] = 63,
	EventTypeID_lcasso_changed<s(0)(0)(0)>[&] = 64,
	EventTypeID_lcassk_changed<s(0)(0)(0)>[&] = 65,
	EventTypeID_mib_file_is_failed<s(0)(0)(0)>[&] = 66,
	EventTypeID_free_space_is_not_enough_in_cf<s(0)(0)(0)>[&] = 67,
	EventTypeID_space_is_released_in_cf<s(0)(0)(0)>[&] = 68,
	EventTypeID_ntp_function_changed<s(0)(0)(0)>[&] = 69,
	EventTypeID_connect_to_ntp_server_failed<s(0)(0)(0)>[&] = 70,
	EventTypeID_connect_to_ntp_server_successfully<s(0)(0)(0)>[&] = 71,
	EventTypeID_primary_load_copy_succeeded<s(0)(0)(0)>[&] = 72,
	EventTypeID_primary_load_copy_failed<s(0)(0)(0)>[&] = 73,
	EventTypeID_lan_port_down_on_csf_alarm<s(0)(0)(0)>[&] = 74,
	EventTypeID_lan_port_recovered_on_csf_alarm_cleared<s(0)(0)(0)>[&] = 75,
	EventTypeID_lan_port_down_on_tlct_alarm<s(0)(0)(0)>[&] = 76,
	EventTypeID_lan_port_recovered_on_tlct_alarm_cleared<s(0)(0)(0)>[&] = 77,
	EventTypeID_lan_port_recovered_on_atls_disable<s(0)(0)(0)>[&] = 78,
	EventTypeID_provision_ssm_mode_changed<s(0)(0)(0)>[&] = 79,
	EventTypeID_ecc_dll_status<s(0)(0)(0)>[&] = 80,
	EventTypeID_software_image_loaded_location<s(0)(0)(0)>[&] = 81,
	EventTypeID_mib_loaded_location<s(0)(0)(0)>[&] = 82,
	EventTypeID_eow_software_download_started<s(0)(0)(0)>[&] = 83,
	EventTypeID_eow_software_download_completed<s(0)(0)(0)>[&] = 84,
	EventTypeID_eow_software_upgrade_started<s(0)(0)(0)>[&] = 85,
	EventTypeID_eow_software_upgrade_completed<s(0)(0)(0)>[&] = 86,
	EventTypeID_eow_box_present_status<s(0)(0)(0)>[&] = 87,
	EventTypeID_eow_box_linkup_status<s(0)(0)(0)>[&] = 88,
	EventTypeID_software_synchronization_started<s(0)(0)(0)>[&] = 89,
	EventTypeID_software_synchronization_statement<s(0)(0)(0)>[&] = 90,
	EventTypeID_mib_syn_started<s(0)(0)(0)>[&] = 91,
	EventTypeID_mib_syn_statement<s(0)(0)(0)>[&] = 92,
	EventTypeID_mib_copy_started<s(0)(0)(0)>[&] = 93,
	EventTypeID_mib_copy_statement<s(0)(0)(0)>[&] = 94,
	EventTypeID_card_mismatch<s(0)(0)(0)>[&] = 95,
	EventTypeID_lcs_download_started<s(0)(0)(0)>[&] = 96,
	EventTypeID_lcs_download_statement<s(0)(0)(0)>[&] = 97,
	EventTypeID_lcs_syn_started<s(0)(0)(0)>[&] = 98,
	EventTypeID_lcs_syn_statement<s(0)(0)(0)>[&] = 99,
	EventTypeID_software_is_different<s(0)(0)(0)>[&] = 101,
	EventTypeID_wr_error<s(0)(0)(0)>[&] = 102,
	EventTypeID_card_inserted<s(0)(0)(0)>[&] = 103,
	EventTypeID_sft_unstable_state<s(0)(0)(0)>[&] = 104,
	EventTypeID_sft_is_switching<s(0)(0)(0)>[&] = 105,
	EventTypeID_sft_switching_complete_by_present<s(0)(0)(0)>[&] = 106,
	EventTypeID_sft_switching_complete_by_external_command<s(0)(0)(0)>[&] = 107,
	EventTypeID_sft_switching_complete_by_unit_failure<s(0)(0)(0)>[&] = 108,
	EventTypeID_sft_switching_complete_by_latch_open<s(0)(0)(0)>[&] = 109,
	EventTypeID_sft_switching_failed<s(0)(0)(0)>[&] = 110,
	EventTypeID_sft_file_lost<s(0)(0)(0)>[&] = 111,
	EventTypeID_sft_ohw_error<s(0)(0)(0)>[&] = 112,
	EventTypeID_sft_pull_ool<s(0)(0)(0)>[&] = 113,
	EventTypeID_sft_gmpls_switch<s(0)(0)(0)>[&] = 114,
	EventTypeID_ms_got_write_authority<s(0)(0)(0)>[&] = 115,
	EventTypeID_ms_release_write_authority<s(0)(0)(0)>[&] = 116,
	EventTypeID_unauthorized_access<s(0)(0)(0)>[&] = 117,
	EventTypeID_si_ens_state<s(0)(0)(0)>[&] = 118,
	EventTypeID_si_erm_state<s(0)(0)(0)>[&] = 119,
	EventTypeID_mstp_port_change<s(0)(0)(0)>[&] = 120,
	EventTypeID_mstp_rstp_enable<s(0)(0)(0)>[&] = 121,
	EventTypeID_initialization_failure<s(0)(0)(0)>[&] = 122,
	EventTypeID_ocxo_failure<s(0)(0)(0)>[&] = 123,
	EventTypeID_vcxo_failure<s(0)(0)(0)>[&] = 124,
	EventTypeID_operation_mode_switch<s(0)(0)(0)>[&] = 125,
	EventTypeID_j0_mode_changed<s(0)(0)(0)>[&] = 126,
	EventTypeID_j0_value_changed<s(0)(0)(0)>[&] = 127,
	EventTypeID_boot_image_upgrade_completed<s(0)(0)(0)>[&] = 128,
	EventTypeID_boot_image_upgrade_failure<s(0)(0)(0)>[&] = 129,
	EventTypeID_pll_cannot_lock<s(0)(0)(0)>[&] = 130,
	EventTypeID_user_enabled<s(0)(0)(0)>[&] = 131,
	EventTypeID_user_disabled<s(0)(0)(0)>[&] = 132,
	EventTypeID_lcs_status_changed<s(0)(0)(0)>[&] = 133,
	EventTypeID_epg_switching_failure<s(0)(0)(0)>[&] = 134,
	EventTypeID_rpr_hardware_passthrough_setup<s(0)(0)(0)>[&] = 135,
	EventTypeID_rpr_hardware_passthrough_removed<s(0)(0)(0)>[&] = 136,
	EventTypeID_account_expired<s(0)(0)(0)>[&] = 137,
	EventTypeID_cpu_util_over<s(0)(0)(0)>[&] = 138,
	EventTypeID_mem_util_over<s(0)(0)(0)>[&] = 139,
	EventTypeID_gmpls_switch_success<s(0)(0)(0)>[&] = 140,
	EventTypeID_queue_over_flow<s(0)(0)(0)>[&] = 141,
	EventTypeID_dcn_mgmt_ethport_down<s(0)(0)(0)>[&] = 142,
	EventTypeID_dcn_mgmt_ethport_up<s(0)(0)(0)>[&] = 143,
	EventTypeID_mib_preserve_clear_started<s(0)(0)(0)>[&] = 144,
	EventTypeID_mib_preserve_clear_completed<s(0)(0)(0)>[&] = 145
} EventTypeID_Tval<s(0)(0)(0)>[&];(D1:EventTypeID_Tval:1)[[TYPENAME:EventTypeID_Tval]]

typedef enum {
	TmsRefSourceNum_reference1<s(0)(0)(0)>[&] = 1,
	TmsRefSourceNum_reference2<s(0)(0)(0)>[&] = 2,
	TmsRefSourceNum_reference3<s(0)(0)(0)>[&] = 3,
	TmsRefSourceNum_reference4<s(0)(0)(0)>[&] = 4
} TmsRefSourceNum_Tval<s(0)(0)(0)>[&];(D1:TmsRefSourceNum_Tval:1)[[TYPENAME:TmsRefSourceNum_Tval]]

typedef enum {
	PbSignalType_normal<s(0)(0)(0)>[&] = 1,
	PbSignalType_unequipped<s(0)(0)(0)>[&] = 2,
	PbSignalType_ais<s(0)(0)(0)>[&] = 3,
	PbSignalType_rdi<s(0)(0)(0)>[&] = 5
} PbSignalType_Tval<s(0)(0)(0)>[&];(D1:PbSignalType_Tval:1)[[TYPENAME:PbSignalType_Tval]]

typedef enum {
	PBSNCPAddRslt_succ<s(0)(0)(0)>[&] = 1,
	PBSNCPAddRslt_workTPError<s(0)(0)(0)>[&] = 2,
	PBSNCPAddRslt_workTPDuplicate<s(0)(0)(0)>[&] = 3,
	PBSNCPAddRslt_protTPDuplicate<s(0)(0)(0)>[&] = 4,
	PBSNCPAddRslt_protTPError<s(0)(0)(0)>[&] = 5,
	PBSNCPAddRslt_msProtTP<s(0)(0)(0)>[&] = 6,
	PBSNCPAddRslt_pcmTimeout<s(0)(0)(0)>[&] = 7,
	PBSNCPAddRslt_noFreeTbl<s(0)(0)(0)>[&] = 8,
	PBSNCPAddRslt_ccFail<s(0)(0)(0)>[&] = 9,
	PBSNCPAddRslt_ccTimeout<s(0)(0)(0)>[&] = 10,
	PBSNCPAddRslt_waitCCReq<s(0)(0)(0)>[&] = 11,
	PBSNCPAddRslt_waitCCResult<s(0)(0)(0)>[&] = 12,
	PBSNCPAddRslt_waitPCMResult<s(0)(0)(0)>[&] = 13,
	PBSNCPAddRslt_pcmFail<s(0)(0)(0)>[&] = 14,
	PBSNCPAddRslt_waitSPAReq<s(0)(0)(0)>[&] = 15,
	PBSNCPAddRslt_waitSPAResult<s(0)(0)(0)>[&] = 16,
	PBSNCPAddRslt_spaFail<s(0)(0)(0)>[&] = 17,
	PBSNCPAddRslt_spaTimeout<s(0)(0)(0)>[&] = 18
} PBSNCPAddRslt_Tval<s(0)(0)(0)>[&];(D1:PBSNCPAddRslt_Tval:1)[[TYPENAME:PBSNCPAddRslt_Tval]]

typedef enum {
	PbMsspTrafficDirection_rx<s(0)(0)(0)>[&] = 0,
	PbMsspTrafficDirection_tx<s(0)(0)(0)>[&] = 1
} PbMsspTrafficDirection_Tval<s(0)(0)(0)>[&];(D1:PbMsspTrafficDirection_Tval:1)[[TYPENAME:PbMsspTrafficDirection_Tval]]

typedef enum {
	PbCmndState_none<s(0)(0)(0)>[&] = 1,
	PbCmndState_running<s(0)(0)(0)>[&] = 2,
	PbCmndState_complete<s(0)(0)(0)>[&] = 3,
	PbCmndState_failed<s(0)(0)(0)>[&] = 4
} PbCmndState_Tval<s(0)(0)(0)>[&];(D1:PbCmndState_Tval:1)[[TYPENAME:PbCmndState_Tval]]

typedef enum {
	PbTIModeType_mode16Byte<s(0)(0)(0)>[&] = 1,
	PbTIModeType_mode64Byte<s(0)(0)(0)>[&] = 2,
	PbTIModeType_modeFixedOneByte<s(0)(0)(0)>[&] = 3,
	PbTIModeType_modeProvisionedOneByte<s(0)(0)(0)>[&] = 4,
	PbTIModeType_modeAutoTrace<s(0)(0)(0)>[&] = 5
} PbTIModeType_Tval<s(0)(0)(0)>[&];(D1:PbTIModeType_Tval:1)[[TYPENAME:PbTIModeType_Tval]]

typedef enum {
	PbCFCardState_notapplicable<s(0)(0)(0)>[&] = 0,
	PbCFCardState_mountedandnormal<s(0)(0)(0)>[&] = 1,
	PbCFCardState_removed<s(0)(0)(0)>[&] = 2,
	PbCFCardState_mountedbutfailed<s(0)(0)(0)>[&] = 3,
	PbCFCardState_mountednofreespace<s(0)(0)(0)>[&] = 4
} PbCFCardState_Tval<s(0)(0)(0)>[&];(D1:PbCFCardState_Tval:1)[[TYPENAME:PbCFCardState_Tval]]

typedef enum {
	PbSlotType_none<s(0)(0)(0)>[&] = 0,
	PbSlotType_mc<s(0)(0)(0)>[&] = 1,
	PbSlotType_lc<s(0)(0)(0)>[&] = 2,
	PbSlotType_ti<s(0)(0)(0)>[&] = 5,
	PbSlotType_to<s(0)(0)(0)>[&] = 6,
	PbSlotType_power<s(0)(0)(0)>[&] = 7,
	PbSlotType_fan<s(0)(0)(0)>[&] = 8,
	PbSlotType_si<s(0)(0)(0)>[&] = 10,
	PbSlotType_io<s(0)(0)(0)>[&] = 12,
	PbSlotType_cc<s(0)(0)(0)>[&] = 13,
	PbSlotType_sfc<s(0)(0)(0)>[&] = 14,
	PbSlotType_sfm<s(0)(0)(0)>[&] = 15,
	PbSlotType_ce<s(0)(0)(0)>[&] = 16
} PbSlotType_Tval<s(0)(0)(0)>[&];(D1:PbSlotType_Tval:1)[[TYPENAME:PbSlotType_Tval]]

typedef enum {
	PbPmUapType_nearend<s(0)(0)(0)>[&] = 1,
	PbPmUapType_farend<s(0)(0)(0)>[&] = 2
} PbPmUapType_Tval<s(0)(0)(0)>[&];(D1:PbPmUapType_Tval:1)[[TYPENAME:PbPmUapType_Tval]]

typedef enum {
	PbSFFTranscCode_unknown<s(0)(0)(0)>[&] = 0,
	PbSFFTranscCode_infiniband_1x_SX<s(0)(0)(0)>[&] = 1,
	PbSFFTranscCode_infiniband_1x_LX<s(0)(0)(0)>[&] = 2,
	PbSFFTranscCode_infiniband_1x_COP_ACT<s(0)(0)(0)>[&] = 3,
	PbSFFTranscCode_infiniband_1x_COP_PSV<s(0)(0)(0)>[&] = 4,
	PbSFFTranscCode_escon_MMF_1310NM_LED<s(0)(0)(0)>[&] = 5,
	PbSFFTranscCode_escon_SMF_1310NM_LASER<s(0)(0)(0)>[&] = 6,
	PbSFFTranscCode_sonet_oc48_SR<s(0)(0)(0)>[&] = 7,
	PbSFFTranscCode_sonet_oc48_SR1<s(0)(0)(0)>[&] = 8,
	PbSFFTranscCode_sonet_oc48_IR<s(0)(0)(0)>[&] = 9,
	PbSFFTranscCode_sonet_oc48_IR1<s(0)(0)(0)>[&] = 10,
	PbSFFTranscCode_sonet_oc48_IR2<s(0)(0)(0)>[&] = 11,
	PbSFFTranscCode_sonet_oc48_LR<s(0)(0)(0)>[&] = 12,
	PbSFFTranscCode_sonet_oc48_LR1<s(0)(0)(0)>[&] = 13,
	PbSFFTranscCode_sonet_oc48_LR2<s(0)(0)(0)>[&] = 14,
	PbSFFTranscCode_sonet_oc48_LR3<s(0)(0)(0)>[&] = 15,
	PbSFFTranscCode_sonet_oc12_SR<s(0)(0)(0)>[&] = 16,
	PbSFFTranscCode_sonet_oc12_SR1<s(0)(0)(0)>[&] = 17,
	PbSFFTranscCode_sonet_oc12_IR<s(0)(0)(0)>[&] = 18,
	PbSFFTranscCode_sonet_oc12_IR1<s(0)(0)(0)>[&] = 19,
	PbSFFTranscCode_sonet_oc12_IR2<s(0)(0)(0)>[&] = 20,
	PbSFFTranscCode_sonet_oc12_LR<s(0)(0)(0)>[&] = 21,
	PbSFFTranscCode_sonet_oc12_LR1<s(0)(0)(0)>[&] = 22,
	PbSFFTranscCode_sonet_oc12_LR2<s(0)(0)(0)>[&] = 23,
	PbSFFTranscCode_sonet_oc12_LR3<s(0)(0)(0)>[&] = 24,
	PbSFFTranscCode_sonet_oc3_SR<s(0)(0)(0)>[&] = 25,
	PbSFFTranscCode_sonet_oc3_SR1<s(0)(0)(0)>[&] = 26,
	PbSFFTranscCode_sonet_oc3_IR<s(0)(0)(0)>[&] = 27,
	PbSFFTranscCode_sonet_oc3_IR1<s(0)(0)(0)>[&] = 28,
	PbSFFTranscCode_sonet_oc3_IR2<s(0)(0)(0)>[&] = 29,
	PbSFFTranscCode_sonet_oc3_LR<s(0)(0)(0)>[&] = 30,
	PbSFFTranscCode_sonet_oc3_LR1<s(0)(0)(0)>[&] = 31,
	PbSFFTranscCode_sonet_oc3_LR2<s(0)(0)(0)>[&] = 32,
	PbSFFTranscCode_sonet_oc3_LR3<s(0)(0)(0)>[&] = 33,
	PbSFFTranscCode_ethernet_BASE_PX<s(0)(0)(0)>[&] = 34,
	PbSFFTranscCode_ethernet_BASE_BX10<s(0)(0)(0)>[&] = 35,
	PbSFFTranscCode_ethernet_100BASE_FX<s(0)(0)(0)>[&] = 36,
	PbSFFTranscCode_ethernet_100BASE_LX_LX10<s(0)(0)(0)>[&] = 37,
	PbSFFTranscCode_ethernet_1000BASE_T<s(0)(0)(0)>[&] = 38,
	PbSFFTranscCode_ethernet_1000BASE_CX<s(0)(0)(0)>[&] = 39,
	PbSFFTranscCode_ethernet_1000BASE_LX<s(0)(0)(0)>[&] = 40,
	PbSFFTranscCode_ethernet_1000BASE_SX<s(0)(0)(0)>[&] = 41,
	PbSFFTranscCode_fibre_CHANNEL<s(0)(0)(0)>[&] = 42,
	PbSFFTranscCode_max<s(0)(0)(0)>[&] = 43
} PbSFFTranscCode_Tval<s(0)(0)(0)>[&];(D1:PbSFFTranscCode_Tval:1)[[TYPENAME:PbSFFTranscCode_Tval]]

typedef enum {
	StorageType_other<s(0)(0)(0)>[&] = 1,
	StorageType_volatile<s(0)(0)(0)>[&] = 2,
	StorageType_nonVolatile<s(0)(0)(0)>[&] = 3,
	StorageType_permanent<s(0)(0)(0)>[&] = 4,
	StorageType_readOnly<s(0)(0)(0)>[&] = 5
} StorageType_Tval<s(0)(0)(0)>[&];(D1:StorageType_Tval:1)[[TYPENAME:StorageType_Tval]]

typedef enum {
	PbCommunityStringAccessLevel_readOnly<s(0)(0)(0)>[&] = 1,
	PbCommunityStringAccessLevel_readWrite<s(0)(0)(0)>[&] = 2
} PbCommunityStringAccessLevel_Tval<s(0)(0)(0)>[&];(D1:PbCommunityStringAccessLevel_Tval:1)[[TYPENAME:PbCommunityStringAccessLevel_Tval]]

typedef enum {
	PbDpnpSwitchEvent_w2p<s(0)(0)(0)>[&] = 1,
	PbDpnpSwitchEvent_w2m<s(0)(0)(0)>[&] = 2,
	PbDpnpSwitchEvent_p2w<s(0)(0)(0)>[&] = 3,
	PbDpnpSwitchEvent_p2m<s(0)(0)(0)>[&] = 4,
	PbDpnpSwitchEvent_m2w<s(0)(0)(0)>[&] = 5,
	PbDpnpSwitchEvent_m2p<s(0)(0)(0)>[&] = 6
} PbDpnpSwitchEvent_Tval<s(0)(0)(0)>[&];(D1:PbDpnpSwitchEvent_Tval:1)[[TYPENAME:PbDpnpSwitchEvent_Tval]]

typedef enum {
	PBSNCPWorkorProtToCC_protection<s(0)(0)(0)>[&] = 0,
	PBSNCPWorkorProtToCC_working<s(0)(0)(0)>[&] = 1,
	PBSNCPWorkorProtToCC_none<s(0)(0)(0)>[&] = 255
} PBSNCPWorkorProtToCC_Tval<s(0)(0)(0)>[&];(D1:PBSNCPWorkorProtToCC_Tval:1)[[TYPENAME:PBSNCPWorkorProtToCC_Tval]]

typedef enum {
	PbTPType_ospiTTP<s(0)(0)(0)>[&] = 1,
	PbTPType_rsDatacomCTP<s(0)(0)(0)>[&] = 2,
	PbTPType_rsTTP<s(0)(0)(0)>[&] = 3,
	PbTPType_msCTP<s(0)(0)(0)>[&] = 4,
	PbTPType_msDatacomCTP<s(0)(0)(0)>[&] = 5,
	PbTPType_msTTP<s(0)(0)(0)>[&] = 6,
	PbTPType_au4CTP<s(0)(0)(0)>[&] = 7,
	PbTPType_vc4TTP<s(0)(0)(0)>[&] = 8,
	PbTPType_tu12CTP<s(0)(0)(0)>[&] = 9,
	PbTPType_vc12TTP<s(0)(0)(0)>[&] = 10,
	PbTPType_ppiTTP<s(0)(0)(0)>[&] = 11,
	PbTPType_vc4xvTTP<s(0)(0)(0)>[&] = 12,
	PbTPType_vc12xvTTP<s(0)(0)(0)>[&] = 13,
	PbTPType_au416cCTP<s(0)(0)(0)>[&] = 14,
	PbTPType_vc416cTTP<s(0)(0)(0)>[&] = 15,
	PbTPType_au44cCTP<s(0)(0)(0)>[&] = 16,
	PbTPType_vc44cTTP<s(0)(0)(0)>[&] = 17,
	PbTPType_au3CTP<s(0)(0)(0)>[&] = 18,
	PbTPType_tu3CTP<s(0)(0)(0)>[&] = 19,
	PbTPType_hovc3TTP<s(0)(0)(0)>[&] = 20,
	PbTPType_lovc3TTP<s(0)(0)(0)>[&] = 21,
	PbTPType_tu11CTP<s(0)(0)(0)>[&] = 22,
	PbTPType_vc11TTP<s(0)(0)(0)>[&] = 23,
	PbTPType_lanTTP<s(0)(0)(0)>[&] = 24,
	PbTPType_wanTTP<s(0)(0)(0)>[&] = 25,
	PbTPType_au464cCTP<s(0)(0)(0)>[&] = 26,
	PbTPType_vc464cTTP<s(0)(0)(0)>[&] = 27,
	PbTPType_tcCTP<s(0)(0)(0)>[&] = 28,
	PbTPType_vpCTP<s(0)(0)(0)>[&] = 29,
	PbTPType_vcCTP<s(0)(0)(0)>[&] = 30,
	PbTPType_vc3xvTTP<s(0)(0)(0)>[&] = 31,
	PbTPType_vc4NIMTTP<s(0)(0)(0)>[&] = 32,
	PbTPType_vc12NIMTTP<s(0)(0)(0)>[&] = 33,
	PbTPType_vc416cNIMTTP<s(0)(0)(0)>[&] = 34,
	PbTPType_vc44cNIMTTP<s(0)(0)(0)>[&] = 35,
	PbTPType_hovc3NIMTTP<s(0)(0)(0)>[&] = 36,
	PbTPType_lovc3NIMTTP<s(0)(0)(0)>[&] = 37,
	PbTPType_vc11NIMTTP<s(0)(0)(0)>[&] = 38,
	PbTPType_vc464cNIMTTP<s(0)(0)(0)>[&] = 39,
	PbTPType_au4256cCTP<s(0)(0)(0)>[&] = 40,
	PbTPType_vc4256cTTP<s(0)(0)(0)>[&] = 41,
	PbTPType_vc4256cNIMTTP<s(0)(0)(0)>[&] = 42
} PbTPType_Tval<s(0)(0)(0)>[&];(D1:PbTPType_Tval:1)[[TYPENAME:PbTPType_Tval]]

typedef enum {
	PbMSPExternalCmd_cmdClear<s(0)(0)(0)>[&] = 1,
	PbMSPExternalCmd_cmdlockout<s(0)(0)(0)>[&] = 2,
	PbMSPExternalCmd_cmdforcedswitch<s(0)(0)(0)>[&] = 3,
	PbMSPExternalCmd_cmdmannualswitch<s(0)(0)(0)>[&] = 4,
	PbMSPExternalCmd_cmdexercise<s(0)(0)(0)>[&] = 5,
	PbMSPExternalCmd_cmdnocomand<s(0)(0)(0)>[&] = 6
} PbMSPExternalCmd_Tval<s(0)(0)(0)>[&];(D1:PbMSPExternalCmd_Tval:1)[[TYPENAME:PbMSPExternalCmd_Tval]]

typedef enum {
	TMSStClkOhm_seventyfive<s(0)(0)(0)>[&] = 1,
	TMSStClkOhm_onehundredtwenty<s(0)(0)(0)>[&] = 2
} TMSStClkOhm_Tval<s(0)(0)(0)>[&];(D1:TMSStClkOhm_Tval:1)[[TYPENAME:TMSStClkOhm_Tval]]

typedef enum {
	PbPmTableType_interval<s(0)(0)(0)>[&] = 1,
	PbPmTableType_intervalFe<s(0)(0)(0)>[&] = 2,
	PbPmTableType_day<s(0)(0)(0)>[&] = 3,
	PbPmTableType_dayFe<s(0)(0)(0)>[&] = 4
} PbPmTableType_Tval<s(0)(0)(0)>[&];(D1:PbPmTableType_Tval:1)[[TYPENAME:PbPmTableType_Tval]]

typedef enum {
	PbPortType_lan<s(0)(0)(0)>[&] = 1,
	PbPortType_console<s(0)(0)(0)>[&] = 2,
	PbPortType_stm1<s(0)(0)(0)>[&] = 3,
	PbPortType_stm4<s(0)(0)(0)>[&] = 4,
	PbPortType_stm16<s(0)(0)(0)>[&] = 5,
	PbPortType_stm64<s(0)(0)(0)>[&] = 6,
	PbPortType_fe<s(0)(0)(0)>[&] = 7,
	PbPortType_ge<s(0)(0)(0)>[&] = 8,
	PbPortType_e1<s(0)(0)(0)>[&] = 9,
	PbPortType_e3ds3<s(0)(0)(0)>[&] = 10,
	PbPortType_ti<s(0)(0)(0)>[&] = 11,
	PbPortType_to<s(0)(0)(0)>[&] = 12,
	PbPortType_vstm1<s(0)(0)(0)>[&] = 13,
	PbPortType_vstm4<s(0)(0)(0)>[&] = 14,
	PbPortType_vstm16<s(0)(0)(0)>[&] = 15,
	PbPortType_vlan<s(0)(0)(0)>[&] = 16,
	PbPortType_vwan<s(0)(0)(0)>[&] = 17,
	PbPortType_e1ds1<s(0)(0)(0)>[&] = 18,
	PbPortType_ivstm1<s(0)(0)(0)>[&] = 19,
	PbPortType_rprclient<s(0)(0)(0)>[&] = 20,
	PbPortType_rprline<s(0)(0)(0)>[&] = 21,
	PbPortType_oa<s(0)(0)(0)>[&] = 22,
	PbPortType_stm1or4<s(0)(0)(0)>[&] = 23,
	PbPortType_stm256<s(0)(0)(0)>[&] = 24,
	PbPortType_tenge<s(0)(0)(0)>[&] = 25,
	PbPortType_fiber_channel<s(0)(0)(0)>[&] = 26,
	PbPortType_vstm64<s(0)(0)(0)>[&] = 27,
	PbPortType_otu2<s(0)(0)(0)>[&] = 28,
	PbPortType_na<s(0)(0)(0)>[&] = 29
} PbPortType_Tval<s(0)(0)(0)>[&];(D1:PbPortType_Tval:1)[[TYPENAME:PbPortType_Tval]]

typedef enum {
	PbSncpCircuitDirection_bidirection<s(0)(0)(0)>[&] = 1,
	PbSncpCircuitDirection_unidirection<s(0)(0)(0)>[&] = 2
} PbSncpCircuitDirection_Tval<s(0)(0)(0)>[&];(D1:PbSncpCircuitDirection_Tval:1)[[TYPENAME:PbSncpCircuitDirection_Tval]]

typedef enum {
	PbPmPortStatusType_normal<s(0)(0)(0)>[&] = 1,
	PbPmPortStatusType_working<s(0)(0)(0)>[&] = 2,
	PbPmPortStatusType_protect<s(0)(0)(0)>[&] = 3
} PbPmPortStatusType_Tval<s(0)(0)(0)>[&];(D1:PbPmPortStatusType_Tval:1)[[TYPENAME:PbPmPortStatusType_Tval]]

typedef enum {
	PbTpMaintenanceType_normal<s(0)(0)(0)>[&] = 1,
	PbTpMaintenanceType_lck<s(0)(0)(0)>[&] = 5,
	PbTpMaintenanceType_oci<s(0)(0)(0)>[&] = 6,
	PbTpMaintenanceType_ais<s(0)(0)(0)>[&] = 7
} PbTpMaintenanceType_Tval<s(0)(0)(0)>[&];(D1:PbTpMaintenanceType_Tval:1)[[TYPENAME:PbTpMaintenanceType_Tval]]

typedef enum {
	PbMSPSwitchReason_clearcmd<s(0)(0)(0)>[&] = 1,
	PbMSPSwitchReason_lpcmd<s(0)(0)(0)>[&] = 2,
	PbMSPSwitchReason_forcedswitch<s(0)(0)(0)>[&] = 3,
	PbMSPSwitchReason_manualswitch<s(0)(0)(0)>[&] = 4,
	PbMSPSwitchReason_signalfail<s(0)(0)(0)>[&] = 5,
	PbMSPSwitchReason_signalfailclear<s(0)(0)(0)>[&] = 6,
	PbMSPSwitchReason_signaldeg<s(0)(0)(0)>[&] = 7,
	PbMSPSwitchReason_signaldegclear<s(0)(0)(0)>[&] = 8,
	PbMSPSwitchReason_noswitch<s(0)(0)(0)>[&] = 9
} PbMSPSwitchReason_Tval<s(0)(0)(0)>[&];(D1:PbMSPSwitchReason_Tval:1)[[TYPENAME:PbMSPSwitchReason_Tval]]

typedef enum {
	PbGmplsCcDirection_forward<s(0)(0)(0)>[&] = 1,
	PbGmplsCcDirection_reverse<s(0)(0)(0)>[&] = 2
} PbGmplsCcDirection_Tval<s(0)(0)(0)>[&];(D1:PbGmplsCcDirection_Tval:1)[[TYPENAME:PbGmplsCcDirection_Tval]]

typedef enum {
	EthPortClass_lan<s(0)(0)(0)>[&] = 0,
	EthPortClass_wan<s(0)(0)(0)>[&] = 1,
	EthPortClass_trunk<s(0)(0)(0)>[&] = 2
} EthPortClass_Tval<s(0)(0)(0)>[&];(D1:EthPortClass_Tval:1)[[TYPENAME:EthPortClass_Tval]]

typedef enum {
	TypeMibCmnd_inactive<s(0)(0)(0)>[&] = 0,
	TypeMibCmnd_activeScMibUpload<s(0)(0)(0)>[&] = 1,
	TypeMibCmnd_activeScMibDownload<s(0)(0)(0)>[&] = 2,
	TypeMibCmnd_activeScMibSwitch<s(0)(0)(0)>[&] = 3,
	TypeMibCmnd_standbyScMibSwitch<s(0)(0)(0)>[&] = 4,
	TypeMibCmnd_synchronizeMibBackup<s(0)(0)(0)>[&] = 5,
	TypeMibCmnd_activeScMibClear<s(0)(0)(0)>[&] = 6,
	TypeMibCmnd_activeScMibCopy<s(0)(0)(0)>[&] = 7,
	TypeMibCmnd_downloadLicense<s(0)(0)(0)>[&] = 8,
	TypeMibCmnd_synchronizeLicense<s(0)(0)(0)>[&] = 9,
	TypeMibCmnd_activeScMibPreserveClear<s(0)(0)(0)>[&] = 10
} TypeMibCmnd_Tval<s(0)(0)(0)>[&];(D1:TypeMibCmnd_Tval:1)[[TYPENAME:TypeMibCmnd_Tval]]

typedef enum {
	RowStatus_active<s(0)(0)(0)>[&] = 1,
	RowStatus_notInService<s(0)(0)(0)>[&] = 2,
	RowStatus_notReady<s(0)(0)(0)>[&] = 3,
	RowStatus_createAndGo<s(0)(0)(0)>[&] = 4,
	RowStatus_createAndWait<s(0)(0)(0)>[&] = 5,
	RowStatus_destroy<s(0)(0)(0)>[&] = 6
} RowStatus_Tval<s(0)(0)(0)>[&];(D1:RowStatus_Tval:1)[[TYPENAME:RowStatus_Tval]]

typedef enum {
	PbSNCPExternalCmd_cmdClear<s(0)(0)(0)>[&] = 1,
	PbSNCPExternalCmd_cmdlockout<s(0)(0)(0)>[&] = 2,
	PbSNCPExternalCmd_cmdforcedswitchtop<s(0)(0)(0)>[&] = 3,
	PbSNCPExternalCmd_cmdforcedswitchtow<s(0)(0)(0)>[&] = 4,
	PbSNCPExternalCmd_cmdmannualswitchtop<s(0)(0)(0)>[&] = 5,
	PbSNCPExternalCmd_cmdmannualswitchtow<s(0)(0)(0)>[&] = 6,
	PbSNCPExternalCmd_cmdnocomand<s(0)(0)(0)>[&] = 7
} PbSNCPExternalCmd_Tval<s(0)(0)(0)>[&];(D1:PbSNCPExternalCmd_Tval:1)[[TYPENAME:PbSNCPExternalCmd_Tval]]

typedef enum {
	RprProtectionType_steering<s(0)(0)(0)>[&] = 1,
	RprProtectionType_wrap<s(0)(0)(0)>[&] = 2,
	RprProtectionType_disable<s(0)(0)(0)>[&] = 3
} RprProtectionType_Tval<s(0)(0)(0)>[&];(D1:RprProtectionType_Tval:1)[[TYPENAME:RprProtectionType_Tval]]

typedef enum {
	PbNodeMode_standalone<s(0)(0)(0)>[&] = 1,
	PbNodeMode_subservient<s(0)(0)(0)>[&] = 2
} PbNodeMode_Tval<s(0)(0)(0)>[&];(D1:PbNodeMode_Tval:1)[[TYPENAME:PbNodeMode_Tval]]

typedef enum {
	PbAcDc_ac<s(0)(0)(0)>[&] = 1,
	PbAcDc_dc<s(0)(0)(0)>[&] = 2
} PbAcDc_Tval<s(0)(0)(0)>[&];(D1:PbAcDc_Tval:1)[[TYPENAME:PbAcDc_Tval]]

typedef enum {
	PbMsspRequest_noRequest<s(0)(0)(0)>[&] = 0,
	PbMsspRequest_reverseRequestRing<s(0)(0)(0)>[&] = 1,
	PbMsspRequest_reverseRequestSpan<s(0)(0)(0)>[&] = 2,
	PbMsspRequest_exerciserRing<s(0)(0)(0)>[&] = 3,
	PbMsspRequest_exerciserSpan<s(0)(0)(0)>[&] = 4,
	PbMsspRequest_waitToRestore<s(0)(0)(0)>[&] = 5,
	PbMsspRequest_manualSwitchRing<s(0)(0)(0)>[&] = 6,
	PbMsspRequest_manualSwitchSpan<s(0)(0)(0)>[&] = 7,
	PbMsspRequest_signalDegradeRing<s(0)(0)(0)>[&] = 8,
	PbMsspRequest_signalDegradeSpan<s(0)(0)(0)>[&] = 9,
	PbMsspRequest_signalDegradeProtection<s(0)(0)(0)>[&] = 10,
	PbMsspRequest_signalFailRing<s(0)(0)(0)>[&] = 11,
	PbMsspRequest_signalFailSpan<s(0)(0)(0)>[&] = 12,
	PbMsspRequest_forcedSwitchRing<s(0)(0)(0)>[&] = 13,
	PbMsspRequest_forcedSwitchSpan<s(0)(0)(0)>[&] = 14,
	PbMsspRequest_lockoutProtection<s(0)(0)(0)>[&] = 15
} PbMsspRequest_Tval<s(0)(0)(0)>[&];(D1:PbMsspRequest_Tval:1)[[TYPENAME:PbMsspRequest_Tval]]

typedef enum {
	PbConnectorType_unknown<s(0)(0)(0)>[&] = 0,
	PbConnectorType_sc<s(0)(0)(0)>[&] = 1,
	PbConnectorType_fiber_1_copper<s(0)(0)(0)>[&] = 2,
	PbConnectorType_fiber_2_copper<s(0)(0)(0)>[&] = 3,
	PbConnectorType_bnctnc<s(0)(0)(0)>[&] = 4,
	PbConnectorType_fiber_coax<s(0)(0)(0)>[&] = 5,
	PbConnectorType_fiber_jack<s(0)(0)(0)>[&] = 6,
	PbConnectorType_lc<s(0)(0)(0)>[&] = 7,
	PbConnectorType_mtrj<s(0)(0)(0)>[&] = 8,
	PbConnectorType_mu<s(0)(0)(0)>[&] = 9,
	PbConnectorType_sg<s(0)(0)(0)>[&] = 10,
	PbConnectorType_optical_pigtail<s(0)(0)(0)>[&] = 11,
	PbConnectorType_hssdc<s(0)(0)(0)>[&] = 32,
	PbConnectorType_copper_pigtail<s(0)(0)(0)>[&] = 33,
	PbConnectorType_unspecified<s(0)(0)(0)>[&] = 256
} PbConnectorType_Tval<s(0)(0)(0)>[&];(D1:PbConnectorType_Tval:1)[[TYPENAME:PbConnectorType_Tval]]

typedef enum {
	PbBoardProperty_none<s(0)(0)(0)>[&] = 0,
	PbBoardProperty_all<s(0)(0)(0)>[&] = 1,
	PbBoardProperty_hiT7065sc<s(0)(0)(0)>[&] = 2,
	PbBoardProperty_hiT7065cc<s(0)(0)(0)>[&] = 4,
	PbBoardProperty_hiT7065lc<s(0)(0)(0)>[&] = 8
} PbBoardProperty_Tval<s(0)(0)(0)>[&];(D1:PbBoardProperty_Tval:1)[[TYPENAME:PbBoardProperty_Tval]]

 




 




 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbSonetSdh_Did<s(0)(0)(0)>[&];(D1:pbSonetSdh_Did:0)

   


 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbPortConfigTable_Did<s(0)(0)(0)>[&];(D1:pbPortConfigTable_Did:0)

   
typedef enum {
	pbPortMode_auto<s(0)(0)(0)>[&]=1,
	pbPortMode_mon<s(0)(0)(0)>[&]=2,
	pbPortMode_nmon<s(0)(0)(0)>[&]=3
} pbPortMode_Tval<s(0)(0)(0)>[&];(D1:pbPortMode_Tval:1)[[TYPENAME:pbPortMode_Tval]]

typedef enum {
	pbPdhPortMap_async<s(0)(0)(0)>[&]=1,
	pbPdhPortMap_byte<s(0)(0)(0)>[&]=2,
	pbPdhPortMap_none<s(0)(0)(0)>[&]=3
} pbPdhPortMap_Tval<s(0)(0)(0)>[&];(D1:pbPdhPortMap_Tval:1)[[TYPENAME:pbPdhPortMap_Tval]]

typedef enum {
	pbPortLoopback_none<s(0)(0)(0)>[&]=1,
	pbPortLoopback_outward<s(0)(0)(0)>[&]=2,
	pbPortLoopback_inward<s(0)(0)(0)>[&]=3
} pbPortLoopback_Tval<s(0)(0)(0)>[&];(D1:pbPortLoopback_Tval:1)[[TYPENAME:pbPortLoopback_Tval]]

typedef enum {
	pbFecMode_correction<s(0)(0)(0)>[&]=1,
	pbFecMode_disable<s(0)(0)(0)>[&]=2
} pbFecMode_Tval<s(0)(0)(0)>[&];(D1:pbFecMode_Tval:1)[[TYPENAME:pbFecMode_Tval]]

typedef enum {
	pbImpedance_ohm75<s(0)(0)(0)>[&]=0,
	pbImpedance_ohm120<s(0)(0)(0)>[&]=1,
	pbImpedance_ohm100<s(0)(0)(0)>[&]=2,
	pbImpedance_ohm110<s(0)(0)(0)>[&]=3
} pbImpedance_Tval<s(0)(0)(0)>[&];(D1:pbImpedance_Tval:1)[[TYPENAME:pbImpedance_Tval]]

typedef enum {
	pbCodeType_hdb3<s(0)(0)(0)>[&]=0,
	pbCodeType_ami<s(0)(0)(0)>[&]=1,
	pbCodeType_bypass<s(0)(0)(0)>[&]=2,
	pbCodeType_cdrbypass<s(0)(0)(0)>[&]=3,
	pbCodeType_b3zs<s(0)(0)(0)>[&]=4
} pbCodeType_Tval<s(0)(0)(0)>[&];(D1:pbCodeType_Tval:1)[[TYPENAME:pbCodeType_Tval]]

typedef enum {
	pbHaulType_e175ohm<s(0)(0)(0)>[&]=0,
	pbHaulType_e1120ohm<s(0)(0)(0)>[&]=1,
	pbHaulType_dsx1133ft<s(0)(0)(0)>[&]=2,
	pbHaulType_dsx1266ft<s(0)(0)(0)>[&]=3,
	pbHaulType_dsx1399ft<s(0)(0)(0)>[&]=4,
	pbHaulType_dsx1533ft<s(0)(0)(0)>[&]=5,
	pbHaulType_dsx1655ft<s(0)(0)(0)>[&]=6,
	pbHaulType_j10655ft<s(0)(0)(0)>[&]=7,
	pbHaulType_ds10<s(0)(0)(0)>[&]=8,
	pbHaulType_ds175<s(0)(0)(0)>[&]=9,
	pbHaulType_ds115<s(0)(0)(0)>[&]=10,
	pbHaulType_ds1225<s(0)(0)(0)>[&]=11,
	pbHaulType_ds111xx<s(0)(0)(0)>[&]=12
} pbHaulType_Tval<s(0)(0)(0)>[&];(D1:pbHaulType_Tval:1)[[TYPENAME:pbHaulType_Tval]]

typedef enum {
	pbRetimingStatus_disable<s(0)(0)(0)>[&]=0,
	pbRetimingStatus_enable<s(0)(0)(0)>[&]=1
} pbRetimingStatus_Tval<s(0)(0)(0)>[&];(D1:pbRetimingStatus_Tval:1)[[TYPENAME:pbRetimingStatus_Tval]]

typedef enum {
	pbPortAlsMode_no_command<s(0)(0)(0)>[&]=0,
	pbPortAlsMode_manual_restart<s(0)(0)(0)>[&]=1,
	pbPortAlsMode_manual_test<s(0)(0)(0)>[&]=2
} pbPortAlsMode_Tval<s(0)(0)(0)>[&];(D1:pbPortAlsMode_Tval:1)[[TYPENAME:pbPortAlsMode_Tval]]

typedef enum {
	expectedFrameStructure_none<s(0)(0)(0)>[&]=0,
	expectedFrameStructure_e1_framed<s(0)(0)(0)>[&]=1,
	expectedFrameStructure_e1_unframed<s(0)(0)(0)>[&]=2,
	expectedFrameStructure_e3_G751<s(0)(0)(0)>[&]=3,
	expectedFrameStructure_e3_G832<s(0)(0)(0)>[&]=4,
	expectedFrameStructure_ds3_M13<s(0)(0)(0)>[&]=5,
	expectedFrameStructure_ds3_CBit<s(0)(0)(0)>[&]=6,
	expectedFrameStructure_e3_unframed<s(0)(0)(0)>[&]=7,
	expectedFrameStructure_ds3_unframed<s(0)(0)(0)>[&]=8
} expectedFrameStructure_Tval<s(0)(0)(0)>[&];(D1:expectedFrameStructure_Tval:1)[[TYPENAME:expectedFrameStructure_Tval]]

typedef enum {
	crcMultiframeDetector_activated<s(0)(0)(0)>[&]=1,
	crcMultiframeDetector_deactivated<s(0)(0)(0)>[&]=2
} crcMultiframeDetector_Tval<s(0)(0)(0)>[&];(D1:crcMultiframeDetector_Tval:1)[[TYPENAME:crcMultiframeDetector_Tval]]

typedef enum {
	portClassification_nongmpls<s(0)(0)(0)>[&]=0,
	portClassification_inni<s(0)(0)(0)>[&]=1,
	portClassification_enni<s(0)(0)(0)>[&]=2,
	portClassification_uni10<s(0)(0)(0)>[&]=3,
	portClassification_uni20<s(0)(0)(0)>[&]=4
} portClassification_Tval<s(0)(0)(0)>[&];(D1:portClassification_Tval:1)[[TYPENAME:portClassification_Tval]]

typedef enum {
	portOperationLock_none<s(0)(0)(0)>[&]=1,
	portOperationLock_nms<s(0)(0)(0)>[&]=2,
	portOperationLock_gmpls<s(0)(0)(0)>[&]=3
} portOperationLock_Tval<s(0)(0)(0)>[&];(D1:portOperationLock_Tval:1)[[TYPENAME:portOperationLock_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                               
	PbPortType_Tval<s(1)(1)(0)>[T] pbPortType<s(1)(1)(0)>[&];                                          
	int		pbPortNo<s(1)(1)(0)>[&];                                                       
	char		pbPortLabel<s(1)(1)(0)>[&][64];   
	pbPortMode_Tval<s(1)(1)(0)>[T] pbPortMode<s(1)(1)(0)>[&];   
	pbPdhPortMap_Tval<s(1)(1)(0)>[T] pbPdhPortMap<s(1)(1)(0)>[&];   
	PbPortStatus_Tval<s(1)(1)(0)>[T] pbPortAdminStatus<s(1)(1)(0)>[&];   
	PbEnableDisable_Tval<s(1)(1)(0)>[T] pbPortMapRefresh<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbPortAutoLaserShutdown<s(1)(1)(0)>[&];   
	pbPortLoopback_Tval<s(1)(1)(0)>[T] pbPortLoopback<s(1)(1)(0)>[&];   
	pbFecMode_Tval<s(1)(1)(0)>[T] pbFecMode<s(1)(1)(0)>[&];   
	PbActualPortType_Tval<s(1)(1)(0)>[T] pbActualPortType<s(1)(1)(0)>[&];   
	pbImpedance_Tval<s(1)(1)(0)>[T] pbImpedance<s(1)(1)(0)>[&];   
	pbCodeType_Tval<s(1)(1)(0)>[T] pbCodeType<s(1)(1)(0)>[&];   
	pbHaulType_Tval<s(1)(1)(0)>[T] pbHaulType<s(1)(1)(0)>[&];   
	pbRetimingStatus_Tval<s(1)(1)(0)>[T] pbRetimingStatus<s(1)(1)(0)>[&];   
	pbPortAlsMode_Tval<s(1)(1)(0)>[T] pbPortAlsMode<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbPortAlarmDisable<s(1)(1)(0)>[&];   
	expectedFrameStructure_Tval<s(1)(1)(0)>[T] expectedFrameStructure<s(1)(1)(0)>[&];
	crcMultiframeDetector_Tval<s(1)(1)(0)>[T] crcMultiframeDetector<s(1)(1)(0)>[&];
	portClassification_Tval<s(1)(1)(0)>[T] portClassification<s(1)(1)(0)>[&];
	PbUsageStatus_Tval<s(1)(1)(0)>[T] portUsageStatus<s(1)(1)(0)>[&];
	int		portMappingString_len<s(1)(1)(0)>[&];
	char		portMappingString<s(1)(1)(0)>[&][384];
	portOperationLock_Tval<s(1)(1)(0)>[T] portOperationLock<s(1)(1)(0)>[&];
}MIBpbPortConfigTable_t<s(0)(0)(0)>[&];(D1:MIBpbPortConfigTable_t:1)[[TYPENAME:MIBpbPortConfigTable_t]]































 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbPortStatusTable_Did<s(0)(0)(0)>[&];(D1:pbPortStatusTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                       
	PbPortType_Tval<s(1)(1)(0)>[T] pbPortType<s(1)(1)(0)>[&];                               
	int		pbPortNo<s(1)(1)(0)>[&];                                            
	int		pbPortStatus<s(1)(1)(0)>[&];   
	PbPortOperationStatus_Tval<s(1)(1)(0)>[T] pbPortOperStatus<s(1)(1)(0)>[&];   
	int		pbLaserIBias<s(1)(1)(0)>[&];   
	int		pbLaserRecvPwr<s(1)(1)(0)>[&];   
	int		pbLaserTransPwr<s(1)(1)(0)>[&];   
	int		pbLaserTemp<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbCompliance8472<s(1)(1)(0)>[&];   
	int		pbnNominalMBps<s(1)(1)(0)>[&];   
	int		pbnWavelength<s(1)(1)(0)>[&];   
	int		pbnLinkLength9125<s(1)(1)(0)>[&];   
	int		pbnLinkLength50125<s(1)(1)(0)>[&];   
	int		pbnLinkLength62125<s(1)(1)(0)>[&];   
	int		pbnLinkLengthCopper<s(1)(1)(0)>[&];   
	char		pbsVendorName<s(1)(1)(0)>[&][20];   
	char		pbsVendorPN<s(1)(1)(0)>[&][20];   
	char		pbsVendorSN<s(1)(1)(0)>[&][20];   
	char		pbsManuDate<s(1)(1)(0)>[&][16];   
	PbSFFTranscCode_Tval<s(1)(1)(0)>[T] pbnTransCode<s(1)(1)(0)>[&];   
	char		pbsVendorOUI<s(1)(1)(0)>[&][16];   
	PbConnectorType_Tval<s(1)(1)(0)>[T] pbnConnectorType<s(1)(1)(0)>[&];   
	int		pbnClLaserTemp<s(1)(1)(0)>[&];
	int		pbnTECCurrent<s(1)(1)(0)>[&];
	char		pbsSAGPartNumber<s(1)(1)(0)>[&][20];
}MIBpbPortStatusTable_t<s(0)(0)(0)>[&];(D1:MIBpbPortStatusTable_t:1)[[TYPENAME:MIBpbPortStatusTable_t]]

































 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbPortHoTpReserveTable_Did<s(0)(0)(0)>[&];(D1:pbPortHoTpReserveTable_Did:0)

   
typedef enum {
	tpOperationLock_none<s(0)(0)(0)>[&]=1,
	tpOperationLock_nms<s(0)(0)(0)>[&]=2,
	tpOperationLock_gmpls<s(0)(0)(0)>[&]=3
} tpOperationLock_Tval<s(0)(0)(0)>[&];(D1:tpOperationLock_Tval:1)[[TYPENAME:tpOperationLock_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                           
	PbPortType_Tval<s(1)(1)(0)>[T] pbPortType<s(1)(1)(0)>[&];                                   
	int		pbPortNo<s(1)(1)(0)>[&];                                                
	int		vc4ReservationStatus_len<s(1)(1)(0)>[&];
	char		vc4ReservationStatus<s(1)(1)(0)>[&][256];   
	int		vc4ReservationOperate_len<s(1)(1)(0)>[&];
	char		vc4ReservationOperate<s(1)(1)(0)>[&][257];   
	tpOperationLock_Tval<s(1)(1)(0)>[T] tpOperationLock<s(1)(1)(0)>[&];   
}MIBpbPortHoTpReserveTable_t<s(0)(0)(0)>[&];(D1:MIBpbPortHoTpReserveTable_t:1)[[TYPENAME:MIBpbPortHoTpReserveTable_t]]













 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbTPConfigTable_Did<s(0)(0)(0)>[&];(D1:pbTPConfigTable_Did:0)

   
typedef enum {
	pbSdMode_poisson<s(0)(0)(0)>[&]=1,
	pbSdMode_bursty<s(0)(0)(0)>[&]=2
} pbSdMode_Tval<s(0)(0)(0)>[&];(D1:pbSdMode_Tval:1)[[TYPENAME:pbSdMode_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                               
	PbPortType_Tval<s(1)(1)(0)>[T] pbPortType<s(1)(1)(0)>[&];                                       
	int		pbPortNo<s(1)(1)(0)>[&];                                                    
	PbTPType_Tval<s(1)(1)(0)>[T] pbTpType<s(1)(1)(0)>[&];                                              
	int		pbTpIndex<s(1)(1)(0)>[&];                                                      
	TruthValue_Tval<s(1)(1)(0)>[T] pbMonitored<s(1)(1)(0)>[&];   
	PbSignalType_Tval<s(1)(1)(0)>[T] pbOutSignalType<s(1)(1)(0)>[&];
	PbInSignalType_Tval<s(1)(1)(0)>[T] pbInSignalType<s(1)(1)(0)>[&];   
	int		pbTransPsl<s(1)(1)(0)>[&];   
	int		pbExpPsl<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbSLEnable<s(1)(1)(0)>[&];   
	int		pbSLAccept<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbTtiEnabled<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbTimAisDis<s(1)(1)(0)>[&];
	PbTIModeType_Tval<s(1)(1)(0)>[T] pbTtiTransmitMode<s(1)(1)(0)>[&];   
	PbTIModeType_Tval<s(1)(1)(0)>[T] pbTtiReceiveMode<s(1)(1)(0)>[&];   
	int		pbTtiOctetTransmitted_len<s(1)(1)(0)>[&];
	char		pbTtiOctetTransmitted<s(1)(1)(0)>[&][65];   
	int		pbTtiOctetExpected_len<s(1)(1)(0)>[&];
	char		pbTtiOctetExpected<s(1)(1)(0)>[&][65];   
	int		pbTtiOctetAccepted_len<s(1)(1)(0)>[&];
	char		pbTtiOctetAccepted<s(1)(1)(0)>[&][65];   
	pbSdMode_Tval<s(1)(1)(0)>[T] pbSdMode<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbBurstyEnable<s(1)(1)(0)>[&];   
	int		pbBurstyPeriod<s(1)(1)(0)>[&];   
	int		pbBurstyPercent<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbDegEnable<s(1)(1)(0)>[&];   
	int		pbDegThreshold<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbExcEnable<s(1)(1)(0)>[&];   
	int		pbExcThreshold<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbAISEnable<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbRDIEnable<s(1)(1)(0)>[&];   
	PbPmMonitor_Tval<s(1)(1)(0)>[T] pmNearEnd15minMonitored<s(1)(1)(0)>[&];
	PbPmMonitor_Tval<s(1)(1)(0)>[T] pmFarEnd15minMonitored<s(1)(1)(0)>[&];
	PbPmMonitor_Tval<s(1)(1)(0)>[T] pmNearEnd24hrMonitored<s(1)(1)(0)>[&];
	PbPmMonitor_Tval<s(1)(1)(0)>[T] pmFarEnd24hrMonitored<s(1)(1)(0)>[&];
}MIBpbTPConfigTable_t<s(0)(0)(0)>[&];(D1:MIBpbTPConfigTable_t:1)[[TYPENAME:MIBpbTPConfigTable_t]]








































 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbOTUPortConfigTable_Did<s(0)(0)(0)>[&];(D1:pbOTUPortConfigTable_Did:0)

   
typedef enum {
	pbOTUPortMode_auto<s(0)(0)(0)>[&]=1,
	pbOTUPortMode_mon<s(0)(0)(0)>[&]=2,
	pbOTUPortMode_nmon<s(0)(0)(0)>[&]=3
} pbOTUPortMode_Tval<s(0)(0)(0)>[&];(D1:pbOTUPortMode_Tval:1)[[TYPENAME:pbOTUPortMode_Tval]]

typedef enum {
	pbOTUPortLoopback_none<s(0)(0)(0)>[&]=1,
	pbOTUPortLoopback_outward<s(0)(0)(0)>[&]=2,
	pbOTUPortLoopback_inward<s(0)(0)(0)>[&]=3
} pbOTUPortLoopback_Tval<s(0)(0)(0)>[&];(D1:pbOTUPortLoopback_Tval:1)[[TYPENAME:pbOTUPortLoopback_Tval]]

typedef enum {
	pbInsFecErrRate_errE3<s(0)(0)(0)>[&]=3,
	pbInsFecErrRate_errE4<s(0)(0)(0)>[&]=4,
	pbInsFecErrRate_errE5<s(0)(0)(0)>[&]=5
} pbInsFecErrRate_Tval<s(0)(0)(0)>[&];(D1:pbInsFecErrRate_Tval:1)[[TYPENAME:pbInsFecErrRate_Tval]]

typedef enum {
	pbOTUFecMode_rsfec<s(0)(0)(0)>[&]=0,
	pbOTUFecMode_ufec<s(0)(0)(0)>[&]=1
} pbOTUFecMode_Tval<s(0)(0)(0)>[&];(D1:pbOTUFecMode_Tval:1)[[TYPENAME:pbOTUFecMode_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                       
	PbPortType_Tval<s(1)(1)(0)>[T] pbPortType<s(1)(1)(0)>[&];                                               
	int		pbPortNo<s(1)(1)(0)>[&];                                                            
	char		pbOTUPortLabel<s(1)(1)(0)>[&][65];   
	pbOTUPortMode_Tval<s(1)(1)(0)>[T] pbOTUPortMode<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbOTUPortAlarmDisable<s(1)(1)(0)>[&];   
	pbOTUPortLoopback_Tval<s(1)(1)(0)>[T] pbOTUPortLoopback<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbFecEnable<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbInsFecErrEnable<s(1)(1)(0)>[&];   
	pbInsFecErrRate_Tval<s(1)(1)(0)>[T] pbInsFecErrRate<s(1)(1)(0)>[&];   
	int		pbWaveLengthId<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbSMTimAlmEnable<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbSMTimActEnable<s(1)(1)(0)>[&];   
	int		pbSMTxTti_len<s(1)(1)(0)>[&];
	char		pbSMTxTti<s(1)(1)(0)>[&][65];   
	int		pbSMExpTti_len<s(1)(1)(0)>[&];
	char		pbSMExpTti<s(1)(1)(0)>[&][65];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbPTAlmEnable<s(1)(1)(0)>[&];   
	int		pbTxPt<s(1)(1)(0)>[&];   
	int		pbExpPt<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbCIDAlmEnable<s(1)(1)(0)>[&];   
	int		pbTxChannelId<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbAutoAdjustManulStopEnable<s(1)(1)(0)>[&];   
	int		pbPortPathMapping_len<s(1)(1)(0)>[&];
	char		pbPortPathMapping<s(1)(1)(0)>[&][9];   
	pbOTUFecMode_Tval<s(1)(1)(0)>[T] pbOTUFecMode<s(1)(1)(0)>[&];   
	PbPortStatus_Tval<s(1)(1)(0)>[T] pbOTUPortAdminStatus<s(1)(1)(0)>[&];   
	PbUsageStatus_Tval<s(1)(1)(0)>[T] pbOTUPortUsageStatus<s(1)(1)(0)>[&];   
}MIBpbOTUPortConfigTable_t<s(0)(0)(0)>[&];(D1:MIBpbOTUPortConfigTable_t:1)[[TYPENAME:MIBpbOTUPortConfigTable_t]]
































 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbPRBSPortHisTable_Did<s(0)(0)(0)>[&];(D1:pbPRBSPortHisTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                               
	int		pbPortNo<s(1)(1)(0)>[&];                                                    
	PbPortType_Tval<s(1)(1)(0)>[T] pbPortType<s(1)(1)(0)>[&];                                       
	unsigned int	pbPRBSHisErrorSeconds<s(1)(1)(0)>[&];   
	int		pbPRBSHisMeanError<s(1)(1)(0)>[&];
	char		pbPRBSTrapTimeStamp<s(1)(1)(0)>[&][15];   
	PbActualPortType_Tval<s(1)(1)(0)>[T] pbPRBSHisActualPortType<s(1)(1)(0)>[&];   
}MIBpbPRBSPortHisTable_t<s(0)(0)(0)>[&];(D1:MIBpbPRBSPortHisTable_t:1)[[TYPENAME:MIBpbPRBSPortHisTable_t]]














 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbPRBSPortCurTable_Did<s(0)(0)(0)>[&];(D1:pbPRBSPortCurTable_Did:0)

   
typedef enum {
	pbPRBSPattern_na<s(0)(0)(0)>[&]=0,
	pbPRBSPattern_power15<s(0)(0)(0)>[&]=1,
	pbPRBSPattern_power20<s(0)(0)(0)>[&]=2,
	pbPRBSPattern_power23<s(0)(0)(0)>[&]=3
} pbPRBSPattern_Tval<s(0)(0)(0)>[&];(D1:pbPRBSPattern_Tval:1)[[TYPENAME:pbPRBSPattern_Tval]]

typedef enum {
	pbPRBSStatus_na<s(0)(0)(0)>[&]=0,
	pbPRBSStatus_syncing<s(0)(0)(0)>[&]=1,
	pbPRBSStatus_syncSucc<s(0)(0)(0)>[&]=2,
	pbPRBSStatus_syncFail<s(0)(0)(0)>[&]=3,
	pbPRBSStatus_syncError<s(0)(0)(0)>[&]=4
} pbPRBSStatus_Tval<s(0)(0)(0)>[&];(D1:pbPRBSStatus_Tval:1)[[TYPENAME:pbPRBSStatus_Tval]]

typedef enum {
	prbsMode_normal<s(0)(0)(0)>[&]=0,
	prbsMode_invert<s(0)(0)(0)>[&]=1
} prbsMode_Tval<s(0)(0)(0)>[&];(D1:prbsMode_Tval:1)[[TYPENAME:prbsMode_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                         
	int		pbPortNo<s(1)(1)(0)>[&];                                              
	PbPortType_Tval<s(1)(1)(0)>[T] pbPortType<s(1)(1)(0)>[&];                                 
	TruthValue_Tval<s(1)(1)(0)>[T] pbPRBSEnable<s(1)(1)(0)>[&];   
	pbPRBSPattern_Tval<s(1)(1)(0)>[T] pbPRBSPattern<s(1)(1)(0)>[&];   
	unsigned int	pbPRBSErrorBlocks<s(1)(1)(0)>[&];   
	unsigned int	pbPRBSErrorSeconds<s(1)(1)(0)>[&];   
	pbPRBSStatus_Tval<s(1)(1)(0)>[T] pbPRBSStatus<s(1)(1)(0)>[&];   
	PbActualPortType_Tval<s(1)(1)(0)>[T] pbPRBSActualPortType<s(1)(1)(0)>[&];   
	prbsMode_Tval<s(1)(1)(0)>[T] prbsMode<s(1)(1)(0)>[&];   
}MIBpbPRBSPortCurTable_t<s(0)(0)(0)>[&];(D1:MIBpbPRBSPortCurTable_t:1)[[TYPENAME:MIBpbPRBSPortCurTable_t]]

















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbOTUPortStatusTable_Did<s(0)(0)(0)>[&];(D1:pbOTUPortStatusTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];           
	PbPortType_Tval<s(1)(1)(0)>[T] pbPortType<s(1)(1)(0)>[&];                   
	int		pbPortNo<s(1)(1)(0)>[&];                                
	int		pbSMRxTti_len<s(1)(1)(0)>[&];
	char		pbSMRxTti<s(1)(1)(0)>[&][65];   
	int		pbRxPt<s(1)(1)(0)>[&];   
	int		pbRxChannelId<s(1)(1)(0)>[&];   
}MIBpbOTUPortStatusTable_t<s(0)(0)(0)>[&];(D1:MIBpbOTUPortStatusTable_t:1)[[TYPENAME:MIBpbOTUPortStatusTable_t]]













 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbOTUTPConfigTable_Did<s(0)(0)(0)>[&];(D1:pbOTUTPConfigTable_Did:0)

   
typedef enum {
	pbOTUTpType_none<s(0)(0)(0)>[&]=0,
	pbOTUTpType_otu1<s(0)(0)(0)>[&]=1,
	pbOTUTpType_otu2<s(0)(0)(0)>[&]=2,
	pbOTUTpType_odu21<s(0)(0)(0)>[&]=3,
	pbOTUTpType_otu3<s(0)(0)(0)>[&]=4,
	pbOTUTpType_odu31<s(0)(0)(0)>[&]=5,
	pbOTUTpType_odu32<s(0)(0)(0)>[&]=6,
	pbOTUTpType_odu321<s(0)(0)(0)>[&]=7,
	pbOTUTpType_otu4<s(0)(0)(0)>[&]=8,
	pbOTUTpType_odu41<s(0)(0)(0)>[&]=9,
	pbOTUTpType_odu42<s(0)(0)(0)>[&]=10,
	pbOTUTpType_odu421<s(0)(0)(0)>[&]=11,
	pbOTUTpType_odu43<s(0)(0)(0)>[&]=12,
	pbOTUTpType_odu431<s(0)(0)(0)>[&]=13,
	pbOTUTpType_odu432<s(0)(0)(0)>[&]=14,
	pbOTUTpType_odu4321<s(0)(0)(0)>[&]=15
} pbOTUTpType_Tval<s(0)(0)(0)>[&];(D1:pbOTUTpType_Tval:1)[[TYPENAME:pbOTUTpType_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                     
	PbPortType_Tval<s(1)(1)(0)>[T] pbPortType<s(1)(1)(0)>[&];                                             
	int		pbPortNo<s(1)(1)(0)>[&];                                                          
	int		pbOTUTpChannelId<s(1)(1)(0)>[&];                                                     
	PbTpSegment_Tval<s(1)(1)(0)>[T] pbOTUTpSegment<s(1)(1)(0)>[&];                                           
	pbOTUTpType_Tval<s(1)(1)(0)>[T] pbOTUTpType<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbOTUMonitored<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbOTUTimAlmEnable<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbOTUTimActEnable<s(1)(1)(0)>[&];   
	int		pbOTUTxTti_len<s(1)(1)(0)>[&];
	char		pbOTUTxTti<s(1)(1)(0)>[&][65];   
	int		pbOTUExpTti_len<s(1)(1)(0)>[&];
	char		pbOTUExpTti<s(1)(1)(0)>[&][65];   
	int		pbOTURxTti_len<s(1)(1)(0)>[&];
	char		pbOTURxTti<s(1)(1)(0)>[&][65];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbOTUDegEnable<s(1)(1)(0)>[&];   
	int		pbOTUDegThreshold<s(1)(1)(0)>[&];   
	int		pbOTUDegIntervals<s(1)(1)(0)>[&];   
	PbTpMaintenanceType_Tval<s(1)(1)(0)>[T] pbOTUSendMaintenanceType<s(1)(1)(0)>[&];   
	PbTpMaintenanceType_Tval<s(1)(1)(0)>[T] pbOTURecvMaintenanceType<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbOTUPlmAlmEnable<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbOTUMsimAlmEnable<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbOTUPtAlmEnable<s(1)(1)(0)>[&];   
	int		pbOTUTxPt<s(1)(1)(0)>[&];   
	int		pbOTUExpPt<s(1)(1)(0)>[&];   
	int		pbOTURxPt<s(1)(1)(0)>[&];   
	PbPmMonitor_Tval<s(1)(1)(0)>[T] pmOTUNearEnd15minMonitored<s(1)(1)(0)>[&];   
	PbPmMonitor_Tval<s(1)(1)(0)>[T] pmOTUFarEnd15minMonitored<s(1)(1)(0)>[&];   
	PbPmMonitor_Tval<s(1)(1)(0)>[T] pmOTUNearEnd24hrMonitored<s(1)(1)(0)>[&];   
	PbPmMonitor_Tval<s(1)(1)(0)>[T] pmOTUFarEnd24hrMonitored<s(1)(1)(0)>[&];   
}MIBpbOTUTPConfigTable_t<s(0)(0)(0)>[&];(D1:MIBpbOTUTPConfigTable_t:1)[[TYPENAME:MIBpbOTUTPConfigTable_t]]


































 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbSonetModule_Did<s(0)(0)(0)>[&];(D1:pbSonetModule_Did:0)

   
















 



typedef struct
{
        UINT32<s(1)(1)(0)>[T]  ulPortId<s(1)(1)(0)>[&];       
        PbPortType_Tval<s(1)(1)(0)>[T] ulPortType<s(1)(1)(0)>[&];

         

        UINT32<s(1)(1)(0)>[T]  ulTug3Num<s(1)(1)(0)>[&];
        
        UINT16<s(1)(1)(0)>[T] ausTug3Mapping<s(1)(1)(0)>[&][192 ];
}PORT_TUG3_MAPPING_T<s(0)(0)(0)>[&];(D1:PORT_TUG3_MAPPING_T:1)[[TYPENAME:PORT_TUG3_MAPPING_T]]  

 
typedef struct
{
        UINT32<s(1)(1)(0)>[T]  ulPortId<s(1)(1)(0)>[&];       
        PbPortType_Tval<s(1)(1)(0)>[T] ulPortType<s(1)(1)(0)>[&];

        UINT32<s(1)(1)(0)>[T]  ulTug3Num<s(1)(1)(0)>[&];

        UINT16<s(1)(1)(0)>[T] ausTug3Mapping<s(1)(1)(0)>[&][1];    
}MSG_PORT_TUG3_MAPPING_T<s(0)(0)(0)>[&];(D1:MSG_PORT_TUG3_MAPPING_T:1)[[TYPENAME:MSG_PORT_TUG3_MAPPING_T]]  

 






















 
















 














 





















typedef struct
{
        UINT32<s(1)(1)(0)>[T]  nPortId<s(1)(1)(0)>[&];     

         
        PbPortOperationStatus_Tval<s(1)(1)(0)>[T] eLaserOn<s(1)(1)(0)>[&];    

 
        
        int         nLaserIBias<s(1)(1)(0)>[&];
        int         nLaserRecvPwr<s(1)(1)(0)>[&];
        int         nLaserTransPwr<s(1)(1)(0)>[&];
        int         nLaserTemp<s(1)(1)(0)>[&];

  

	TruthValue_Tval<s(1)(1)(0)>[T] pbCompliance8472<s(1)(1)(0)>[&];   
	int		pbnNominalMBps<s(1)(1)(0)>[&];   
	int		pbnWavelength<s(1)(1)(0)>[&];   
	int		pbnLinkLength9125<s(1)(1)(0)>[&];   
	int		pbnLinkLength50125<s(1)(1)(0)>[&];   
	int		pbnLinkLength62125<s(1)(1)(0)>[&];   
	int		pbnLinkLengthCopper<s(1)(1)(0)>[&];   
	char		pbsVendorName<s(1)(1)(0)>[&][20];   
	char		pbsVendorPN<s(1)(1)(0)>[&][20];   
	char		pbsVendorSN<s(1)(1)(0)>[&][20];   
	char		pbsManuDate<s(1)(1)(0)>[&][16];   
	PbSFFTranscCode_Tval<s(1)(1)(0)>[T] pbnTransCode<s(1)(1)(0)>[&];   
	char		pbsVendorOUI<s(1)(1)(0)>[&][16];   
	PbConnectorType_Tval<s(1)(1)(0)>[T] pbnConnectorType<s(1)(1)(0)>[&];  
    int     pbnClLaserTemp<s(1)(1)(0)>[&];  
    int     pbnTECCurrent<s(1)(1)(0)>[&];   
    char    pbsSagPN<s(1)(1)(0)>[&][20];  
}__attribute__ ((packed))  PORT_STATUS_T<s(0)(0)(0)>[&];(D1:PORT_STATUS_T:1)[[TYPENAME:PORT_STATUS_T]]  

 


 



























typedef struct
{
    UINT8<s(1)(1)(0)>[T]  slotNo<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]  portType<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]  portNo<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T] mappingStrLen<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]  mappingStr<s(1)(1)(0)>[&][0];
}__attribute__ ((packed))  PORT_MAPPING_T<s(0)(0)(0)>[&];(D1:PORT_MAPPING_T:1)[[TYPENAME:PORT_MAPPING_T]]

typedef struct
{
    UINT8<s(1)(1)(0)>[T]  slotNo<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]  portType<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]  portNo<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T] mappingStrLen<s(1)(1)(0)>[&];    
}__attribute__ ((packed))  CTD_MAPPING_T<s(0)(0)(0)>[&];(D1:CTD_MAPPING_T:1)[[TYPENAME:CTD_MAPPING_T]]

 






 














typedef struct
{
    UINT32<s(1)(1)(0)>[T] SlotNo<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T] BoardStyle<s(1)(1)(0)>[&];
}__attribute__ ((packed))  SLOT_ATTRIB<s(0)(0)(0)>[&];(D1:SLOT_ATTRIB:1)[[TYPENAME:SLOT_ATTRIB]]

typedef struct
{
    UINT32<s(1)(1)(0)>[T] PortNo_Min<s(1)(1)(0)>[&];  
	UINT32<s(1)(1)(0)>[T] PortNo_Max<s(1)(1)(0)>[&];  
}__attribute__ ((packed))  PORT_RANGE<s(0)(0)(0)>[&];(D1:PORT_RANGE:1)[[TYPENAME:PORT_RANGE]]

typedef struct
{
    SLOT_ATTRIB<s(1)(1)(0)>[T] slotAttrib<s(1)(1)(0)>[&][13];  
}__attribute__ ((packed))  PdhCardFuncToIoSuit<s(0)(0)(0)>[&];(D1:PdhCardFuncToIoSuit:1)[[TYPENAME:PdhCardFuncToIoSuit]]

typedef struct
{
    SLOT_ATTRIB<s(1)(1)(0)>[T] slotAttrib<s(1)(1)(0)>[&][2]; 
    PORT_RANGE<s(1)(1)(0)>[T] portRange<s(1)(1)(0)>[&];
}__attribute__ ((packed))  PdhCardIoToFuncSuit<s(0)(0)(0)>[&];(D1:PdhCardIoToFuncSuit:1)[[TYPENAME:PdhCardIoToFuncSuit]]

typedef struct
{
    UINT32<s(1)(1)(0)>[T] number<s(1)(1)(0)>[&];             
    SLOT_ATTRIB<s(1)(1)(0)>[T] cardInfo<s(1)(1)(0)>[&][12];   
    PORT_RANGE<s(1)(1)(0)>[T] portRange<s(1)(1)(0)>[&][12];   
}__attribute__ ((packed))  PdhCardRelation<s(0)(0)(0)>[&];(D1:PdhCardRelation:1)[[TYPENAME:PdhCardRelation]]

 


typedef struct
{    
    UINT8<s(1)(1)(0)>[T]  portType<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]  portNo<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]  actualPortType<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T] mappingStrLen<s(1)(1)(0)>[&];
     
}__attribute__ ((packed))  ONE_PORT_MAPPING_T<s(0)(0)(0)>[&];(D1:ONE_PORT_MAPPING_T:1)[[TYPENAME:ONE_PORT_MAPPING_T]]

typedef struct
{
    UINT8<s(1)(1)(0)>[T] ucSlotNo<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T] ucPortNum<s(1)(1)(0)>[&];
     
}__attribute__ ((packed))  ONE_SLOT_MAPPING_T<s(0)(0)(0)>[&];(D1:ONE_SLOT_MAPPING_T:1)[[TYPENAME:ONE_SLOT_MAPPING_T]]

typedef struct
{
    UINT8<s(1)(1)(0)>[T] ucSlotNum<s(1)(1)(0)>[&];
         
}__attribute__ ((packed))  NE_MAPPING_T<s(0)(0)(0)>[&];(D1:NE_MAPPING_T:1)[[TYPENAME:NE_MAPPING_T]]

 


 

 
typedef void (*funcDCCPortStateChangeNew<s(0)(0)(0)>[&])TYPENAME:FUNC:(funcDCCPortStateChangeNew)(UINT32<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&], int state<s(0)(0)(0)>[&]);(D1:state:0)

PB_ERROR_CODE_T<s(0)(0)(0)>[T] CTD_GetPdhIoCardInfoFromFuncCard<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] funcCardSlotNo<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] funcCardBoardStlye<s(0)(0)(0)>[&], PdhCardRelation<s(0)(0)(0)>[T] *pPdhRelatedCard<s(0)(0)(0)>[&]);(D1:pPdhRelatedCard:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] CTD_GetPdhFuncCardInfoFromIoCard<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] ioCardSlotNo<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ioCardBoardStlye<s(0)(0)(0)>[&], PdhCardRelation<s(0)(0)(0)>[T] *pPdhRelatedCard<s(0)(0)(0)>[&]);(D1:pPdhRelatedCard:0)


PB_ERROR_CODE_T<s(0)(0)(0)>[T] CTD_ifm_clrNeMappingSeachFlag<s(0)(0)(0)>[&](NE_MAPPING_T<s(0)(0)(0)>[T]* pNeMapping<s(0)(0)(0)>[&]);(D1:pNeMapping:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] CTD_ifm_GetNextMappingfromNe<s(0)(0)(0)>[&](NE_MAPPING_T<s(0)(0)(0)>[T]* pNeMapping<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T]* pSlotNo<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T]* pPortType<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T]* pPortNo<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] *pMappingStrLen<s(0)(0)(0)>[&],
                                 UINT8<s(0)(0)(0)>[T] *pMappingStr<s(0)(0)(0)>[&]);(D1:pMappingStr:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] CTD_ifm_clrSlotMappingSeachFlag<s(0)(0)(0)>[&](ONE_SLOT_MAPPING_T<s(0)(0)(0)>[T]* pSlotMapping<s(0)(0)(0)>[&]);(D1:pSlotMapping:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] CTD_ifm_GetNextMappingfromSlot<s(0)(0)(0)>[&](ONE_SLOT_MAPPING_T<s(0)(0)(0)>[T]* pSlotMapping<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T]* pSlotNo<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T]* pPortType<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T]* pPortNo<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] *pMappingStrLen<s(0)(0)(0)>[&],
                                 UINT8<s(0)(0)(0)>[T] *pMappingStr<s(0)(0)(0)>[&]);(D1:pMappingStr:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] CTD_ifm_GetSlotNumberFromNeMapping<s(0)(0)(0)>[&](NE_MAPPING_T<s(0)(0)(0)>[T] *pNeMapping<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] *pSlotNumber<s(0)(0)(0)>[&]);(D1:pSlotNumber:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] CTD_ifm_GetPortNumberFromNeMapping<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] slotNo<s(0)(0)(0)>[&], NE_MAPPING_T<s(0)(0)(0)>[T] *pNeMapping<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] *pPortNumber<s(0)(0)(0)>[&]);(D1:pPortNumber:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] CTD_ifm_GetPortMappingFromNeMapping<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] slotNo<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] portType<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] portNo<s(0)(0)(0)>[&], NE_MAPPING_T<s(0)(0)(0)>[T] *pNeMapping<s(0)(0)(0)>[&],  
                              UINT32<s(0)(0)(0)>[T] *pPortMappingLen<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] *pMappingStr<s(0)(0)(0)>[&]);(D1:pMappingStr:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] CTD_ifm_GetPortNumberFromSlotMapping<s(0)(0)(0)>[&](ONE_SLOT_MAPPING_T<s(0)(0)(0)>[T] *pSlotMapping<s(0)(0)(0)>[&],UINT32<s(0)(0)(0)>[T] *pSlotNo<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] *pPortNumber<s(0)(0)(0)>[&]);(D1:pPortNumber:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] CTD_ifm_GetPortMappingFromSlotMapping<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] slotNo<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] portType<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] portNo<s(0)(0)(0)>[&], ONE_SLOT_MAPPING_T<s(0)(0)(0)>[T] *pSlotMapping<s(0)(0)(0)>[&],  
                              UINT32<s(0)(0)(0)>[T] *pPortMappingLen<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] *pMappingStr<s(0)(0)(0)>[&]);(D1:pMappingStr:0)











 





























































































 
































typedef INT16<s(0)(0)(0)>[T] TEMPERATURE_T<s(0)(0)(0)>[&];(D1:TEMPERATURE_T:1)[[TYPENAME:TEMPERATURE_T]]

typedef enum {
  TEMPERATURE_STATE_NORMAL<s(0)(0)(0)>[&],
  TEMPERATURE_STATE_OVERHEAT<s(0)(0)(0)>[&],
  TEMPERATURE_STATE_UNDERHEAT<s(0)(0)(0)>[&]
} TEMPERATURE_STATE_T<s(0)(0)(0)>[&];(D1:TEMPERATURE_STATE_T:1)[[TYPENAME:TEMPERATURE_STATE_T]]

typedef enum
{
  LED_TYPE_CRITICAL<s(0)(0)(0)>[&]=0,
  LED_TYPE_MAJOR<s(0)(0)(0)>[&]=1,
  LED_TYPE_MINOR<s(0)(0)(0)>[&]=2,
  LED_TYPE_ACTIVE<s(0)(0)(0)>[&]=3,
  LED_TYPE_FAULTY<s(0)(0)(0)>[&]=4,
  LED_TYPE_FAN<s(0)(0)(0)>[&]=5,
  LED_TYPE_POWER<s(0)(0)(0)>[&]=6,
  LED_TYPE_PORTLINK<s(0)(0)(0)>[&]=7,
  LED_TYPE_PORTALARM<s(0)(0)(0)>[&]=8,
  LED_TYPE_CARDMISMATCH<s(0)(0)(0)>[&]=9,
  LED_TYPE_STANDBY<s(0)(0)(0)>[&]=10,
  LED_TYPE_CFCARD<s(0)(0)(0)>[&]=11,
  LED_TYPE_USRLINK<s(0)(0)(0)>[&]=12
} LED_TYPE_T<s(0)(0)(0)>[&];(D1:LED_TYPE_T:1)[[TYPENAME:LED_TYPE_T]]

typedef enum
{
  LED_STATE_UNKNOWN<s(0)(0)(0)>[&] = -1,  
  LED_STATE_ON<s(0)(0)(0)>[&] = 0,
  LED_STATE_OFF<s(0)(0)(0)>[&] = 1,
  LED_STATE_BLINK<s(0)(0)(0)>[&] = 2,
} LED_STATE_T<s(0)(0)(0)>[&];(D1:LED_STATE_T:1)[[TYPENAME:LED_STATE_T]]

typedef int BOARD_STYLE_T<s(0)(0)(0)>[&];(D1:BOARD_STYLE_T:1)[[TYPENAME:BOARD_STYLE_T]]

typedef enum {
  SDD_BOARD_ABSENT<s(0)(0)(0)>[&] = 0,
  SDD_BOARD_PRESENT<s(0)(0)(0)>[&] = 1,
  SDD_BOARD_UNKNOWN<s(0)(0)(0)>[&] = 2
} BOARD_PRESENCE_T<s(0)(0)(0)>[&];(D1:BOARD_PRESENCE_T:1)[[TYPENAME:BOARD_PRESENCE_T]]

typedef enum {
  SDD_REBOOT_STATE_START<s(0)(0)(0)>[&]    = 0,
  SDD_REBOOT_STATE_FINISH<s(0)(0)(0)>[&]   = 1,
  SDD_REBOOT_STATE_UNKNOWN<s(0)(0)(0)>[&]  = 2
} SDD_REBOOT_STATE_T<s(0)(0)(0)>[&];(D1:SDD_REBOOT_STATE_T:1)[[TYPENAME:SDD_REBOOT_STATE_T]]

typedef enum
{
  BOARD_EVENT_REMOVE<s(0)(0)(0)>[&] = 0,
  BOARD_EVENT_INSERT<s(0)(0)(0)>[&] = 1,
  BOARD_EVENT_LATCH_ATTACH<s(0)(0)(0)>[&] = 2,
  BOARD_EVENT_LATCH_DETATCH<s(0)(0)(0)>[&] = 3
} BOARD_EVENT_T<s(0)(0)(0)>[&];(D1:BOARD_EVENT_T:1)[[TYPENAME:BOARD_EVENT_T]]

 
typedef enum
{
    SDD_RESET_UNKNOWN<s(0)(0)(0)>[&]       = 0,
    SDD_RESET_WARM<s(0)(0)(0)>[&]   = 1,    
    SDD_RESET_COLD<s(0)(0)(0)>[&]         = 2,    
    SDD_RESET_NE_WARM<s(0)(0)(0)>[&]    = 3,    
    SDD_RESET_NE_COLD<s(0)(0)(0)>[&]      = 4,     
    SDD_RESET_BOARD_PLUG<s(0)(0)(0)>[&]	= 5		 
     
} SDD_RESET_REASON<s(0)(0)(0)>[&];(D1:SDD_RESET_REASON:1)[[TYPENAME:SDD_RESET_REASON]]

 
typedef enum
{
    SDD_BOARD_TYPE_EMPTY<s(0)(0)(0)>[&]        = 0,
    SDD_BOARD_TYPE_MC<s(0)(0)(0)>[&]           = 1,
    SDD_BOARD_TYPE_CC<s(0)(0)(0)>[&]           = 2,
    SDD_BOARD_TYPE_CHASSIS<s(0)(0)(0)>[&]      = 3,
    SDD_BOARD_TYPE_8STM16<s(0)(0)(0)>[&]       = 4,
    SDD_BOARD_TYPE_8STM14<s(0)(0)(0)>[&]       = 5,
    SDD_BOARD_TYPE_2STM64<s(0)(0)(0)>[&]       = 6,
    SDD_BOARD_TYPE_8GET<s(0)(0)(0)>[&]         = 7,
    SDD_BOARD_TYPE_10GEA<s(0)(0)(0)>[&]        = 8,
    SDD_BOARD_TYPE_10GET<s(0)(0)(0)>[&]        = 9,
    SDD_BOARD_TYPE_RPR<s(0)(0)(0)>[&]          = 10,
    SDD_BOARD_TYPE_8STM1E<s(0)(0)(0)>[&]       = 11,
    SDD_BOARD_TYPE_8STM1EIO<s(0)(0)(0)>[&]     = 12,
    SDD_BOARD_TYPE_12E3DS3<s(0)(0)(0)>[&]      = 13,
    SDD_BOARD_TYPE_12E3DS3IO<s(0)(0)(0)>[&]    = 14,
    SDD_BOARD_TYPE_126E1<s(0)(0)(0)>[&]        = 15,
    SDD_BOARD_TYPE_126E1IO<s(0)(0)(0)>[&]      = 16,
    SDD_BOARD_TYPE_SI<s(0)(0)(0)>[&]           = 17,
    SDD_BOARD_TYPE_OA<s(0)(0)(0)>[&]           = 18,
    SDD_BOARD_TYPE_PWR<s(0)(0)(0)>[&]          = 19,
    SDD_BOARD_TYPE_FAN<s(0)(0)(0)>[&]          = 20,
    SDD_BOARD_TYPE_1OTU<s(0)(0)(0)>[&]         = 21,
    SDD_BOARD_TYPE_10GEL2<s(0)(0)(0)>[&]       = 22,
    SDD_BOARD_TYPE_8STM16M<s(0)(0)(0)>[&]      = 23,
    SDD_BOARD_TYPE_16STM14M<s(0)(0)(0)>[&]     = 24,
    SDD_BOARD_TYPE_2STM64M<s(0)(0)(0)>[&]      = 25,
    SDD_BOARD_TYPE_EOS<s(0)(0)(0)>[&]          = 26,
    SDD_BOARD_TYPE_GMPLS<s(0)(0)(0)>[&]        = 27,
    SDD_BOARD_TYPE_DATAFABRIC_CONTROLLER<s(0)(0)(0)>[&]        = 28,
    SDD_BOARD_TYPE_DATAFABRIC<s(0)(0)(0)>[&]   = 29,
    SDD_BOARD_TYPE_BACKPLANE<s(0)(0)(0)>[&]    = 30,
    SDD_BOARD_TYPE_TENGE<s(0)(0)(0)>[&]        = 31,

    SDD_BOARD_TYPE_10GEL2_46<s(0)(0)(0)>[&]    = 32,    

    SDD_BOARD_TYPE_MAX<s(0)(0)(0)>[&]
} SDD_BOARD_TYPE_T<s(0)(0)(0)>[&];(D1:SDD_BOARD_TYPE_T:1)[[TYPENAME:SDD_BOARD_TYPE_T]]

typedef enum
{
    SDD_BUTTON_EVENT_TYPE_LEDTEST<s(0)(0)(0)>[&],
    SDD_BUTTON_EVENT_TYPE_ALARMCUTOFF<s(0)(0)(0)>[&],
    SDD_BUTTON_EVENT_TYPE_ALARMSUPPRESS<s(0)(0)(0)>[&]
}SDD_BUTTON_EVENT_TYPE<s(0)(0)(0)>[&];(D1:SDD_BUTTON_EVENT_TYPE:1)[[TYPENAME:SDD_BUTTON_EVENT_TYPE]]

typedef enum 
{
  BUTTON_STATE_DOWN<s(0)(0)(0)>[&],
  BUTTON_STATE_UP<s(0)(0)(0)>[&],
} BUTTON_STATE_T<s(0)(0)(0)>[&];(D1:BUTTON_STATE_T:1)[[TYPENAME:BUTTON_STATE_T]]

typedef enum
{
  POWER_FAIL<s(0)(0)(0)>[&],
  POWER_OK<s(0)(0)(0)>[&],
  POWER_PRESENT<s(0)(0)(0)>[&],
  POWER_ABSENT<s(0)(0)(0)>[&]
} POWER_STATUS_T<s(0)(0)(0)>[&];(D1:POWER_STATUS_T:1)[[TYPENAME:POWER_STATUS_T]]

typedef enum{
    FAN_STATUS_OK<s(0)(0)(0)>[&],
    FAN_STATUS_FAIL<s(0)(0)(0)>[&],
    FAN_STATUS_ABSENT<s(0)(0)(0)>[&],
    FAN_STATUS_PRESENT<s(0)(0)(0)>[&]
}FAN_STATUS_T<s(0)(0)(0)>[&];(D1:FAN_STATUS_T:1)[[TYPENAME:FAN_STATUS_T]]

typedef enum
{
    TIMING_LINE_NULL<s(0)(0)(0)>[&] = 0,
    TIMING_LINE_1<s(0)(0)(0)>[&]    = 1,        
    TIMING_LINE_2<s(0)(0)(0)>[&]    = 2            
        
}TIMING_LINE_T<s(0)(0)(0)>[&];(D1:TIMING_LINE_T:1)[[TYPENAME:TIMING_LINE_T]]

typedef enum 
{
    none<s(0)(0)(0)>[&]=0,
    manre<s(0)(0)(0)>[&]=1,
    mantest<s(0)(0)(0)>[&]=2
} ALS_MODE_STATUS_T<s(0)(0)(0)>[&];(D1:ALS_MODE_STATUS_T:1)[[TYPENAME:ALS_MODE_STATUS_T]]

typedef enum
{
    PORT_STATE_UNKNOWN<s(0)(0)(0)>[&] = -1,
    PORT_STATE_DIS<s(0)(0)(0)>[&],
    PORT_STATE_EN<s(0)(0)(0)>[&]
} PORTADMIN_STATE_T<s(0)(0)(0)>[&];(D1:PORTADMIN_STATE_T:1)[[TYPENAME:PORTADMIN_STATE_T]]

typedef enum
{
    ALS_FUNC_UNKNOWN<s(0)(0)(0)>[&] = -1,
    ALS_FUNC_DIS<s(0)(0)(0)>[&],
    ALS_FUNC_EN<s(0)(0)(0)>[&]
}ALS_FUNC_STATE_T<s(0)(0)(0)>[&];(D1:ALS_FUNC_STATE_T:1)[[TYPENAME:ALS_FUNC_STATE_T]]

typedef struct
{
    TIMING_LINE_T<s(1)(1)(0)>[T] port1_Line<s(1)(1)(0)>[&];
    TIMING_LINE_T<s(1)(1)(0)>[T] port2_Line<s(1)(1)(0)>[&];
    TIMING_LINE_T<s(1)(1)(0)>[T] port3_Line<s(1)(1)(0)>[&];
    TIMING_LINE_T<s(1)(1)(0)>[T] port4_Line<s(1)(1)(0)>[&];
    TIMING_LINE_T<s(1)(1)(0)>[T] port5_Line<s(1)(1)(0)>[&];
    TIMING_LINE_T<s(1)(1)(0)>[T] port6_Line<s(1)(1)(0)>[&];
    TIMING_LINE_T<s(1)(1)(0)>[T] port7_Line<s(1)(1)(0)>[&];
    TIMING_LINE_T<s(1)(1)(0)>[T] port8_Line<s(1)(1)(0)>[&];
} TIMING_REF_T<s(0)(0)(0)>[&];(D1:TIMING_REF_T:1)[[TYPENAME:TIMING_REF_T]]


typedef enum
{
    LED_TEST_KNOWN<s(0)(0)(0)>[&] = -1,
    LED_TEST_BEGIN<s(0)(0)(0)>[&] = 0,
    LED_TEST_PROC<s(0)(0)(0)>[&]  = 1,
    LED_TEST_END<s(0)(0)(0)>[&]   = 2
} SDD_LED_TEST_STATE_T<s(0)(0)(0)>[&];(D1:SDD_LED_TEST_STATE_T:1)[[TYPENAME:SDD_LED_TEST_STATE_T]]

 
typedef void (*SDD_BOARD_EVENT_CBACK<s(0)(0)(0)>[&])TYPENAME:FUNC:(SDD_BOARD_EVENT_CBACK)(BOARD_EVENT_T<s(0)(0)(0)>[T] event<s(0)(0)(0)>[&],
                                    SLOT_NUMBER_T<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&],
                                    BOARD_STYLE_T<s(0)(0)(0)>[T] cardType<s(0)(0)(0)>[&]);(D1:cardType:0)

typedef void (*SDD_LATCH_EVENT_CBACK<s(0)(0)(0)>[&])TYPENAME:FUNC:(SDD_LATCH_EVENT_CBACK)(BOARD_EVENT_T<s(0)(0)(0)>[T] event<s(0)(0)(0)>[&],
                                    SLOT_NUMBER_T<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&],
                                    BOARD_STYLE_T<s(0)(0)(0)>[T] cardType<s(0)(0)(0)>[&]);(D1:cardType:0)

typedef void (*SDD_ENTITY_UPDATE_CBACK<s(0)(0)(0)>[&])TYPENAME:FUNC:(SDD_ENTITY_UPDATE_CBACK)(INT16<s(0)(0)(0)>[T] entityNum<s(0)(0)(0)>[&],
                                       ENTITY_INFO_T<s(0)(0)(0)>[T] *pInfo<s(0)(0)(0)>[&]);(D1:pInfo:0)


typedef void (*SDD_ONE_SECOND_TIMER_CBACK<s(0)(0)(0)>[&])TYPENAME:FUNC:(SDD_ONE_SECOND_TIMER_CBACK)(UINT32<s(0)(0)(0)>[T] counter<s(0)(0)(0)>[&]);(D1:counter:0)

typedef void (*SDD_BUTTON_EVENT_CBACK<s(0)(0)(0)>[&])TYPENAME:FUNC:(SDD_BUTTON_EVENT_CBACK)(SDD_BUTTON_EVENT_TYPE<s(0)(0)(0)>[T] buttonType<s(0)(0)(0)>[&],
                                      BUTTON_STATE_T<s(0)(0)(0)>[T] oldState<s(0)(0)(0)>[&],
                                      BUTTON_STATE_T<s(0)(0)(0)>[T] newState<s(0)(0)(0)>[&]);(D1:newState:0)                                      







 


































































 


typedef unsigned int  HW_PORT_TYPE<s(0)(0)(0)>[&];(D1:HW_PORT_TYPE:1)[[TYPENAME:HW_PORT_TYPE]]      
































 


typedef unsigned int  HW_ACT_PORT_TYPE<s(0)(0)(0)>[&];(D1:HW_ACT_PORT_TYPE:1)[[TYPENAME:HW_ACT_PORT_TYPE]]      













 


typedef UINT32<s(0)(0)(0)>[T] SDH_TP_TYPE<s(0)(0)(0)>[&];(D1:SDH_TP_TYPE:1)[[TYPENAME:SDH_TP_TYPE]]   











































 


typedef UINT8<s(0)(0)(0)>[T] MAGUS_TP_TYPE<s(0)(0)(0)>[&];(D1:MAGUS_TP_TYPE:1)[[TYPENAME:MAGUS_TP_TYPE]]







 
typedef enum 
{
    TTI_LEN_16BYTE<s(0)(0)(0)>[&]        = 0x1,
    TTI_LEN_64BYTE<s(0)(0)(0)>[&]        = 0x2,
    TTI_LEN_FIXED1B<s(0)(0)(0)>[&]       = 0x3,
    TTI_LEN_PROVISIONED1B<s(0)(0)(0)>[&] = 0x4,
}TTI_LEN_T<s(0)(0)(0)>[&];(D1:TTI_LEN_T:1)[[TYPENAME:TTI_LEN_T]]




typedef int ePort_MAPPING_MODE<s(0)(0)(0)>[&];(D1:ePort_MAPPING_MODE:1)[[TYPENAME:ePort_MAPPING_MODE]]




typedef enum 
{
    PORT_LOOP_NONE<s(0)(0)(0)>[&]     = 0x1,       
    PORT_LOOP_INWARD<s(0)(0)(0)>[&]   = 0x2,       
    PORT_LOOP_OUTWARD<s(0)(0)(0)>[&]  = 0x3        
} PORT_LOOPBACK_T<s(0)(0)(0)>[&];(D1:PORT_LOOPBACK_T:1)[[TYPENAME:PORT_LOOPBACK_T]]

typedef enum
{
    TTI_TYPE_TRANSMIT<s(0)(0)(0)>[&]   = 0x0,
    TTI_TYPE_ACCEPTED<s(0)(0)(0)>[&]   = 0x1,
    TTI_TYPE_CAPTURED<s(0)(0)(0)>[&]   = 0x2,
    TTI_TYPE_EXPECTED<s(0)(0)(0)>[&]   = 0x3
} TTI_TYPE_T<s(0)(0)(0)>[&];(D1:TTI_TYPE_T:1)[[TYPENAME:TTI_TYPE_T]]

typedef char TTI_STRING<s(0)(0)(0)>[&][64];(D1:TTI_STRING:1)[[TYPENAME:TTI_STRING]]

typedef enum
{
    TIM_DISABLED<s(0)(0)(0)>[&]    = 0x0,
    TIM_ENABLED<s(0)(0)(0)>[&]     = 0x1
} eTIM_MODE<s(0)(0)(0)>[&];(D1:eTIM_MODE:1)[[TYPENAME:eTIM_MODE]]

typedef enum 
{
    PSL_TYPE_TRANSMIT<s(0)(0)(0)>[&]   = 0x0,
    PSL_TYPE_ACCEPTED<s(0)(0)(0)>[&]   = 0x1,
    PSL_TYPE_CAPTURED<s(0)(0)(0)>[&]   = 0x2,
    PSL_TYPE_EXPECTED<s(0)(0)(0)>[&]   = 0x3
} PSL_TYPE_T<s(0)(0)(0)>[&];(D1:PSL_TYPE_T:1)[[TYPENAME:PSL_TYPE_T]]

typedef enum 
{
    PORT_MODE_INVALID<s(0)(0)(0)>[&]   = 0x0,   
    PORT_MODE_AUTO<s(0)(0)(0)>[&]      = 0x1,   
    PORT_MODE_MON<s(0)(0)(0)>[&]       = 0x2,   
    PORT_MODE_NMON<s(0)(0)(0)>[&]      = 0x3    
} PORT_MODE_T<s(0)(0)(0)>[&];(D1:PORT_MODE_T:1)[[TYPENAME:PORT_MODE_T]]

 
typedef enum 
{
    ALARM_SOURCE<s(0)(0)(0)>[&]    = 0x0,
    ALARM_SINK<s(0)(0)(0)>[&]      = 0x1
}ALARM_DIRECTION_T<s(0)(0)(0)>[&];(D1:ALARM_DIRECTION_T:1)[[TYPENAME:ALARM_DIRECTION_T]]

 
typedef struct
{
    UINT32<s(1)(1)(0)>[T]  bip<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]  fc<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T]    b_lof<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T]    b_ses<s(1)(1)(0)>[&];
} RS_PMPARA_T<s(0)(0)(0)>[&];(D1:RS_PMPARA_T:1)[[TYPENAME:RS_PMPARA_T]]

typedef struct
{
    UINT32<s(1)(1)(0)>[T]  bip<s(1)(1)(0)>[&];      
    UINT32<s(1)(1)(0)>[T]  rei<s(1)(1)(0)>[&];      
    UINT32<s(1)(1)(0)>[T]  fc<s(1)(1)(0)>[&];       
    UINT32<s(1)(1)(0)>[T]  fefc<s(1)(1)(0)>[&];     
    BOOL<s(1)(1)(0)>[T]    b_ses<s(1)(1)(0)>[&];    
    BOOL<s(1)(1)(0)>[T]    b_fses<s(1)(1)(0)>[&];   
} MSHPLP_PMPARA_T<s(0)(0)(0)>[&];(D1:MSHPLP_PMPARA_T:1)[[TYPENAME:MSHPLP_PMPARA_T]]

typedef struct
{
    UINT32<s(1)(1)(0)>[T] npjc<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T] ppjc<s(1)(1)(0)>[&];
} AUTU_PMPARA_T<s(0)(0)(0)>[&];(D1:AUTU_PMPARA_T:1)[[TYPENAME:AUTU_PMPARA_T]]

typedef struct
{
    UINT32<s(1)(1)(0)>[T]  bip<s(1)(1)(0)>[&];      
    UINT32<s(1)(1)(0)>[T]  bei<s(1)(1)(0)>[&];      
    UINT32<s(1)(1)(0)>[T]  fc<s(1)(1)(0)>[&];       
    UINT32<s(1)(1)(0)>[T]  fefc<s(1)(1)(0)>[&];     
} OTU_PMPARA_T<s(0)(0)(0)>[&];(D1:OTU_PMPARA_T:1)[[TYPENAME:OTU_PMPARA_T]]

typedef struct
{
    UINT32<s(1)(1)(0)>[T]  fec0<s(1)(1)(0)>[&];      
    UINT32<s(1)(1)(0)>[T]  fec1<s(1)(1)(0)>[&];      
    UINT32<s(1)(1)(0)>[T]  fecall<s(1)(1)(0)>[&];       
    UINT32<s(1)(1)(0)>[T]  fecbyte<s(1)(1)(0)>[&];      
    UINT32<s(1)(1)(0)>[T]  fecun<s(1)(1)(0)>[&];      
    UINT32<s(1)(1)(0)>[T]  fc<s(1)(1)(0)>[&];     
} FEC_PMPARA_T<s(0)(0)(0)>[&];(D1:FEC_PMPARA_T:1)[[TYPENAME:FEC_PMPARA_T]]

typedef struct 
{
    int   nLaserIBias<s(1)(1)(0)>[&];
    float nVcc<s(1)(1)(0)>[&];                              
    int   nLaserTemp<s(1)(1)(0)>[&];
    int   nLaserTransPwr<s(1)(1)(0)>[&];
    int   nLaserRecvPwr<s(1)(1)(0)>[&];
    int   bCompliance8472<s(1)(1)(0)>[&];                    
    int   pbnNominalMBps<s(1)(1)(0)>[&];                     
    int   pbnWavelength<s(1)(1)(0)>[&];                      
    int   pbnLinkLength9125<s(1)(1)(0)>[&];                  
    int   pbnLinkLength50125<s(1)(1)(0)>[&];                 
    int   pbnLinkLength62125<s(1)(1)(0)>[&];                 
    int   pbnLinkLengthCopper<s(1)(1)(0)>[&];                
    char  pbsVendorName<s(1)(1)(0)>[&][20];                  
    char  pbsVendorPN<s(1)(1)(0)>[&][20];                    
    char  pbsVendorSN<s(1)(1)(0)>[&][20];                    
    char  pbsManuDate<s(1)(1)(0)>[&][16];                    
    PbSFFTranscCode_Tval<s(1)(1)(0)>[T] pbnTransCode<s(1)(1)(0)>[&];        
    char  pbsVendorOUI<s(1)(1)(0)>[&][16];                   
    PbConnectorType_Tval<s(1)(1)(0)>[T] pbnConnectorType<s(1)(1)(0)>[&];    
    int   pbnClLaserTemp<s(1)(1)(0)>[&];                    
    int   pbnTECCurrent<s(1)(1)(0)>[&];                     
    char  pbsSagPN<s(1)(1)(0)>[&][20];                      
} LASER_PARAMETER_T<s(0)(0)(0)>[&];(D1:LASER_PARAMETER_T:1)[[TYPENAME:LASER_PARAMETER_T]]

 
typedef enum 
{
    PDH_MAP_E1_VC12_TU12<s(0)(0)(0)>[&]    = 0x0,
    PDH_MAP_DS1_VC11_TU11<s(0)(0)(0)>[&]   = 0x1,
    PDH_MAP_DS1_VC11_TU12<s(0)(0)(0)>[&]   = 0x2,
    PDH_MAP_E3_LOVC3_TU3<s(0)(0)(0)>[&]    = 0x3,
    PDH_MAP_E3_HOVC3_AU3<s(0)(0)(0)>[&]    = 0x4,
    PDH_MAP_DS3_LOVC3_TU3<s(0)(0)(0)>[&]   = 0x5,
    PDH_MAP_DS3_HOVC3_AU3<s(0)(0)(0)>[&]   = 0x6
} PDH_MAPPING_T<s(0)(0)(0)>[&];(D1:PDH_MAPPING_T:1)[[TYPENAME:PDH_MAPPING_T]]

typedef enum
{
    LINE_CODING_HDB3<s(0)(0)(0)>[&]    = 0x0,
    LINE_CODING_CMI<s(0)(0)(0)>[&]     = 0x1,
    LINE_CODING_AMI<s(0)(0)(0)>[&]     = 0x2,
    LINE_CODING_B3ZS<s(0)(0)(0)>[&]    = 0x3,
    LINE_CODING_B6ZS<s(0)(0)(0)>[&]    = 0x4,
    LINE_CODING_B8ZS<s(0)(0)(0)>[&]    = 0x5
}LINE_CODING_T<s(0)(0)(0)>[&];(D1:LINE_CODING_T:1)[[TYPENAME:LINE_CODING_T]]

typedef enum
{
    OHM_75_R<s(0)(0)(0)>[&]  = 0x0,
    OHM_120_R<s(0)(0)(0)>[&] = 0x1,
    OHM_100_R<s(0)(0)(0)>[&] = 0x2,
    OHM_110_R<s(0)(0)(0)>[&] = 0x3,
}PDH_OHM_TYPE_T<s(0)(0)(0)>[&];(D1:PDH_OHM_TYPE_T:1)[[TYPENAME:PDH_OHM_TYPE_T]]

typedef enum 
{
    PDH_MAP_OPTION_ASYNC<s(0)(0)(0)>[&]    = 0x0,
    PDH_MAP_OPTION_BITSYNC<s(0)(0)(0)>[&]  = 0x1,
    PDH_MAP_OPTION_BYTESYNC<s(0)(0)(0)>[&] = 0x2
}PDH_MAP_OPTION_T<s(0)(0)(0)>[&];(D1:PDH_MAP_OPTION_T:1)[[TYPENAME:PDH_MAP_OPTION_T]]

 
typedef enum 
{
    E1_SA_BIT_4<s(0)(0)(0)>[&]     = 0x0,
    E1_SA_BIT_5<s(0)(0)(0)>[&]     = 0x1,
    E1_SA_BIT_6<s(0)(0)(0)>[&]     = 0x2,
    E1_SA_BIT_7<s(0)(0)(0)>[&]     = 0x3,
    E1_SA_BIT_8<s(0)(0)(0)>[&]     = 0x4
}E1_SA_BIT_T<s(0)(0)(0)>[&];(D1:E1_SA_BIT_T:1)[[TYPENAME:E1_SA_BIT_T]]

typedef enum 
{
    PORT_STATE_ABSENT<s(0)(0)(0)>[&]   = 0x0,
    PORT_STATE_UP<s(0)(0)(0)>[&]       = 0x1,
    PORT_STATE_DOWN<s(0)(0)(0)>[&]     = 0x2
} PORT_STATE_T<s(0)(0)(0)>[&];(D1:PORT_STATE_T:1)[[TYPENAME:PORT_STATE_T]]

typedef enum 
{
    LATCH_STATE_UNKNOWN<s(0)(0)(0)>[&]     = 0x0,
    LATCH_STATE_CLOSE<s(0)(0)(0)>[&]       = 0x1,
    LATCH_STATE_OPEN<s(0)(0)(0)>[&]        = 0x2,
    LATCH_STATE_CARDFAIL<s(0)(0)(0)>[&]    = 0x3,
    LATCH_STATE_CARD_REMOVE<s(0)(0)(0)>[&] = 0x4,
    LATCH_STATE_CARD_INSERT<s(0)(0)(0)>[&] = 0x5
}LATCH_STATE_T<s(0)(0)(0)>[&];(D1:LATCH_STATE_T:1)[[TYPENAME:LATCH_STATE_T]]

typedef enum
{
    EOW_TYPE_NULL<s(0)(0)(0)>[&]   = 0x0,
    EOW_TYPE_E1<s(0)(0)(0)>[&]     = 0x1,
    EOW_TYPE_E2<s(0)(0)(0)>[&]     = 0x2,
    EOW_TYPE_F1<s(0)(0)(0)>[&]     = 0x3
}EOW_TYPE_T<s(0)(0)(0)>[&];(D1:EOW_TYPE_T:1)[[TYPENAME:EOW_TYPE_T]]

typedef enum
{ 
    PDH_MODE_DS3<s(0)(0)(0)>[&]  = 0x0,
    PDH_MODE_E3<s(0)(0)(0)>[&]   = 0x1,
    PDH_MODE_E1<s(0)(0)(0)>[&]   = 0x2,
    PDH_MODE_DS1<s(0)(0)(0)>[&]  = 0x3
}PDH_PORT_MODE_T<s(0)(0)(0)>[&];(D1:PDH_PORT_MODE_T:1)[[TYPENAME:PDH_PORT_MODE_T]]

typedef enum
{
    E1_STRUCTURE_INVALID<s(0)(0)(0)>[&]   = 0x0,
    E1_STRUCTURE_FRAMED<s(0)(0)(0)>[&]    = 0x1,
    E1_STRUCTURE_UNFRAMED<s(0)(0)(0)>[&]  = 0x2,
    E3_STRUCTURE_G751<s(0)(0)(0)>[&]      = 0x3,
    E3_STRUCTURE_G832<s(0)(0)(0)>[&]      = 0x4,
    E3_STRUCTURE_UNFRAMED<s(0)(0)(0)>[&]  = 0x5,
    DS3_STRUCTURE_M13<s(0)(0)(0)>[&]      = 0x6,
    DS3_STRUCTURE_CBIT<s(0)(0)(0)>[&]     = 0x7,
    DS3_STRUCTURE_UNFRAMED<s(0)(0)(0)>[&] = 0x8,
}PDH_FRAME_MODE_T<s(0)(0)(0)>[&];(D1:PDH_FRAME_MODE_T:1)[[TYPENAME:PDH_FRAME_MODE_T]]

 
typedef enum 
{
    PRBS_STATUS_NA<s(0)(0)(0)>[&]          = 0x0,
    PRBS_STATUS_SYNCING<s(0)(0)(0)>[&]     = 0x1,
    PRBS_STATUS_SYNC_SUCC<s(0)(0)(0)>[&]   = 0x2,
    PRBS_STATUS_SYNC_FAIL<s(0)(0)(0)>[&]   = 0x3,
    PRBS_STATUS_SYNC_ERROR<s(0)(0)(0)>[&]  = 0x4
} PRBS_STATUS_T<s(0)(0)(0)>[&];(D1:PRBS_STATUS_T:1)[[TYPENAME:PRBS_STATUS_T]]

typedef enum 
{
    PRBS_MODE_NA<s(0)(0)(0)>[&]      = 0x0,
    PRBS_MODE_POWER15<s(0)(0)(0)>[&] = 0x1,
    PRBS_MODE_POWER20<s(0)(0)(0)>[&] = 0x2,
    PRBS_MODE_POWER23<s(0)(0)(0)>[&] = 0x3,
} PRBS_MODE_T<s(0)(0)(0)>[&];(D1:PRBS_MODE_T:1)[[TYPENAME:PRBS_MODE_T]]

typedef enum 
{
    SIGNAL_TYPE_NORMAL<s(0)(0)(0)>[&]  = 0x1,      
    SIGNAL_TYPE_UNEQ<s(0)(0)(0)>[&]    = 0x2,      
    SIGNAL_TYPE_AIS<s(0)(0)(0)>[&]     = 0x3,      
    SIGNAL_TYPE_RDI<s(0)(0)(0)>[&]     = 0x4,       
     
    SIGNAL_TYPE_PPIAIS<s(0)(0)(0)>[&]  = 0x8
} SIGNAL_TYPE_T<s(0)(0)(0)>[&];(D1:SIGNAL_TYPE_T:1)[[TYPENAME:SIGNAL_TYPE_T]]

typedef enum 
{
    ALARM_INSERT_AUTO<s(0)(0)(0)>[&]   = 0x0,
    ALARM_INSERT_FORCE<s(0)(0)(0)>[&]  = 0x1,
}ALARM_INSERT_WAY_T<s(0)(0)(0)>[&];(D1:ALARM_INSERT_WAY_T:1)[[TYPENAME:ALARM_INSERT_WAY_T]]

typedef enum
{
    DCC_TYPE_NONE<s(0)(0)(0)>[&]    = 0x0,
    DCC_TYPE_RS<s(0)(0)(0)>[&]      = 0x1,
    DCC_TYPE_MS<s(0)(0)(0)>[&]      = 0x2,
    DCC_TYPE_BOTH<s(0)(0)(0)>[&]    = 0x3,
} DCC_TYPE_T<s(0)(0)(0)>[&];(D1:DCC_TYPE_T:1)[[TYPENAME:DCC_TYPE_T]]

typedef enum
{
    CTD_BOARD_EPGTYPE_ERROR<s(0)(0)(0)>[&]         = 0x0,
    CTD_BOARD_EPGTYPE_NONE<s(0)(0)(0)>[&]          = 0x1,
    CTD_BOARD_EPGTYPE_1TON_WORK<s(0)(0)(0)>[&]     = 0x2,
    CTD_BOARD_EPGTYPE_1TON_PROT<s(0)(0)(0)>[&]     = 0x3,
    CTD_BOARD_EPGTYPE_1PLUS1_WORK<s(0)(0)(0)>[&]   = 0x4,
    CTD_BOARD_EPGTYPE_1PLUS1_PROT<s(0)(0)(0)>[&]   = 0x5,
    CTD_BOARD_EPGTYPE_1TO1_WORK<s(0)(0)(0)>[&]     = 0x6,
    CTD_BOARD_EPGTYPE_1TO1_PROT<s(0)(0)(0)>[&]     = 0x7
} CTD_BOARD_EPGTYPE<s(0)(0)(0)>[&];(D1:CTD_BOARD_EPGTYPE:1)[[TYPENAME:CTD_BOARD_EPGTYPE]]

 
typedef enum
{
    CTD_LOCC_NONE<s(0)(0)(0)>[&]    = 0x0,
    CTD_LOCC_20G<s(0)(0)(0)>[&]     = 0x1,
    CTD_LOCC_40G<s(0)(0)(0)>[&]     = 0x2,
}CTD_LOCC_MODE_T<s(0)(0)(0)>[&];(D1:CTD_LOCC_MODE_T:1)[[TYPENAME:CTD_LOCC_MODE_T]]

 
typedef enum
{
    CTD_CARD_UNKNOWN<s(0)(0)(0)>[&]    = 0x0,
    CTD_CARD_ACTIVE<s(0)(0)(0)>[&]     = 0x1,
    CTD_CARD_STANDBY<s(0)(0)(0)>[&]    = 0x2,
}CTD_CARD_STATE_T<s(0)(0)(0)>[&];(D1:CTD_CARD_STATE_T:1)[[TYPENAME:CTD_CARD_STATE_T]]

 
typedef enum
{
    CTD_FEC_ERR_NONE<s(0)(0)(0)>[&]    = 0x0,
    CTD_FEC_ERR_E3<s(0)(0)(0)>[&]      = 0x3,
    CTD_FEC_ERR_E4<s(0)(0)(0)>[&]      = 0x4,
    CTD_FEC_ERR_E5<s(0)(0)(0)>[&]      = 0x5,
}CTD_FEC_INSERT_RATE_T<s(0)(0)(0)>[&];(D1:CTD_FEC_INSERT_RATE_T:1)[[TYPENAME:CTD_FEC_INSERT_RATE_T]]

 












 









 











typedef struct 
{
    char   *name<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]  style<s(1)(1)(0)>[&];           
    UINT32<s(1)(1)(0)>[T]  option<s(1)(1)(0)>[&];          
    UINT32<s(1)(1)(0)>[T]  totalPortNum<s(1)(1)(0)>[&];    
    UINT32<s(1)(1)(0)>[T]  portIdRange<s(1)(1)(0)>[&][(29 ) ][2];   



    UINT32<s(1)(1)(0)>[T]  dataPortNum<s(1)(1)(0)>[&][2];  
} CTD_BOARD_INFO_T<s(0)(0)(0)>[&];(D1:CTD_BOARD_INFO_T:1)[[TYPENAME:CTD_BOARD_INFO_T]]

 













































 
 






 


 













typedef UINT16<s(0)(0)(0)>[T] TU_TP_T<s(0)(0)(0)>[&];(D1:TU_TP_T:1)[[TYPENAME:TU_TP_T]]

 


 





























typedef UINT32<s(0)(0)(0)>[T] AU_TP_T<s(0)(0)(0)>[&];(D1:AU_TP_T:1)[[TYPENAME:AU_TP_T]]

 



 







typedef UINT32<s(0)(0)(0)>[T] COMPACT_TP_T<s(0)(0)(0)>[&];(D1:COMPACT_TP_T:1)[[TYPENAME:COMPACT_TP_T]]






 






 




 









 


typedef struct
{
     
    SDH_TP_TYPE<s(1)(1)(0)>[T] eTpType<s(1)(1)(0)>[&];

     
    UINT32<s(1)(1)(0)>[T] E<s(1)(1)(0)>[&]: 4,
           D<s(1)(1)(0)>[&]: 4,
           C<s(1)(1)(0)>[&]: 4,
           B<s(1)(1)(0)>[&]: 4,
           A<s(1)(1)(0)>[&]: 4,
           K<s(1)(1)(0)>[&]: 4,
           L<s(1)(1)(0)>[&]: 4,
           M<s(1)(1)(0)>[&]: 4;        
}__attribute__ ((packed))  TP_INDEX_T<s(0)(0)(0)>[&];(D1:TP_INDEX_T:1)[[TYPENAME:TP_INDEX_T]]  

 


 
















typedef UINT16<s(0)(0)(0)>[T] SDH_TUG3_MAPPING_T<s(0)(0)(0)>[&];(D1:SDH_TUG3_MAPPING_T:1)[[TYPENAME:SDH_TUG3_MAPPING_T]]



typedef UINT8<s(0)(0)(0)>[T] SDH_TUG2_MAPPING_T<s(0)(0)(0)>[&];(D1:SDH_TUG2_MAPPING_T:1)[[TYPENAME:SDH_TUG2_MAPPING_T]]




 


typedef UINT16<s(0)(0)(0)>[T] SDH_VC3H_MAPPING_T<s(0)(0)(0)>[&];(D1:SDH_VC3H_MAPPING_T:1)[[TYPENAME:SDH_VC3H_MAPPING_T]]

 







 









typedef struct
{
    



    BOOL<s(1)(1)(0)>[T] b_clr<s(1)(1)(0)>[&];
    SDH_TUG3_MAPPING_T<s(1)(1)(0)>[T] tug3<s(1)(1)(0)>[&][3];
} SDH_VC4_MAPPING_T<s(0)(0)(0)>[&];(D1:SDH_VC4_MAPPING_T:1)[[TYPENAME:SDH_VC4_MAPPING_T]]

typedef struct
{
    



    BOOL<s(1)(1)(0)>[T] b_au4<s(1)(1)(0)>[&];

    union
    {
         
        SDH_VC4_MAPPING_T<s(2)(1)(0)>[T] vc4<s(2)(1)(0)>[&];
 
         
        SDH_VC3H_MAPPING_T<s(2)(1)(0)>[T] vc3h<s(2)(1)(0)>[&][3];
    } hovc<s(1)(0)(0)>[&];
} SDH_AUG1_MAPPING_T<s(0)(0)(0)>[&];(D1:SDH_AUG1_MAPPING_T:1)[[TYPENAME:SDH_AUG1_MAPPING_T]]

typedef struct
{
    



    BOOL<s(1)(1)(0)>[T] b_4c<s(1)(1)(0)>[&];
 
    SDH_AUG1_MAPPING_T<s(1)(1)(0)>[T] aug1<s(1)(1)(0)>[&][4];
} SDH_AUG4_MAPPING_T<s(0)(0)(0)>[&];(D1:SDH_AUG4_MAPPING_T:1)[[TYPENAME:SDH_AUG4_MAPPING_T]]

typedef struct
{
    



    BOOL<s(1)(1)(0)>[T] b_16c<s(1)(1)(0)>[&];
 
    SDH_AUG4_MAPPING_T<s(1)(1)(0)>[T] aug4<s(1)(1)(0)>[&][4];
} SDH_AUG16_MAPPING_T<s(0)(0)(0)>[&];(D1:SDH_AUG16_MAPPING_T:1)[[TYPENAME:SDH_AUG16_MAPPING_T]]

typedef struct
{
    



    BOOL<s(1)(1)(0)>[T] b_64c<s(1)(1)(0)>[&];

    SDH_AUG16_MAPPING_T<s(1)(1)(0)>[T] aug16<s(1)(1)(0)>[&][4];
} SDH_AUG64_MAPPING_T<s(0)(0)(0)>[&];(D1:SDH_AUG64_MAPPING_T:1)[[TYPENAME:SDH_AUG64_MAPPING_T]]

typedef struct
{
    



    BOOL<s(1)(1)(0)>[T] b_256c<s(1)(1)(0)>[&];

    SDH_AUG64_MAPPING_T<s(1)(1)(0)>[T] aug64<s(1)(1)(0)>[&][4];
} SDH_AUG256_MAPPING_T<s(0)(0)(0)>[&];(D1:SDH_AUG256_MAPPING_T:1)[[TYPENAME:SDH_AUG256_MAPPING_T]]

extern void CTD_InitModule<s(0)(0)(0)>[&]();(D1:CTD_InitModule:0)
extern UINT32<s(0)(0)(0)>[T] CTD_GetPortTotalNumber<s(0)(0)(0)>[&](SLOT_NUMBER_T<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&]);(D1:slot:0)
extern UINT32<s(0)(0)(0)>[T] CTD_GetPortNumber<s(0)(0)(0)>[&](SLOT_NUMBER_T<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&], HW_PORT_TYPE<s(0)(0)(0)>[T] type<s(0)(0)(0)>[&]);(D1:type:0)
extern UINT32<s(0)(0)(0)>[T] CTD_GetPortBegin<s(0)(0)(0)>[&](SLOT_NUMBER_T<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&], HW_PORT_TYPE<s(0)(0)(0)>[T] type<s(0)(0)(0)>[&]);(D1:type:0)
extern UINT32<s(0)(0)(0)>[T] CTD_GetBoardStyle<s(0)(0)(0)>[&](SLOT_NUMBER_T<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&]);(D1:slot:0)
extern UINT32<s(0)(0)(0)>[T] CTD_GetBoardOption<s(0)(0)(0)>[&](SLOT_NUMBER_T<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&]);(D1:slot:0)
extern PB_ERROR_CODE_T<s(0)(0)(0)>[T] CTD_SetBoardInfo<s(0)(0)(0)>[&](SLOT_NUMBER_T<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulStyle<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulOption<s(0)(0)(0)>[&]);(D1:ulOption:0)
extern PB_ERROR_CODE_T<s(0)(0)(0)>[T] CTD_GetPortType<s(0)(0)(0)>[&](SLOT_NUMBER_T<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] *pucTypeNum<s(0)(0)(0)>[&], HW_PORT_TYPE<s(0)(0)(0)>[T] *pePortType<s(0)(0)(0)>[&]);(D1:pePortType:0)
extern SLOT_NUMBER_T<s(0)(0)(0)>[T] CTD_InstanceToSlot<s(0)(0)(0)>[&](INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&]);(D1:inst:0)
extern INSTANCE_T<s(0)(0)(0)>[T] CTD_SlotToInstance<s(0)(0)(0)>[&](SLOT_NUMBER_T<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&]);(D1:slot:0)
extern UINT32<s(0)(0)(0)>[T] CTD_GetRelativePortId<s(0)(0)(0)>[&](SLOT_NUMBER_T<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] port<s(0)(0)(0)>[&]);(D1:port:0)
extern UINT32<s(0)(0)(0)>[T] CTD_GetAbsolutePortId<s(0)(0)(0)>[&](SLOT_NUMBER_T<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&], HW_PORT_TYPE<s(0)(0)(0)>[T] pType<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] port<s(0)(0)(0)>[&]);(D1:port:0)
extern CTD_BOARD_EPGTYPE<s(0)(0)(0)>[T] CTD_GetBoardEpgType<s(0)(0)(0)>[&](SLOT_NUMBER_T<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&]);(D1:slot:0)
extern CARDTYPE_T<s(0)(0)(0)>[T] CTD_BoardStyleToCardType<s(0)(0)(0)>[&](PbBoardStyle_Tval<s(0)(0)(0)>[T] boardStyle<s(0)(0)(0)>[&]);(D1:boardStyle:0)
extern PORT_LOOPBACK_T<s(0)(0)(0)>[T] CTD_TransToCdhLoopType<s(0)(0)(0)>[&](pbPortLoopback_Tval<s(0)(0)(0)>[T]  eLoopbackType<s(0)(0)(0)>[&]);(D1:eLoopbackType:0)
extern PB_ERROR_CODE_T<s(0)(0)(0)>[T] CTD_TransToCdhMap<s(0)(0)(0)>[&](PORT_MAPPING_T<s(0)(0)(0)>[T] *pTug3Map<s(0)(0)(0)>[&], void *pCdhMap<s(0)(0)(0)>[&]);(D1:pCdhMap:0)
extern PB_ERROR_CODE_T<s(0)(0)(0)>[T] CTD_TransToCdhTp<s(0)(0)(0)>[&](const TP_INDEX_T<s(0)(0)(0)>[T] *pTpIndex<s(0)(0)(0)>[&], COMPACT_TP_T<s(0)(0)(0)>[T] *pTpId<s(0)(0)(0)>[&]);(D1:pTpId:0)
extern SDH_TP_TYPE<s(0)(0)(0)>[T] CTD_GetTpType<s(0)(0)(0)>[&](const TP_INDEX_T<s(0)(0)(0)>[T] *pTpIndex<s(0)(0)(0)>[&]);(D1:pTpIndex:0)
extern TTI_LEN_T<s(0)(0)(0)>[T] CTD_TransToCdhTtiMode<s(0)(0)(0)>[&](PbTIModeType_Tval<s(0)(0)(0)>[T] mode<s(0)(0)(0)>[&]);(D1:mode:0)
extern SIGNAL_TYPE_T<s(0)(0)(0)>[T] CTD_TransToCdhSigType<s(0)(0)(0)>[&](PbSignalType_Tval<s(0)(0)(0)>[T] signalType<s(0)(0)(0)>[&]);(D1:signalType:0)
extern LATCH_STATE_T<s(0)(0)(0)>[T] CTD_TransToCdhLatchState<s(0)(0)(0)>[&](PbEpgFunctionCardStatus_Tval<s(0)(0)(0)>[T] eState<s(0)(0)(0)>[&]);(D1:eState:0)
extern PbEpgFunctionCardStatus_Tval<s(0)(0)(0)>[T] CTD_TransToExLatchState<s(0)(0)(0)>[&](LATCH_STATE_T<s(0)(0)(0)>[T] eState<s(0)(0)(0)>[&]);(D1:eState:0)
extern PRBS_MODE_T<s(0)(0)(0)>[T] CTD_TransToCdhPrbsMode<s(0)(0)(0)>[&](pbPRBSPattern_Tval<s(0)(0)(0)>[T] prbsPattern<s(0)(0)(0)>[&]);(D1:prbsPattern:0)
extern PbPortOperationStatus_Tval<s(0)(0)(0)>[T] CTD_TransToExPortState<s(0)(0)(0)>[&](PORT_STATE_T<s(0)(0)(0)>[T] cdhPortState<s(0)(0)(0)>[&]);(D1:cdhPortState:0)
extern const char* CTD_GetLedStateName<s(0)(0)(0)>[&](LED_STATE_T<s(0)(0)(0)>[T] state<s(0)(0)(0)>[&]);(D1:state:0)
extern PDH_FRAME_MODE_T<s(0)(0)(0)>[T] CTD_TransToCdhFrameMode<s(0)(0)(0)>[&](expectedFrameStructure_Tval<s(0)(0)(0)>[T] eFrameMode<s(0)(0)(0)>[&]);(D1:eFrameMode:0)
extern UINT32<s(0)(0)(0)>[T] CTD_TransToCdhPortType<s(0)(0)(0)>[&](HW_ACT_PORT_TYPE<s(0)(0)(0)>[T] ePortType<s(0)(0)(0)>[&]);(D1:ePortType:0)
extern PORT_LOOPBACK_T<s(0)(0)(0)>[T] CTD_TransToOtuLoopType<s(0)(0)(0)>[&](pbOTUPortLoopback_Tval<s(0)(0)(0)>[T] eLoopbackType<s(0)(0)(0)>[&]);(D1:eLoopbackType:0)
extern CTD_FEC_INSERT_RATE_T<s(0)(0)(0)>[T] CTD_TransToOtuFecErrRate<s(0)(0)(0)>[&](pbInsFecErrRate_Tval<s(0)(0)(0)>[T] InsFecErrRate<s(0)(0)(0)>[&]);(D1:InsFecErrRate:0)
extern CTD_CARD_STATE_T<s(0)(0)(0)>[T] CTD_GetXcState<s(0)(0)(0)>[&]();(D1:CTD_GetXcState:0)
extern PB_ERROR_CODE_T<s(0)(0)(0)>[T] CTD_SetXcState<s(0)(0)(0)>[&](BOOL<s(0)(0)(0)>[T] bCardState<s(0)(0)(0)>[&]);(D1:bCardState:0)
extern const char* CTD_GetCardName<s(0)(0)(0)>[&](SLOT_NUMBER_T<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&]);(D1:slot:0)

extern CTD_BOARD_INFO_T<s(0)(0)(0)>[T] ctd_boardInfo<s(0)(0)(0)>[&][];(D1:ctd_boardInfo:0)








 














































































































 


















 

 
 

 



















































 

 

 

























 

 

 




































 

 

 







 
































 








































 



 

	 












	 


















 






 



 






 



 


 




 




extern int *	__errno<s(0)(0)(0)>[&](void);(D1:__errno:0)























 









 

typedef struct obj_core<s(1)(0)(1)>[&]  *OBJ_ID<s(0)(0)(0)>[&];(D1:OBJ_ID:1)[[TYPENAME:OBJ_ID]]		 


 

















 



extern STATUS<s(0)(0)(0)>[T] 	objShow<s(0)(0)(0)>[&] (OBJ_ID<s(0)(0)(0)>[T] objId<s(0)(0)(0)>[&], int showType<s(0)(0)(0)>[&]);(D1:showType:0)















 

 

 






















































 







 



typedef struct mem_part<s(1)(0)(1)>[&] *PART_ID<s(0)(0)(0)>[&];(D1:PART_ID:1)[[TYPENAME:PART_ID]]

 

typedef struct
    {

    unsigned long numBytesFree<s(1)(1)(0)>[&],	    
		  numBlocksFree<s(1)(1)(0)>[&],    
		  maxBlockSizeFree<s(1)(1)(0)>[&], 
		  numBytesAlloc<s(1)(1)(0)>[&],    
		  numBlocksAlloc<s(1)(1)(0)>[&];   

    }  MEM_PART_STATS<s(0)(0)(0)>[&];(D1:MEM_PART_STATS:1)[[TYPENAME:MEM_PART_STATS]]


 

 



 




 




 






 









 

 

extern PART_ID<s(0)(0)(0)>[T] memSysPartId<s(0)(0)(0)>[&];(D1:memSysPartId:0)

 

extern FUNCPTR<s(0)(0)(0)>[T]  smMemPartOptionsSetRtn<s(0)(0)(0)>[&];(D1:smMemPartOptionsSetRtn:0)
extern FUNCPTR<s(0)(0)(0)>[T]  smMemPartFindMaxRtn<s(0)(0)(0)>[&];(D1:smMemPartFindMaxRtn:0)
extern FUNCPTR<s(0)(0)(0)>[T]  smMemPartReallocRtn<s(0)(0)(0)>[&];(D1:smMemPartReallocRtn:0)
extern FUNCPTR<s(0)(0)(0)>[T]  smMemPartShowRtn<s(0)(0)(0)>[&];(D1:smMemPartShowRtn:0)

 



extern STATUS<s(0)(0)(0)>[T] 	memInit<s(0)(0)(0)>[&] (char *pPool<s(0)(0)(0)>[&], unsigned poolSize<s(0)(0)(0)>[&]);(D1:poolSize:0)
extern STATUS<s(0)(0)(0)>[T] 	memPartLibInit<s(0)(0)(0)>[&] (char *pPool<s(0)(0)(0)>[&], unsigned poolSize<s(0)(0)(0)>[&]);(D1:poolSize:0)
extern PART_ID<s(0)(0)(0)>[T] 	memPartCreate<s(0)(0)(0)>[&] (char *pPool<s(0)(0)(0)>[&], unsigned poolSize<s(0)(0)(0)>[&]);(D1:poolSize:0)
extern void 	memPartInit<s(0)(0)(0)>[&] (PART_ID<s(0)(0)(0)>[T] partId<s(0)(0)(0)>[&], char *pPool<s(0)(0)(0)>[&], unsigned poolSize<s(0)(0)(0)>[&]);(D1:poolSize:0)
extern STATUS<s(0)(0)(0)>[T] 	memPartAddToPool<s(0)(0)(0)>[&] (PART_ID<s(0)(0)(0)>[T] partId<s(0)(0)(0)>[&], char *pPool<s(0)(0)(0)>[&],
				  unsigned poolSize<s(0)(0)(0)>[&]);(D1:poolSize:0)
extern void 	memAddToPool<s(0)(0)(0)>[&] (char *pPool<s(0)(0)(0)>[&], unsigned poolSize<s(0)(0)(0)>[&]);(D1:poolSize:0)
extern void *	memPartAlloc<s(0)(0)(0)>[&] (PART_ID<s(0)(0)(0)>[T] partId<s(0)(0)(0)>[&], unsigned nBytes<s(0)(0)(0)>[&]);(D1:nBytes:0)
extern void *   memPartAlignedAlloc<s(0)(0)(0)>[&] (PART_ID<s(0)(0)(0)>[T] partId<s(0)(0)(0)>[&], unsigned nBytes<s(0)(0)(0)>[&],
				     unsigned alignment<s(0)(0)(0)>[&]);(D1:alignment:0)
extern void *	memalign<s(0)(0)(0)>[&] (unsigned alignment<s(0)(0)(0)>[&], unsigned size<s(0)(0)(0)>[&]);(D1:size:0)
extern void *   valloc<s(0)(0)(0)>[&] (unsigned size<s(0)(0)(0)>[&]);(D1:size:0)
extern STATUS<s(0)(0)(0)>[T] 	memPartFree<s(0)(0)(0)>[&] (PART_ID<s(0)(0)(0)>[T] partId<s(0)(0)(0)>[&], char *pBlock<s(0)(0)(0)>[&]);(D1:pBlock:0)
extern STATUS<s(0)(0)(0)>[T] 	memPartOptionsSet<s(0)(0)(0)>[&] (PART_ID<s(0)(0)(0)>[T] partId<s(0)(0)(0)>[&], unsigned options<s(0)(0)(0)>[&]);(D1:options:0)
extern int 	memFindMax<s(0)(0)(0)>[&] (void);(D1:memFindMax:0)
extern int 	memPartFindMax<s(0)(0)(0)>[&] (PART_ID<s(0)(0)(0)>[T] partId<s(0)(0)(0)>[&]);(D1:partId:0)
extern void *	memPartRealloc<s(0)(0)(0)>[&] (PART_ID<s(0)(0)(0)>[T] partId<s(0)(0)(0)>[&], char *pBlock<s(0)(0)(0)>[&], unsigned nBytes<s(0)(0)(0)>[&]);(D1:nBytes:0)
extern void 	memOptionsSet<s(0)(0)(0)>[&] (unsigned options<s(0)(0)(0)>[&]);(D1:options:0)
extern STATUS<s(0)(0)(0)>[T] 	cfree<s(0)(0)(0)>[&] (char *pBlock<s(0)(0)(0)>[&]);(D1:pBlock:0)
extern void 	memShowInit<s(0)(0)(0)>[&] (void);(D1:memShowInit:0)
extern void 	memShow<s(0)(0)(0)>[&] (int type<s(0)(0)(0)>[&]);(D1:type:0)
extern STATUS<s(0)(0)(0)>[T] 	memPartShow<s(0)(0)(0)>[&] (PART_ID<s(0)(0)(0)>[T] partId<s(0)(0)(0)>[&], int type<s(0)(0)(0)>[&]);(D1:type:0)
extern STATUS<s(0)(0)(0)>[T]   memPartInfoGet<s(0)(0)(0)>[&] (PART_ID<s(0)(0)(0)>[T]	partId<s(0)(0)(0)>[&], MEM_PART_STATS<s(0)(0)(0)>[T] * ppartStats<s(0)(0)(0)>[&]);(D1:ppartStats:0)












 






typedef struct obj_class<s(1)(0)(1)>[&] *CLASS_ID<s(0)(0)(0)>[&];(D1:CLASS_ID:1)[[TYPENAME:CLASS_ID]]		 

extern CLASS_ID<s(0)(0)(0)>[T] classClassId<s(0)(0)(0)>[&];(D1:classClassId:0)			 

 



extern STATUS<s(0)(0)(0)>[T] 	classLibInit<s(0)(0)(0)>[&] (void);(D1:classLibInit:0)
extern STATUS<s(0)(0)(0)>[T] 	classMemPartIdSet<s(0)(0)(0)>[&] (CLASS_ID<s(0)(0)(0)>[T] classId<s(0)(0)(0)>[&], PART_ID<s(0)(0)(0)>[T] memPartId<s(0)(0)(0)>[&]);(D1:memPartId:0)
extern void 	classShowInit<s(0)(0)(0)>[&] (void);(D1:classShowInit:0)
extern STATUS<s(0)(0)(0)>[T] 	classShow<s(0)(0)(0)>[&] (CLASS_ID<s(0)(0)(0)>[T] classId<s(0)(0)(0)>[&], int level<s(0)(0)(0)>[&]);(D1:level:0)



















 

 

 


























typedef struct obj_core<s(1)(0)(1)>[&]		 
    {
    struct obj_class<s(2)(1)(1)>[&] *pObjClass<s(1)(1)(0)>[&];	 
    } OBJ_CORE<s(0)(0)(0)>[&];(D1:OBJ_CORE:1)[[TYPENAME:OBJ_CORE]]






 



extern OBJ_ID<s(0)(0)(0)>[T] 	objCreate<s(0)(0)(0)>[&] (CLASS_ID<s(0)(0)(0)>[T] classId<s(0)(0)(0)>[&], ...);(D1:classId:0)
extern STATUS<s(0)(0)(0)>[T] 	objInit<s(0)(0)(0)>[&] (CLASS_ID<s(0)(0)(0)>[T] classId<s(0)(0)(0)>[&], OBJ_ID<s(0)(0)(0)>[T] objId<s(0)(0)(0)>[&], ...);(D1:objId:0)
extern STATUS<s(0)(0)(0)>[T] 	objDelete<s(0)(0)(0)>[&] (OBJ_ID<s(0)(0)(0)>[T] objId<s(0)(0)(0)>[&]);(D1:objId:0)
extern STATUS<s(0)(0)(0)>[T] 	objDestroy<s(0)(0)(0)>[&] (OBJ_ID<s(0)(0)(0)>[T] objId<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] dealloc<s(0)(0)(0)>[&], int timeout<s(0)(0)(0)>[&]);(D1:timeout:0)
extern STATUS<s(0)(0)(0)>[T] 	objFree<s(0)(0)(0)>[&] (CLASS_ID<s(0)(0)(0)>[T] classId<s(0)(0)(0)>[&], char *pObject<s(0)(0)(0)>[&]);(D1:pObject:0)
extern STATUS<s(0)(0)(0)>[T] 	objTerminate<s(0)(0)(0)>[&] (OBJ_ID<s(0)(0)(0)>[T] objId<s(0)(0)(0)>[&]);(D1:objId:0)
extern void *	objAlloc<s(0)(0)(0)>[&] (CLASS_ID<s(0)(0)(0)>[T] classId<s(0)(0)(0)>[&]);(D1:classId:0)
extern void *	objAllocExtra<s(0)(0)(0)>[&] (CLASS_ID<s(0)(0)(0)>[T] classId<s(0)(0)(0)>[&], unsigned nExtraBytes<s(0)(0)(0)>[&],
			       void ** ppExtra<s(0)(0)(0)>[&]);(D1:ppExtra:0)
extern void 	objCoreInit<s(0)(0)(0)>[&] (OBJ_CORE<s(0)(0)(0)>[T] *pObjCore<s(0)(0)(0)>[&], CLASS_ID<s(0)(0)(0)>[T] pObjClass<s(0)(0)(0)>[&]);(D1:pObjClass:0)
extern void 	objCoreTerminate<s(0)(0)(0)>[&] (OBJ_CORE<s(0)(0)(0)>[T] *pObjCore<s(0)(0)(0)>[&]);(D1:pObjCore:0)











 

 
 























 









typedef struct obj_class<s(1)(0)(1)>[&]	 
    {
    OBJ_CORE<s(1)(1)(0)>[T]		objCore<s(1)(1)(0)>[&];	 
    struct mem_part<s(2)(1)(1)>[&]	*objPartId<s(1)(1)(0)>[&];	 
    unsigned		objSize<s(1)(1)(0)>[&];	 
    unsigned		objAllocCnt<s(1)(1)(0)>[&];	 
    unsigned		objFreeCnt<s(1)(1)(0)>[&];	 
    unsigned		objInitCnt<s(1)(1)(0)>[&];	 
    unsigned		objTerminateCnt<s(1)(1)(0)>[&]; 
    int			coreOffset<s(1)(1)(0)>[&];	 
    FUNCPTR<s(1)(1)(0)>[T]		createRtn<s(1)(1)(0)>[&];	 
    FUNCPTR<s(1)(1)(0)>[T]		initRtn<s(1)(1)(0)>[&];	 
    FUNCPTR<s(1)(1)(0)>[T]		destroyRtn<s(1)(1)(0)>[&];	 
    FUNCPTR<s(1)(1)(0)>[T]		showRtn<s(1)(1)(0)>[&];	 
    FUNCPTR<s(1)(1)(0)>[T]		instRtn<s(1)(1)(0)>[&];	 
    } OBJ_CLASS<s(0)(0)(0)>[&];(D1:OBJ_CLASS:1)[[TYPENAME:OBJ_CLASS]]


 



extern CLASS_ID<s(0)(0)(0)>[T]	classCreate<s(0)(0)(0)>[&] (unsigned objectSize<s(0)(0)(0)>[&], int coreOffset<s(0)(0)(0)>[&],
			     FUNCPTR<s(0)(0)(0)>[T] createRtn<s(0)(0)(0)>[&], FUNCPTR<s(0)(0)(0)>[T] initRtn<s(0)(0)(0)>[&],
			     FUNCPTR<s(0)(0)(0)>[T] destroyRtn<s(0)(0)(0)>[&]);(D1:destroyRtn:0)
extern STATUS<s(0)(0)(0)>[T]	classInit<s(0)(0)(0)>[&] (OBJ_CLASS<s(0)(0)(0)>[T] *pObjClass<s(0)(0)(0)>[&], unsigned objectSize<s(0)(0)(0)>[&],
			   int coreOffset<s(0)(0)(0)>[&], FUNCPTR<s(0)(0)(0)>[T] createRtn<s(0)(0)(0)>[&], FUNCPTR<s(0)(0)(0)>[T] initRtn<s(0)(0)(0)>[&],
			   FUNCPTR<s(0)(0)(0)>[T] destroyRtn<s(0)(0)(0)>[&]);(D1:destroyRtn:0)
extern STATUS<s(0)(0)(0)>[T]	classDestroy<s(0)(0)(0)>[&] (CLASS_ID<s(0)(0)(0)>[T] classId<s(0)(0)(0)>[&]);(D1:classId:0)
extern STATUS<s(0)(0)(0)>[T]	classInstConnect<s(0)(0)(0)>[&] (CLASS_ID<s(0)(0)(0)>[T] classId<s(0)(0)(0)>[&], FUNCPTR<s(0)(0)(0)>[T] instRtn<s(0)(0)(0)>[&]);(D1:instRtn:0)
extern STATUS<s(0)(0)(0)>[T]	classShowConnect<s(0)(0)(0)>[&] (CLASS_ID<s(0)(0)(0)>[T] classId<s(0)(0)(0)>[&], FUNCPTR<s(0)(0)(0)>[T] showRtn<s(0)(0)(0)>[&]);(D1:showRtn:0)
extern STATUS<s(0)(0)(0)>[T]   classInstrument<s(0)(0)(0)>[&] ( OBJ_CLASS<s(0)(0)(0)>[T] * pObjClass<s(0)(0)(0)>[&], 
				  OBJ_CLASS<s(0)(0)(0)>[T] * pObjInstClass<s(0)(0)(0)>[&] );(D1:pObjInstClass:0)











   









 








































 



 
 







 



 

typedef struct __va_list_tag<s(1)(0)(1)>[&] {
  unsigned char gpr<s(1)(1)(0)>[&];		 


  unsigned char fpr<s(1)(1)(0)>[&];		 


  char *overflow_arg_area<s(1)(1)(0)>[&];	 

  char *reg_save_area<s(1)(1)(0)>[&];		 
} __va_list<s(0)(0)(0)>[&][1],(D1:__va_list:1) __gnuc_va_list<s(0)(0)(0)>[&][1];(D1:__gnuc_va_list:1)[[TYPENAME:__gnuc_va_list]]









 



 


typedef struct {
  long   __gp_save<s(1)(1)(0)>[&][8];		 
  double __fp_save<s(1)(1)(0)>[&][8];		 
} __va_regsave_t<s(0)(0)(0)>[&];(D1:__va_regsave_t:1)[[TYPENAME:__va_regsave_t]]

 
 









 









 























 
















 





















 
 















 




 

 

 

typedef __gnuc_va_list<s(0)(0)(0)>[T] va_list<s(0)(0)(0)>[&];(D1:va_list:1)[[TYPENAME:va_list]]





























 

struct __sbuf<s(1)(0)(1)>[&] 			 
    {
    uchar_t<s(1)(1)(0)>[T] * _base<s(1)(1)(0)>[&];		 
    int	      _size<s(1)(1)(0)>[&];		 
    };

typedef	struct __sFILE<s(1)(0)(1)>[&]
    {
    OBJ_CORE<s(1)(1)(0)>[T]		objCore<s(1)(1)(0)>[&];	 
    uchar_t<s(1)(1)(0)>[T] *		_p<s(1)(1)(0)>[&];		 
    int			_r<s(1)(1)(0)>[&];		 
    int			_w<s(1)(1)(0)>[&];		 
    short		_flags<s(1)(1)(0)>[&];		 
    short		_file<s(1)(1)(0)>[&];		 
    struct __sbuf<s(2)(1)(1)>[&]	_bf<s(2)(1)(1)>[&];		 
    int			_lbfsize<s(1)(1)(0)>[&];	 
    struct __sbuf<s(2)(1)(1)>[&]	_ub<s(2)(1)(1)>[&];		 
    uchar_t<s(1)(1)(0)>[T] *		_up<s(1)(1)(0)>[&];		 
    int			_ur<s(1)(1)(0)>[&];		 
    uchar_t<s(1)(1)(0)>[T]		_ubuf<s(1)(1)(0)>[&][3];	 
    uchar_t<s(1)(1)(0)>[T]		_nbuf<s(1)(1)(0)>[&][1];	 
    struct __sbuf<s(2)(1)(1)>[&]	_lb<s(2)(1)(1)>[&];		 
    int			_blksize<s(1)(1)(0)>[&];	 
    int			_offset<s(1)(1)(0)>[&];	 
    int			taskId<s(1)(1)(0)>[&];		 
    } FILE<s(0)(0)(0)>[&];(D1:FILE:1)[[TYPENAME:FILE]]

 

extern CLASS_ID<s(0)(0)(0)>[T] fpClassId<s(0)(0)(0)>[&];(D1:fpClassId:0)		 

 

























































extern void	clearerr<s(0)(0)(0)>[&] (FILE<s(0)(0)(0)>[T] *);(D1:FILE:0)
extern int	fclose<s(0)(0)(0)>[&] (FILE<s(0)(0)(0)>[T] *);(D1:FILE:0)
extern int	feof<s(0)(0)(0)>[&] (FILE<s(0)(0)(0)>[T] *);(D1:FILE:0)
extern int	ferror<s(0)(0)(0)>[&] (FILE<s(0)(0)(0)>[T] *);(D1:FILE:0)
extern int	fflush<s(0)(0)(0)>[&] (FILE<s(0)(0)(0)>[T] *);(D1:FILE:0)
extern int	fgetc<s(0)(0)(0)>[&] (FILE<s(0)(0)(0)>[T] *);(D1:FILE:0)
extern int	fgetpos<s(0)(0)(0)>[&] (FILE<s(0)(0)(0)>[T] *, fpos_t<s(0)(0)(0)>[T] *);(D1:fpos_t:0)
extern char *	fgets<s(0)(0)(0)>[&] (char *, size_t<s(0)(0)(0)>[T], FILE<s(0)(0)(0)>[T] *);(D1:FILE:0)
extern FILE<s(0)(0)(0)>[T] *	fopen<s(0)(0)(0)>[&] (const char *, const char *);(D1:fopen:0)
extern int	fprintf<s(0)(0)(0)>[&] (FILE<s(0)(0)(0)>[T] *, const char *, ...);(D1:FILE:0)
extern int	fputc<s(0)(0)(0)>[&] (int, FILE<s(0)(0)(0)>[T] *);(D1:FILE:0)
extern int	fputs<s(0)(0)(0)>[&] (const char *, FILE<s(0)(0)(0)>[T] *);(D1:FILE:0)
extern int	fread<s(0)(0)(0)>[&] (void *, size_t<s(0)(0)(0)>[T], size_t<s(0)(0)(0)>[T], FILE<s(0)(0)(0)>[T] *);(D1:FILE:0)
extern FILE<s(0)(0)(0)>[T] *	freopen<s(0)(0)(0)>[&] (const char *, const char *, FILE<s(0)(0)(0)>[T] *);(D1:FILE:0)
extern int	fscanf<s(0)(0)(0)>[&] (FILE<s(0)(0)(0)>[T] *, const char *, ...);(D1:FILE:0)
extern int	fseek<s(0)(0)(0)>[&] (FILE<s(0)(0)(0)>[T] *, long, int);(D1:FILE:0)
extern int	fsetpos<s(0)(0)(0)>[&] (FILE<s(0)(0)(0)>[T] *, const fpos_t<s(0)(0)(0)>[T] *);(D1:fpos_t:0)
extern long	ftell<s(0)(0)(0)>[&] (FILE<s(0)(0)(0)>[T] *);(D1:FILE:0)
extern int	fwrite<s(0)(0)(0)>[&] (const void *, size_t<s(0)(0)(0)>[T], size_t<s(0)(0)(0)>[T], FILE<s(0)(0)(0)>[T] *);(D1:FILE:0)
extern int	getc<s(0)(0)(0)>[&] (FILE<s(0)(0)(0)>[T] *);(D1:FILE:0)
extern int	getchar<s(0)(0)(0)>[&] (void);(D1:getchar:0)
extern char *	gets<s(0)(0)(0)>[&] (char *);(D1:gets:0)
extern void	perror<s(0)(0)(0)>[&] (const char *);(D1:perror:0)
extern int	printf<s(0)(0)(0)>[&] (const char *, ...);(D1:printf:0)
extern int	putc<s(0)(0)(0)>[&] (int, FILE<s(0)(0)(0)>[T] *);(D1:FILE:0)
extern int	putchar<s(0)(0)(0)>[&] (int);(D1:putchar:0)
extern int	puts<s(0)(0)(0)>[&] (const char *);(D1:puts:0)
extern int	remove<s(0)(0)(0)>[&] (const char *);(D1:remove:0)
extern int	rename<s(0)(0)(0)>[&]  (const char *, const char *);(D1:rename:0)
extern void	rewind<s(0)(0)(0)>[&] (FILE<s(0)(0)(0)>[T] *);(D1:FILE:0)
extern int	scanf<s(0)(0)(0)>[&] (const char *, ...);(D1:scanf:0)
extern void	setbuf<s(0)(0)(0)>[&] (FILE<s(0)(0)(0)>[T] *, char *);(D1:FILE:0)
extern int	setvbuf<s(0)(0)(0)>[&] (FILE<s(0)(0)(0)>[T] *, char *, int, size_t<s(0)(0)(0)>[T]);(D1:size_t:0)
extern int	sprintf<s(0)(0)(0)>[&] (char *, const char *, ...);(D1:sprintf:0)
extern int	sscanf<s(0)(0)(0)>[&] (const char *, const char *, ...);(D1:sscanf:0)
extern FILE<s(0)(0)(0)>[T] *	tmpfile<s(0)(0)(0)>[&] (void);(D1:tmpfile:0)
extern char *	tmpnam<s(0)(0)(0)>[&] (char *);(D1:tmpnam:0)
extern int	ungetc<s(0)(0)(0)>[&] (int, FILE<s(0)(0)(0)>[T] *);(D1:FILE:0)
extern int	vfprintf<s(0)(0)(0)>[&] (FILE<s(0)(0)(0)>[T] *, const char *, va_list<s(0)(0)(0)>[T]);(D1:va_list:0)
extern int	vprintf<s(0)(0)(0)>[&] (const char *, va_list<s(0)(0)(0)>[T]);(D1:va_list:0)
extern int	vsprintf<s(0)(0)(0)>[&] (char *, const char *, va_list<s(0)(0)(0)>[T]);(D1:va_list:0)
extern int	__srget<s(0)(0)(0)>[&] (FILE<s(0)(0)(0)>[T] *);(D1:FILE:0)		 
extern int	__swbuf<s(0)(0)(0)>[&] (int, FILE<s(0)(0)(0)>[T] *);(D1:FILE:0)		 

 

extern FILE<s(0)(0)(0)>[T] *	fdopen<s(0)(0)(0)>[&] (int, const char *);(D1:fdopen:0)
extern int	fileno<s(0)(0)(0)>[&] (FILE<s(0)(0)(0)>[T] *);(D1:FILE:0)

 

 



extern int	fdprintf<s(0)(0)(0)>[&] (int fd<s(0)(0)(0)>[&], const char *fmt<s(0)(0)(0)>[&], ...);(D1:fmt:0)
extern int	vfdprintf<s(0)(0)(0)>[&] (int fd<s(0)(0)(0)>[&], const char *fmt<s(0)(0)(0)>[&], va_list<s(0)(0)(0)>[T] ap<s(0)(0)(0)>[&]);(D1:ap:0)
extern int	printErr<s(0)(0)(0)>[&] (const char *fmt<s(0)(0)(0)>[&], ...);(D1:fmt:0)
extern int	getw<s(0)(0)(0)>[&] (FILE<s(0)(0)(0)>[T] *);(D1:FILE:0)
extern int	putw<s(0)(0)(0)>[&] (int, FILE<s(0)(0)(0)>[T] *);(D1:FILE:0)
extern void	setbuffer<s(0)(0)(0)>[&] (FILE<s(0)(0)(0)>[T] *, char *, int);(D1:FILE:0)
extern int	setlinebuf<s(0)(0)(0)>[&] (FILE<s(0)(0)(0)>[T] *);(D1:FILE:0)
extern FILE<s(0)(0)(0)>[T] *   stdioFp<s(0)(0)(0)>[&] (int std<s(0)(0)(0)>[&]);(D1:std:0)
extern STATUS<s(0)(0)(0)>[T]   stdioShow<s(0)(0)(0)>[&] (FILE<s(0)(0)(0)>[T] * fp<s(0)(0)(0)>[&], int level<s(0)(0)(0)>[&]);(D1:level:0)
extern STATUS<s(0)(0)(0)>[T]   stdioShowInit<s(0)(0)(0)>[&] (void);(D1:stdioShowInit:0)
extern STATUS<s(0)(0)(0)>[T]   stdioInit<s(0)(0)(0)>[&] (void);(D1:stdioInit:0)






 


extern FILE<s(0)(0)(0)>[T] **	__stdin<s(0)(0)(0)>[&](void);(D1:__stdin:0)		 
extern FILE<s(0)(0)(0)>[T] **	__stdout<s(0)(0)(0)>[&](void);(D1:__stdout:0)		 
extern FILE<s(0)(0)(0)>[T] **	__stderr<s(0)(0)(0)>[&](void);(D1:__stderr:0)		 











 












































 


















 

























 












 






 






 












 















 






















 














 









    typedef void *ClientData<s(0)(0)(0)>[&];(D1:ClientData:1)[[TYPENAME:ClientData]]






 


















typedef struct Tcl_Interp<s(1)(0)(1)>[&] {
    char *result<s(1)(1)(0)>[&];		 

    void (*freeProc<s(1)(1)(0)>[&])  (char *blockPtr<s(1)(1)(0)>[&])  ;
				 






    int errorLine<s(1)(1)(0)>[&];               


} Tcl_Interp<s(0)(0)(0)>[&];(D1:Tcl_Interp:1)[[TYPENAME:Tcl_Interp]]

typedef struct Tcl_AsyncHandler_<s(1)(0)(1)>[&] *Tcl_AsyncHandler<s(0)(0)(0)>[&];(D1:Tcl_AsyncHandler:1)[[TYPENAME:Tcl_AsyncHandler]]
typedef struct Tcl_Channel_<s(1)(0)(1)>[&] *Tcl_Channel<s(0)(0)(0)>[&];(D1:Tcl_Channel:1)[[TYPENAME:Tcl_Channel]]
typedef struct Tcl_Command_<s(1)(0)(1)>[&] *Tcl_Command<s(0)(0)(0)>[&];(D1:Tcl_Command:1)[[TYPENAME:Tcl_Command]]
typedef struct Tcl_Event<s(1)(0)(1)>[&] Tcl_Event<s(1)(0)(1)>[&];(D1:Tcl_Event:1)[[TYPENAME:Tcl_Event]]
typedef struct Tcl_Pid_<s(1)(0)(1)>[&] *Tcl_Pid<s(0)(0)(0)>[&];(D1:Tcl_Pid:1)[[TYPENAME:Tcl_Pid]]
typedef struct Tcl_RegExp_<s(1)(0)(1)>[&] *Tcl_RegExp<s(0)(0)(0)>[&];(D1:Tcl_RegExp:1)[[TYPENAME:Tcl_RegExp]]
typedef struct Tcl_TimerToken_<s(1)(0)(1)>[&] *Tcl_TimerToken<s(0)(0)(0)>[&];(D1:Tcl_TimerToken:1)[[TYPENAME:Tcl_TimerToken]]
typedef struct Tcl_Trace_<s(1)(0)(1)>[&] *Tcl_Trace<s(0)(0)(0)>[&];(D1:Tcl_Trace:1)[[TYPENAME:Tcl_Trace]]
typedef struct Tcl_Var_<s(1)(0)(1)>[&] *Tcl_Var<s(0)(0)(0)>[&];(D1:Tcl_Var:1)[[TYPENAME:Tcl_Var]]

 




























 



typedef enum {TCL_INT<s(0)(0)(0)>[&], TCL_DOUBLE<s(0)(0)(0)>[&], TCL_EITHER<s(0)(0)(0)>[&]} Tcl_ValueType<s(0)(0)(0)>[&];(D1:Tcl_ValueType:1)[[TYPENAME:Tcl_ValueType]]
typedef struct Tcl_Value<s(1)(0)(1)>[&] {
    Tcl_ValueType<s(1)(1)(0)>[T] type<s(1)(1)(0)>[&];		 

    long intValue<s(1)(1)(0)>[&];		 
    double doubleValue<s(1)(1)(0)>[&];		 
} Tcl_Value<s(0)(0)(0)>[&];(D1:Tcl_Value:1)[[TYPENAME:Tcl_Value]]

 





struct Tcl_Obj<s(1)(0)(1)>[&];

 



typedef int (Tcl_AppInitProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_AppInitProc)  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&])  ;(D1:interp:0)
typedef int (Tcl_AsyncProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_AsyncProc)  (ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&],
	Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&], int code<s(0)(0)(0)>[&])  ;(D1:code:0)
typedef void (Tcl_ChannelProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_ChannelProc)  (ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&], int mask<s(0)(0)(0)>[&])  ;(D1:mask:0)
typedef void (Tcl_CloseProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_CloseProc)  (ClientData<s(0)(0)(0)>[T] data<s(0)(0)(0)>[&])  ;(D1:data:0)
typedef void (Tcl_CmdDeleteProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_CmdDeleteProc)  (ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&])  ;(D1:clientData:0)
typedef int (Tcl_CmdProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_CmdProc)  (ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&],
	Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&], int argc<s(0)(0)(0)>[&], char *argv<s(0)(0)(0)>[&][])  ;(D1:argv:0)
typedef void (Tcl_CmdTraceProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_CmdTraceProc)  (ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&],
	Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&], int level<s(0)(0)(0)>[&], char *command<s(0)(0)(0)>[&], Tcl_CmdProc<s(0)(0)(0)>[T] *proc<s(0)(0)(0)>[&],
	ClientData<s(0)(0)(0)>[T] cmdClientData<s(0)(0)(0)>[&], int argc<s(0)(0)(0)>[&], char *argv<s(0)(0)(0)>[&][])  ;(D1:argv:0)
typedef void (Tcl_DupInternalRepProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_DupInternalRepProc)  (struct Tcl_Obj<s(1)(0)(1)>[&] *srcPtr<s(0)(0)(0)>[&], 
        struct Tcl_Obj<s(1)(0)(1)>[&] *dupPtr<s(0)(0)(0)>[&])  ;(D1:dupPtr:0)
typedef int (Tcl_EventProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_EventProc)  (Tcl_Event<s(0)(0)(0)>[T] *evPtr<s(0)(0)(0)>[&], int flags<s(0)(0)(0)>[&])  ;(D1:flags:0)
typedef void (Tcl_EventCheckProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_EventCheckProc)  (ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&],
	int flags<s(0)(0)(0)>[&])  ;(D1:flags:0)
typedef int (Tcl_EventDeleteProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_EventDeleteProc)  (Tcl_Event<s(0)(0)(0)>[T] *evPtr<s(0)(0)(0)>[&],
        ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&])  ;(D1:clientData:0)
typedef void (Tcl_EventSetupProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_EventSetupProc)  (ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&],
	int flags<s(0)(0)(0)>[&])  ;(D1:flags:0)
typedef void (Tcl_ExitProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_ExitProc)  (ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&])  ;(D1:clientData:0)
typedef void (Tcl_FileProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_FileProc)  (ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&], int mask<s(0)(0)(0)>[&])  ;(D1:mask:0)
typedef void (Tcl_FileFreeProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_FileFreeProc)  (ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&])  ;(D1:clientData:0)
typedef void (Tcl_FreeInternalRepProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_FreeInternalRepProc)  (struct Tcl_Obj<s(1)(0)(1)>[&] *objPtr<s(0)(0)(0)>[&])  ;(D1:objPtr:0)
typedef void (Tcl_FreeProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_FreeProc)  (char *blockPtr<s(0)(0)(0)>[&])  ;(D1:blockPtr:0)
typedef void (Tcl_IdleProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_IdleProc)  (ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&])  ;(D1:clientData:0)
typedef void (Tcl_InterpDeleteProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_InterpDeleteProc)  (ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&],
	Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&])  ;(D1:interp:0)
typedef int (Tcl_MathProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_MathProc)  (ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&],
	Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&], Tcl_Value<s(0)(0)(0)>[T] *args<s(0)(0)(0)>[&], Tcl_Value<s(0)(0)(0)>[T] *resultPtr<s(0)(0)(0)>[&])  ;(D1:resultPtr:0)
typedef void (Tcl_NamespaceDeleteProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_NamespaceDeleteProc)  (ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&])  ;(D1:clientData:0)
typedef int (Tcl_ObjCmdProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_ObjCmdProc)  (ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&],
	Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&], int objc<s(0)(0)(0)>[&], struct Tcl_Obj<s(1)(0)(1)>[&] * const  objv<s(0)(0)(0)>[&][])  ;(D1:objv:0)
typedef int (Tcl_PackageInitProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_PackageInitProc)  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&])  ;(D1:interp:0)
typedef void (Tcl_TcpAcceptProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_TcpAcceptProc)  (ClientData<s(0)(0)(0)>[T] callbackData<s(0)(0)(0)>[&],
        Tcl_Channel<s(0)(0)(0)>[T] chan<s(0)(0)(0)>[&], char *address<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&])  ;(D1:port:0)
typedef void (Tcl_TimerProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_TimerProc)  (ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&])  ;(D1:clientData:0)
typedef int (Tcl_SetFromAnyProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_SetFromAnyProc)  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
	struct Tcl_Obj<s(1)(0)(1)>[&] *objPtr<s(0)(0)(0)>[&])  ;(D1:objPtr:0)
typedef void (Tcl_UpdateStringProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_UpdateStringProc)  (struct Tcl_Obj<s(1)(0)(1)>[&] *objPtr<s(0)(0)(0)>[&])  ;(D1:objPtr:0)
typedef char *(Tcl_VarTraceProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_VarTraceProc)  (ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&],
	Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&], char *part1<s(0)(0)(0)>[&], char *part2<s(0)(0)(0)>[&], int flags<s(0)(0)(0)>[&])  ;(D1:flags:0)

 





typedef struct Tcl_ObjType<s(1)(0)(1)>[&] {
    char *name<s(1)(1)(0)>[&];			 
    Tcl_FreeInternalRepProc<s(1)(1)(0)>[T] *freeIntRepProc<s(1)(1)(0)>[&];
				 


    Tcl_DupInternalRepProc<s(1)(1)(0)>[T] *dupIntRepProc<s(1)(1)(0)>[&];
    				 

    Tcl_UpdateStringProc<s(1)(1)(0)>[T] *updateStringProc<s(1)(1)(0)>[&];
    				 

    Tcl_SetFromAnyProc<s(1)(1)(0)>[T] *setFromAnyProc<s(1)(1)(0)>[&];
    				 



} Tcl_ObjType<s(0)(0)(0)>[&];(D1:Tcl_ObjType:1)[[TYPENAME:Tcl_ObjType]]

 





typedef struct Tcl_Obj<s(1)(0)(1)>[&] {
    int refCount<s(1)(1)(0)>[&];		 
    char *bytes<s(1)(1)(0)>[&];		 










    int length<s(1)(1)(0)>[&];			 

    Tcl_ObjType<s(1)(1)(0)>[T] *typePtr<s(1)(1)(0)>[&];	 



    union {			 
	long longValue<s(2)(1)(0)>[&];		 
	double doubleValue<s(2)(1)(0)>[&];	 
	void  *otherValuePtr<s(2)(1)(0)>[&];	 
	struct {		 
	    void  *ptr1<s(3)(1)(0)>[&];
	    void  *ptr2<s(3)(1)(0)>[&];
	} twoPtrValue<s(2)(0)(0)>[&];
    } internalRep<s(1)(0)(0)>[&];
} Tcl_Obj<s(0)(0)(0)>[&];(D1:Tcl_Obj:1)[[TYPENAME:Tcl_Obj]]

 










extern  void		Tcl_IncrRefCount<s(0)(0)(0)>[&]  (Tcl_Obj<s(0)(0)(0)>[T] *objPtr<s(0)(0)(0)>[&])  ;(D1:objPtr:0)
extern  void		Tcl_DecrRefCount<s(0)(0)(0)>[&]  (Tcl_Obj<s(0)(0)(0)>[T] *objPtr<s(0)(0)(0)>[&])  ;(D1:objPtr:0)
extern  int		Tcl_IsShared<s(0)(0)(0)>[&]  (Tcl_Obj<s(0)(0)(0)>[T] *objPtr<s(0)(0)(0)>[&])  ;(D1:objPtr:0)

















 





extern  Tcl_Obj<s(0)(0)(0)>[T] *	Tcl_NewBooleanObj<s(0)(0)(0)>[&]  (int boolValue<s(0)(0)(0)>[&])  ;(D1:boolValue:0)
extern  Tcl_Obj<s(0)(0)(0)>[T] *	Tcl_NewDoubleObj<s(0)(0)(0)>[&]  (double doubleValue<s(0)(0)(0)>[&])  ;(D1:doubleValue:0)
extern  Tcl_Obj<s(0)(0)(0)>[T] *	Tcl_NewIntObj<s(0)(0)(0)>[&]  (int intValue<s(0)(0)(0)>[&])  ;(D1:intValue:0)
extern  Tcl_Obj<s(0)(0)(0)>[T] *	Tcl_NewListObj<s(0)(0)(0)>[&]  (int objc<s(0)(0)(0)>[&],
			    Tcl_Obj<s(0)(0)(0)>[T] * const  objv<s(0)(0)(0)>[&][])  ;(D1:objv:0)
extern  Tcl_Obj<s(0)(0)(0)>[T] *	Tcl_NewLongObj<s(0)(0)(0)>[&]  (long longValue<s(0)(0)(0)>[&])  ;(D1:longValue:0)
extern  Tcl_Obj<s(0)(0)(0)>[T] *	Tcl_NewObj<s(0)(0)(0)>[&]  (void)  ;(D1:Tcl_NewObj:0)
extern  Tcl_Obj<s(0)(0)(0)>[T] *	Tcl_NewStringObj<s(0)(0)(0)>[&]  (char *bytes<s(0)(0)(0)>[&],
			    int length<s(0)(0)(0)>[&])  ;(D1:length:0)



 





typedef struct Tcl_Namespace<s(1)(0)(1)>[&] {
    char *name<s(1)(1)(0)>[&];                  



    char *fullName<s(1)(1)(0)>[&];              

    ClientData<s(1)(1)(0)>[T] clientData<s(1)(1)(0)>[&];       

    Tcl_NamespaceDeleteProc<s(1)(1)(0)>[T]* deleteProc<s(1)(1)(0)>[&];
                                 

    struct Tcl_Namespace<s(2)(1)(1)>[&]* parentPtr<s(1)(1)(0)>[&];
                                 


} Tcl_Namespace<s(0)(0)(0)>[&];(D1:Tcl_Namespace:1)[[TYPENAME:Tcl_Namespace]]

 





















typedef struct Tcl_CallFrame<s(1)(0)(1)>[&] {
    Tcl_Namespace<s(1)(1)(0)>[T] *nsPtr<s(1)(1)(0)>[&];
    int dummy1<s(1)(1)(0)>[&];
    int dummy2<s(1)(1)(0)>[&];
    char *dummy3<s(1)(1)(0)>[&];
    char *dummy4<s(1)(1)(0)>[&];
    char *dummy5<s(1)(1)(0)>[&];
    int dummy6<s(1)(1)(0)>[&];
    char *dummy7<s(1)(1)(0)>[&];
    char *dummy8<s(1)(1)(0)>[&];
    int dummy9<s(1)(1)(0)>[&];
    char* dummy10<s(1)(1)(0)>[&];
} Tcl_CallFrame<s(0)(0)(0)>[&];(D1:Tcl_CallFrame:1)[[TYPENAME:Tcl_CallFrame]]

 













     
typedef struct Tcl_CmdInfo<s(1)(0)(1)>[&] {
    int isNativeObjectProc<s(1)(1)(0)>[&];	  



    Tcl_ObjCmdProc<s(1)(1)(0)>[T] *objProc<s(1)(1)(0)>[&];	  
    ClientData<s(1)(1)(0)>[T] objClientData<s(1)(1)(0)>[&];	  
    Tcl_CmdProc<s(1)(1)(0)>[T] *proc<s(1)(1)(0)>[&];		  
    ClientData<s(1)(1)(0)>[T] clientData<s(1)(1)(0)>[&];	  
    Tcl_CmdDeleteProc<s(1)(1)(0)>[T] *deleteProc<s(1)(1)(0)>[&];
                                  

    ClientData<s(1)(1)(0)>[T] deleteData<s(1)(1)(0)>[&];	  

    Tcl_Namespace<s(1)(1)(0)>[T] *namespacePtr<s(1)(1)(0)>[&];  




} Tcl_CmdInfo<s(0)(0)(0)>[&];(D1:Tcl_CmdInfo:1)[[TYPENAME:Tcl_CmdInfo]]

 






typedef struct Tcl_DString<s(1)(0)(1)>[&] {
    char *string<s(1)(1)(0)>[&];		 

    int length<s(1)(1)(0)>[&];			 

    int spaceAvl<s(1)(1)(0)>[&];		 

    char staticSpace<s(1)(1)(0)>[&][200 ];
				 

} Tcl_DString<s(0)(0)(0)>[&];(D1:Tcl_DString:1)[[TYPENAME:Tcl_DString]]





 




 



 







 






 








 








 















 









 





extern  char *		Tcl_Alloc<s(0)(0)(0)>[&]  (unsigned int size<s(0)(0)(0)>[&])  ;(D1:size:0)
extern  void		Tcl_Free<s(0)(0)(0)>[&]  (char *ptr<s(0)(0)(0)>[&])  ;(D1:ptr:0)
extern  char *		Tcl_Realloc<s(0)(0)(0)>[&]  (char *ptr<s(0)(0)(0)>[&],
			    unsigned int size<s(0)(0)(0)>[&])  ;(D1:size:0)

















 









 





typedef struct Tcl_HashEntry<s(1)(0)(1)>[&] {
    struct Tcl_HashEntry<s(2)(1)(1)>[&] *nextPtr<s(1)(1)(0)>[&];	 


    struct Tcl_HashTable<s(2)(1)(1)>[&] *tablePtr<s(1)(1)(0)>[&];	 
    struct Tcl_HashEntry<s(2)(1)(1)>[&] **bucketPtr<s(1)(1)(0)>[&];	 


    ClientData<s(1)(1)(0)>[T] clientData<s(1)(1)(0)>[&];		 

    union {				 
	char *oneWordValue<s(2)(1)(0)>[&];		 
	int words<s(2)(1)(0)>[&][1];			 



	char string<s(2)(1)(0)>[&][4];			 


    } key<s(1)(0)(0)>[&];				 
} Tcl_HashEntry<s(0)(0)(0)>[&];(D1:Tcl_HashEntry:1)[[TYPENAME:Tcl_HashEntry]]

 






typedef struct Tcl_HashTable<s(1)(0)(1)>[&] {
    Tcl_HashEntry<s(1)(1)(0)>[T] **buckets<s(1)(1)(0)>[&];		 


    Tcl_HashEntry<s(1)(1)(0)>[T] *staticBuckets<s(1)(1)(0)>[&][4 ];
					 

    int numBuckets<s(1)(1)(0)>[&];			 

    int numEntries<s(1)(1)(0)>[&];			 

    int rebuildSize<s(1)(1)(0)>[&];			 

    int downShift<s(1)(1)(0)>[&];			 


    int mask<s(1)(1)(0)>[&];				 

    int keyType<s(1)(1)(0)>[&];			 





    Tcl_HashEntry<s(1)(1)(0)>[T] *(*findProc<s(1)(1)(0)>[&])  (struct Tcl_HashTable<s(2)(1)(1)>[&] *tablePtr<s(1)(1)(0)>[&], 
	    const  char *key<s(1)(1)(0)>[&])  ;
    Tcl_HashEntry<s(1)(1)(0)>[T] *(*createProc<s(1)(1)(0)>[&])  (struct Tcl_HashTable<s(2)(1)(1)>[&] *tablePtr<s(1)(1)(0)>[&],
	    const  char *key<s(1)(1)(0)>[&], int *newPtr<s(1)(1)(0)>[&])  ;
} Tcl_HashTable<s(0)(0)(0)>[&];(D1:Tcl_HashTable:1)[[TYPENAME:Tcl_HashTable]]

 




typedef struct Tcl_HashSearch<s(1)(0)(1)>[&] {
    Tcl_HashTable<s(1)(1)(0)>[T] *tablePtr<s(1)(1)(0)>[&];		 
    int nextIndex<s(1)(1)(0)>[&];			 

    Tcl_HashEntry<s(1)(1)(0)>[T] *nextEntryPtr<s(1)(1)(0)>[&];	 

} Tcl_HashSearch<s(0)(0)(0)>[&];(D1:Tcl_HashSearch:1)[[TYPENAME:Tcl_HashSearch]]

 






 









 









 











 









struct Tcl_Event<s(1)(0)(1)> {
    Tcl_EventProc<s(1)(1)(0)>[T] *proc<s(1)(1)(0)>[&];	 
    struct Tcl_Event<s(2)(1)(1)> *nextPtr<s(1)(1)(0)>[&];	 
};

 



typedef enum {
    TCL_QUEUE_TAIL<s(0)(0)(0)>[&], TCL_QUEUE_HEAD<s(0)(0)(0)>[&], TCL_QUEUE_MARK<s(0)(0)(0)>[&]
} Tcl_QueuePosition<s(0)(0)(0)>[&];(D1:Tcl_QueuePosition:1)[[TYPENAME:Tcl_QueuePosition]]

 







 






typedef struct Tcl_Time<s(1)(0)(1)>[&] {
    long sec<s(1)(1)(0)>[&];			 
    long usec<s(1)(1)(0)>[&];			 
} Tcl_Time<s(0)(0)(0)>[&];(D1:Tcl_Time:1)[[TYPENAME:Tcl_Time]]

 








 










 



typedef int	(Tcl_DriverBlockModeProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_DriverBlockModeProc)  (
		    ClientData<s(0)(0)(0)>[T] instanceData<s(0)(0)(0)>[&], int mode<s(0)(0)(0)>[&])  ;(D1:mode:0)
typedef int	(Tcl_DriverCloseProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_DriverCloseProc)  (ClientData<s(0)(0)(0)>[T] instanceData<s(0)(0)(0)>[&],
		    Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&])  ;(D1:interp:0)
typedef int	(Tcl_DriverInputProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_DriverInputProc)  (ClientData<s(0)(0)(0)>[T] instanceData<s(0)(0)(0)>[&],
		    char *buf<s(0)(0)(0)>[&], int toRead<s(0)(0)(0)>[&], int *errorCodePtr<s(0)(0)(0)>[&])  ;(D1:errorCodePtr:0)
typedef int	(Tcl_DriverOutputProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_DriverOutputProc)  (ClientData<s(0)(0)(0)>[T] instanceData<s(0)(0)(0)>[&],
		    char *buf<s(0)(0)(0)>[&], int toWrite<s(0)(0)(0)>[&], int *errorCodePtr<s(0)(0)(0)>[&])  ;(D1:errorCodePtr:0)
typedef int	(Tcl_DriverSeekProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_DriverSeekProc)  (ClientData<s(0)(0)(0)>[T] instanceData<s(0)(0)(0)>[&],
		    long offset<s(0)(0)(0)>[&], int mode<s(0)(0)(0)>[&], int *errorCodePtr<s(0)(0)(0)>[&])  ;(D1:errorCodePtr:0)
typedef int	(Tcl_DriverSetOptionProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_DriverSetOptionProc)  (
		    ClientData<s(0)(0)(0)>[T] instanceData<s(0)(0)(0)>[&], Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
	            char *optionName<s(0)(0)(0)>[&], char *value<s(0)(0)(0)>[&])  ;(D1:value:0)
typedef int	(Tcl_DriverGetOptionProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_DriverGetOptionProc)  (
		    ClientData<s(0)(0)(0)>[T] instanceData<s(0)(0)(0)>[&], Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
		    char *optionName<s(0)(0)(0)>[&], Tcl_DString<s(0)(0)(0)>[T] *dsPtr<s(0)(0)(0)>[&])  ;(D1:dsPtr:0)
typedef void	(Tcl_DriverWatchProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_DriverWatchProc)  (
		    ClientData<s(0)(0)(0)>[T] instanceData<s(0)(0)(0)>[&], int mask<s(0)(0)(0)>[&])  ;(D1:mask:0)
typedef int	(Tcl_DriverGetHandleProc<s(0)(0)(0)>[&])TYPENAME:FUNC:(Tcl_DriverGetHandleProc)  (
		    ClientData<s(0)(0)(0)>[T] instanceData<s(0)(0)(0)>[&], int direction<s(0)(0)(0)>[&],
		    ClientData<s(0)(0)(0)>[T] *handlePtr<s(0)(0)(0)>[&])  ;(D1:handlePtr:0)

 



typedef enum Tcl_EolTranslation<s(0)(0)(0)>[&] {
    TCL_TRANSLATE_AUTO<s(0)(0)(0)>[&],			 
    TCL_TRANSLATE_CR<s(0)(0)(0)>[&],			 
    TCL_TRANSLATE_LF<s(0)(0)(0)>[&],			 
    TCL_TRANSLATE_CRLF<s(0)(0)(0)>[&]			 
} Tcl_EolTranslation<s(0)(0)(0)>[&];(D1:Tcl_EolTranslation:1)[[TYPENAME:Tcl_EolTranslation]]

 







typedef struct Tcl_ChannelType<s(1)(0)(1)>[&] {
    char *typeName<s(1)(1)(0)>[&];			 


    Tcl_DriverBlockModeProc<s(1)(1)(0)>[T] *blockModeProc<s(1)(1)(0)>[&];
    					 

    Tcl_DriverCloseProc<s(1)(1)(0)>[T] *closeProc<s(1)(1)(0)>[&];	 

    Tcl_DriverInputProc<s(1)(1)(0)>[T] *inputProc<s(1)(1)(0)>[&];	 

    Tcl_DriverOutputProc<s(1)(1)(0)>[T] *outputProc<s(1)(1)(0)>[&];	 

    Tcl_DriverSeekProc<s(1)(1)(0)>[T] *seekProc<s(1)(1)(0)>[&];	 

    Tcl_DriverSetOptionProc<s(1)(1)(0)>[T] *setOptionProc<s(1)(1)(0)>[&];
    					 
    Tcl_DriverGetOptionProc<s(1)(1)(0)>[T] *getOptionProc<s(1)(1)(0)>[&];
    					 
    Tcl_DriverWatchProc<s(1)(1)(0)>[T] *watchProc<s(1)(1)(0)>[&];	 

    Tcl_DriverGetHandleProc<s(1)(1)(0)>[T] *getHandleProc<s(1)(1)(0)>[&];
					 

} Tcl_ChannelType<s(0)(0)(0)>[&];(D1:Tcl_ChannelType:1)[[TYPENAME:Tcl_ChannelType]]

 









 



typedef enum Tcl_PathType<s(0)(0)(0)>[&] {
    TCL_PATH_ABSOLUTE<s(0)(0)(0)>[&],
    TCL_PATH_RELATIVE<s(0)(0)(0)>[&],
    TCL_PATH_VOLUME_RELATIVE<s(0)(0)(0)>[&]
} Tcl_PathType<s(0)(0)(0)>[&];(D1:Tcl_PathType:1)[[TYPENAME:Tcl_PathType]]

 



extern  void		Tcl_AddErrorInfo<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *message<s(0)(0)(0)>[&])  ;(D1:message:0)
extern  void		Tcl_AddObjErrorInfo<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *message<s(0)(0)(0)>[&], int length<s(0)(0)(0)>[&])  ;(D1:length:0)
extern  void		Tcl_AllowExceptions<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&])  ;(D1:interp:0)
extern  int		Tcl_AppendAllObjTypes<s(0)(0)(0)>[&]  (
			    Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&], Tcl_Obj<s(0)(0)(0)>[T] *objPtr<s(0)(0)(0)>[&])  ;(D1:objPtr:0)
extern  void		Tcl_AppendElement<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *string<s(0)(0)(0)>[&])  ;(D1:string:0)
extern  void		Tcl_AppendResult<s(0)(0)(0)>[&]  
			    ( Tcl_Interp<s(0)(0)(0)>[T] *   interp<s(0)(0)(0)>[&] , ...)   ;(D1:interp:0)
extern  void		Tcl_AppendToObj<s(0)(0)(0)>[&]  (Tcl_Obj<s(0)(0)(0)>[T] *objPtr<s(0)(0)(0)>[&],
			    char *bytes<s(0)(0)(0)>[&], int length<s(0)(0)(0)>[&])  ;(D1:length:0)
extern  void		Tcl_AppendStringsToObj<s(0)(0)(0)>[&]  
			    ( Tcl_Obj<s(0)(0)(0)>[T] *   interp<s(0)(0)(0)>[&] , ...)   ;(D1:interp:0)
extern  int		Tcl_AppInit<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&])  ;(D1:interp:0)
extern  Tcl_AsyncHandler<s(0)(0)(0)>[T]	Tcl_AsyncCreate<s(0)(0)(0)>[&]  (Tcl_AsyncProc<s(0)(0)(0)>[T] *proc<s(0)(0)(0)>[&],
			    ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&])  ;(D1:clientData:0)
extern  void		Tcl_AsyncDelete<s(0)(0)(0)>[&]  (Tcl_AsyncHandler<s(0)(0)(0)>[T] async<s(0)(0)(0)>[&])  ;(D1:async:0)
extern  int		Tcl_AsyncInvoke<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    int code<s(0)(0)(0)>[&])  ;(D1:code:0)
extern  void		Tcl_AsyncMark<s(0)(0)(0)>[&]  (Tcl_AsyncHandler<s(0)(0)(0)>[T] async<s(0)(0)(0)>[&])  ;(D1:async:0)
extern  int		Tcl_AsyncReady<s(0)(0)(0)>[&]  (void)  ;(D1:Tcl_AsyncReady:0)
extern  void		Tcl_BackgroundError<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&])  ;(D1:interp:0)
extern  char		Tcl_Backslash<s(0)(0)(0)>[&]  (const  char *src<s(0)(0)(0)>[&],
			    int *readPtr<s(0)(0)(0)>[&])  ;(D1:readPtr:0)
extern  int		Tcl_BadChannelOption<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *optionName<s(0)(0)(0)>[&], char *optionList<s(0)(0)(0)>[&])  ;(D1:optionList:0)
extern  void		Tcl_CallWhenDeleted<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    Tcl_InterpDeleteProc<s(0)(0)(0)>[T] *proc<s(0)(0)(0)>[&],
			    ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&])  ;(D1:clientData:0)
extern  void		Tcl_CancelIdleCall<s(0)(0)(0)>[&]  (Tcl_IdleProc<s(0)(0)(0)>[T] *idleProc<s(0)(0)(0)>[&],
			    ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&])  ;(D1:clientData:0)



extern  int		Tcl_Close<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
        		    Tcl_Channel<s(0)(0)(0)>[T] chan<s(0)(0)(0)>[&])  ;(D1:chan:0)
extern  int		Tcl_CommandComplete<s(0)(0)(0)>[&]  (char *cmd<s(0)(0)(0)>[&])  ;(D1:cmd:0)
extern  char *		Tcl_Concat<s(0)(0)(0)>[&]  (int argc<s(0)(0)(0)>[&], char **argv<s(0)(0)(0)>[&])  ;(D1:argv:0)
extern  Tcl_Obj<s(0)(0)(0)>[T] *	Tcl_ConcatObj<s(0)(0)(0)>[&]  (int objc<s(0)(0)(0)>[&],
			    Tcl_Obj<s(0)(0)(0)>[T] * const  objv<s(0)(0)(0)>[&][])  ;(D1:objv:0)
extern  int		Tcl_ConvertCountedElement<s(0)(0)(0)>[&]  (const  char *src<s(0)(0)(0)>[&],
			    int length<s(0)(0)(0)>[&], char *dst<s(0)(0)(0)>[&], int flags<s(0)(0)(0)>[&])  ;(D1:flags:0)
extern  int		Tcl_ConvertElement<s(0)(0)(0)>[&]  (const  char *src<s(0)(0)(0)>[&],
			    char *dst<s(0)(0)(0)>[&], int flags<s(0)(0)(0)>[&])  ;(D1:flags:0)
extern  int		Tcl_ConvertToType<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    Tcl_Obj<s(0)(0)(0)>[T] *objPtr<s(0)(0)(0)>[&], Tcl_ObjType<s(0)(0)(0)>[T] *typePtr<s(0)(0)(0)>[&])  ;(D1:typePtr:0)
extern  int		Tcl_CreateAlias<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *slave<s(0)(0)(0)>[&],
			    char *slaveCmd<s(0)(0)(0)>[&], Tcl_Interp<s(0)(0)(0)>[T] *target<s(0)(0)(0)>[&],
        		    char *targetCmd<s(0)(0)(0)>[&], int argc<s(0)(0)(0)>[&], char **argv<s(0)(0)(0)>[&])  ;(D1:argv:0)
extern  int		Tcl_CreateAliasObj<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *slave<s(0)(0)(0)>[&],
			    char *slaveCmd<s(0)(0)(0)>[&], Tcl_Interp<s(0)(0)(0)>[T] *target<s(0)(0)(0)>[&],
        		    char *targetCmd<s(0)(0)(0)>[&], int objc<s(0)(0)(0)>[&],
		            Tcl_Obj<s(0)(0)(0)>[T] * const  objv<s(0)(0)(0)>[&][])  ;(D1:objv:0)
extern  Tcl_Channel<s(0)(0)(0)>[T]	Tcl_CreateChannel<s(0)(0)(0)>[&]  (
    			    Tcl_ChannelType<s(0)(0)(0)>[T] *typePtr<s(0)(0)(0)>[&], char *chanName<s(0)(0)(0)>[&],
                            ClientData<s(0)(0)(0)>[T] instanceData<s(0)(0)(0)>[&], int mask<s(0)(0)(0)>[&])  ;(D1:mask:0)
extern  void		Tcl_CreateChannelHandler<s(0)(0)(0)>[&]  (
			    Tcl_Channel<s(0)(0)(0)>[T] chan<s(0)(0)(0)>[&], int mask<s(0)(0)(0)>[&],
                            Tcl_ChannelProc<s(0)(0)(0)>[T] *proc<s(0)(0)(0)>[&], ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&])  ;(D1:clientData:0)
extern  void		Tcl_CreateCloseHandler<s(0)(0)(0)>[&]  (
			    Tcl_Channel<s(0)(0)(0)>[T] chan<s(0)(0)(0)>[&], Tcl_CloseProc<s(0)(0)(0)>[T] *proc<s(0)(0)(0)>[&],
                            ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&])  ;(D1:clientData:0)
extern  Tcl_Command<s(0)(0)(0)>[T]	Tcl_CreateCommand<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *cmdName<s(0)(0)(0)>[&], Tcl_CmdProc<s(0)(0)(0)>[T] *proc<s(0)(0)(0)>[&],
			    ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&],
			    Tcl_CmdDeleteProc<s(0)(0)(0)>[T] *deleteProc<s(0)(0)(0)>[&])  ;(D1:deleteProc:0)
extern  void		Tcl_CreateEventSource<s(0)(0)(0)>[&]  (
			    Tcl_EventSetupProc<s(0)(0)(0)>[T] *setupProc<s(0)(0)(0)>[&],
			    Tcl_EventCheckProc<s(0)(0)(0)>[T] *checkProc<s(0)(0)(0)>[&],
			    ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&])  ;(D1:clientData:0)
extern  void		Tcl_CreateExitHandler<s(0)(0)(0)>[&]  (Tcl_ExitProc<s(0)(0)(0)>[T] *proc<s(0)(0)(0)>[&],
			    ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&])  ;(D1:clientData:0)
extern  void		Tcl_CreateFileHandler<s(0)(0)(0)>[&]  (
    			    int fd<s(0)(0)(0)>[&], int mask<s(0)(0)(0)>[&], Tcl_FileProc<s(0)(0)(0)>[T] *proc<s(0)(0)(0)>[&],
			    ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&])  ;(D1:clientData:0)
extern  Tcl_Interp<s(0)(0)(0)>[T] *	Tcl_CreateInterp<s(0)(0)(0)>[&]  (void)  ;(D1:Tcl_CreateInterp:0)
extern  void		Tcl_CreateMathFunc<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *name<s(0)(0)(0)>[&], int numArgs<s(0)(0)(0)>[&], Tcl_ValueType<s(0)(0)(0)>[T] *argTypes<s(0)(0)(0)>[&],
			    Tcl_MathProc<s(0)(0)(0)>[T] *proc<s(0)(0)(0)>[&], ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&])  ;(D1:clientData:0)
extern  Tcl_Command<s(0)(0)(0)>[T]	Tcl_CreateObjCommand<s(0)(0)(0)>[&]  (
			    Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&], char *cmdName<s(0)(0)(0)>[&],
			    Tcl_ObjCmdProc<s(0)(0)(0)>[T] *proc<s(0)(0)(0)>[&], ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&],
			    Tcl_CmdDeleteProc<s(0)(0)(0)>[T] *deleteProc<s(0)(0)(0)>[&])  ;(D1:deleteProc:0)
extern  Tcl_Interp<s(0)(0)(0)>[T] *	Tcl_CreateSlave<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
		            char *slaveName<s(0)(0)(0)>[&], int isSafe<s(0)(0)(0)>[&])  ;(D1:isSafe:0)
extern  Tcl_TimerToken<s(0)(0)(0)>[T]	Tcl_CreateTimerHandler<s(0)(0)(0)>[&]  (int milliseconds<s(0)(0)(0)>[&],
			    Tcl_TimerProc<s(0)(0)(0)>[T] *proc<s(0)(0)(0)>[&], ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&])  ;(D1:clientData:0)
extern  Tcl_Trace<s(0)(0)(0)>[T]	Tcl_CreateTrace<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    int level<s(0)(0)(0)>[&], Tcl_CmdTraceProc<s(0)(0)(0)>[T] *proc<s(0)(0)(0)>[&],
			    ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&])  ;(D1:clientData:0)
extern  char *		Tcl_DbCkalloc<s(0)(0)(0)>[&]  (unsigned int size<s(0)(0)(0)>[&],
			    char *file<s(0)(0)(0)>[&], int line<s(0)(0)(0)>[&])  ;(D1:line:0)
extern  int		Tcl_DbCkfree<s(0)(0)(0)>[&]  (char *ptr<s(0)(0)(0)>[&],
			    char *file<s(0)(0)(0)>[&], int line<s(0)(0)(0)>[&])  ;(D1:line:0)
extern  char *		Tcl_DbCkrealloc<s(0)(0)(0)>[&]  (char *ptr<s(0)(0)(0)>[&],
			    unsigned int size<s(0)(0)(0)>[&], char *file<s(0)(0)(0)>[&], int line<s(0)(0)(0)>[&])  ;(D1:line:0)
extern  void		Tcl_DbDecrRefCount<s(0)(0)(0)>[&]  (Tcl_Obj<s(0)(0)(0)>[T] *objPtr<s(0)(0)(0)>[&],
			    char *file<s(0)(0)(0)>[&], int line<s(0)(0)(0)>[&])  ;(D1:line:0)
extern  void		Tcl_DbIncrRefCount<s(0)(0)(0)>[&]  (Tcl_Obj<s(0)(0)(0)>[T] *objPtr<s(0)(0)(0)>[&],
			    char *file<s(0)(0)(0)>[&], int line<s(0)(0)(0)>[&])  ;(D1:line:0)
extern  int		Tcl_DbIsShared<s(0)(0)(0)>[&]  (Tcl_Obj<s(0)(0)(0)>[T] *objPtr<s(0)(0)(0)>[&],
			    char *file<s(0)(0)(0)>[&], int line<s(0)(0)(0)>[&])  ;(D1:line:0)
extern  Tcl_Obj<s(0)(0)(0)>[T] *	Tcl_DbNewBooleanObj<s(0)(0)(0)>[&]  (int boolValue<s(0)(0)(0)>[&],
                            char *file<s(0)(0)(0)>[&], int line<s(0)(0)(0)>[&])  ;(D1:line:0)
extern  Tcl_Obj<s(0)(0)(0)>[T] *	Tcl_DbNewDoubleObj<s(0)(0)(0)>[&]  (double doubleValue<s(0)(0)(0)>[&],
                            char *file<s(0)(0)(0)>[&], int line<s(0)(0)(0)>[&])  ;(D1:line:0)
extern  Tcl_Obj<s(0)(0)(0)>[T] *	Tcl_DbNewListObj<s(0)(0)(0)>[&]  (int objc<s(0)(0)(0)>[&],
			    Tcl_Obj<s(0)(0)(0)>[T] * const  objv<s(0)(0)(0)>[&][], char *file<s(0)(0)(0)>[&], int line<s(0)(0)(0)>[&])  ;(D1:line:0)
extern  Tcl_Obj<s(0)(0)(0)>[T] *	Tcl_DbNewLongObj<s(0)(0)(0)>[&]  (long longValue<s(0)(0)(0)>[&],
                            char *file<s(0)(0)(0)>[&], int line<s(0)(0)(0)>[&])  ;(D1:line:0)
extern  Tcl_Obj<s(0)(0)(0)>[T] *	Tcl_DbNewObj<s(0)(0)(0)>[&]  (char *file<s(0)(0)(0)>[&], int line<s(0)(0)(0)>[&])  ;(D1:line:0)
extern  Tcl_Obj<s(0)(0)(0)>[T] *	Tcl_DbNewStringObj<s(0)(0)(0)>[&]  (char *bytes<s(0)(0)(0)>[&],
			    int length<s(0)(0)(0)>[&], char *file<s(0)(0)(0)>[&], int line<s(0)(0)(0)>[&])  ;(D1:line:0)
extern  void		Tcl_DeleteAssocData<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
                            char *name<s(0)(0)(0)>[&])  ;(D1:name:0)
extern  int		Tcl_DeleteCommand<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *cmdName<s(0)(0)(0)>[&])  ;(D1:cmdName:0)
extern  int		Tcl_DeleteCommandFromToken<s(0)(0)(0)>[&]  (
			    Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&], Tcl_Command<s(0)(0)(0)>[T] command<s(0)(0)(0)>[&])  ;(D1:command:0)
extern  void		Tcl_DeleteChannelHandler<s(0)(0)(0)>[&]  (
    			    Tcl_Channel<s(0)(0)(0)>[T] chan<s(0)(0)(0)>[&], Tcl_ChannelProc<s(0)(0)(0)>[T] *proc<s(0)(0)(0)>[&],
                            ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&])  ;(D1:clientData:0)
extern  void		Tcl_DeleteCloseHandler<s(0)(0)(0)>[&]  (
			    Tcl_Channel<s(0)(0)(0)>[T] chan<s(0)(0)(0)>[&], Tcl_CloseProc<s(0)(0)(0)>[T] *proc<s(0)(0)(0)>[&],
                            ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&])  ;(D1:clientData:0)
extern  void		Tcl_DeleteEvents<s(0)(0)(0)>[&]  (
			    Tcl_EventDeleteProc<s(0)(0)(0)>[T] *proc<s(0)(0)(0)>[&],
                            ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&])  ;(D1:clientData:0)
extern  void		Tcl_DeleteEventSource<s(0)(0)(0)>[&]  (
			    Tcl_EventSetupProc<s(0)(0)(0)>[T] *setupProc<s(0)(0)(0)>[&],
			    Tcl_EventCheckProc<s(0)(0)(0)>[T] *checkProc<s(0)(0)(0)>[&],
			    ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&])  ;(D1:clientData:0)
extern  void		Tcl_DeleteExitHandler<s(0)(0)(0)>[&]  (Tcl_ExitProc<s(0)(0)(0)>[T] *proc<s(0)(0)(0)>[&],
			    ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&])  ;(D1:clientData:0)
extern  void		Tcl_DeleteFileHandler<s(0)(0)(0)>[&]  (int fd<s(0)(0)(0)>[&])  ;(D1:fd:0)
extern  void		Tcl_DeleteHashEntry<s(0)(0)(0)>[&]  (
			    Tcl_HashEntry<s(0)(0)(0)>[T] *entryPtr<s(0)(0)(0)>[&])  ;(D1:entryPtr:0)
extern  void		Tcl_DeleteHashTable<s(0)(0)(0)>[&]  (
			    Tcl_HashTable<s(0)(0)(0)>[T] *tablePtr<s(0)(0)(0)>[&])  ;(D1:tablePtr:0)
extern  void		Tcl_DeleteInterp<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&])  ;(D1:interp:0)
extern  void		Tcl_DeleteTimerHandler<s(0)(0)(0)>[&]  (
			    Tcl_TimerToken<s(0)(0)(0)>[T] token<s(0)(0)(0)>[&])  ;(D1:token:0)
extern  void		Tcl_DeleteTrace<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    Tcl_Trace<s(0)(0)(0)>[T] trace<s(0)(0)(0)>[&])  ;(D1:trace:0)
extern  void		Tcl_DetachPids<s(0)(0)(0)>[&]  (int numPids<s(0)(0)(0)>[&], Tcl_Pid<s(0)(0)(0)>[T] *pidPtr<s(0)(0)(0)>[&])  ;(D1:pidPtr:0)
extern  void		Tcl_DontCallWhenDeleted<s(0)(0)(0)>[&]  (
			    Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&], Tcl_InterpDeleteProc<s(0)(0)(0)>[T] *proc<s(0)(0)(0)>[&],
			    ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&])  ;(D1:clientData:0)
extern  int		Tcl_DoOneEvent<s(0)(0)(0)>[&]  (int flags<s(0)(0)(0)>[&])  ;(D1:flags:0)
extern  void		Tcl_DoWhenIdle<s(0)(0)(0)>[&]  (Tcl_IdleProc<s(0)(0)(0)>[T] *proc<s(0)(0)(0)>[&],
			    ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&])  ;(D1:clientData:0)
extern  char *		Tcl_DStringAppend<s(0)(0)(0)>[&]  (Tcl_DString<s(0)(0)(0)>[T] *dsPtr<s(0)(0)(0)>[&],
			    const  char *string<s(0)(0)(0)>[&], int length<s(0)(0)(0)>[&])  ;(D1:length:0)
extern  char *		Tcl_DStringAppendElement<s(0)(0)(0)>[&]  (
			    Tcl_DString<s(0)(0)(0)>[T] *dsPtr<s(0)(0)(0)>[&], const  char *string<s(0)(0)(0)>[&])  ;(D1:string:0)
extern  void		Tcl_DStringEndSublist<s(0)(0)(0)>[&]  (Tcl_DString<s(0)(0)(0)>[T] *dsPtr<s(0)(0)(0)>[&])  ;(D1:dsPtr:0)
extern  void		Tcl_DStringFree<s(0)(0)(0)>[&]  (Tcl_DString<s(0)(0)(0)>[T] *dsPtr<s(0)(0)(0)>[&])  ;(D1:dsPtr:0)
extern  void		Tcl_DStringGetResult<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    Tcl_DString<s(0)(0)(0)>[T] *dsPtr<s(0)(0)(0)>[&])  ;(D1:dsPtr:0)
extern  void		Tcl_DStringInit<s(0)(0)(0)>[&]  (Tcl_DString<s(0)(0)(0)>[T] *dsPtr<s(0)(0)(0)>[&])  ;(D1:dsPtr:0)
extern  void		Tcl_DStringResult<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    Tcl_DString<s(0)(0)(0)>[T] *dsPtr<s(0)(0)(0)>[&])  ;(D1:dsPtr:0)
extern  void		Tcl_DStringSetLength<s(0)(0)(0)>[&]  (Tcl_DString<s(0)(0)(0)>[T] *dsPtr<s(0)(0)(0)>[&],
			    int length<s(0)(0)(0)>[&])  ;(D1:length:0)
extern  void		Tcl_DStringStartSublist<s(0)(0)(0)>[&]  (
			    Tcl_DString<s(0)(0)(0)>[T] *dsPtr<s(0)(0)(0)>[&])  ;(D1:dsPtr:0)
extern  Tcl_Obj<s(0)(0)(0)>[T] *	Tcl_DuplicateObj<s(0)(0)(0)>[&]  (Tcl_Obj<s(0)(0)(0)>[T] *objPtr<s(0)(0)(0)>[&])  ;(D1:objPtr:0)
extern  int		Tcl_Eof<s(0)(0)(0)>[&]  (Tcl_Channel<s(0)(0)(0)>[T] chan<s(0)(0)(0)>[&])  ;(D1:chan:0)
extern  char *		Tcl_ErrnoId<s(0)(0)(0)>[&]  (void)  ;(D1:Tcl_ErrnoId:0)
extern  char *		Tcl_ErrnoMsg<s(0)(0)(0)>[&]  (int err<s(0)(0)(0)>[&])  ;(D1:err:0)
extern  int		Tcl_Eval<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *string<s(0)(0)(0)>[&])  ;(D1:string:0)
extern  int		Tcl_EvalFile<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *fileName<s(0)(0)(0)>[&])  ;(D1:fileName:0)
extern  void		Tcl_EventuallyFree<s(0)(0)(0)>[&]  (ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&],
			    Tcl_FreeProc<s(0)(0)(0)>[T] *freeProc<s(0)(0)(0)>[&])  ;(D1:freeProc:0)
extern  int		Tcl_EvalObj<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    Tcl_Obj<s(0)(0)(0)>[T] *objPtr<s(0)(0)(0)>[&])  ;(D1:objPtr:0)
extern  void		Tcl_Exit<s(0)(0)(0)>[&]  (int status<s(0)(0)(0)>[&])  ;(D1:status:0)
extern  int		Tcl_ExposeCommand<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
        		    char *hiddenCmdToken<s(0)(0)(0)>[&], char *cmdName<s(0)(0)(0)>[&])  ;(D1:cmdName:0)
extern  int		Tcl_ExprBoolean<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *string<s(0)(0)(0)>[&], int *ptr<s(0)(0)(0)>[&])  ;(D1:ptr:0)
extern  int		Tcl_ExprBooleanObj<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    Tcl_Obj<s(0)(0)(0)>[T] *objPtr<s(0)(0)(0)>[&], int *ptr<s(0)(0)(0)>[&])  ;(D1:ptr:0)
extern  int		Tcl_ExprDouble<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *string<s(0)(0)(0)>[&], double *ptr<s(0)(0)(0)>[&])  ;(D1:ptr:0)
extern  int		Tcl_ExprDoubleObj<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    Tcl_Obj<s(0)(0)(0)>[T] *objPtr<s(0)(0)(0)>[&], double *ptr<s(0)(0)(0)>[&])  ;(D1:ptr:0)
extern  int		Tcl_ExprLong<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *string<s(0)(0)(0)>[&], long *ptr<s(0)(0)(0)>[&])  ;(D1:ptr:0)
extern  int		Tcl_ExprLongObj<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    Tcl_Obj<s(0)(0)(0)>[T] *objPtr<s(0)(0)(0)>[&], long *ptr<s(0)(0)(0)>[&])  ;(D1:ptr:0)
extern  int		Tcl_ExprObj<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    Tcl_Obj<s(0)(0)(0)>[T] *objPtr<s(0)(0)(0)>[&], Tcl_Obj<s(0)(0)(0)>[T] **resultPtrPtr<s(0)(0)(0)>[&])  ;(D1:resultPtrPtr:0)
extern  int		Tcl_ExprString<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *string<s(0)(0)(0)>[&])  ;(D1:string:0)
extern  void		Tcl_Finalize<s(0)(0)(0)>[&]  (void)  ;(D1:Tcl_Finalize:0)
extern  void		Tcl_FindExecutable<s(0)(0)(0)>[&]  (char *argv0<s(0)(0)(0)>[&])  ;(D1:argv0:0)
extern  Tcl_HashEntry<s(0)(0)(0)>[T] *	Tcl_FirstHashEntry<s(0)(0)(0)>[&]  (
			    Tcl_HashTable<s(0)(0)(0)>[T] *tablePtr<s(0)(0)(0)>[&],
			    Tcl_HashSearch<s(0)(0)(0)>[T] *searchPtr<s(0)(0)(0)>[&])  ;(D1:searchPtr:0)
extern  int		Tcl_Flush<s(0)(0)(0)>[&]  (Tcl_Channel<s(0)(0)(0)>[T] chan<s(0)(0)(0)>[&])  ;(D1:chan:0)
extern  void		TclFreeObj<s(0)(0)(0)>[&]  (Tcl_Obj<s(0)(0)(0)>[T] *objPtr<s(0)(0)(0)>[&])  ;(D1:objPtr:0)
extern  void		Tcl_FreeResult<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&])  ;(D1:interp:0)
extern  int		Tcl_GetAlias<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
       			    char *slaveCmd<s(0)(0)(0)>[&], Tcl_Interp<s(0)(0)(0)>[T] **targetInterpPtr<s(0)(0)(0)>[&],
                            char **targetCmdPtr<s(0)(0)(0)>[&], int *argcPtr<s(0)(0)(0)>[&],
			    char ***argvPtr<s(0)(0)(0)>[&])  ;(D1:argvPtr:0)
extern  int		Tcl_GetAliasObj<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
       			    char *slaveCmd<s(0)(0)(0)>[&], Tcl_Interp<s(0)(0)(0)>[T] **targetInterpPtr<s(0)(0)(0)>[&],
                            char **targetCmdPtr<s(0)(0)(0)>[&], int *objcPtr<s(0)(0)(0)>[&],
			    Tcl_Obj<s(0)(0)(0)>[T] ***objv<s(0)(0)(0)>[&])  ;(D1:objv:0)
extern  ClientData<s(0)(0)(0)>[T]	Tcl_GetAssocData<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
                            char *name<s(0)(0)(0)>[&], Tcl_InterpDeleteProc<s(0)(0)(0)>[T] **procPtr<s(0)(0)(0)>[&])  ;(D1:procPtr:0)
extern  int		Tcl_GetBoolean<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *string<s(0)(0)(0)>[&], int *boolPtr<s(0)(0)(0)>[&])  ;(D1:boolPtr:0)
extern  int		Tcl_GetBooleanFromObj<s(0)(0)(0)>[&]  (
			    Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&], Tcl_Obj<s(0)(0)(0)>[T] *objPtr<s(0)(0)(0)>[&],
			    int *boolPtr<s(0)(0)(0)>[&])  ;(D1:boolPtr:0)
extern  Tcl_Channel<s(0)(0)(0)>[T]	Tcl_GetChannel<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
	        	    char *chanName<s(0)(0)(0)>[&], int *modePtr<s(0)(0)(0)>[&])  ;(D1:modePtr:0)
extern  int		Tcl_GetChannelBufferSize<s(0)(0)(0)>[&]  (
    			    Tcl_Channel<s(0)(0)(0)>[T] chan<s(0)(0)(0)>[&])  ;(D1:chan:0)
extern  int		Tcl_GetChannelHandle<s(0)(0)(0)>[&]  (Tcl_Channel<s(0)(0)(0)>[T] chan<s(0)(0)(0)>[&],
	        	    int direction<s(0)(0)(0)>[&], ClientData<s(0)(0)(0)>[T] *handlePtr<s(0)(0)(0)>[&])  ;(D1:handlePtr:0)
extern  ClientData<s(0)(0)(0)>[T]	Tcl_GetChannelInstanceData<s(0)(0)(0)>[&]  (
    			    Tcl_Channel<s(0)(0)(0)>[T] chan<s(0)(0)(0)>[&])  ;(D1:chan:0)
extern  int		Tcl_GetChannelMode<s(0)(0)(0)>[&]  (Tcl_Channel<s(0)(0)(0)>[T] chan<s(0)(0)(0)>[&])  ;(D1:chan:0)
extern  char *		Tcl_GetChannelName<s(0)(0)(0)>[&]  (Tcl_Channel<s(0)(0)(0)>[T] chan<s(0)(0)(0)>[&])  ;(D1:chan:0)
extern  int		Tcl_GetChannelOption<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    Tcl_Channel<s(0)(0)(0)>[T] chan<s(0)(0)(0)>[&], char *optionName<s(0)(0)(0)>[&],
			    Tcl_DString<s(0)(0)(0)>[T] *dsPtr<s(0)(0)(0)>[&])  ;(D1:dsPtr:0)
extern  Tcl_ChannelType<s(0)(0)(0)>[T] * Tcl_GetChannelType<s(0)(0)(0)>[&]  (Tcl_Channel<s(0)(0)(0)>[T] chan<s(0)(0)(0)>[&])  ;(D1:chan:0)
extern  int		Tcl_GetCommandInfo<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *cmdName<s(0)(0)(0)>[&], Tcl_CmdInfo<s(0)(0)(0)>[T] *infoPtr<s(0)(0)(0)>[&])  ;(D1:infoPtr:0)
extern  char *		Tcl_GetCommandName<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    Tcl_Command<s(0)(0)(0)>[T] command<s(0)(0)(0)>[&])  ;(D1:command:0)
extern  char *		Tcl_GetCwd<s(0)(0)(0)>[&]  (char *buf<s(0)(0)(0)>[&], int len<s(0)(0)(0)>[&])  ;(D1:len:0)
extern  int		Tcl_GetDouble<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *string<s(0)(0)(0)>[&], double *doublePtr<s(0)(0)(0)>[&])  ;(D1:doublePtr:0)
extern  int		Tcl_GetDoubleFromObj<s(0)(0)(0)>[&]  (
			    Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&], Tcl_Obj<s(0)(0)(0)>[T] *objPtr<s(0)(0)(0)>[&],
			    double *doublePtr<s(0)(0)(0)>[&])  ;(D1:doublePtr:0)
extern  int		Tcl_GetErrno<s(0)(0)(0)>[&]  (void)  ;(D1:Tcl_GetErrno:0)
extern  int		Tcl_GetErrorLine<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&])  ;(D1:interp:0)
extern  char *		Tcl_GetHostName<s(0)(0)(0)>[&]  (void)  ;(D1:Tcl_GetHostName:0)
extern  int		Tcl_GetIndexFromObj<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    Tcl_Obj<s(0)(0)(0)>[T] *objPtr<s(0)(0)(0)>[&], char **tablePtr<s(0)(0)(0)>[&], char *msg<s(0)(0)(0)>[&],
			    int flags<s(0)(0)(0)>[&], int *indexPtr<s(0)(0)(0)>[&])  ;(D1:indexPtr:0)
extern  int		Tcl_GetInt<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *string<s(0)(0)(0)>[&], int *intPtr<s(0)(0)(0)>[&])  ;(D1:intPtr:0)
extern  int		Tcl_GetInterpPath<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *askInterp<s(0)(0)(0)>[&],
			    Tcl_Interp<s(0)(0)(0)>[T] *slaveInterp<s(0)(0)(0)>[&])  ;(D1:slaveInterp:0)
extern  int		Tcl_GetIntFromObj<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    Tcl_Obj<s(0)(0)(0)>[T] *objPtr<s(0)(0)(0)>[&], int *intPtr<s(0)(0)(0)>[&])  ;(D1:intPtr:0)
extern  int		Tcl_GetLongFromObj<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    Tcl_Obj<s(0)(0)(0)>[T] *objPtr<s(0)(0)(0)>[&], long *longPtr<s(0)(0)(0)>[&])  ;(D1:longPtr:0)
extern  Tcl_Interp<s(0)(0)(0)>[T] *	Tcl_GetMaster<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&])  ;(D1:interp:0)
extern  Tcl_Obj<s(0)(0)(0)>[T] *	Tcl_GetObjResult<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&])  ;(D1:interp:0)
extern  Tcl_ObjType<s(0)(0)(0)>[T] *	Tcl_GetObjType<s(0)(0)(0)>[&]  (char *typeName<s(0)(0)(0)>[&])  ;(D1:typeName:0)
extern  int		Tcl_GetOpenFile<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *string<s(0)(0)(0)>[&], int write<s(0)(0)(0)>[&], int checkUsage<s(0)(0)(0)>[&],
			    ClientData<s(0)(0)(0)>[T] *filePtr<s(0)(0)(0)>[&])  ;(D1:filePtr:0)
extern  Tcl_Command<s(0)(0)(0)>[T]	Tcl_GetOriginalCommand<s(0)(0)(0)>[&]  (
			    Tcl_Command<s(0)(0)(0)>[T] command<s(0)(0)(0)>[&])  ;(D1:command:0)
extern  Tcl_PathType<s(0)(0)(0)>[T]	Tcl_GetPathType<s(0)(0)(0)>[&]  (char *path<s(0)(0)(0)>[&])  ;(D1:path:0)
extern  int		Tcl_Gets<s(0)(0)(0)>[&]  (Tcl_Channel<s(0)(0)(0)>[T] chan<s(0)(0)(0)>[&],
        		    Tcl_DString<s(0)(0)(0)>[T] *dsPtr<s(0)(0)(0)>[&])  ;(D1:dsPtr:0)
extern  int		Tcl_GetsObj<s(0)(0)(0)>[&]  (Tcl_Channel<s(0)(0)(0)>[T] chan<s(0)(0)(0)>[&],
        		    Tcl_Obj<s(0)(0)(0)>[T] *objPtr<s(0)(0)(0)>[&])  ;(D1:objPtr:0)
extern  int		Tcl_GetServiceMode<s(0)(0)(0)>[&]  (void)  ;(D1:Tcl_GetServiceMode:0)
extern  Tcl_Interp<s(0)(0)(0)>[T] *	Tcl_GetSlave<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *slaveName<s(0)(0)(0)>[&])  ;(D1:slaveName:0)
extern  Tcl_Channel<s(0)(0)(0)>[T]	Tcl_GetStdChannel<s(0)(0)(0)>[&]  (int type<s(0)(0)(0)>[&])  ;(D1:type:0)
extern  char *		Tcl_GetStringFromObj<s(0)(0)(0)>[&]  (Tcl_Obj<s(0)(0)(0)>[T] *objPtr<s(0)(0)(0)>[&],
			    int *lengthPtr<s(0)(0)(0)>[&])  ;(D1:lengthPtr:0)
extern  char *		Tcl_GetStringResult<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&])  ;(D1:interp:0)
extern  char *		Tcl_GetVar<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *varName<s(0)(0)(0)>[&], int flags<s(0)(0)(0)>[&])  ;(D1:flags:0)
extern  char *		Tcl_GetVar2<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *part1<s(0)(0)(0)>[&], char *part2<s(0)(0)(0)>[&], int flags<s(0)(0)(0)>[&])  ;(D1:flags:0)
extern  int		Tcl_GlobalEval<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *command<s(0)(0)(0)>[&])  ;(D1:command:0)
extern  int		Tcl_GlobalEvalObj<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    Tcl_Obj<s(0)(0)(0)>[T] *objPtr<s(0)(0)(0)>[&])  ;(D1:objPtr:0)
extern  char *		Tcl_HashStats<s(0)(0)(0)>[&]  (Tcl_HashTable<s(0)(0)(0)>[T] *tablePtr<s(0)(0)(0)>[&])  ;(D1:tablePtr:0)
extern  int		Tcl_HideCommand<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
		            char *cmdName<s(0)(0)(0)>[&], char *hiddenCmdToken<s(0)(0)(0)>[&])  ;(D1:hiddenCmdToken:0)
extern  int		Tcl_Init<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&])  ;(D1:interp:0)
extern  void		Tcl_InitHashTable<s(0)(0)(0)>[&]  (Tcl_HashTable<s(0)(0)(0)>[T] *tablePtr<s(0)(0)(0)>[&],
			    int keyType<s(0)(0)(0)>[&])  ;(D1:keyType:0)
extern  void		Tcl_InitMemory<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&])  ;(D1:interp:0)
extern  int		Tcl_InputBlocked<s(0)(0)(0)>[&]  (Tcl_Channel<s(0)(0)(0)>[T] chan<s(0)(0)(0)>[&])  ;(D1:chan:0)
extern  int		Tcl_InputBuffered<s(0)(0)(0)>[&]  (Tcl_Channel<s(0)(0)(0)>[T] chan<s(0)(0)(0)>[&])  ;(D1:chan:0)
extern  int		Tcl_InterpDeleted<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&])  ;(D1:interp:0)
extern  int		Tcl_IsSafe<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&])  ;(D1:interp:0)
extern  void		Tcl_InvalidateStringRep<s(0)(0)(0)>[&]  (
			    Tcl_Obj<s(0)(0)(0)>[T] *objPtr<s(0)(0)(0)>[&])  ;(D1:objPtr:0)
extern  char *		Tcl_JoinPath<s(0)(0)(0)>[&]  (int argc<s(0)(0)(0)>[&], char **argv<s(0)(0)(0)>[&],
			    Tcl_DString<s(0)(0)(0)>[T] *resultPtr<s(0)(0)(0)>[&])  ;(D1:resultPtr:0)
extern  int		Tcl_LinkVar<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *varName<s(0)(0)(0)>[&], char *addr<s(0)(0)(0)>[&], int type<s(0)(0)(0)>[&])  ;(D1:type:0)
extern  int		Tcl_ListObjAppendList<s(0)(0)(0)>[&]  (
			    Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&], Tcl_Obj<s(0)(0)(0)>[T] *listPtr<s(0)(0)(0)>[&], 
			    Tcl_Obj<s(0)(0)(0)>[T] *elemListPtr<s(0)(0)(0)>[&])  ;(D1:elemListPtr:0)
extern  int		Tcl_ListObjAppendElement<s(0)(0)(0)>[&]  (
			    Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&], Tcl_Obj<s(0)(0)(0)>[T] *listPtr<s(0)(0)(0)>[&],
			    Tcl_Obj<s(0)(0)(0)>[T] *objPtr<s(0)(0)(0)>[&])  ;(D1:objPtr:0)
extern  int		Tcl_ListObjGetElements<s(0)(0)(0)>[&]  (
			    Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&], Tcl_Obj<s(0)(0)(0)>[T] *listPtr<s(0)(0)(0)>[&],
			    int *objcPtr<s(0)(0)(0)>[&], Tcl_Obj<s(0)(0)(0)>[T] ***objvPtr<s(0)(0)(0)>[&])  ;(D1:objvPtr:0)
extern  int		Tcl_ListObjIndex<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    Tcl_Obj<s(0)(0)(0)>[T] *listPtr<s(0)(0)(0)>[&], int index<s(0)(0)(0)>[&], 
			    Tcl_Obj<s(0)(0)(0)>[T] **objPtrPtr<s(0)(0)(0)>[&])  ;(D1:objPtrPtr:0)
extern  int		Tcl_ListObjLength<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    Tcl_Obj<s(0)(0)(0)>[T] *listPtr<s(0)(0)(0)>[&], int *intPtr<s(0)(0)(0)>[&])  ;(D1:intPtr:0)
extern  int		Tcl_ListObjReplace<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    Tcl_Obj<s(0)(0)(0)>[T] *listPtr<s(0)(0)(0)>[&], int first<s(0)(0)(0)>[&], int count<s(0)(0)(0)>[&],
			    int objc<s(0)(0)(0)>[&], Tcl_Obj<s(0)(0)(0)>[T] * const  objv<s(0)(0)(0)>[&][])  ;(D1:objv:0)
extern  void		Tcl_Main<s(0)(0)(0)>[&]  (int argc<s(0)(0)(0)>[&], char **argv<s(0)(0)(0)>[&], int fd<s(0)(0)(0)>[&],
			    Tcl_AppInitProc<s(0)(0)(0)>[T] *appInitProc<s(0)(0)(0)>[&])  ;(D1:appInitProc:0)
 
extern  int		Tcl_MakeSafe<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&])  ;(D1:interp:0)
extern  Tcl_Channel<s(0)(0)(0)>[T]	Tcl_MakeTcpClientChannel<s(0)(0)(0)>[&]  (
    			    ClientData<s(0)(0)(0)>[T] tcpSocket<s(0)(0)(0)>[&])  ;(D1:tcpSocket:0)
extern  char *		Tcl_Merge<s(0)(0)(0)>[&]  (int argc<s(0)(0)(0)>[&], char **argv<s(0)(0)(0)>[&])  ;(D1:argv:0)
extern  Tcl_HashEntry<s(0)(0)(0)>[T] *	Tcl_NextHashEntry<s(0)(0)(0)>[&]  (
			    Tcl_HashSearch<s(0)(0)(0)>[T] *searchPtr<s(0)(0)(0)>[&])  ;(D1:searchPtr:0)
extern  void		Tcl_NotifyChannel<s(0)(0)(0)>[&]  (Tcl_Channel<s(0)(0)(0)>[T] channel<s(0)(0)(0)>[&],
			    int mask<s(0)(0)(0)>[&])  ;(D1:mask:0)
extern  Tcl_Obj<s(0)(0)(0)>[T] *	Tcl_ObjGetVar2<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    Tcl_Obj<s(0)(0)(0)>[T] *part1Ptr<s(0)(0)(0)>[&], Tcl_Obj<s(0)(0)(0)>[T] *part2Ptr<s(0)(0)(0)>[&],
			    int flags<s(0)(0)(0)>[&])  ;(D1:flags:0)
extern  Tcl_Obj<s(0)(0)(0)>[T] *	Tcl_ObjSetVar2<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    Tcl_Obj<s(0)(0)(0)>[T] *part1Ptr<s(0)(0)(0)>[&], Tcl_Obj<s(0)(0)(0)>[T] *part2Ptr<s(0)(0)(0)>[&],
			    Tcl_Obj<s(0)(0)(0)>[T] *newValuePtr<s(0)(0)(0)>[&], int flags<s(0)(0)(0)>[&])  ;(D1:flags:0)
extern  Tcl_Channel<s(0)(0)(0)>[T]	Tcl_OpenCommandChannel<s(0)(0)(0)>[&]  (
    			    Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&], int argc<s(0)(0)(0)>[&], char **argv<s(0)(0)(0)>[&],
			    int flags<s(0)(0)(0)>[&])  ;(D1:flags:0)
extern  Tcl_Channel<s(0)(0)(0)>[T]	Tcl_OpenFileChannel<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
        		    char *fileName<s(0)(0)(0)>[&], char *modeString<s(0)(0)(0)>[&],
                            int permissions<s(0)(0)(0)>[&])  ;(D1:permissions:0)
extern  Tcl_Channel<s(0)(0)(0)>[T]	Tcl_OpenTcpClient<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    int port<s(0)(0)(0)>[&], char *address<s(0)(0)(0)>[&], char *myaddr<s(0)(0)(0)>[&],
		            int myport<s(0)(0)(0)>[&], int async<s(0)(0)(0)>[&])  ;(D1:async:0)
extern  Tcl_Channel<s(0)(0)(0)>[T]	Tcl_OpenTcpServer<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
		            int port<s(0)(0)(0)>[&], char *host<s(0)(0)(0)>[&],
        		    Tcl_TcpAcceptProc<s(0)(0)(0)>[T] *acceptProc<s(0)(0)(0)>[&],
			    ClientData<s(0)(0)(0)>[T] callbackData<s(0)(0)(0)>[&])  ;(D1:callbackData:0)
extern  char *		Tcl_ParseVar<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *string<s(0)(0)(0)>[&], char **termPtr<s(0)(0)(0)>[&])  ;(D1:termPtr:0)
extern  int		Tcl_PkgProvide<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *name<s(0)(0)(0)>[&], char *version<s(0)(0)(0)>[&])  ;(D1:version:0)
extern  char *		Tcl_PkgRequire<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *name<s(0)(0)(0)>[&], char *version<s(0)(0)(0)>[&], int exact<s(0)(0)(0)>[&])  ;(D1:exact:0)
extern  char *		Tcl_PosixError<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&])  ;(D1:interp:0)
extern  void		Tcl_Preserve<s(0)(0)(0)>[&]  (ClientData<s(0)(0)(0)>[T] data<s(0)(0)(0)>[&])  ;(D1:data:0)
extern  void		Tcl_PrintDouble<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    double value<s(0)(0)(0)>[&], char *dst<s(0)(0)(0)>[&])  ;(D1:dst:0)
extern  int		Tcl_PutEnv<s(0)(0)(0)>[&]  (const  char *string<s(0)(0)(0)>[&])  ;(D1:string:0)
extern  void		Tcl_QueueEvent<s(0)(0)(0)>[&]  (Tcl_Event<s(0)(0)(0)>[T] *evPtr<s(0)(0)(0)>[&],
			    Tcl_QueuePosition<s(0)(0)(0)>[T] position<s(0)(0)(0)>[&])  ;(D1:position:0)
extern  int		Tcl_Read<s(0)(0)(0)>[&]  (Tcl_Channel<s(0)(0)(0)>[T] chan<s(0)(0)(0)>[&],
	        	    char *bufPtr<s(0)(0)(0)>[&], int toRead<s(0)(0)(0)>[&])  ;(D1:toRead:0)
extern  void		Tcl_ReapDetachedProcs<s(0)(0)(0)>[&]  (void)  ;(D1:Tcl_ReapDetachedProcs:0)
extern  int		Tcl_RecordAndEval<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *cmd<s(0)(0)(0)>[&], int flags<s(0)(0)(0)>[&])  ;(D1:flags:0)
extern  int		Tcl_RecordAndEvalObj<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    Tcl_Obj<s(0)(0)(0)>[T] *cmdPtr<s(0)(0)(0)>[&], int flags<s(0)(0)(0)>[&])  ;(D1:flags:0)
extern  Tcl_RegExp<s(0)(0)(0)>[T]	Tcl_RegExpCompile<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *string<s(0)(0)(0)>[&])  ;(D1:string:0)
extern  int		Tcl_RegExpExec<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    Tcl_RegExp<s(0)(0)(0)>[T] regexp<s(0)(0)(0)>[&], char *string<s(0)(0)(0)>[&], char *start<s(0)(0)(0)>[&])  ;(D1:start:0)
extern  int		Tcl_RegExpMatch<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *string<s(0)(0)(0)>[&], char *pattern<s(0)(0)(0)>[&])  ;(D1:pattern:0)
extern  void		Tcl_RegExpRange<s(0)(0)(0)>[&]  (Tcl_RegExp<s(0)(0)(0)>[T] regexp<s(0)(0)(0)>[&],
			    int index<s(0)(0)(0)>[&], char **startPtr<s(0)(0)(0)>[&], char **endPtr<s(0)(0)(0)>[&])  ;(D1:endPtr:0)
extern  void		Tcl_RegisterChannel<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
	        	    Tcl_Channel<s(0)(0)(0)>[T] chan<s(0)(0)(0)>[&])  ;(D1:chan:0)
extern  void		Tcl_RegisterObjType<s(0)(0)(0)>[&]  (
			    Tcl_ObjType<s(0)(0)(0)>[T] *typePtr<s(0)(0)(0)>[&])  ;(D1:typePtr:0)
extern  void		Tcl_Release<s(0)(0)(0)>[&]  (ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&])  ;(D1:clientData:0)
extern  void		Tcl_RestartIdleTimer<s(0)(0)(0)>[&]  (void)  ;(D1:Tcl_RestartIdleTimer:0)
extern  void		Tcl_ResetResult<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&])  ;(D1:interp:0)

extern  int		Tcl_ScanCountedElement<s(0)(0)(0)>[&]  (const  char *string<s(0)(0)(0)>[&],
			    int length<s(0)(0)(0)>[&], int *flagPtr<s(0)(0)(0)>[&])  ;(D1:flagPtr:0)
extern  int		Tcl_ScanElement<s(0)(0)(0)>[&]  (const  char *string<s(0)(0)(0)>[&],
			    int *flagPtr<s(0)(0)(0)>[&])  ;(D1:flagPtr:0)
extern  int		Tcl_Seek<s(0)(0)(0)>[&]  (Tcl_Channel<s(0)(0)(0)>[T] chan<s(0)(0)(0)>[&],
        		    int offset<s(0)(0)(0)>[&], int mode<s(0)(0)(0)>[&])  ;(D1:mode:0)
extern  int		Tcl_ServiceAll<s(0)(0)(0)>[&]  (void)  ;(D1:Tcl_ServiceAll:0)
extern  int		Tcl_ServiceEvent<s(0)(0)(0)>[&]  (int flags<s(0)(0)(0)>[&])  ;(D1:flags:0)
extern  void		Tcl_SetAssocData<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
                            char *name<s(0)(0)(0)>[&], Tcl_InterpDeleteProc<s(0)(0)(0)>[T] *proc<s(0)(0)(0)>[&],
                            ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&])  ;(D1:clientData:0)
extern  void		Tcl_SetBooleanObj<s(0)(0)(0)>[&]  (Tcl_Obj<s(0)(0)(0)>[T] *objPtr<s(0)(0)(0)>[&], 
			    int boolValue<s(0)(0)(0)>[&])  ;(D1:boolValue:0)
extern  void		Tcl_SetChannelBufferSize<s(0)(0)(0)>[&]  (
			    Tcl_Channel<s(0)(0)(0)>[T] chan<s(0)(0)(0)>[&], int sz<s(0)(0)(0)>[&])  ;(D1:sz:0)
extern  int		Tcl_SetChannelOption<s(0)(0)(0)>[&]  (
			    Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&], Tcl_Channel<s(0)(0)(0)>[T] chan<s(0)(0)(0)>[&],
	        	    char *optionName<s(0)(0)(0)>[&], char *newValue<s(0)(0)(0)>[&])  ;(D1:newValue:0)
extern  int		Tcl_SetCommandInfo<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *cmdName<s(0)(0)(0)>[&], Tcl_CmdInfo<s(0)(0)(0)>[T] *infoPtr<s(0)(0)(0)>[&])  ;(D1:infoPtr:0)
extern  void		Tcl_SetDoubleObj<s(0)(0)(0)>[&]  (Tcl_Obj<s(0)(0)(0)>[T] *objPtr<s(0)(0)(0)>[&], 
			    double doubleValue<s(0)(0)(0)>[&])  ;(D1:doubleValue:0)
extern  void		Tcl_SetErrno<s(0)(0)(0)>[&]  (int err<s(0)(0)(0)>[&])  ;(D1:err:0)
extern  void		Tcl_SetErrorCode<s(0)(0)(0)>[&]  
    			    ( Tcl_Interp<s(0)(0)(0)>[T] *   arg1<s(0)(0)(0)>[&] , ...)   ;(D1:arg1:0)
extern  void		Tcl_SetIntObj<s(0)(0)(0)>[&]  (Tcl_Obj<s(0)(0)(0)>[T] *objPtr<s(0)(0)(0)>[&], 
			    int intValue<s(0)(0)(0)>[&])  ;(D1:intValue:0)
extern  void		Tcl_SetListObj<s(0)(0)(0)>[&]  (Tcl_Obj<s(0)(0)(0)>[T] *objPtr<s(0)(0)(0)>[&], 
			    int objc<s(0)(0)(0)>[&], Tcl_Obj<s(0)(0)(0)>[T] * const  objv<s(0)(0)(0)>[&][])  ;(D1:objv:0)
extern  void		Tcl_SetLongObj<s(0)(0)(0)>[&]  (Tcl_Obj<s(0)(0)(0)>[T] *objPtr<s(0)(0)(0)>[&], 
			    long longValue<s(0)(0)(0)>[&])  ;(D1:longValue:0)
extern  void		Tcl_SetMaxBlockTime<s(0)(0)(0)>[&]  (Tcl_Time<s(0)(0)(0)>[T] *timePtr<s(0)(0)(0)>[&])  ;(D1:timePtr:0)
extern  void		Tcl_SetObjErrorCode<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    Tcl_Obj<s(0)(0)(0)>[T] *errorObjPtr<s(0)(0)(0)>[&])  ;(D1:errorObjPtr:0)
extern  void		Tcl_SetObjLength<s(0)(0)(0)>[&]  (Tcl_Obj<s(0)(0)(0)>[T] *objPtr<s(0)(0)(0)>[&],
			    int length<s(0)(0)(0)>[&])  ;(D1:length:0)
extern  void		Tcl_SetObjResult<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    Tcl_Obj<s(0)(0)(0)>[T] *resultObjPtr<s(0)(0)(0)>[&])  ;(D1:resultObjPtr:0)
extern  void		Tcl_SetPanicProc<s(0)(0)(0)>[&]  (void (*proc<s(0)(0)(0)>[&])
			     ( char *    format<s(0)(0)(0)>[&] , ...)   )  ;(D1:format:0)
extern  int		Tcl_SetRecursionLimit<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    int depth<s(0)(0)(0)>[&])  ;(D1:depth:0)
extern  void		Tcl_SetResult<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *string<s(0)(0)(0)>[&], Tcl_FreeProc<s(0)(0)(0)>[T] *freeProc<s(0)(0)(0)>[&])  ;(D1:freeProc:0)
extern  int		Tcl_SetServiceMode<s(0)(0)(0)>[&]  (int mode<s(0)(0)(0)>[&])  ;(D1:mode:0)
extern  void		Tcl_SetStdChannel<s(0)(0)(0)>[&]  (Tcl_Channel<s(0)(0)(0)>[T] channel<s(0)(0)(0)>[&],
			    int type<s(0)(0)(0)>[&])  ;(D1:type:0)
extern  void		Tcl_SetStringObj<s(0)(0)(0)>[&]  (Tcl_Obj<s(0)(0)(0)>[T] *objPtr<s(0)(0)(0)>[&], 
			    char *bytes<s(0)(0)(0)>[&], int length<s(0)(0)(0)>[&])  ;(D1:length:0)
extern  void		Tcl_SetTimer<s(0)(0)(0)>[&]  (Tcl_Time<s(0)(0)(0)>[T] *timePtr<s(0)(0)(0)>[&])  ;(D1:timePtr:0)
extern  char *		Tcl_SetVar<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *varName<s(0)(0)(0)>[&], char *newValue<s(0)(0)(0)>[&], int flags<s(0)(0)(0)>[&])  ;(D1:flags:0)
extern  char *		Tcl_SetVar2<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *part1<s(0)(0)(0)>[&], char *part2<s(0)(0)(0)>[&], char *newValue<s(0)(0)(0)>[&],
			    int flags<s(0)(0)(0)>[&])  ;(D1:flags:0)
extern  char *		Tcl_SignalId<s(0)(0)(0)>[&]  (int sig<s(0)(0)(0)>[&])  ;(D1:sig:0)
extern  char *		Tcl_SignalMsg<s(0)(0)(0)>[&]  (int sig<s(0)(0)(0)>[&])  ;(D1:sig:0)
extern  void		Tcl_Sleep<s(0)(0)(0)>[&]  (int ms<s(0)(0)(0)>[&])  ;(D1:ms:0)
extern  void		Tcl_SourceRCFile<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&])  ;(D1:interp:0)
extern  int		Tcl_SplitList<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *list<s(0)(0)(0)>[&], int *argcPtr<s(0)(0)(0)>[&], char ***argvPtr<s(0)(0)(0)>[&])  ;(D1:argvPtr:0)
extern  void		Tcl_SplitPath<s(0)(0)(0)>[&]  (char *path<s(0)(0)(0)>[&],
			    int *argcPtr<s(0)(0)(0)>[&], char ***argvPtr<s(0)(0)(0)>[&])  ;(D1:argvPtr:0)
extern  void		Tcl_StaticPackage<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *pkgName<s(0)(0)(0)>[&], Tcl_PackageInitProc<s(0)(0)(0)>[T] *initProc<s(0)(0)(0)>[&],
			    Tcl_PackageInitProc<s(0)(0)(0)>[T] *safeInitProc<s(0)(0)(0)>[&])  ;(D1:safeInitProc:0)
extern  int		Tcl_StringMatch<s(0)(0)(0)>[&]  (char *string<s(0)(0)(0)>[&],
			    char *pattern<s(0)(0)(0)>[&])  ;(D1:pattern:0)
extern  int		Tcl_Tell<s(0)(0)(0)>[&]  (Tcl_Channel<s(0)(0)(0)>[T] chan<s(0)(0)(0)>[&])  ;(D1:chan:0)

extern  int		Tcl_TraceVar<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *varName<s(0)(0)(0)>[&], int flags<s(0)(0)(0)>[&], Tcl_VarTraceProc<s(0)(0)(0)>[T] *proc<s(0)(0)(0)>[&],
			    ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&])  ;(D1:clientData:0)
extern  int		Tcl_TraceVar2<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *part1<s(0)(0)(0)>[&], char *part2<s(0)(0)(0)>[&], int flags<s(0)(0)(0)>[&],
			    Tcl_VarTraceProc<s(0)(0)(0)>[T] *proc<s(0)(0)(0)>[&], ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&])  ;(D1:clientData:0)
extern  char *		Tcl_TranslateFileName<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *name<s(0)(0)(0)>[&], Tcl_DString<s(0)(0)(0)>[T] *bufferPtr<s(0)(0)(0)>[&])  ;(D1:bufferPtr:0)
extern  int		Tcl_Ungets<s(0)(0)(0)>[&]  (Tcl_Channel<s(0)(0)(0)>[T] chan<s(0)(0)(0)>[&], char *str<s(0)(0)(0)>[&],
			    int len<s(0)(0)(0)>[&], int atHead<s(0)(0)(0)>[&])  ;(D1:atHead:0)
extern  void		Tcl_UnlinkVar<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *varName<s(0)(0)(0)>[&])  ;(D1:varName:0)
extern  int		Tcl_UnregisterChannel<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    Tcl_Channel<s(0)(0)(0)>[T] chan<s(0)(0)(0)>[&])  ;(D1:chan:0)
extern  int		Tcl_UnsetVar<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *varName<s(0)(0)(0)>[&], int flags<s(0)(0)(0)>[&])  ;(D1:flags:0)
extern  int		Tcl_UnsetVar2<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *part1<s(0)(0)(0)>[&], char *part2<s(0)(0)(0)>[&], int flags<s(0)(0)(0)>[&])  ;(D1:flags:0)
extern  void		Tcl_UntraceVar<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *varName<s(0)(0)(0)>[&], int flags<s(0)(0)(0)>[&], Tcl_VarTraceProc<s(0)(0)(0)>[T] *proc<s(0)(0)(0)>[&],
			    ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&])  ;(D1:clientData:0)
extern  void		Tcl_UntraceVar2<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *part1<s(0)(0)(0)>[&], char *part2<s(0)(0)(0)>[&], int flags<s(0)(0)(0)>[&],
			    Tcl_VarTraceProc<s(0)(0)(0)>[T] *proc<s(0)(0)(0)>[&], ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&])  ;(D1:clientData:0)
extern  void		Tcl_UpdateLinkedVar<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *varName<s(0)(0)(0)>[&])  ;(D1:varName:0)
extern  int		Tcl_UpVar<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *frameName<s(0)(0)(0)>[&], char *varName<s(0)(0)(0)>[&],
			    char *localName<s(0)(0)(0)>[&], int flags<s(0)(0)(0)>[&])  ;(D1:flags:0)
extern  int		Tcl_UpVar2<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *frameName<s(0)(0)(0)>[&], char *part1<s(0)(0)(0)>[&], char *part2<s(0)(0)(0)>[&],
			    char *localName<s(0)(0)(0)>[&], int flags<s(0)(0)(0)>[&])  ;(D1:flags:0)
extern  int		Tcl_VarEval<s(0)(0)(0)>[&]  
    			    ( Tcl_Interp<s(0)(0)(0)>[T] *   interp<s(0)(0)(0)>[&] , ...)   ;(D1:interp:0)
extern  ClientData<s(0)(0)(0)>[T]	Tcl_VarTraceInfo<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *varName<s(0)(0)(0)>[&], int flags<s(0)(0)(0)>[&],
			    Tcl_VarTraceProc<s(0)(0)(0)>[T] *procPtr<s(0)(0)(0)>[&],
			    ClientData<s(0)(0)(0)>[T] prevClientData<s(0)(0)(0)>[&])  ;(D1:prevClientData:0)
extern  ClientData<s(0)(0)(0)>[T]	Tcl_VarTraceInfo2<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    char *part1<s(0)(0)(0)>[&], char *part2<s(0)(0)(0)>[&], int flags<s(0)(0)(0)>[&],
			    Tcl_VarTraceProc<s(0)(0)(0)>[T] *procPtr<s(0)(0)(0)>[&],
			    ClientData<s(0)(0)(0)>[T] prevClientData<s(0)(0)(0)>[&])  ;(D1:prevClientData:0)
extern  int		Tcl_WaitForEvent<s(0)(0)(0)>[&]  (Tcl_Time<s(0)(0)(0)>[T] *timePtr<s(0)(0)(0)>[&])  ;(D1:timePtr:0)
extern  Tcl_Pid<s(0)(0)(0)>[T]		Tcl_WaitPid<s(0)(0)(0)>[&]  (Tcl_Pid<s(0)(0)(0)>[T] pid<s(0)(0)(0)>[&], int *statPtr<s(0)(0)(0)>[&], 
			    int options<s(0)(0)(0)>[&])  ;(D1:options:0)
extern  int		Tcl_Write<s(0)(0)(0)>[&]  (Tcl_Channel<s(0)(0)(0)>[T] chan<s(0)(0)(0)>[&],
			    char *s<s(0)(0)(0)>[&], int slen<s(0)(0)(0)>[&])  ;(D1:slen:0)
extern  void		Tcl_WrongNumArgs<s(0)(0)(0)>[&]  (Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&],
			    int objc<s(0)(0)(0)>[&], Tcl_Obj<s(0)(0)(0)>[T] * const  objv<s(0)(0)(0)>[&][], char *message<s(0)(0)(0)>[&])  ;(D1:message:0)




 

 

 




















 



extern void 	tickAnnounce<s(0)(0)(0)>[&] (void);(D1:tickAnnounce:0)
extern void 	tickSet<s(0)(0)(0)>[&] (ULONG<s(0)(0)(0)>[T] ticks<s(0)(0)(0)>[&]);(D1:ticks:0)
extern ULONG<s(0)(0)(0)>[T] 	tickGet<s(0)(0)(0)>[&] (void);(D1:tickGet:0)
















 





typedef INT2<s(0)(0)(0)>[T] DEBUG_LEVEL<s(0)(0)(0)>[&];(D1:DEBUG_LEVEL:1)[[TYPENAME:DEBUG_LEVEL]]

 




extern DEBUG_LEVEL<s(0)(0)(0)>[T] DBG_SetDebugLevel<s(0)(0)(0)>[&](DEBUG_LEVEL<s(0)(0)(0)>[T] level<s(0)(0)(0)>[&]);(D1:level:0)

 




extern DEBUG_LEVEL<s(0)(0)(0)>[T] DBG_GetDebugLevel<s(0)(0)(0)>[&]();(D1:DBG_GetDebugLevel:0)

 











extern STATUS<s(0)(0)(0)>[T] DBG_debug<s(0)(0)(0)>[&](int argc<s(0)(0)(0)>[&], char **argv<s(0)(0)(0)>[&]);(D1:argv:0)

 

















 




















extern UINT4<s(0)(0)(0)>[T] DBG_ReadRegister<s(0)(0)(0)>[&](UINT1<s(0)(0)(0)>[T] * pAddress<s(0)(0)(0)>[&], INT4<s(0)(0)(0)>[T] num<s(0)(0)(0)>[&]);(D1:num:0)
extern void DBG_WriteRegister<s(0)(0)(0)>[&](UINT1<s(0)(0)(0)>[T] * pAddress<s(0)(0)(0)>[&], UINT1<s(0)(0)(0)>[T] value<s(0)(0)(0)>[&]);(D1:value:0)



 





 






typedef struct {
    char levelName<s(1)(1)(0)>[&][16 ];
    UINT8<s(1)(1)(0)>[T]  initVal<s(1)(1)(0)>[&];          
    char levelDesc<s(1)(1)(0)>[&][256 ];
}DBG_LEVEL_INFO_T<s(0)(0)(0)>[&];(D1:DBG_LEVEL_INFO_T:1)[[TYPENAME:DBG_LEVEL_INFO_T]]

typedef struct {
    char module<s(1)(1)(0)>[&][16 ];
    DBG_LEVEL_INFO_T<s(1)(1)(0)>[T] levels<s(1)(1)(0)>[&][32 ];
}DBG_INFO_T<s(0)(0)(0)>[&];(D1:DBG_INFO_T:1)[[TYPENAME:DBG_INFO_T]]

 
typedef struct {
    UINT32<s(1)(1)(0)>[T] level<s(1)(1)(0)>[&][253];
    UINT32<s(1)(1)(0)>[T] warmFlag<s(1)(1)(0)>[&];   
    UINT32<s(1)(1)(0)>[T] nvramMaxLen<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T] nvramLen<s(1)(1)(0)>[&];
    char nvram<s(1)(1)(0)>[&][1];   
}DBG_NVRAM_T<s(0)(0)(0)>[&];(D1:DBG_NVRAM_T:1)[[TYPENAME:DBG_NVRAM_T]]
extern DBG_NVRAM_T<s(0)(0)(0)>[T]* gpDbgNvram<s(0)(0)(0)>[&];(D1:gpDbgNvram:0)

typedef UINT16<s(0)(0)(0)>[T] DBG_MODULE_T<s(0)(0)(0)>[&];(D1:DBG_MODULE_T:1)[[TYPENAME:DBG_MODULE_T]]

 





void DBG_Init<s(0)(0)(0)>[&](void);(D1:DBG_Init:0)

 









DBG_MODULE_T<s(0)(0)(0)>[T] DBG_RegisterModule<s(0)(0)(0)>[&](DBG_INFO_T<s(0)(0)(0)>[T] *pInfo<s(0)(0)(0)>[&]);(D1:pInfo:0)

 









void DBG_SetLevel<s(0)(0)(0)>[&](char* module<s(0)(0)(0)>[&], char* level<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] set<s(0)(0)(0)>[&]);(D1:set:0)
 








void DBG_SetAllLevels<s(0)(0)(0)>[&](char* module<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] set<s(0)(0)(0)>[&]);(D1:set:0)
 










void DBG_SetLevelByNum<s(0)(0)(0)>[&](DBG_MODULE_T<s(0)(0)(0)>[T] module<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] level<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] set<s(0)(0)(0)>[&]);(D1:set:0)

 




void DBG_ShowModules<s(0)(0)(0)>[&](void);(D1:DBG_ShowModules:0)

 






void DBG_ShowModuleInfo<s(0)(0)(0)>[&](char* module<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] full<s(0)(0)(0)>[&]);(D1:full:0)

 








BOOL<s(0)(0)(0)>[T] DBG_GetLevelByName<s(0)(0)(0)>[&](char* module<s(0)(0)(0)>[&], char* level<s(0)(0)(0)>[&]);(D1:level:0)
 









BOOL<s(0)(0)(0)>[T] DBG_GetLevel<s(0)(0)(0)>[&](DBG_MODULE_T<s(0)(0)(0)>[T] module<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] level<s(0)(0)(0)>[&]);(D1:level:0)
 











BOOL<s(0)(0)(0)>[T] DBG_GetLevel2And<s(0)(0)(0)>[&](DBG_MODULE_T<s(0)(0)(0)>[T] module<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] level1<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] level2<s(0)(0)(0)>[&]);(D1:level2:0)
 











BOOL<s(0)(0)(0)>[T] DBG_GetLevel2Or<s(0)(0)(0)>[&](DBG_MODULE_T<s(0)(0)(0)>[T] module<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] level1<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] level2<s(0)(0)(0)>[&]);(D1:level2:0)

 
void DBG_NvResetLevel<s(0)(0)(0)>[&](void);(D1:DBG_NvResetLevel:0)
 
int DBG_NvResetBuffer<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] base<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] bufLen<s(0)(0)(0)>[&]);(D1:bufLen:0)
 
void DBG_NvPrintBuffer<s(0)(0)(0)>[&](void);(D1:DBG_NvPrintBuffer:0)
 

void DBG_NvPrintBufferBack<s(0)(0)(0)>[&](void);(D1:DBG_NvPrintBufferBack:0)
void DBG_NvSetLevel<s(0)(0)(0)>[&](char* module<s(0)(0)(0)>[&], char* level<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] set<s(0)(0)(0)>[&]);(D1:set:0)
void DBG_NvSetAllLevels<s(0)(0)(0)>[&](char* module<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] set<s(0)(0)(0)>[&]);(D1:set:0)
void DBG_NvSetLevelByNum<s(0)(0)(0)>[&](DBG_MODULE_T<s(0)(0)(0)>[T] module<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] level<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] set<s(0)(0)(0)>[&]);(D1:set:0)
void DBG_NvShowModules<s(0)(0)(0)>[&](void);(D1:DBG_NvShowModules:0)
void DBG_NvShowModuleInfo<s(0)(0)(0)>[&](char* module<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] full<s(0)(0)(0)>[&]);(D1:full:0)
BOOL<s(0)(0)(0)>[T] DBG_NvGetLevelByName<s(0)(0)(0)>[&](char* module<s(0)(0)(0)>[&], char* level<s(0)(0)(0)>[&]);(D1:level:0)
BOOL<s(0)(0)(0)>[T] DBG_NvGetLevel<s(0)(0)(0)>[&](DBG_MODULE_T<s(0)(0)(0)>[T] module<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] level<s(0)(0)(0)>[&]);(D1:level:0)
BOOL<s(0)(0)(0)>[T] DBG_NvGetLevel2And<s(0)(0)(0)>[&](DBG_MODULE_T<s(0)(0)(0)>[T] module<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] level1<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] level2<s(0)(0)(0)>[&]);(D1:level2:0)
BOOL<s(0)(0)(0)>[T] DBG_NvGetLevel2Or<s(0)(0)(0)>[&](DBG_MODULE_T<s(0)(0)(0)>[T] module<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] level1<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] level2<s(0)(0)(0)>[&]);(D1:level2:0)






  














extern int DBG_TclAppInit<s(0)(0)(0)>[&](Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&]);(D1:interp:0)





 

















 
 
 
 
 
 
 
 
 
 
 
 







 











 












 



 

 







 


 


 



 



 








 



 

















































































































 


 








 




 


typedef struct {
    unsigned short slot<s(1)(1)(0)>[&];         
    unsigned short pslot<s(1)(1)(0)>[&];        
    unsigned int applNumber<s(1)(1)(0)>[&]; 
    unsigned int instance<s(1)(1)(0)>[&];
} applId_tt<s(0)(0)(0)>[&];(D1:applId_tt:1)[[TYPENAME:applId_tt]]

typedef struct {
    unsigned char packet_type<s(1)(1)(0)>[&];   
    unsigned char packet_flags<s(1)(1)(0)>[&];  
    unsigned short packet_sequence<s(1)(1)(0)>[&];   
    applId_tt<s(1)(1)(0)>[T] dest<s(1)(1)(0)>[&];   
    applId_tt<s(1)(1)(0)>[T] src<s(1)(1)(0)>[&];  

    int command<s(1)(1)(0)>[&];      
    int length<s(1)(1)(0)>[&];                  
    unsigned short reSendSynMsgMax<s(1)(1)(0)>[&]; 

    unsigned short  sendSynMsgTimerLen<s(1)(1)(0)>[&];   

    unsigned short  wCheckSum<s(1)(1)(0)>[&];   
    unsigned char aExt<s(1)(1)(0)>[&][2];
    void *handle<s(1)(1)(0)>[&];   
     
} command_tt<s(0)(0)(0)>[&];(D1:command_tt:1)[[TYPENAME:command_tt]]



 











 















































 














 




typedef struct _CM_PHYCARDPARA_T<s(1)(0)(1)>[&] {
    unsigned int style<s(1)(1)(0)>[&];
    unsigned int function<s(1)(1)(0)>[&];
    unsigned int hwVersion<s(1)(1)(0)>[&];
    unsigned int option<s(1)(1)(0)>[&];
    unsigned int slot<s(1)(1)(0)>[&];
    char   serialNum<s(1)(1)(0)>[&][18 ];
    char   manuDate<s(1)(1)(0)>[&][9 ];
    char   prodCode<s(1)(1)(0)>[&][11 ]; 
    char   oemCode<s(1)(1)(0)>[&][11 ];
    char   simCode<s(1)(1)(0)>[&][26 ];
    char   bootDate<s(1)(1)(0)>[&][41 ];
    char   bootVersion<s(1)(1)(0)>[&][17 ];
    char   hardVersion<s(1)(1)(0)>[&][17 ];
    char   softVersion<s(1)(1)(0)>[&][33 ];
    char   fusionVersion<s(1)(1)(0)>[&][17 ];
    char   fpgaVersion<s(1)(1)(0)>[&][(17  * 15) ];	
} CM_PHYCARDPARA_T<s(0)(0)(0)>[&];(D1:CM_PHYCARDPARA_T:1)[[TYPENAME:CM_PHYCARDPARA_T]]

typedef struct _CM_INFRA_BOOT_ACK_T<s(1)(0)(1)>[&]
{
    int    m_boot<s(1)(1)(0)>[&]; 
}CM_INFRA_BOOT_ACK_T<s(0)(0)(0)>[&];(D1:CM_INFRA_BOOT_ACK_T:1)[[TYPENAME:CM_INFRA_BOOT_ACK_T]]

typedef struct _CM_LOAD_OBJ_T<s(1)(0)(1)>[&]
{
    unsigned int slot<s(1)(1)(0)>[&];
}CM_LOAD_OBJ_T<s(0)(0)(0)>[&];(D1:CM_LOAD_OBJ_T:1)[[TYPENAME:CM_LOAD_OBJ_T]]

typedef struct cmndFmtApplState<s(1)(0)(1)>[&] {
    command_tt<s(1)(1)(0)>[T] head<s(1)(1)(0)>[&];
    int state<s(1)(1)(0)>[&];
    int applOptions<s(1)(1)(0)>[&];
} cmndFmtApplState_t<s(0)(0)(0)>[&];(D1:cmndFmtApplState_t:1)[[TYPENAME:cmndFmtApplState_t]]

 







































 






































typedef UINT16<s(0)(0)(0)>[T] DTL_MODULE_T<s(0)(0)(0)>[&];(D1:DTL_MODULE_T:1)[[TYPENAME:DTL_MODULE_T]]

typedef enum
{
    DTL_NOTHING_OPEN<s(0)(0)(0)>[&] = 0,       
    DTL_REALTIME_PRINT<s(0)(0)(0)>[&],         
    DTL_RAM_SAVE<s(0)(0)(0)>[&],               
    DTL_FLASH_SAVE<s(0)(0)(0)>[&],              
    DTL_FLASH_SAVE_DIRECTLY<s(0)(0)(0)>[&],    
                                
}DTL_LEVEL_MODE_T<s(0)(0)(0)>[&];(D1:DTL_LEVEL_MODE_T:1)[[TYPENAME:DTL_LEVEL_MODE_T]]

typedef struct
{
    char                 levelName<s(1)(1)(0)>[&][32 ];
    DTL_LEVEL_MODE_T<s(1)(1)(0)>[T]     levelControl<s(1)(1)(0)>[&];         
    UINT16<s(1)(1)(0)>[T]               levelCount<s(1)(1)(0)>[&];            
    char                 levelDesc<s(1)(1)(0)>[&][128 ];
}DTL_LEVEL_INFO_T<s(0)(0)(0)>[&];(D1:DTL_LEVEL_INFO_T:1)[[TYPENAME:DTL_LEVEL_INFO_T]]

typedef struct 
{
    char                module<s(1)(1)(0)>[&][32 ];
    DTL_LEVEL_INFO_T<s(1)(1)(0)>[T]    levels<s(1)(1)(0)>[&][32 ];
}DTL_MOD_INFO_T<s(0)(0)(0)>[&];(D1:DTL_MOD_INFO_T:1)[[TYPENAME:DTL_MOD_INFO_T]]

















extern DTL_MODULE_T<s(0)(0)(0)>[T]  DTL_RegisterModule<s(0)(0)(0)>[&](DTL_MOD_INFO_T<s(0)(0)(0)>[T] *pInfo<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] timeStampEnable<s(0)(0)(0)>[&]);(D1:timeStampEnable:0)
extern void          DTL_PrintProc<s(0)(0)(0)>[&](DTL_MODULE_T<s(0)(0)(0)>[T] module<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] level<s(0)(0)(0)>[&], char* fileName<s(0)(0)(0)>[&], int line<s(0)(0)(0)>[&],  char *fmt<s(0)(0)(0)>[&], ...);(D1:fmt:0)
extern void          DTL_LoadModule<s(0)(0)(0)>[&](void);(D1:DTL_LoadModule:0)










 
 
 
 
 
 
 
 










 
 
 
 
 
 
 
 
 



















































































































































































 
 

 

 

 


































 











































 



 








 















 














 






struct opthdr<s(1)(0)(1)>[&] {
	long 	level<s(1)(1)(0)>[&];			 
	long	name<s(1)(1)(0)>[&];			 
	long	len<s(1)(1)(0)>[&];			 
};




 


struct	linger<s(1)(0)(1)>[&] {
	int	l_onoff<s(1)(1)(0)>[&];		 
	int	l_linger<s(1)(1)(0)>[&];		 
};

 




 





































 



struct sockaddr<s(1)(0)(1)>[&] {
	u_char<s(1)(1)(0)>[T]	sa_len<s(1)(1)(0)>[&];			 
	u_char<s(1)(1)(0)>[T]	sa_family<s(1)(1)(0)>[&];		 
	char	sa_data<s(1)(1)(0)>[&][14];		 
};

typedef struct sockaddr<s(1)(0)(1)>[&] SOCKADDR<s(1)(0)(1)>[&];(D1:SOCKADDR:1)[[TYPENAME:SOCKADDR]]

 



struct sockproto<s(1)(0)(1)>[&] {
	u_short<s(1)(1)(0)>[T]	sp_family<s(1)(1)(0)>[&];		 
	u_short<s(1)(1)(0)>[T]	sp_protocol<s(1)(1)(0)>[&];		 
};

 

































 











 



















 




extern UINT32<s(0)(0)(0)>[T] somaxconn<s(0)(0)(0)>[&];(D1:somaxconn:0)

 



struct msghdr<s(1)(0)(1)>[&] {
	caddr_t<s(1)(1)(0)>[T]	msg_name<s(1)(1)(0)>[&];		 
	u_int<s(1)(1)(0)>[T]	msg_namelen<s(1)(1)(0)>[&];		 
	struct	iovec<s(2)(1)(1)>[&] *msg_iov<s(1)(1)(0)>[&];		 
	u_int<s(1)(1)(0)>[T]	msg_iovlen<s(1)(1)(0)>[&];		 
	caddr_t<s(1)(1)(0)>[T]	msg_control<s(1)(1)(0)>[&];		 
	u_int<s(1)(1)(0)>[T]	msg_controllen<s(1)(1)(0)>[&];		 
 


	int	msg_flags<s(1)(1)(0)>[&];		 
};
















 





struct cmsghdr<s(1)(0)(1)>[&] {
	u_int<s(1)(1)(0)>[T]	cmsg_len<s(1)(1)(0)>[&];		 
	int	cmsg_level<s(1)(1)(0)>[&];		 
	int	cmsg_type<s(1)(1)(0)>[&];		 
 
};

 



 






 







 












 

 

 





























 




struct timeval<s(1)(0)(1)>[&]
    {
    long tv_sec<s(1)(1)(0)>[&];	 
    long tv_usec<s(1)(1)(0)>[&];	 
    };

struct timezone<s(1)(0)(1)>[&]
    {
    int	tz_minuteswest<s(1)(1)(0)>[&];	 
    int	tz_dsttime<s(1)(1)(0)>[&];	 
    };













 

 

 































 





 







 




 

typedef struct msg_q<s(1)(0)(1)>[&] *MSG_Q_ID<s(0)(0)(0)>[&];(D1:MSG_Q_ID:1)[[TYPENAME:MSG_Q_ID]]	 

typedef struct			 
    {
    int     numMsgs<s(1)(1)(0)>[&];		 
    int     numTasks<s(1)(1)(0)>[&];		 

    int     sendTimeouts<s(1)(1)(0)>[&];	 
    int     recvTimeouts<s(1)(1)(0)>[&];	 

    int     options<s(1)(1)(0)>[&];		 
    int     maxMsgs<s(1)(1)(0)>[&];		 
    int     maxMsgLength<s(1)(1)(0)>[&];	 

    int     taskIdListMax<s(1)(1)(0)>[&];	 
    int *   taskIdList<s(1)(1)(0)>[&];		 

    int     msgListMax<s(1)(1)(0)>[&];		 
    char ** msgPtrList<s(1)(1)(0)>[&];		 
    int *   msgLenList<s(1)(1)(0)>[&];		 

    } MSG_Q_INFO<s(0)(0)(0)>[&];(D1:MSG_Q_INFO:1)[[TYPENAME:MSG_Q_INFO]]

 

 










 



extern STATUS<s(0)(0)(0)>[T] 	msgQLibInit<s(0)(0)(0)>[&] (void);(D1:msgQLibInit:0)
extern MSG_Q_ID<s(0)(0)(0)>[T] msgQCreate<s(0)(0)(0)>[&] (int maxMsgs<s(0)(0)(0)>[&], int maxMsgLength<s(0)(0)(0)>[&], int options<s(0)(0)(0)>[&]);(D1:options:0)
extern STATUS<s(0)(0)(0)>[T] 	msgQDelete<s(0)(0)(0)>[&] (MSG_Q_ID<s(0)(0)(0)>[T] msgQId<s(0)(0)(0)>[&]);(D1:msgQId:0)
extern STATUS<s(0)(0)(0)>[T] 	msgQSend<s(0)(0)(0)>[&] (MSG_Q_ID<s(0)(0)(0)>[T] msgQId<s(0)(0)(0)>[&], char *buffer<s(0)(0)(0)>[&], UINT<s(0)(0)(0)>[T] nBytes<s(0)(0)(0)>[&],
			  int timeout<s(0)(0)(0)>[&], int priority<s(0)(0)(0)>[&]);(D1:priority:0)
extern int 	msgQReceive<s(0)(0)(0)>[&] (MSG_Q_ID<s(0)(0)(0)>[T] msgQId<s(0)(0)(0)>[&], char *buffer<s(0)(0)(0)>[&], UINT<s(0)(0)(0)>[T] maxNBytes<s(0)(0)(0)>[&],
			     int timeout<s(0)(0)(0)>[&]);(D1:timeout:0)
extern STATUS<s(0)(0)(0)>[T] 	msgQInfoGet<s(0)(0)(0)>[&] (MSG_Q_ID<s(0)(0)(0)>[T] msgQId<s(0)(0)(0)>[&], MSG_Q_INFO<s(0)(0)(0)>[T] *pInfo<s(0)(0)(0)>[&]);(D1:pInfo:0)
extern int 	msgQNumMsgs<s(0)(0)(0)>[&] (MSG_Q_ID<s(0)(0)(0)>[T] msgQId<s(0)(0)(0)>[&]);(D1:msgQId:0)
extern void 	msgQShowInit<s(0)(0)(0)>[&] (void);(D1:msgQShowInit:0)
extern STATUS<s(0)(0)(0)>[T] 	msgQShow<s(0)(0)(0)>[&] (MSG_Q_ID<s(0)(0)(0)>[T] msgQId<s(0)(0)(0)>[&], int level<s(0)(0)(0)>[&]);(D1:level:0)














 
 
 
 
 
 
 
 
 






















































































































































































    typedef struct {
        int waiterCount<s(1)(1)(0)>[&];
        void *semaphore<s(1)(1)(0)>[&];
    } *PDQsema<s(0)(0)(0)>[&];(D1:PDQsema:1)[[TYPENAME:PDQsema]]



    extern char *Strerror<s(0)(0)(0)>[&](int error<s(0)(0)(0)>[&]);(D1:error:0)
    extern STATUS<s(0)(0)(0)>[T] *Strerror_r<s(0)(0)(0)>[&](int error<s(0)(0)(0)>[&], char *buffer<s(0)(0)(0)>[&]);(D1:buffer:0)
    extern char *Strdup<s(0)(0)(0)>[&](const char *src<s(0)(0)(0)>[&]);(D1:src:0)







    extern void *Int_Malloc<s(0)(0)(0)>[&](char *file<s(0)(0)(0)>[&], int line<s(0)(0)(0)>[&], size_t<s(0)(0)(0)>[T] len<s(0)(0)(0)>[&]);(D1:len:0)
    extern void Int_FFree<s(0)(0)(0)>[&](char *file<s(0)(0)(0)>[&], int line<s(0)(0)(0)>[&], void *ptr<s(0)(0)(0)>[&]);(D1:ptr:0)
    extern void Int_Mem_Add_User<s(0)(0)(0)>[&](char *file<s(0)(0)(0)>[&], int line<s(0)(0)(0)>[&], void *mem<s(0)(0)(0)>[&]);(D1:mem:0)








    extern void *Calloc<s(0)(0)(0)>[&](size_t<s(0)(0)(0)>[T] nmemb<s(0)(0)(0)>[&], size_t<s(0)(0)(0)>[T] size<s(0)(0)(0)>[&]);(D1:size:0)
    extern void *Realloc<s(0)(0)(0)>[&](void *ptr<s(0)(0)(0)>[&], size_t<s(0)(0)(0)>[T] newSize<s(0)(0)(0)>[&]);(D1:newSize:0)


    extern char *Strncpy<s(0)(0)(0)>[&](char *s1<s(0)(0)(0)>[&], const char *s2<s(0)(0)(0)>[&], size_t<s(0)(0)(0)>[T] n<s(0)(0)(0)>[&]);(D1:n:0)
    extern int StrEQ<s(0)(0)(0)>[&](const char *s1<s(0)(0)(0)>[&], const char *s2<s(0)(0)(0)>[&]);(D1:s2:0)
    extern int StrcaseEQ<s(0)(0)(0)>[&](const char *s1<s(0)(0)(0)>[&], const char *s2<s(0)(0)(0)>[&]);(D1:s2:0)
    extern int StrIsNumber<s(0)(0)(0)>[&](const char *str<s(0)(0)(0)>[&]);(D1:str:0)

    extern PDQsema<s(0)(0)(0)>[T] pdqSemCreate<s(0)(0)(0)>[&](void);(D1:pdqSemCreate:0)
    extern void pdqSemTake<s(0)(0)(0)>[&](PDQsema<s(0)(0)(0)>[T] sema<s(0)(0)(0)>[&]);(D1:sema:0)
    extern void pdqSemGive<s(0)(0)(0)>[&](PDQsema<s(0)(0)(0)>[T] sema<s(0)(0)(0)>[&]);(D1:sema:0)














 

 

 




























 

 

 





















 











 



 



 




 





 



 












 

 




 



 








 



 













 




 








 















































 

struct dirent<s(1)(0)(1)>[&]		 
    {
    char	d_name<s(1)(1)(0)>[&] [99   + 1];	 
    };


 
 

typedef struct		 
    {
    int		  dd_fd<s(1)(1)(0)>[&];		 
    int		  dd_cookie<s(1)(1)(0)>[&];		 
    struct dirent<s(2)(1)(1)>[&] dd_dirent<s(2)(1)(1)>[&];		 
    } DIR<s(0)(0)(0)>[&];(D1:DIR:1)[[TYPENAME:DIR]]

 





 



extern DIR<s(0)(0)(0)>[T] *	opendir<s(0)(0)(0)>[&] (char *dirName<s(0)(0)(0)>[&]);(D1:dirName:0)
extern STATUS<s(0)(0)(0)>[T] 	closedir<s(0)(0)(0)>[&] (DIR<s(0)(0)(0)>[T] *pDir<s(0)(0)(0)>[&]);(D1:pDir:0)
extern struct 	dirent<s(1)(0)(1)>[&] *readdir<s(0)(0)(0)>[&] (DIR<s(0)(0)(0)>[T] *pDir<s(0)(0)(0)>[&]);(D1:pDir:0)
extern void 	rewinddir<s(0)(0)(0)>[&] (DIR<s(0)(0)(0)>[T] *pDir<s(0)(0)(0)>[&]);(D1:pDir:0)





























 
 
void SFT_ApplSwRegister<s(0)(0)(0)>[&](void);(D1:SFT_ApplSwRegister:0)
 
 













typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*AMM_AppNotifyRegister<s(0)(0)(0)>[&])TYPENAME:FUNC:(AMM_AppNotifyRegister)(int flag<s(0)(0)(0)>[&]);(D1:flag:0)

typedef void (*auxClockHookFunc_t<s(0)(0)(0)>[&])TYPENAME:FUNC:(auxClockHookFunc_t)(int user_para<s(0)(0)(0)>[&]);(D1:user_para:0)


void tmd_ReportApplInitState<s(0)(0)(0)>[&](int status<s(0)(0)(0)>[&]);(D1:status:0)
void  Amm_ApplNotifyRegister<s(0)(0)(0)>[&](AMM_AppNotifyRegister<s(0)(0)(0)>[T] *fptr<s(0)(0)(0)>[&]);(D1:fptr:0)
void Amm_SwRegister<s(0)(0)(0)>[&](void);(D1:Amm_SwRegister:0)
void  Amm_ApplInit<s(0)(0)(0)>[&](void);(D1:Amm_ApplInit:0)
void Amm_ApplWaitStatus<s(0)(0)(0)>[&](BOOL<s(0)(0)(0)>[T] bSwFlag<s(0)(0)(0)>[&]);(D1:bSwFlag:0)
void Amm_FdrCycleChange<s(0)(0)(0)>[&](int dwCycleTime<s(0)(0)(0)>[&]);(D1:dwCycleTime:0)
int AMM_Select<s(0)(0)(0)>[&](int width<s(0)(0)(0)>[&], fd_set<s(0)(0)(0)>[T] *pReadFds<s(0)(0)(0)>[&], fd_set<s(0)(0)(0)>[T] *pWriteFds<s(0)(0)(0)>[&],fd_set<s(0)(0)(0)>[T] *pExceptFds<s(0)(0)(0)>[&], struct timeval<s(1)(0)(1)>[&] *pTimeOut<s(0)(0)(0)>[&]);(D1:pTimeOut:0)


 
    int tmd_GetFDforAppl<s(0)(0)(0)>[&](int applNumber<s(0)(0)(0)>[&]);(D1:applNumber:0)
    int tmd_GetApplIDforAppl<s(0)(0)(0)>[&](char *taskName<s(0)(0)(0)>[&]);(D1:taskName:0)

 
    int gettimeofday<s(0)(0)(0)>[&](struct timeval<s(1)(0)(1)>[&] *tv<s(0)(0)(0)>[&], struct timezone<s(1)(0)(1)>[&] *tz<s(0)(0)(0)>[&]);(D1:tz:0)
    int settimeofday<s(0)(0)(0)>[&](const struct timeval<s(1)(0)(1)>[&] *tv<s(0)(0)(0)>[&], const struct timezone<s(1)(0)(1)>[&] *tz<s(0)(0)(0)>[&]);(D1:tz:0)

 
 
    int AMM_SpawnAppl<s(0)(0)(0)>[&](char *name<s(0)(0)(0)>[&], int priority<s(0)(0)(0)>[&], int options<s(0)(0)(0)>[&], int stackSize<s(0)(0)(0)>[&], int (*entryPt<s(0)(0)(0)>[&]) (void), int applNum<s(0)(0)(0)>[&],
                      char *applName<s(0)(0)(0)>[&], unsigned int logflags<s(0)(0)(0)>[&], int cfgOptions<s(0)(0)(0)>[&]);(D1:cfgOptions:0)

 
 
 
    int AMM_SpawnTask<s(0)(0)(0)>[&](char *name<s(0)(0)(0)>[&], int priority<s(0)(0)(0)>[&], int options<s(0)(0)(0)>[&], int stackSize<s(0)(0)(0)>[&], int (*entryPt<s(0)(0)(0)>[&]) (void), int taskNum<s(0)(0)(0)>[&], int arg1<s(0)(0)(0)>[&],
                      int arg2<s(0)(0)(0)>[&], int arg3<s(0)(0)(0)>[&], int arg4<s(0)(0)(0)>[&], int arg5<s(0)(0)(0)>[&], int arg6<s(0)(0)(0)>[&], int arg7<s(0)(0)(0)>[&]);(D1:arg7:0)

     
     
    int AMM_SpawnApplTask<s(0)(0)(0)>[&](char *name<s(0)(0)(0)>[&], int priority<s(0)(0)(0)>[&], int options<s(0)(0)(0)>[&], int stackSize<s(0)(0)(0)>[&], int (*entryPt<s(0)(0)(0)>[&]) (void), int applNum<s(0)(0)(0)>[&], char *applName<s(0)(0)(0)>[&],
                  unsigned int logflags<s(0)(0)(0)>[&], int cfgOptions<s(0)(0)(0)>[&], int arg1<s(0)(0)(0)>[&], int arg2<s(0)(0)(0)>[&], int arg3<s(0)(0)(0)>[&], int arg4<s(0)(0)(0)>[&], int arg5<s(0)(0)(0)>[&], int arg6<s(0)(0)(0)>[&], int arg7<s(0)(0)(0)>[&]);(D1:arg7:0)

 















 
    struct acb<s(1)(0)(1)>[&] *tmd_RegisterApplication<s(0)(0)(0)>[&](int applNum<s(0)(0)(0)>[&], char *applName<s(0)(0)(0)>[&], unsigned int logflags<s(0)(0)(0)>[&], int cfgOptions<s(0)(0)(0)>[&]);(D1:cfgOptions:0)

 
    void tmd_TaskEnd<s(0)(0)(0)>[&](void);(D1:tmd_TaskEnd:0)
    void tmd_RemoveRegistration<s(0)(0)(0)>[&](int applNumber<s(0)(0)(0)>[&]);(D1:applNumber:0)

 
    int tmd_GenerateAlarm<s(0)(0)(0)>[&](int alarm_interface_index<s(0)(0)(0)>[&], int slot_num<s(0)(0)(0)>[&], int port_num<s(0)(0)(0)>[&], int ifAlarmEnabled<s(0)(0)(0)>[&], int alarm_type_id<s(0)(0)(0)>[&],
                           int new_alarm_status<s(0)(0)(0)>[&], int interface_type<s(0)(0)(0)>[&], int instances<s(0)(0)(0)>[&][]);(D1:instances:0)
    int tmd_GenerateEvent<s(0)(0)(0)>[&](int event_type_id<s(0)(0)(0)>[&], char *event_detail<s(0)(0)(0)>[&]);(D1:event_detail:0)



    int SIPADDR<s(0)(0)(0)>[&](int slot<s(0)(0)(0)>[&]);(D1:slot:0)
    int PSIPADDR<s(0)(0)(0)>[&](int slot<s(0)(0)(0)>[&]);(D1:slot:0)

 
    unsigned int FindBoardProperties<s(0)(0)(0)>[&](void);(D1:FindBoardProperties:0)
    int BoardInit<s(0)(0)(0)>[&](int boardtype<s(0)(0)(0)>[&]);(D1:boardtype:0)

 



 















 









 
typedef enum{	
		SEND_OK<s(0)(0)(0)>[&] = 0,		
		QUEUE_FULL<s(0)(0)(0)>[&]=1,
		LINK_BREAKDOWN<s(0)(0)(0)>[&]=2,
		NET_CONGESTION<s(0)(0)(0)>[&] =3,
		DEST_APP_NOTRESP<s(0)(0)(0)>[&]=4,
		PROTO_ERROR<s(0)(0)(0)>[&]=5,
		OTHER_ERROR<s(0)(0)(0)>[&]=6,
                MS_STATE_UNKNOWN<s(0)(0)(0)>[&]=7,
                DMM_CMND_NULL<s(0)(0)(0)>[&]=8,
                DMM_SRC_INVALID<s(0)(0)(0)>[&]=9,
                DMM_DEST_INVALID<s(0)(0)(0)>[&]= 10,
                DMM_MSG_LEN_ERROR<s(0)(0)(0)>[&]=11,
                DMM_NOT_READY<s(0)(0)(0)>[&]=12,
                DMM_SLOT_TRANSFER_ERROR<s(0)(0)(0)>[&]=13,
                DMM_SYN_INNER_DEST_NCK<s(0)(0)(0)>[&]=14,
                DMM_SYN_NCK_BY_DMM<s(0)(0)(0)>[&] =15,
                DMM_SYN_NCK_BY_APPL<s(0)(0)(0)>[&]=16
}DMM_ERR_CODE_t<s(0)(0)(0)>[&];(D1:DMM_ERR_CODE_t:1)[[TYPENAME:DMM_ERR_CODE_t]]



 void *msg_q_Receive<s(0)(0)(0)>[&](int qid<s(0)(0)(0)>[&], int timeout<s(0)(0)(0)>[&]);(D1:timeout:0)
 
 command_tt<s(0)(0)(0)>[T] *DMM_ReadPipe<s(0)(0)(0)>[&](int fd<s(0)(0)(0)>[&]);(D1:fd:0)
 
 command_tt<s(0)(0)(0)>[T] *DMM_ReadQueue<s(0)(0)(0)>[&](int qid<s(0)(0)(0)>[&], int timeout<s(0)(0)(0)>[&]);(D1:timeout:0)


 command_tt<s(0)(0)(0)>[T] *DMM_CreateMsgExt<s(0)(0)(0)>[&](char *file<s(0)(0)(0)>[&], int line<s(0)(0)(0)>[&],int length<s(0)(0)(0)>[&]);(D1:length:0)
 
 void DMM_ReleaseMsgExt<s(0)(0)(0)>[&](char *file<s(0)(0)(0)>[&], int line<s(0)(0)(0)>[&],command_tt<s(0)(0)(0)>[T] *pCommand<s(0)(0)(0)>[&]);(D1:pCommand:0)




 
 command_tt<s(0)(0)(0)>[T] * DMM_ReadCommandForAppl<s(0)(0)(0)>[&] ();(D1:DMM_ReadCommandForAppl:0)
 int DMM_CreateApplQueue<s(0)(0)(0)>[&](int size<s(0)(0)(0)>[&]);(D1:size:0)
 
 int DMM_CreateQueue<s(0)(0)(0)>[&](int size<s(0)(0)(0)>[&]);(D1:size:0)
 int DMM_ReleaseQueue<s(0)(0)(0)>[&]( int qid<s(0)(0)(0)>[&]);(D1:qid:0)
 
 int DMM_CreateApplPipe<s(0)(0)(0)>[&](int size<s(0)(0)(0)>[&]);(D1:size:0)
 
 int DMM_ReleasePipe<s(0)(0)(0)>[&](int fd<s(0)(0)(0)>[&]);(D1:fd:0)


 DMM_ERR_CODE_t<s(0)(0)(0)>[T] DMM_SendCommand<s(0)(0)(0)>[&] (command_tt<s(0)(0)(0)>[T] *command<s(0)(0)(0)>[&]);(D1:command:0)
 DMM_ERR_CODE_t<s(0)(0)(0)>[T] DMM_SendUnAckedCommand<s(0)(0)(0)>[&](command_tt<s(0)(0)(0)>[T] *command<s(0)(0)(0)>[&]);(D1:command:0)
 DMM_ERR_CODE_t<s(0)(0)(0)>[T] DMM_SendWRes<s(0)(0)(0)>[&](command_tt<s(0)(0)(0)>[T] *command<s(0)(0)(0)>[&], int retries<s(0)(0)(0)>[&], int timeout<s(0)(0)(0)>[&], command_tt<s(0)(0)(0)>[T] **ppResMsg<s(0)(0)(0)>[&]);(D1:ppResMsg:0)
   DMM_ERR_CODE_t<s(0)(0)(0)>[T] DMM_SendSynAck<s(0)(0)(0)>[&](command_tt<s(0)(0)(0)>[T]  *pInCmd<s(0)(0)(0)>[&],command_tt<s(0)(0)(0)>[T] *pAckCmd<s(0)(0)(0)>[&],BOOL<s(0)(0)(0)>[T] bRecvSucc<s(0)(0)(0)>[&]);(D1:bRecvSucc:0)
 DMM_ERR_CODE_t<s(0)(0)(0)>[T] DMM_SendBcCmd<s(0)(0)(0)>[&](command_tt<s(0)(0)(0)>[T] *pCommand<s(0)(0)(0)>[&]);(D1:pCommand:0)
 command_tt<s(0)(0)(0)>[T] * DMM_Recv<s(0)(0)(0)>[&] (int timeout<s(0)(0)(0)>[&]);(D1:timeout:0)
 command_tt<s(0)(0)(0)>[T] * DMM_ReadCommandForAppl<s(0)(0)(0)>[&] ();(D1:DMM_ReadCommandForAppl:0)
 int  DMM_GetPhysicalSlot<s(0)(0)(0)>[&](int iLogicSlot<s(0)(0)(0)>[&]);(D1:iLogicSlot:0)
 int   DMM_GetLogicalSlot<s(0)(0)(0)>[&](int iPhysicalSlot<s(0)(0)(0)>[&]);(D1:iPhysicalSlot:0)
 int DMM_GetMatePSlot<s(0)(0)(0)>[&](void );(D1:DMM_GetMatePSlot:0)
DMM_ERR_CODE_t<s(0)(0)(0)>[T] DmmGetLinkState<s(0)(0)(0)>[&](unsigned short wDestPslot<s(0)(0)(0)>[&]);(D1:wDestPslot:0)


 
 int DMM_GetMatePSlot<s(0)(0)(0)>[&](void );(D1:DMM_GetMatePSlot:0)

 int DMM_GetLocalPSlot<s(0)(0)(0)>[&](void );(D1:DMM_GetLocalPSlot:0)
 int DMM_GetLocalLSlot<s(0)(0)(0)>[&](void );(D1:DMM_GetLocalLSlot:0)
BOOL<s(0)(0)(0)>[T] DMM_SetSpcMsMap<s(0)(0)(0)>[&](UINT16<s(0)(0)(0)>[T]  wActivePSlot<s(0)(0)(0)>[&],BOOL<s(0)(0)(0)>[T] bStdbyIsOnline<s(0)(0)(0)>[&]);(D1:bStdbyIsOnline:0)
BOOL<s(0)(0)(0)>[T] DMM_GetPSlotOnLine<s(0)(0)(0)>[&](UINT16<s(0)(0)(0)>[T] wPSlotNo<s(0)(0)(0)>[&]);(D1:wPSlotNo:0)
BOOL<s(0)(0)(0)>[T] DMM_GetLSlotOnLine<s(0)(0)(0)>[&](UINT16<s(0)(0)(0)>[T] wLSlotNo<s(0)(0)(0)>[&]);(D1:wLSlotNo:0)

int DMM_CreateSpcApplQ<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] dwHighQSize<s(0)(0)(0)>[&],UINT32<s(0)(0)(0)>[T] dwLowQSize<s(0)(0)(0)>[&],UINT32<s(0)(0)(0)>[T] dwExtQSize<s(0)(0)(0)>[&]);(D1:dwExtQSize:0)
UINT32<s(0)(0)(0)>[T] DMM_GetMsgType<s(0)(0)(0)>[&](const command_tt<s(0)(0)(0)>[T] *pCommand<s(0)(0)(0)>[&]);(D1:pCommand:0)

void  DMM_SetCmdUrgent<s(0)(0)(0)>[&](command_tt<s(0)(0)(0)>[T] *pCommand<s(0)(0)(0)>[&]);(D1:pCommand:0)
BOOL<s(0)(0)(0)>[T] DMM_IsSmartCard<s(0)(0)(0)>[&](int PhySlot<s(0)(0)(0)>[&]);(D1:PhySlot:0)


BOOL<s(0)(0)(0)>[T] msTimer_Start<s(0)(0)(0)>[&](auxClockHookFunc_t<s(0)(0)(0)>[T] FuncPtr<s(0)(0)(0)>[&],int user_para<s(0)(0)(0)>[&],UINT32<s(0)(0)(0)>[T] MsLen<s(0)(0)(0)>[&]);(D1:MsLen:0)
BOOL<s(0)(0)(0)>[T] taskDelayMs<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] DelayLen<s(0)(0)(0)>[&]);(D1:DelayLen:0)



 

extern FILE<s(0)(0)(0)>[T] *NfsOpenFile<s(0)(0)(0)>[&](const char *pFileName<s(0)(0)(0)>[&], const char *pMode<s(0)(0)(0)>[&]);(D1:pMode:0)
extern STATUS<s(0)(0)(0)>[T] NfsRemoveFile<s(0)(0)(0)>[&](const char *pFileName<s(0)(0)(0)>[&]);(D1:pFileName:0)
extern STATUS<s(0)(0)(0)>[T] NfsCreatePath<s(0)(0)(0)>[&](const char *pDirName<s(0)(0)(0)>[&]);(D1:pDirName:0)
extern STATUS<s(0)(0)(0)>[T] NfsDelPath<s(0)(0)(0)>[&](const char *pDirName<s(0)(0)(0)>[&]);(D1:pDirName:0)
extern DIR<s(0)(0)(0)>[T] *NfsOpenDir<s(0)(0)(0)>[&](const char *pDirName<s(0)(0)(0)>[&]);(D1:pDirName:0)

 



extern int RFileWrite<s(0)(0)(0)>[&](char *pFileName<s(0)(0)(0)>[&],char *pMem<s(0)(0)(0)>[&],int WriteLen<s(0)(0)(0)>[&],int WriteMode<s(0)(0)(0)>[&]);(D1:WriteMode:0)
extern int RFileRead<s(0)(0)(0)>[&](char *pFileName<s(0)(0)(0)>[&],char *pMem<s(0)(0)(0)>[&],int ReadLen<s(0)(0)(0)>[&]);(D1:ReadLen:0)



 
 int tmd_SendQueueCmnd<s(0)(0)(0)>[&](int qid<s(0)(0)(0)>[&], command_tt<s(0)(0)(0)>[T] *command<s(0)(0)(0)>[&]);(D1:command:0)
 
 int tmd_SendPipeCmnd<s(0)(0)(0)>[&](int fd<s(0)(0)(0)>[&], command_tt<s(0)(0)(0)>[T] *command<s(0)(0)(0)>[&]);(D1:command:0)

 
 int tmd_IsrSendQueueCmnd<s(0)(0)(0)>[&](int qid<s(0)(0)(0)>[&], command_tt<s(0)(0)(0)>[T] *command<s(0)(0)(0)>[&]);(D1:command:0)
 
 int tmd_IsrSendCommand<s(0)(0)(0)>[&](command_tt<s(0)(0)(0)>[T] *command<s(0)(0)(0)>[&]);(D1:command:0)
 STATUS<s(0)(0)(0)>[T] tmd_PipeDrv<s(0)(0)(0)>[&] (void);(D1:tmd_PipeDrv:0)

 BOOL<s(0)(0)(0)>[T] tmd_RemapSlot<s(0)(0)(0)>[&](int LSlotIndex<s(0)(0)(0)>[&],int PSlotIndex<s(0)(0)(0)>[&]);(D1:PSlotIndex:0)
 int tmd_StackCheck<s(0)(0)(0)>[&](int taskNum<s(0)(0)(0)>[&]);(D1:taskNum:0)
 int tmd_GetQueueSize<s(0)(0)(0)>[&](int qid<s(0)(0)(0)>[&]);(D1:qid:0)
 int tmd_GetNumLowCmnds<s(0)(0)(0)>[&](int qid<s(0)(0)(0)>[&]);(D1:qid:0)
 int tmd_GetNumHiCmnds<s(0)(0)(0)>[&](int qid<s(0)(0)(0)>[&]);(D1:qid:0)
 int tmd_GetMaxLowCmnds<s(0)(0)(0)>[&](int qid<s(0)(0)(0)>[&]);(D1:qid:0)
 int tmd_GetMaxHiCmnds<s(0)(0)(0)>[&](int qid<s(0)(0)(0)>[&]);(D1:qid:0)
 int tmd_GetNumRxMsgs<s(0)(0)(0)>[&](int qid<s(0)(0)(0)>[&]);(D1:qid:0)

 int tmd_GetNumLowCmnds<s(0)(0)(0)>[&](int qid<s(0)(0)(0)>[&]);(D1:qid:0)
 int tmd_ClrQueueDbg<s(0)(0)(0)>[&](int qid<s(0)(0)(0)>[&]);(D1:qid:0)
 int tmd_GetSlotMac<s(0)(0)(0)>[&](int slot<s(0)(0)(0)>[&], char *mac<s(0)(0)(0)>[&]);(D1:mac:0)

 STATUS<s(0)(0)(0)>[T] tmd_RemapProxeeSlot<s(0)(0)(0)>[&](int slot<s(0)(0)(0)>[&], int proxy<s(0)(0)(0)>[&]);(D1:proxy:0)

 int tmd_MsgSlotCheck<s(0)(0)(0)>[&](int slot<s(0)(0)(0)>[&]);(D1:slot:0)


extern int tmd_GetSlotIfName<s(0)(0)(0)>[&](int slot<s(0)(0)(0)>[&], char *name_buffer<s(0)(0)(0)>[&]);(D1:name_buffer:0)
extern int tmd_GetSlotTxMsgNum<s(0)(0)(0)>[&](int slot<s(0)(0)(0)>[&]);(D1:slot:0)
extern int tmd_GetSlotRxMsgNum<s(0)(0)(0)>[&](int slot<s(0)(0)(0)>[&]);(D1:slot:0)

 int tmd_GetSlotIfName<s(0)(0)(0)>[&](int slot<s(0)(0)(0)>[&], char *name_buffer<s(0)(0)(0)>[&]);(D1:name_buffer:0)
 int tmd_GetSlotTxMsgNum<s(0)(0)(0)>[&](int slot<s(0)(0)(0)>[&]);(D1:slot:0)
 int tmd_GetSlotRxMsgNum<s(0)(0)(0)>[&](int slot<s(0)(0)(0)>[&]);(D1:slot:0)

 void tmd_ResetSlotMsgCnts<s(0)(0)(0)>[&](int slot<s(0)(0)(0)>[&]);(D1:slot:0)


 int Zip<s(0)(0)(0)>[&](char* pstSrcName<s(0)(0)(0)>[&], char* pszArchFileName<s(0)(0)(0)>[&]);(D1:pszArchFileName:0)
 int Zip_PSM<s(0)(0)(0)>[&](char* pstSrcName<s(0)(0)(0)>[&], char* pszArchFileName<s(0)(0)(0)>[&]);(D1:pszArchFileName:0)
 int unZip<s(0)(0)(0)>[&](char* pstSrcName<s(0)(0)(0)>[&], char* pszArchFileName<s(0)(0)(0)>[&]);(D1:pszArchFileName:0)
 int Zip_Buffer<s(0)(0)(0)>[&](char* bufferData<s(0)(0)(0)>[&], unsigned int bufferLen<s(0)(0)(0)>[&], char* pszArchFileName<s(0)(0)(0)>[&]);(D1:pszArchFileName:0)





 


    void SetUseEther<s(0)(0)(0)>[&](int i<s(0)(0)(0)>[&]);(D1:i:0)

    void *tmd_CreatePrivateArea<s(0)(0)(0)>[&](unsigned int size<s(0)(0)(0)>[&]);(D1:size:0)
    int tmd_EnablePrivateArea<s(0)(0)(0)>[&](unsigned int appl<s(0)(0)(0)>[&]);(D1:appl:0)
    int tmd_DisablePrivateArea<s(0)(0)(0)>[&](unsigned int appl<s(0)(0)(0)>[&]);(D1:appl:0)    
    
 
 
 
    void initializeMirroringServices<s(0)(0)(0)>[&](void);(D1:initializeMirroringServices:0)

 
    STATUS<s(0)(0)(0)>[T] isMemLocMirrored<s(0)(0)(0)>[&](void *address<s(0)(0)(0)>[&]);(D1:address:0)
    STATUS<s(0)(0)(0)>[T] registerMirroredMemLoc<s(0)(0)(0)>[&](void *address<s(0)(0)(0)>[&], short numbytes<s(0)(0)(0)>[&], unsigned short initialValue<s(0)(0)(0)>[&]);(D1:initialValue:0)
    STATUS<s(0)(0)(0)>[T] setMemLoc_16bit<s(0)(0)(0)>[&](void *address<s(0)(0)(0)>[&], short accessType<s(0)(0)(0)>[&], unsigned short bitMask<s(0)(0)(0)>[&], unsigned short bitPattern<s(0)(0)(0)>[&]);(D1:bitPattern:0)
    STATUS<s(0)(0)(0)>[T] setMemLoc_16bit_Isr<s(0)(0)(0)>[&](void *address<s(0)(0)(0)>[&], short accessType<s(0)(0)(0)>[&], unsigned short bitMask<s(0)(0)(0)>[&], unsigned short bitPattern<s(0)(0)(0)>[&]);(D1:bitPattern:0)
    unsigned short getMemLoc_16bit<s(0)(0)(0)>[&](void *address<s(0)(0)(0)>[&]);(D1:address:0)
    unsigned short getMemLoc_16bit_Isr<s(0)(0)(0)>[&](void *address<s(0)(0)(0)>[&]);(D1:address:0)

 
    STATUS<s(0)(0)(0)>[T] is_I2C_Register_Shared<s(0)(0)(0)>[&](int address<s(0)(0)(0)>[&]);(D1:address:0)
    STATUS<s(0)(0)(0)>[T] register_Shared_16bit_I2C_Register<s(0)(0)(0)>[&](int address<s(0)(0)(0)>[&], unsigned short initialValue<s(0)(0)(0)>[&], char setInitValNow<s(0)(0)(0)>[&]);(D1:setInitValNow:0)
    STATUS<s(0)(0)(0)>[T] set_shared_16bit_I2C_register<s(0)(0)(0)>[&](int address<s(0)(0)(0)>[&], short accessType<s(0)(0)(0)>[&], unsigned short bitMask<s(0)(0)(0)>[&],
                                         unsigned short bitPattern<s(0)(0)(0)>[&]);(D1:bitPattern:0)
    int get_shared_16bit_I2C_register<s(0)(0)(0)>[&](int address<s(0)(0)(0)>[&], unsigned short *data<s(0)(0)(0)>[&]);(D1:data:0)

void AMM_SlotWdgTimeoutProc<s(0)(0)(0)>[&](int slot<s(0)(0)(0)>[&]);(D1:slot:0)
    
 


 


    void registerDynamicDumps<s(0)(0)(0)>[&](void *area<s(0)(0)(0)>[&], int len<s(0)(0)(0)>[&], char *name<s(0)(0)(0)>[&]);(D1:name:0)

    void tmd_prepare_card_for_impending_shutdown<s(0)(0)(0)>[&](void);(D1:tmd_prepare_card_for_impending_shutdown:0)













unsigned int  CRC32<s(0)(0)(0)>[&](unsigned int crc<s(0)(0)(0)>[&], const unsigned char *buf<s(0)(0)(0)>[&], unsigned int len<s(0)(0)(0)>[&]);(D1:len:0)












 

 

 





































































































































 

 

 
































 

 

 




























 

typedef struct q_class<s(1)(0)(1)>[&]		 
    {
    FUNCPTR<s(1)(1)(0)>[T] createRtn<s(1)(1)(0)>[&];		 
    FUNCPTR<s(1)(1)(0)>[T] initRtn<s(1)(1)(0)>[&];		 
    FUNCPTR<s(1)(1)(0)>[T] deleteRtn<s(1)(1)(0)>[&];		 
    FUNCPTR<s(1)(1)(0)>[T] terminateRtn<s(1)(1)(0)>[&];	 
    FUNCPTR<s(1)(1)(0)>[T] putRtn<s(1)(1)(0)>[&];		 
    FUNCPTR<s(1)(1)(0)>[T] getRtn<s(1)(1)(0)>[&];		 
    FUNCPTR<s(1)(1)(0)>[T] removeRtn<s(1)(1)(0)>[&];		 
    FUNCPTR<s(1)(1)(0)>[T] resortRtn<s(1)(1)(0)>[&];		 
    FUNCPTR<s(1)(1)(0)>[T] advanceRtn<s(1)(1)(0)>[&];		 
    FUNCPTR<s(1)(1)(0)>[T] getExpiredRtn<s(1)(1)(0)>[&];	 
    FUNCPTR<s(1)(1)(0)>[T] keyRtn<s(1)(1)(0)>[&];		 
    FUNCPTR<s(1)(1)(0)>[T] calibrateRtn<s(1)(1)(0)>[&];	 
    FUNCPTR<s(1)(1)(0)>[T] infoRtn<s(1)(1)(0)>[&];		 
    FUNCPTR<s(1)(1)(0)>[T] eachRtn<s(1)(1)(0)>[&];		 
    struct q_class<s(2)(1)(1)>[&] *valid<s(1)(1)(0)>[&];	 
    } Q_CLASS<s(0)(0)(0)>[&];(D1:Q_CLASS:1)[[TYPENAME:Q_CLASS]]

typedef Q_CLASS<s(0)(0)(0)>[T] *Q_CLASS_ID<s(0)(0)(0)>[&];(D1:Q_CLASS_ID:1)[[TYPENAME:Q_CLASS_ID]]	 

 

 




























 





 

extern  Q_CLASS_ID<s(0)(0)(0)>[T]		qFifoClassId<s(0)(0)(0)>[&];(D1:qFifoClassId:0)
extern  Q_CLASS_ID<s(0)(0)(0)>[T]		qPriListClassId<s(0)(0)(0)>[&];(D1:qPriListClassId:0)
extern  Q_CLASS_ID<s(0)(0)(0)>[T]		qPriListFromTailClassId<s(0)(0)(0)>[&];(D1:qPriListFromTailClassId:0)
extern  Q_CLASS_ID<s(0)(0)(0)>[T]		qPriDeltaClassId<s(0)(0)(0)>[&];(D1:qPriDeltaClassId:0)
extern  Q_CLASS_ID<s(0)(0)(0)>[T]		qPriHeapClassId<s(0)(0)(0)>[&];(D1:qPriHeapClassId:0)
extern  Q_CLASS_ID<s(0)(0)(0)>[T]		qPriBMapClassId<s(0)(0)(0)>[&];(D1:qPriBMapClassId:0)

 








 

 








typedef struct		 
    {
    UINT<s(1)(1)(0)>[T]     qPriv1<s(1)(1)(0)>[&];			 
    UINT<s(1)(1)(0)>[T]     qPriv2<s(1)(1)(0)>[&];			 
    UINT<s(1)(1)(0)>[T]     qPriv3<s(1)(1)(0)>[&];			 
    UINT<s(1)(1)(0)>[T]     qPriv4<s(1)(1)(0)>[&];			 
    } Q_NODE<s(0)(0)(0)>[&];(D1:Q_NODE:1)[[TYPENAME:Q_NODE]]


 








typedef struct		 
    {
    Q_NODE<s(1)(1)(0)>[T]  *pFirstNode<s(1)(1)(0)>[&];		 
    UINT<s(1)(1)(0)>[T]     qPriv1<s(1)(1)(0)>[&];			 
    UINT<s(1)(1)(0)>[T]     qPriv2<s(1)(1)(0)>[&];			 
    Q_CLASS<s(1)(1)(0)>[T] *pQClass<s(1)(1)(0)>[&];			 
    } Q_HEAD<s(0)(0)(0)>[&];(D1:Q_HEAD:1)[[TYPENAME:Q_HEAD]]





 


 
















 













 

















 












 













 














 




















 
















 













 



















 

























extern Q_HEAD<s(0)(0)(0)>[T] *	qCreate<s(0)(0)(0)>[&] (Q_CLASS<s(0)(0)(0)>[T] *pQClass<s(0)(0)(0)>[&], ...);(D1:pQClass:0)
extern Q_NODE<s(0)(0)(0)>[T] *	qEach<s(0)(0)(0)>[&] (Q_HEAD<s(0)(0)(0)>[T] *pQHead<s(0)(0)(0)>[&], FUNCPTR<s(0)(0)(0)>[T] routine<s(0)(0)(0)>[&], int routineArg<s(0)(0)(0)>[&]);(D1:routineArg:0)
extern Q_NODE<s(0)(0)(0)>[T] *	qFirst<s(0)(0)(0)>[&] (Q_HEAD<s(0)(0)(0)>[T] *pQHead<s(0)(0)(0)>[&]);(D1:pQHead:0)
extern Q_NODE<s(0)(0)(0)>[T] *	qGet<s(0)(0)(0)>[&] (Q_HEAD<s(0)(0)(0)>[T] *pQHead<s(0)(0)(0)>[&]);(D1:pQHead:0)
extern Q_NODE<s(0)(0)(0)>[T] *	qGetExpired<s(0)(0)(0)>[&] (Q_HEAD<s(0)(0)(0)>[T] *pQHead<s(0)(0)(0)>[&]);(D1:pQHead:0)
extern STATUS<s(0)(0)(0)>[T] 	qDelete<s(0)(0)(0)>[&] (Q_HEAD<s(0)(0)(0)>[T] *pQHead<s(0)(0)(0)>[&]);(D1:pQHead:0)
extern STATUS<s(0)(0)(0)>[T] 	qInit<s(0)(0)(0)>[&] (Q_HEAD<s(0)(0)(0)>[T] *pQHead<s(0)(0)(0)>[&], Q_CLASS<s(0)(0)(0)>[T] *pQClass<s(0)(0)(0)>[&], ...);(D1:pQClass:0)
extern STATUS<s(0)(0)(0)>[T] 	qTerminate<s(0)(0)(0)>[&] (Q_HEAD<s(0)(0)(0)>[T] *pQHead<s(0)(0)(0)>[&]);(D1:pQHead:0)
extern ULONG<s(0)(0)(0)>[T] 	qKey<s(0)(0)(0)>[&] (Q_HEAD<s(0)(0)(0)>[T] *pQHead<s(0)(0)(0)>[&], Q_NODE<s(0)(0)(0)>[T] *pQNode<s(0)(0)(0)>[&], int keyType<s(0)(0)(0)>[&]);(D1:keyType:0)
extern int 	qInfo<s(0)(0)(0)>[&] (Q_HEAD<s(0)(0)(0)>[T] *pQHead<s(0)(0)(0)>[&], Q_NODE<s(0)(0)(0)>[T] *nodeArray<s(0)(0)(0)>[&] [ ], int maxNodes<s(0)(0)(0)>[&]);(D1:maxNodes:0)
extern void 	qAdvance<s(0)(0)(0)>[&] (Q_HEAD<s(0)(0)(0)>[T] *pQHead<s(0)(0)(0)>[&]);(D1:pQHead:0)
extern void 	qCalibrate<s(0)(0)(0)>[&] (Q_HEAD<s(0)(0)(0)>[T] *pQHead<s(0)(0)(0)>[&], ULONG<s(0)(0)(0)>[T] keyDelta<s(0)(0)(0)>[&]);(D1:keyDelta:0)
extern void 	qPut<s(0)(0)(0)>[&] (Q_HEAD<s(0)(0)(0)>[T] *pQHead<s(0)(0)(0)>[&], Q_NODE<s(0)(0)(0)>[T] *pQNode<s(0)(0)(0)>[&], ULONG<s(0)(0)(0)>[T] key<s(0)(0)(0)>[&]);(D1:key:0)
extern STATUS<s(0)(0)(0)>[T] 	qRemove<s(0)(0)(0)>[&] (Q_HEAD<s(0)(0)(0)>[T] *pQHead<s(0)(0)(0)>[&], Q_NODE<s(0)(0)(0)>[T] *pQNode<s(0)(0)(0)>[&]);(D1:pQNode:0)
extern void 	qResort<s(0)(0)(0)>[&] (Q_HEAD<s(0)(0)(0)>[T] *pQHead<s(0)(0)(0)>[&], Q_NODE<s(0)(0)(0)>[T] *pQNode<s(0)(0)(0)>[&], ULONG<s(0)(0)(0)>[T] newKey<s(0)(0)(0)>[&]);(D1:newKey:0)











 

 

 




























































 

 
 





















typedef struct		 
    {
    _RType<s(1)(1)(0)>[T] gpr<s(1)(1)(0)>[&][32 ];	 
    _RType<s(1)(1)(0)>[T] msr<s(1)(1)(0)>[&];			 
    _RType<s(1)(1)(0)>[T] lr<s(1)(1)(0)>[&];			 
    _RType<s(1)(1)(0)>[T] ctr<s(1)(1)(0)>[&];			 
    _RType<s(1)(1)(0)>[T] pc<s(1)(1)(0)>[&];			 
    UINT32<s(1)(1)(0)>[T] cr<s(1)(1)(0)>[&];			 
    UINT32<s(1)(1)(0)>[T] xer<s(1)(1)(0)>[&];			 





    UINT32<s(1)(1)(0)>[T] pad<s(1)(1)(0)>[&];			 

    } REG_SET<s(0)(0)(0)>[&];(D1:REG_SET:1)[[TYPENAME:REG_SET]]

 


































































































































































typedef struct regindex<s(1)(0)(1)>[&]
    {
    char	*regName<s(1)(1)(0)>[&];	 
    int		regOff<s(1)(1)(0)>[&];		 







    } REG_INDEX<s(0)(0)(0)>[&];(D1:REG_INDEX:1)[[TYPENAME:REG_INDEX]]








 

 

 






































































 

 

 


































 



























typedef struct
    {
    UINT32<s(1)(1)(0)>[T]	valid<s(1)(1)(0)>[&];		 

    UINT32<s(1)(1)(0)>[T]	vecOff<s(1)(1)(0)>[&];		 
    _RType<s(1)(1)(0)>[T]	cia<s(1)(1)(0)>[&];		 

    _RType<s(1)(1)(0)>[T]	msr<s(1)(1)(0)>[&];		 




    _RType<s(1)(1)(0)>[T]	dar<s(1)(1)(0)>[&];		 


    UINT32<s(1)(1)(0)>[T]      cr<s(1)(1)(0)>[&];		 
    UINT32<s(1)(1)(0)>[T]	xer<s(1)(1)(0)>[&];		 


    UINT32<s(1)(1)(0)>[T]	fpcsr<s(1)(1)(0)>[&];		 
    UINT32<s(1)(1)(0)>[T]	dsisr<s(1)(1)(0)>[&];		 



    } EXC_INFO<s(0)(0)(0)>[&];(D1:EXC_INFO:1)[[TYPENAME:EXC_INFO]]











 


















						 






























 











 

extern FUNCPTR<s(0)(0)(0)>[T]  excExcepHook<s(0)(0)(0)>[&];(D1:excExcepHook:0)    

 



extern STATUS<s(0)(0)(0)>[T]		excConnect<s(0)(0)(0)>[&] (VOIDFUNCPTR<s(0)(0)(0)>[T] *, VOIDFUNCPTR<s(0)(0)(0)>[T]);(D1:VOIDFUNCPTR:0)
extern STATUS<s(0)(0)(0)>[T]  		excIntConnect<s(0)(0)(0)>[&] (VOIDFUNCPTR<s(0)(0)(0)>[T] *, VOIDFUNCPTR<s(0)(0)(0)>[T]);(D1:VOIDFUNCPTR:0)
extern void		excVecSet<s(0)(0)(0)>[&] (FUNCPTR<s(0)(0)(0)>[T] *, FUNCPTR<s(0)(0)(0)>[T]);(D1:FUNCPTR:0)
extern FUNCPTR<s(0)(0)(0)>[T]		excVecGet<s(0)(0)(0)>[&] (FUNCPTR<s(0)(0)(0)>[T] *);(D1:FUNCPTR:0)
extern void		excVecBaseSet<s(0)(0)(0)>[&] (FUNCPTR<s(0)(0)(0)>[T] *);(D1:FUNCPTR:0)
extern FUNCPTR<s(0)(0)(0)>[T] *	excVecBaseGet<s(0)(0)(0)>[&] (void);(D1:excVecBaseGet:0)






























































typedef struct  excfaultTab<s(1)(0)(1)>[&]
    {
    int faultType<s(1)(1)(0)>[&];		 
    int subtype<s(1)(1)(0)>[&];		 
    int signal<s(1)(1)(0)>[&];			 
    int code<s(1)(1)(0)>[&];			 
    } EXC_FAULT_TAB<s(0)(0)(0)>[&];(D1:EXC_FAULT_TAB:1)[[TYPENAME:EXC_FAULT_TAB]]

 


extern STATUS<s(0)(0)(0)>[T] 	excShowInit<s(0)(0)(0)>[&] (void);(D1:excShowInit:0)
extern void 	excHookAdd<s(0)(0)(0)>[&] (FUNCPTR<s(0)(0)(0)>[T] excepHook<s(0)(0)(0)>[&]);(D1:excepHook:0)
extern STATUS<s(0)(0)(0)>[T] 	excJobAdd<s(0)(0)(0)>[&] (VOIDFUNCPTR<s(0)(0)(0)>[T] func<s(0)(0)(0)>[&], int arg1<s(0)(0)(0)>[&], int arg2<s(0)(0)(0)>[&], int arg3<s(0)(0)(0)>[&],
			   int arg4<s(0)(0)(0)>[&], int arg5<s(0)(0)(0)>[&], int arg6<s(0)(0)(0)>[&]);(D1:arg6:0)















 

 

 


















































































 

 







 





































 



typedef unsigned short event_t<s(0)(0)(0)>[&];(D1:event_t:1)[[TYPENAME:event_t]]



 

 

 

























































 

extern FUNCPTR<s(0)(0)(0)>[T]     _func_ioTaskStdSet<s(0)(0)(0)>[&];(D1:_func_ioTaskStdSet:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_bdall<s(0)(0)(0)>[&];(D1:_func_bdall:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_dspTaskRegsShow<s(0)(0)(0)>[&];(D1:_func_dspTaskRegsShow:0)
extern  VOIDFUNCPTR<s(0)(0)(0)>[T] _func_dspRegsListHook<s(0)(0)(0)>[&];(D1:_func_dspRegsListHook:0)	 
extern  FUNCPTR<s(0)(0)(0)>[T]	   _func_dspMregsHook<s(0)(0)(0)>[&];(D1:_func_dspMregsHook:0)		 
extern FUNCPTR<s(0)(0)(0)>[T]     _func_excBaseHook<s(0)(0)(0)>[&];(D1:_func_excBaseHook:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_excInfoShow<s(0)(0)(0)>[&];(D1:_func_excInfoShow:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_excIntHook<s(0)(0)(0)>[&];(D1:_func_excIntHook:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_excJobAdd<s(0)(0)(0)>[&];(D1:_func_excJobAdd:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_excPanicHook<s(0)(0)(0)>[&];(D1:_func_excPanicHook:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_fastUdpErrorNotify<s(0)(0)(0)>[&];(D1:_func_fastUdpErrorNotify:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_fastUdpInput<s(0)(0)(0)>[&];(D1:_func_fastUdpInput:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_fastUdpPortTest<s(0)(0)(0)>[&];(D1:_func_fastUdpPortTest:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_fclose<s(0)(0)(0)>[&];(D1:_func_fclose:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_fppTaskRegsShow<s(0)(0)(0)>[&];(D1:_func_fppTaskRegsShow:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_altivecProbe<s(0)(0)(0)>[&];(D1:_func_altivecProbe:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_altivecTaskRegsGet<s(0)(0)(0)>[&];(D1:_func_altivecTaskRegsGet:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_altivecTaskRegsShow<s(0)(0)(0)>[&];(D1:_func_altivecTaskRegsShow:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_speTaskRegsShow<s(0)(0)(0)>[&];(D1:_func_speTaskRegsShow:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_ftpLs<s(0)(0)(0)>[&];(D1:_func_ftpLs:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_netLsByName<s(0)(0)(0)>[&];(D1:_func_netLsByName:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_printErr<s(0)(0)(0)>[&];(D1:_func_printErr:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_logMsg<s(0)(0)(0)>[&];(D1:_func_logMsg:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_memalign<s(0)(0)(0)>[&];(D1:_func_memalign:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_pthread_setcanceltype<s(0)(0)(0)>[&];(D1:_func_pthread_setcanceltype:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_selPtyAdd<s(0)(0)(0)>[&];(D1:_func_selPtyAdd:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_selPtyDelete<s(0)(0)(0)>[&];(D1:_func_selPtyDelete:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_selTyAdd<s(0)(0)(0)>[&];(D1:_func_selTyAdd:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_selTyDelete<s(0)(0)(0)>[&];(D1:_func_selTyDelete:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_selWakeupAll<s(0)(0)(0)>[&];(D1:_func_selWakeupAll:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_selWakeupListInit<s(0)(0)(0)>[&];(D1:_func_selWakeupListInit:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_selWakeupListTerm<s(0)(0)(0)>[&];(D1:_func_selWakeupListTerm:0)
extern VOIDFUNCPTR<s(0)(0)(0)>[T] _func_sigExcKill<s(0)(0)(0)>[&];(D1:_func_sigExcKill:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_sigprocmask<s(0)(0)(0)>[&];(D1:_func_sigprocmask:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_sigTimeoutRecalc<s(0)(0)(0)>[&];(D1:_func_sigTimeoutRecalc:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_smObjObjShow<s(0)(0)(0)>[&];(D1:_func_smObjObjShow:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_spy<s(0)(0)(0)>[&];(D1:_func_spy:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_spyStop<s(0)(0)(0)>[&];(D1:_func_spyStop:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_spyClkStart<s(0)(0)(0)>[&];(D1:_func_spyClkStart:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_spyClkStop<s(0)(0)(0)>[&];(D1:_func_spyClkStop:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_spyReport<s(0)(0)(0)>[&];(D1:_func_spyReport:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_spyTask<s(0)(0)(0)>[&];(D1:_func_spyTask:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_sseTaskRegsShow<s(0)(0)(0)>[&];(D1:_func_sseTaskRegsShow:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_symFindByValueAndType<s(0)(0)(0)>[&];(D1:_func_symFindByValueAndType:0)    
extern FUNCPTR<s(0)(0)(0)>[T]     _func_symFindByValue<s(0)(0)(0)>[&];(D1:_func_symFindByValue:0)           
extern FUNCPTR<s(0)(0)(0)>[T]     _func_symFindSymbol<s(0)(0)(0)>[&];(D1:_func_symFindSymbol:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_symNameGet<s(0)(0)(0)>[&];(D1:_func_symNameGet:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_symValueGet<s(0)(0)(0)>[&];(D1:_func_symValueGet:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_symTypeGet<s(0)(0)(0)>[&];(D1:_func_symTypeGet:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_taskCreateHookAdd<s(0)(0)(0)>[&];(D1:_func_taskCreateHookAdd:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_taskDeleteHookAdd<s(0)(0)(0)>[&];(D1:_func_taskDeleteHookAdd:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_valloc<s(0)(0)(0)>[&];(D1:_func_valloc:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_remCurIdGet<s(0)(0)(0)>[&];(D1:_func_remCurIdGet:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_remCurIdSet<s(0)(0)(0)>[&];(D1:_func_remCurIdSet:0)

extern FUNCPTR<s(0)(0)(0)>[T]	   _dbgDsmInstRtn<s(0)(0)(0)>[&];(D1:_dbgDsmInstRtn:0)


extern BOOL<s(0)(0)(0)>[T]        fastUdpInitialized<s(0)(0)(0)>[&];(D1:fastUdpInitialized:0)


extern BOOL<s(0)(0)(0)>[T]	   ftpErrorSuppress<s(0)(0)(0)>[&];(D1:ftpErrorSuppress:0)
extern BOOL<s(0)(0)(0)>[T]	   _procNumWasSet<s(0)(0)(0)>[&];(D1:_procNumWasSet:0)
extern int	   m2If64BitCounters<s(0)(0)(0)>[&];(D1:m2If64BitCounters:0)

extern VOIDFUNCPTR<s(0)(0)(0)>[T] _func_evtLogO<s(0)(0)(0)>[&];(D1:_func_evtLogO:0)
extern VOIDFUNCPTR<s(0)(0)(0)>[T] _func_evtLogOIntLock<s(0)(0)(0)>[&];(D1:_func_evtLogOIntLock:0)

extern VOIDFUNCPTR<s(0)(0)(0)>[T] _func_evtLogM0<s(0)(0)(0)>[&];(D1:_func_evtLogM0:0)
extern VOIDFUNCPTR<s(0)(0)(0)>[T] _func_evtLogM1<s(0)(0)(0)>[&];(D1:_func_evtLogM1:0)
extern VOIDFUNCPTR<s(0)(0)(0)>[T] _func_evtLogM2<s(0)(0)(0)>[&];(D1:_func_evtLogM2:0)
extern VOIDFUNCPTR<s(0)(0)(0)>[T] _func_evtLogM3<s(0)(0)(0)>[&];(D1:_func_evtLogM3:0)

extern VOIDFUNCPTR<s(0)(0)(0)>[T] _func_evtLogT0<s(0)(0)(0)>[&];(D1:_func_evtLogT0:0)
extern VOIDFUNCPTR<s(0)(0)(0)>[T] _func_evtLogT0_noInt<s(0)(0)(0)>[&];(D1:_func_evtLogT0_noInt:0)
extern VOIDFUNCPTR<s(0)(0)(0)>[T] _func_evtLogT1<s(0)(0)(0)>[&];(D1:_func_evtLogT1:0)
extern VOIDFUNCPTR<s(0)(0)(0)>[T] _func_evtLogT1_noTS<s(0)(0)(0)>[&];(D1:_func_evtLogT1_noTS:0)
extern VOIDFUNCPTR<s(0)(0)(0)>[T] _func_evtLogTSched<s(0)(0)(0)>[&];(D1:_func_evtLogTSched:0)

extern VOIDFUNCPTR<s(0)(0)(0)>[T] _func_evtLogString<s(0)(0)(0)>[&];(D1:_func_evtLogString:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_evtLogPoint<s(0)(0)(0)>[&];(D1:_func_evtLogPoint:0)
extern FUNCPTR<s(0)(0)(0)>[T]	   _func_evtLogReserveTaskName<s(0)(0)(0)>[&];(D1:_func_evtLogReserveTaskName:0)



extern FUNCPTR<s(0)(0)(0)>[T]     _func_tmrStamp<s(0)(0)(0)>[&];(D1:_func_tmrStamp:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_tmrStampLock<s(0)(0)(0)>[&];(D1:_func_tmrStampLock:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_tmrFreq<s(0)(0)(0)>[&];(D1:_func_tmrFreq:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_tmrPeriod<s(0)(0)(0)>[&];(D1:_func_tmrPeriod:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_tmrConnect<s(0)(0)(0)>[&];(D1:_func_tmrConnect:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_tmrEnable<s(0)(0)(0)>[&];(D1:_func_tmrEnable:0)
extern FUNCPTR<s(0)(0)(0)>[T]     _func_tmrDisable<s(0)(0)(0)>[&];(D1:_func_tmrDisable:0)

extern VOIDFUNCPTR<s(0)(0)(0)>[T] _func_trgCheck<s(0)(0)(0)>[&];(D1:_func_trgCheck:0)
extern UINT32<s(0)(0)(0)>[T] evtAction<s(0)(0)(0)>[&];(D1:evtAction:0)
extern UINT32<s(0)(0)(0)>[T] wvEvtClass<s(0)(0)(0)>[&];(D1:wvEvtClass:0)
extern UINT32<s(0)(0)(0)>[T] trgEvtClass<s(0)(0)(0)>[&];(D1:trgEvtClass:0)

extern BOOL<s(0)(0)(0)>[T]   wvInstIsOn<s(0)(0)(0)>[&];(D1:wvInstIsOn:0)              
extern BOOL<s(0)(0)(0)>[T]   wvObjIsEnabled<s(0)(0)(0)>[&];(D1:wvObjIsEnabled:0)          




















































 













 

 










 












 
















 

















 


















 













 













 











 

















 
















 










 
















 
















 









 









 









 









 









 









 
















 









 









 









 


























 














































 

 


     





     





     




 


     











     





     





     










     











     






     





      





     

 


     










     







     






     








     






     







     







     







     








     








     









     









     








     








     








     








     






     






     







     






     









     






     









     










     







     






     






     







     





     







     








     







     






     








     






     





     





 


     






     





     





     





     








     







     





     




     





     





     





     





     





     





     





     




     





     





     





     





     





     





     





     





     





     





     





     





     





     





     




     




 


     







     






     







     







     




     





     





     





     





     






     






 




     





     




     























 














	 


















 






























 

 

 





























 

 

 























extern VOIDFUNCPTR<s(0)(0)(0)>[T] eventEvtRtn<s(0)(0)(0)>[&];(D1:eventEvtRtn:0)  

 

typedef struct eventsCb<s(1)(0)(1)>[&]
    {
    UINT32<s(1)(1)(0)>[T] wanted<s(1)(1)(0)>[&];	 
    volatile UINT32<s(1)(1)(0)>[T] received<s(1)(1)(0)>[&];	 
    UINT8<s(1)(1)(0)>[T]  options<s(1)(1)(0)>[&];	 
    UINT8<s(1)(1)(0)>[T]  sysflags<s(1)(1)(0)>[&];	 
    UINT8<s(1)(1)(0)>[T]  pad<s(1)(1)(0)>[&][2];	 
    } EVENTS<s(0)(0)(0)>[&];(D1:EVENTS:1)[[TYPENAME:EVENTS]]		 

 



 



					 


 

typedef struct eventsResourceCb<s(1)(0)(1)>[&]
    {
    UINT32<s(1)(1)(0)>[T] registered<s(1)(1)(0)>[&];	 
    int    taskId<s(1)(1)(0)>[&];	 
    UINT8<s(1)(1)(0)>[T]  options<s(1)(1)(0)>[&];	 
    UINT8<s(1)(1)(0)>[T]  pad<s(1)(1)(0)>[&][3];	 
    } EVENTS_RSRC<s(0)(0)(0)>[&];(D1:EVENTS_RSRC:1)[[TYPENAME:EVENTS_RSRC]]	 





 














extern void 	eventLibInit<s(0)(0)(0)>[&]	(void);(D1:eventLibInit:0)
extern void 	eventInit<s(0)(0)(0)>[&]	(EVENTS_RSRC<s(0)(0)(0)>[T] * pEvRsrc<s(0)(0)(0)>[&]);(D1:pEvRsrc:0)
extern void 	eventTerminate<s(0)(0)(0)>[&] 	(const EVENTS_RSRC<s(0)(0)(0)>[T] * pEvRsrc<s(0)(0)(0)>[&]);(D1:pEvRsrc:0)
extern void 	semEvLibInit<s(0)(0)(0)>[&]	(void);(D1:semEvLibInit:0)
extern void 	msgQEvLibInit<s(0)(0)(0)>[&]	(void);(D1:msgQEvLibInit:0)
extern STATUS<s(0)(0)(0)>[T] 	eventStart<s(0)(0)(0)>[&]	(OBJ_ID<s(0)(0)(0)>[T] objId<s(0)(0)(0)>[&], EVENTS_RSRC<s(0)(0)(0)>[T] * pEvRsrc<s(0)(0)(0)>[&],
				 FUNCPTR<s(0)(0)(0)>[T] isRsrcFree<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] events<s(0)(0)(0)>[&],
				 UINT8<s(0)(0)(0)>[T] options<s(0)(0)(0)>[&]);(D1:options:0)
extern STATUS<s(0)(0)(0)>[T]	eventRsrcSend<s(0)(0)(0)>[&]	(int taskId<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] events<s(0)(0)(0)>[&]);(D1:events:0)
extern STATUS<s(0)(0)(0)>[T]	eventRsrcShow<s(0)(0)(0)>[&]	(EVENTS_RSRC<s(0)(0)(0)>[T] * pEvRsrc<s(0)(0)(0)>[&]);(D1:pEvRsrc:0)
extern STATUS<s(0)(0)(0)>[T]   eventTaskShow<s(0)(0)(0)>[&]	(EVENTS<s(0)(0)(0)>[T]	* pEvents<s(0)(0)(0)>[&]);(D1:pEvents:0)























 













typedef struct semaphore<s(1)(0)(1)>[&]  
    {
    OBJ_CORE<s(1)(1)(0)>[T]	objCore<s(1)(1)(0)>[&];	 
    UINT8<s(1)(1)(0)>[T]	semType<s(1)(1)(0)>[&];	 
    UINT8<s(1)(1)(0)>[T]	options<s(1)(1)(0)>[&];	 
    UINT16<s(1)(1)(0)>[T]	recurse<s(1)(1)(0)>[&];	 
    Q_HEAD<s(1)(1)(0)>[T]	qHead<s(1)(1)(0)>[&];		 
    union
	{
	UINT<s(2)(1)(0)>[T]		 count<s(2)(1)(0)>[&];	 
	struct windTcb<s(3)(1)(1)>[&]	*owner<s(2)(1)(0)>[&];	 
	} state<s(1)(0)(0)>[&];
    EVENTS_RSRC<s(1)(0)(0)>[T]	events<s(1)(0)(0)>[&];		 

    } SEMAPHORE<s(0)(0)(0)>[&];(D1:SEMAPHORE:1)[[TYPENAME:SEMAPHORE]]




 












 
















 

extern OBJ_CLASS<s(0)(0)(0)>[T]	semClass<s(0)(0)(0)>[&];(D1:semClass:0)		 
extern OBJ_CLASS<s(0)(0)(0)>[T]	semInstClass<s(0)(0)(0)>[&];(D1:semInstClass:0)		 
extern CLASS_ID<s(0)(0)(0)>[T]		semClassId<s(0)(0)(0)>[&];(D1:semClassId:0)		 
extern CLASS_ID<s(0)(0)(0)>[T]		semInstClassId<s(0)(0)(0)>[&];(D1:semInstClassId:0)		 
extern FUNCPTR<s(0)(0)(0)>[T]		semGiveTbl<s(0)(0)(0)>[&] [];(D1:semGiveTbl:0)		 
extern FUNCPTR<s(0)(0)(0)>[T]		semTakeTbl<s(0)(0)(0)>[&] [];(D1:semTakeTbl:0)		 
extern FUNCPTR<s(0)(0)(0)>[T]		semFlushTbl<s(0)(0)(0)>[&] [];(D1:semFlushTbl:0)		 
extern FUNCPTR<s(0)(0)(0)>[T]		semGiveDeferTbl<s(0)(0)(0)>[&] [];(D1:semGiveDeferTbl:0)	 
extern FUNCPTR<s(0)(0)(0)>[T]		semFlushDeferTbl<s(0)(0)(0)>[&] [];(D1:semFlushDeferTbl:0)	 
extern int		semMGiveKernWork<s(0)(0)(0)>[&];(D1:semMGiveKernWork:0)	 

extern FUNCPTR<s(0)(0)(0)>[T]  semSmShowRtn<s(0)(0)(0)>[&];(D1:semSmShowRtn:0)	 
extern FUNCPTR<s(0)(0)(0)>[T]  semSmInfoRtn<s(0)(0)(0)>[&];(D1:semSmInfoRtn:0)	 

 



extern STATUS<s(0)(0)(0)>[T]	semLibInit<s(0)(0)(0)>[&] (void);(D1:semLibInit:0)
extern STATUS<s(0)(0)(0)>[T]	semTerminate<s(0)(0)(0)>[&] (SEM_ID<s(0)(0)(0)>[T] semId<s(0)(0)(0)>[&]);(D1:semId:0)
extern STATUS<s(0)(0)(0)>[T]	semDestroy<s(0)(0)(0)>[&] (SEM_ID<s(0)(0)(0)>[T] semId<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] dealloc<s(0)(0)(0)>[&]);(D1:dealloc:0)
extern STATUS<s(0)(0)(0)>[T]	semGiveDefer<s(0)(0)(0)>[&] (SEM_ID<s(0)(0)(0)>[T] semId<s(0)(0)(0)>[&]);(D1:semId:0)
extern STATUS<s(0)(0)(0)>[T]	semFlushDefer<s(0)(0)(0)>[&] (SEM_ID<s(0)(0)(0)>[T] semId<s(0)(0)(0)>[&]);(D1:semId:0)
extern STATUS<s(0)(0)(0)>[T]	semInvalid<s(0)(0)(0)>[&] (SEM_ID<s(0)(0)(0)>[T] semId<s(0)(0)(0)>[&]);(D1:semId:0)
extern STATUS<s(0)(0)(0)>[T]	semIntRestrict<s(0)(0)(0)>[&] (SEM_ID<s(0)(0)(0)>[T] semId<s(0)(0)(0)>[&]);(D1:semId:0)
extern STATUS<s(0)(0)(0)>[T]	semQInit<s(0)(0)(0)>[&] (SEMAPHORE<s(0)(0)(0)>[T] *pSemaphore<s(0)(0)(0)>[&], int options<s(0)(0)(0)>[&]);(D1:options:0)
extern STATUS<s(0)(0)(0)>[T]	semQFlush<s(0)(0)(0)>[&] (SEM_ID<s(0)(0)(0)>[T] semId<s(0)(0)(0)>[&]);(D1:semId:0)
extern void	semQFlushDefer<s(0)(0)(0)>[&] (SEM_ID<s(0)(0)(0)>[T] semId<s(0)(0)(0)>[&]);(D1:semId:0)
extern STATUS<s(0)(0)(0)>[T]	semBInit<s(0)(0)(0)>[&] (SEMAPHORE<s(0)(0)(0)>[T] *pSem<s(0)(0)(0)>[&],int options<s(0)(0)(0)>[&],SEM_B_STATE<s(0)(0)(0)>[T] initialState<s(0)(0)(0)>[&]);(D1:initialState:0)
extern STATUS<s(0)(0)(0)>[T]	semBCoreInit<s(0)(0)(0)>[&] (SEMAPHORE<s(0)(0)(0)>[T] *pSemaphore<s(0)(0)(0)>[&], int options<s(0)(0)(0)>[&],
			      SEM_B_STATE<s(0)(0)(0)>[T] initialState<s(0)(0)(0)>[&]);(D1:initialState:0)
extern STATUS<s(0)(0)(0)>[T]	semBGive<s(0)(0)(0)>[&] (SEM_ID<s(0)(0)(0)>[T] semId<s(0)(0)(0)>[&]);(D1:semId:0)
extern STATUS<s(0)(0)(0)>[T]	semBTake<s(0)(0)(0)>[&] (SEM_ID<s(0)(0)(0)>[T] semId<s(0)(0)(0)>[&], int timeout<s(0)(0)(0)>[&]);(D1:timeout:0)
extern void	semBGiveDefer<s(0)(0)(0)>[&] (SEM_ID<s(0)(0)(0)>[T] semId<s(0)(0)(0)>[&]);(D1:semId:0)
extern STATUS<s(0)(0)(0)>[T]	semMInit<s(0)(0)(0)>[&] (SEMAPHORE<s(0)(0)(0)>[T] *pSem<s(0)(0)(0)>[&], int options<s(0)(0)(0)>[&]);(D1:options:0)
extern STATUS<s(0)(0)(0)>[T]	semMCoreInit<s(0)(0)(0)>[&] (SEMAPHORE<s(0)(0)(0)>[T] *pSemaphore<s(0)(0)(0)>[&], int options<s(0)(0)(0)>[&]);(D1:options:0)
extern STATUS<s(0)(0)(0)>[T]	semMGive<s(0)(0)(0)>[&] (SEM_ID<s(0)(0)(0)>[T] semId<s(0)(0)(0)>[&]);(D1:semId:0)
extern STATUS<s(0)(0)(0)>[T]	semMTake<s(0)(0)(0)>[&] (SEM_ID<s(0)(0)(0)>[T] semId<s(0)(0)(0)>[&], int timeout<s(0)(0)(0)>[&]);(D1:timeout:0)
extern STATUS<s(0)(0)(0)>[T]	semMGiveKern<s(0)(0)(0)>[&] (SEM_ID<s(0)(0)(0)>[T] semId<s(0)(0)(0)>[&]);(D1:semId:0)
extern STATUS<s(0)(0)(0)>[T]	semMPendQPut<s(0)(0)(0)>[&] (SEM_ID<s(0)(0)(0)>[T] semId<s(0)(0)(0)>[&], int timeout<s(0)(0)(0)>[&]);(D1:timeout:0)
extern STATUS<s(0)(0)(0)>[T]	semCInit<s(0)(0)(0)>[&] (SEMAPHORE<s(0)(0)(0)>[T] *pSem<s(0)(0)(0)>[&],int options<s(0)(0)(0)>[&],int initialCount<s(0)(0)(0)>[&]);(D1:initialCount:0)
extern STATUS<s(0)(0)(0)>[T]	semCCoreInit<s(0)(0)(0)>[&] (SEMAPHORE<s(0)(0)(0)>[T] *pSemaphore<s(0)(0)(0)>[&], int options<s(0)(0)(0)>[&],
			      int initialCount<s(0)(0)(0)>[&]);(D1:initialCount:0)
extern STATUS<s(0)(0)(0)>[T]	semCGive<s(0)(0)(0)>[&] (SEM_ID<s(0)(0)(0)>[T] semId<s(0)(0)(0)>[&]);(D1:semId:0)
extern STATUS<s(0)(0)(0)>[T]	semCTake<s(0)(0)(0)>[&] (SEM_ID<s(0)(0)(0)>[T] semId<s(0)(0)(0)>[&], int timeout<s(0)(0)(0)>[&]);(D1:timeout:0)
extern void	semCGiveDefer<s(0)(0)(0)>[&] (SEM_ID<s(0)(0)(0)>[T] semId<s(0)(0)(0)>[&]);(D1:semId:0)
extern STATUS<s(0)(0)(0)>[T]	semOTake<s(0)(0)(0)>[&] (SEM_ID<s(0)(0)(0)>[T] semId<s(0)(0)(0)>[&]);(D1:semId:0)


















 

 

 


















































 















typedef struct { int quot<s(1)(1)(0)>[&]; int rem<s(1)(1)(0)>[&]; } div_t<s(0)(0)(0)>[&] ;(D1:div_t:1)[[TYPENAME:div_t]]




typedef struct { long quot<s(1)(1)(0)>[&]; long rem<s(1)(1)(0)>[&]; } ldiv_t<s(0)(0)(0)>[&] ;(D1:ldiv_t:1)[[TYPENAME:ldiv_t]]



typedef struct {		 
	unsigned char __state<s(1)(1)(0)>[&];
	unsigned short __wchar<s(1)(1)(0)>[&];
	} _Mbsave<s(0)(0)(0)>[&];(D1:_Mbsave:1)[[TYPENAME:_Mbsave]]



extern void	abort<s(0)(0)(0)>[&] (void);(D1:abort:0)
extern int	abs<s(0)(0)(0)>[&] (int __i<s(0)(0)(0)>[&]);(D1:__i:0)
extern int	atexit<s(0)(0)(0)>[&] (void (*__func<s(0)(0)(0)>[&])(void));(D1:__func:0)
extern double	atof<s(0)(0)(0)>[&] (const char *__s<s(0)(0)(0)>[&]);(D1:__s:0)
extern int	atoi<s(0)(0)(0)>[&] (const char *__s<s(0)(0)(0)>[&]);(D1:__s:0)
extern long	atol<s(0)(0)(0)>[&] (const char *__s<s(0)(0)(0)>[&]);(D1:__s:0)
extern void *	bsearch<s(0)(0)(0)>[&] (const void *__key<s(0)(0)(0)>[&], const void *__base<s(0)(0)(0)>[&],
		         size_t<s(0)(0)(0)>[T] __nelem<s(0)(0)(0)>[&], size_t<s(0)(0)(0)>[T] __size<s(0)(0)(0)>[&],
		         int  (*__cmp<s(0)(0)(0)>[&])(const void *__ck<s(0)(0)(0)>[&], const void *__ce<s(0)(0)(0)>[&]));(D1:__ce:0)
extern div_t<s(0)(0)(0)>[T]	div<s(0)(0)(0)>[&] (int __numer<s(0)(0)(0)>[&], int __denom<s(0)(0)(0)>[&]);(D1:__denom:0)
extern long	labs<s(0)(0)(0)>[&] (long __i<s(0)(0)(0)>[&]);(D1:__i:0)
extern ldiv_t<s(0)(0)(0)>[T]	ldiv<s(0)(0)(0)>[&] (long __numer<s(0)(0)(0)>[&], long __denom<s(0)(0)(0)>[&]);(D1:__denom:0)
extern int	mblen<s(0)(0)(0)>[&] (const char *__s<s(0)(0)(0)>[&], size_t<s(0)(0)(0)>[T] __n<s(0)(0)(0)>[&]);(D1:__n:0)
extern size_t<s(0)(0)(0)>[T]	mbstowcs<s(0)(0)(0)>[&] (wchar_t<s(0)(0)(0)>[T] *__wcs<s(0)(0)(0)>[&], const char *__s<s(0)(0)(0)>[&], size_t<s(0)(0)(0)>[T] __n<s(0)(0)(0)>[&]);(D1:__n:0)
extern int	mbtowc<s(0)(0)(0)>[&] (wchar_t<s(0)(0)(0)>[T] *__pwc<s(0)(0)(0)>[&], const char *__s<s(0)(0)(0)>[&], size_t<s(0)(0)(0)>[T] __n<s(0)(0)(0)>[&]);(D1:__n:0)
extern void	qsort<s(0)(0)(0)>[&] (void *__base<s(0)(0)(0)>[&], size_t<s(0)(0)(0)>[T] __nelem<s(0)(0)(0)>[&], size_t<s(0)(0)(0)>[T] __size<s(0)(0)(0)>[&],
		       int  (*__cmp<s(0)(0)(0)>[&])(const void *__e1<s(0)(0)(0)>[&], const void *__e2<s(0)(0)(0)>[&]));(D1:__e2:0)
extern int	rand<s(0)(0)(0)>[&] (void);(D1:rand:0)
extern void *	srand<s(0)(0)(0)>[&] (unsigned int __seed<s(0)(0)(0)>[&]);(D1:__seed:0)
extern double	strtod<s(0)(0)(0)>[&] (const char *__s<s(0)(0)(0)>[&], char **__endptr<s(0)(0)(0)>[&]);(D1:__endptr:0)
extern long	strtol<s(0)(0)(0)>[&] (const char *__s<s(0)(0)(0)>[&], char **__endptr<s(0)(0)(0)>[&], int __base<s(0)(0)(0)>[&]);(D1:__base:0)
extern unsigned long strtoul<s(0)(0)(0)>[&] (const char *__s<s(0)(0)(0)>[&], char **__endptr<s(0)(0)(0)>[&], int __base<s(0)(0)(0)>[&]);(D1:__base:0)
extern int	system<s(0)(0)(0)>[&] (const char *__s<s(0)(0)(0)>[&]);(D1:__s:0)
extern size_t<s(0)(0)(0)>[T]	wcstombs<s(0)(0)(0)>[&] (char *__s<s(0)(0)(0)>[&], const wchar_t<s(0)(0)(0)>[T] *__wcs<s(0)(0)(0)>[&], size_t<s(0)(0)(0)>[T] __n<s(0)(0)(0)>[&]);(D1:__n:0)
extern int	wctomb<s(0)(0)(0)>[&] (char *__s<s(0)(0)(0)>[&], wchar_t<s(0)(0)(0)>[T] __wchar<s(0)(0)(0)>[&]);(D1:__wchar:0)

extern void *	calloc<s(0)(0)(0)>[&] (size_t<s(0)(0)(0)>[T] __nelem<s(0)(0)(0)>[&], size_t<s(0)(0)(0)>[T] __size<s(0)(0)(0)>[&]);(D1:__size:0)
extern void	exit<s(0)(0)(0)>[&] (int __status<s(0)(0)(0)>[&]);(D1:__status:0)
extern void	free<s(0)(0)(0)>[&] (void *__ptr<s(0)(0)(0)>[&]);(D1:__ptr:0)
extern char *	getenv<s(0)(0)(0)>[&] (const char *__name<s(0)(0)(0)>[&]);(D1:__name:0)
extern void *	malloc<s(0)(0)(0)>[&] (size_t<s(0)(0)(0)>[T] __size<s(0)(0)(0)>[&]);(D1:__size:0)
extern void *	realloc<s(0)(0)(0)>[&] (void *__ptr<s(0)(0)(0)>[&], size_t<s(0)(0)(0)>[T] __size<s(0)(0)(0)>[&]);(D1:__size:0)



extern void     div_r<s(0)(0)(0)>[&] (int numer<s(0)(0)(0)>[&], int denom<s(0)(0)(0)>[&], div_t<s(0)(0)(0)>[T] * divStructPtr<s(0)(0)(0)>[&]);(D1:divStructPtr:0)
extern void     ldiv_r<s(0)(0)(0)>[&] (long numer<s(0)(0)(0)>[&], long denom<s(0)(0)(0)>[&], ldiv_t<s(0)(0)(0)>[T] * divStructPtr<s(0)(0)(0)>[&]);(D1:divStructPtr:0)















 












 







 



















 







typedef struct wdb_info<s(1)(0)(1)>[&]		 
    {
    int			wdbState<s(1)(1)(0)>[&];	 
    REG_SET<s(1)(1)(0)>[T] *		wdbRegisters<s(1)(1)(0)>[&];	 
    struct
        {
	void *	wdb1<s(2)(1)(0)>[&];
	void *	wdb2<s(2)(1)(0)>[&];
	} wdbEvtList<s(1)(0)(0)>[&];			 
    int			bpAddr<s(1)(0)(0)>[&];		 
					 
    int			taskBpAddr<s(1)(0)(0)>[&];	 
    int			taskPc<s(1)(0)(0)>[&];		 
    int			taskFp<s(1)(0)(0)>[&];		 
    int			taskSp<s(1)(0)(0)>[&];		 
    VOIDFUNCPTR<s(1)(0)(0)>[T]		wdbExitHook<s(1)(0)(0)>[&];	 
  } WDB_INFO<s(0)(0)(0)>[&];(D1:WDB_INFO:1)[[TYPENAME:WDB_INFO]]

typedef struct windTcb<s(1)(0)(1)>[&]		 
    {
    Q_NODE<s(1)(1)(0)>[T]		qNode<s(1)(1)(0)>[&];		 
    Q_NODE<s(1)(1)(0)>[T]		tickNode<s(1)(1)(0)>[&];	 
    Q_NODE<s(1)(1)(0)>[T]		activeNode<s(1)(1)(0)>[&];	 

    OBJ_CORE<s(1)(1)(0)>[T]		objCore<s(1)(1)(0)>[&];	 
    char *		name<s(1)(1)(0)>[&];		 
    int			options<s(1)(1)(0)>[&];	 
    UINT<s(1)(1)(0)>[T]		status<s(1)(1)(0)>[&];		 
    UINT<s(1)(1)(0)>[T]		priority<s(1)(1)(0)>[&];	 
    UINT<s(1)(1)(0)>[T]		priNormal<s(1)(1)(0)>[&];	 
    UINT<s(1)(1)(0)>[T]		priMutexCnt<s(1)(1)(0)>[&];	 
    struct semaphore<s(2)(1)(1)>[&] *	pPriMutex<s(1)(1)(0)>[&];	 

    UINT<s(1)(1)(0)>[T]		lockCnt<s(1)(1)(0)>[&];	 
    UINT<s(1)(1)(0)>[T]		tslice<s(1)(1)(0)>[&];		 

    UINT16<s(1)(1)(0)>[T]		swapInMask<s(1)(1)(0)>[&];	 
    UINT16<s(1)(1)(0)>[T]		swapOutMask<s(1)(1)(0)>[&];	 

    Q_HEAD<s(1)(1)(0)>[T] *		pPendQ<s(1)(1)(0)>[&];		 

    UINT<s(1)(1)(0)>[T]		safeCnt<s(1)(1)(0)>[&];	 
    Q_HEAD<s(1)(1)(0)>[T]		safetyQHead<s(1)(1)(0)>[&];	 

    FUNCPTR<s(1)(1)(0)>[T]		entry<s(1)(1)(0)>[&];		 

    char *		pStackBase<s(1)(1)(0)>[&];	 
    char *		pStackLimit<s(1)(1)(0)>[&];	 
    char *		pStackEnd<s(1)(1)(0)>[&];	 

    int			errorStatus<s(1)(1)(0)>[&];	 
    int			exitCode<s(1)(1)(0)>[&];	 

    struct sigtcb<s(2)(1)(1)>[&] *	pSignalInfo<s(1)(1)(0)>[&];	 
    struct selContext<s(2)(1)(1)>[&] *	pSelectContext<s(1)(1)(0)>[&];	 

    UINT<s(1)(1)(0)>[T]		taskTicks<s(1)(1)(0)>[&];	 
    UINT<s(1)(1)(0)>[T]		taskIncTicks<s(1)(1)(0)>[&];	 

    struct taskVar<s(2)(1)(1)>[&] *	pTaskVar<s(1)(1)(0)>[&];	 
    struct rpcModList<s(2)(1)(1)>[&] *	pRPCModList<s(1)(1)(0)>[&];	 
    struct fpContext<s(2)(1)(1)>[&] *	pFpContext<s(1)(1)(0)>[&];	 

    struct __sFILE<s(2)(1)(1)>[&] *	taskStdFp<s(1)(1)(0)>[&][3];	 
    int			taskStd<s(1)(1)(0)>[&][3];	 

    char **		ppEnviron<s(1)(1)(0)>[&];	 
    int                 envTblSize<s(1)(1)(0)>[&];      
    int                 nEnvVarEntries<s(1)(1)(0)>[&];  
    struct sm_obj_tcb<s(2)(1)(1)>[&] *	pSmObjTcb<s(1)(1)(0)>[&];	 
    int			windxLock<s(1)(1)(0)>[&];	 
    void *		pComLocal<s(1)(1)(0)>[&];	 
    REG_SET<s(1)(1)(0)>[T] *		pExcRegSet<s(1)(1)(0)>[&];	 
    EVENTS<s(1)(1)(0)>[T]		events<s(1)(1)(0)>[&];		 
    WDB_INFO<s(1)(1)(0)>[T] *		pWdbInfo<s(1)(1)(0)>[&];	 
    void *		pPthread<s(1)(1)(0)>[&];	 
    int			reserved1<s(1)(1)(0)>[&];	 
    int			compiler1<s(1)(1)(0)>[&];	 
    int			spare1<s(1)(1)(0)>[&];		 
    int			spare2<s(1)(1)(0)>[&];		 
    int			spare3<s(1)(1)(0)>[&];		 
    int			spare4<s(1)(1)(0)>[&];		 

    




     

















    EXC_INFO<s(1)(1)(0)>[T]            excInfo<s(1)(1)(0)>[&];         
    UINT<s(1)(1)(0)>[T]                pCoprocCtx<s(1)(1)(0)>[&];      

     

    REG_SET<s(1)(1)(0)>[T]             regs<s(1)(1)(0)>[&];            

















































    struct dspContext<s(2)(1)(1)>[&] *	pDspContext<s(1)(1)(0)>[&];	 
    WDB_INFO<s(1)(1)(0)>[T]		wdbInfo<s(1)(1)(0)>[&];	 
    } WIND_TCB<s(0)(0)(0)>[&];(D1:WIND_TCB:1)[[TYPENAME:WIND_TCB]]

typedef struct 			 
    {
    int			td_id<s(1)(1)(0)>[&];		 
    char *		td_name<s(1)(1)(0)>[&];	 
    int			td_priority<s(1)(1)(0)>[&];	 
    int			td_status<s(1)(1)(0)>[&];	 
    int			td_options<s(1)(1)(0)>[&];	 
    FUNCPTR<s(1)(1)(0)>[T]		td_entry<s(1)(1)(0)>[&];	 
    char *		td_sp<s(1)(1)(0)>[&];		 
    char *		td_pStackBase<s(1)(1)(0)>[&];	 
    char *		td_pStackLimit<s(1)(1)(0)>[&];	 
    char *		td_pStackEnd<s(1)(1)(0)>[&];	 
    int			td_stackSize<s(1)(1)(0)>[&];	 
    int			td_stackCurrent<s(1)(1)(0)>[&]; 
    int			td_stackHigh<s(1)(1)(0)>[&];	 
    int			td_stackMargin<s(1)(1)(0)>[&];	 
    int			td_errorStatus<s(1)(1)(0)>[&];	 
    int			td_delay<s(1)(1)(0)>[&];	 
    EVENTS<s(1)(1)(0)>[T]		td_events<s(1)(1)(0)>[&];	 
    } TASK_DESC<s(0)(0)(0)>[&];(D1:TASK_DESC:1)[[TYPENAME:TASK_DESC]]





 


















 


















 













 











 














 

extern CLASS_ID<s(0)(0)(0)>[T]	taskClassId<s(0)(0)(0)>[&];(D1:taskClassId:0)		 
extern CLASS_ID<s(0)(0)(0)>[T] taskInstClassId<s(0)(0)(0)>[&];(D1:taskInstClassId:0)  	 
extern WIND_TCB<s(0)(0)(0)>[T] *taskIdCurrent<s(0)(0)(0)>[&];(D1:taskIdCurrent:0)		 
extern BOOL<s(0)(0)(0)>[T]     taskPriRangeCheck<s(0)(0)(0)>[&];(D1:taskPriRangeCheck:0)       

 



extern STATUS<s(0)(0)(0)>[T] 	taskLibInit<s(0)(0)(0)>[&] (void);(D1:taskLibInit:0)





extern int 	taskSpawn<s(0)(0)(0)>[&] (char *name<s(0)(0)(0)>[&], int priority<s(0)(0)(0)>[&], int options<s(0)(0)(0)>[&], int stackSize<s(0)(0)(0)>[&],
		      	   FUNCPTR<s(0)(0)(0)>[T] entryPt<s(0)(0)(0)>[&], int arg1<s(0)(0)(0)>[&], int arg2<s(0)(0)(0)>[&], int arg3<s(0)(0)(0)>[&],
		      	   int arg4<s(0)(0)(0)>[&], int arg5<s(0)(0)(0)>[&], int arg6<s(0)(0)(0)>[&], int arg7<s(0)(0)(0)>[&],
		      	   int arg8<s(0)(0)(0)>[&], int arg9<s(0)(0)(0)>[&], int arg10<s(0)(0)(0)>[&]);(D1:arg10:0)


extern STATUS<s(0)(0)(0)>[T] 	taskInit<s(0)(0)(0)>[&] (WIND_TCB<s(0)(0)(0)>[T] *pTcb<s(0)(0)(0)>[&], char *name<s(0)(0)(0)>[&], int priority<s(0)(0)(0)>[&], int options<s(0)(0)(0)>[&],
			  char *pStackBase<s(0)(0)(0)>[&], int stackSize<s(0)(0)(0)>[&], FUNCPTR<s(0)(0)(0)>[T] entryPt<s(0)(0)(0)>[&],
			  int arg1<s(0)(0)(0)>[&], int arg2<s(0)(0)(0)>[&], int arg3<s(0)(0)(0)>[&], int arg4<s(0)(0)(0)>[&], int arg5<s(0)(0)(0)>[&],
			  int arg6<s(0)(0)(0)>[&], int arg7<s(0)(0)(0)>[&], int arg8<s(0)(0)(0)>[&], int arg9<s(0)(0)(0)>[&], int arg10<s(0)(0)(0)>[&]);(D1:arg10:0)
extern STATUS<s(0)(0)(0)>[T] 	taskActivate<s(0)(0)(0)>[&] (int tid<s(0)(0)(0)>[&]);(D1:tid:0)
extern STATUS<s(0)(0)(0)>[T] 	taskDelete<s(0)(0)(0)>[&] (int tid<s(0)(0)(0)>[&]);(D1:tid:0)
extern STATUS<s(0)(0)(0)>[T] 	taskDeleteForce<s(0)(0)(0)>[&] (int tid<s(0)(0)(0)>[&]);(D1:tid:0)
extern STATUS<s(0)(0)(0)>[T] 	taskSuspend<s(0)(0)(0)>[&] (int tid<s(0)(0)(0)>[&]);(D1:tid:0)
extern STATUS<s(0)(0)(0)>[T] 	taskResume<s(0)(0)(0)>[&] (int tid<s(0)(0)(0)>[&]);(D1:tid:0)
extern STATUS<s(0)(0)(0)>[T] 	taskRestart<s(0)(0)(0)>[&] (int tid<s(0)(0)(0)>[&]);(D1:tid:0)
extern STATUS<s(0)(0)(0)>[T] 	taskPrioritySet<s(0)(0)(0)>[&] (int tid<s(0)(0)(0)>[&], int newPriority<s(0)(0)(0)>[&]);(D1:newPriority:0)
extern STATUS<s(0)(0)(0)>[T] 	taskPriorityGet<s(0)(0)(0)>[&] (int tid<s(0)(0)(0)>[&], int *pPriority<s(0)(0)(0)>[&]);(D1:pPriority:0)
extern STATUS<s(0)(0)(0)>[T] 	taskLock<s(0)(0)(0)>[&] (void);(D1:taskLock:0)
extern STATUS<s(0)(0)(0)>[T] 	taskUnlock<s(0)(0)(0)>[&] (void);(D1:taskUnlock:0)
extern STATUS<s(0)(0)(0)>[T] 	taskSafe<s(0)(0)(0)>[&] (void);(D1:taskSafe:0)
extern STATUS<s(0)(0)(0)>[T] 	taskUnsafe<s(0)(0)(0)>[&] (void);(D1:taskUnsafe:0)
extern STATUS<s(0)(0)(0)>[T] 	taskDelay<s(0)(0)(0)>[&] (int ticks<s(0)(0)(0)>[&]);(D1:ticks:0)
extern STATUS<s(0)(0)(0)>[T] 	taskOptionsSet<s(0)(0)(0)>[&] (int tid<s(0)(0)(0)>[&], int mask<s(0)(0)(0)>[&], int newOptions<s(0)(0)(0)>[&]);(D1:newOptions:0)
extern STATUS<s(0)(0)(0)>[T] 	taskOptionsGet<s(0)(0)(0)>[&] (int tid<s(0)(0)(0)>[&], int *pOptions<s(0)(0)(0)>[&]);(D1:pOptions:0)
extern char *	taskName<s(0)(0)(0)>[&] (int tid<s(0)(0)(0)>[&]);(D1:tid:0)
extern int 	taskNameToId<s(0)(0)(0)>[&] (char *name<s(0)(0)(0)>[&]);(D1:name:0)
extern STATUS<s(0)(0)(0)>[T] 	taskIdVerify<s(0)(0)(0)>[&] (int tid<s(0)(0)(0)>[&]);(D1:tid:0)
extern int 	taskIdSelf<s(0)(0)(0)>[&] (void);(D1:taskIdSelf:0)
extern int 	taskIdDefault<s(0)(0)(0)>[&] (int tid<s(0)(0)(0)>[&]);(D1:tid:0)
extern BOOL<s(0)(0)(0)>[T] 	taskIsReady<s(0)(0)(0)>[&] (int tid<s(0)(0)(0)>[&]);(D1:tid:0)
extern BOOL<s(0)(0)(0)>[T] 	taskIsSuspended<s(0)(0)(0)>[&] (int tid<s(0)(0)(0)>[&]);(D1:tid:0)
extern WIND_TCB<s(0)(0)(0)>[T] *taskTcb<s(0)(0)(0)>[&] (int tid<s(0)(0)(0)>[&]);(D1:tid:0)
extern int 	taskIdListGet<s(0)(0)(0)>[&] (int idList<s(0)(0)(0)>[&] [ ], int maxTasks<s(0)(0)(0)>[&]);(D1:maxTasks:0)
extern STATUS<s(0)(0)(0)>[T] 	taskInfoGet<s(0)(0)(0)>[&] (int tid<s(0)(0)(0)>[&], TASK_DESC<s(0)(0)(0)>[T] *pTaskDesc<s(0)(0)(0)>[&]);(D1:pTaskDesc:0)
extern STATUS<s(0)(0)(0)>[T] 	taskStatusString<s(0)(0)(0)>[&] (int tid<s(0)(0)(0)>[&], char *pString<s(0)(0)(0)>[&]);(D1:pString:0)
extern STATUS<s(0)(0)(0)>[T] 	taskOptionsString<s(0)(0)(0)>[&] (int tid<s(0)(0)(0)>[&], char *pString<s(0)(0)(0)>[&]);(D1:pString:0)
extern STATUS<s(0)(0)(0)>[T] 	taskRegsGet<s(0)(0)(0)>[&] (int tid<s(0)(0)(0)>[&], REG_SET<s(0)(0)(0)>[T] *pRegs<s(0)(0)(0)>[&]);(D1:pRegs:0)
extern STATUS<s(0)(0)(0)>[T] 	taskRegsSet<s(0)(0)(0)>[&] (int tid<s(0)(0)(0)>[&], REG_SET<s(0)(0)(0)>[T] *pRegs<s(0)(0)(0)>[&]);(D1:pRegs:0)
extern void 	taskRegsShow<s(0)(0)(0)>[&] (int tid<s(0)(0)(0)>[&]);(D1:tid:0)
extern void *	taskStackAllot<s(0)(0)(0)>[&] (int tid<s(0)(0)(0)>[&], unsigned nBytes<s(0)(0)(0)>[&]);(D1:nBytes:0)
extern void 	taskShowInit<s(0)(0)(0)>[&] (void);(D1:taskShowInit:0)
extern STATUS<s(0)(0)(0)>[T] 	taskShow<s(0)(0)(0)>[&] (int tid<s(0)(0)(0)>[&], int level<s(0)(0)(0)>[&]);(D1:level:0)












 

 

 


































 

typedef struct node<s(1)(0)(1)>[&]		 
    {
    struct node<s(2)(1)(1)>[&] *next<s(1)(1)(0)>[&];		 
    struct node<s(2)(1)(1)>[&] *previous<s(1)(1)(0)>[&];	 
    } NODE<s(0)(0)(0)>[&];(D1:NODE:1)[[TYPENAME:NODE]]


 

typedef struct			 
    {
    NODE<s(1)(1)(0)>[T] node<s(1)(1)(0)>[&];			 
    int count<s(1)(1)(0)>[&];			 
    } LIST<s(0)(0)(0)>[&];(D1:LIST:1)[[TYPENAME:LIST]]

 


 




extern void	lstLibInit<s(0)(0)(0)>[&] (void);(D1:lstLibInit:0)
extern NODE<s(0)(0)(0)>[T] *	lstFirst<s(0)(0)(0)>[&] (LIST<s(0)(0)(0)>[T] *pList<s(0)(0)(0)>[&]);(D1:pList:0)
extern NODE<s(0)(0)(0)>[T] *	lstGet<s(0)(0)(0)>[&] (LIST<s(0)(0)(0)>[T] *pList<s(0)(0)(0)>[&]);(D1:pList:0)
extern NODE<s(0)(0)(0)>[T] *	lstLast<s(0)(0)(0)>[&] (LIST<s(0)(0)(0)>[T] *pList<s(0)(0)(0)>[&]);(D1:pList:0)
extern NODE<s(0)(0)(0)>[T] *	lstNStep<s(0)(0)(0)>[&] (NODE<s(0)(0)(0)>[T] *pNode<s(0)(0)(0)>[&], int nStep<s(0)(0)(0)>[&]);(D1:nStep:0)
extern NODE<s(0)(0)(0)>[T] *	lstNext<s(0)(0)(0)>[&] (NODE<s(0)(0)(0)>[T] *pNode<s(0)(0)(0)>[&]);(D1:pNode:0)
extern NODE<s(0)(0)(0)>[T] *	lstNth<s(0)(0)(0)>[&] (LIST<s(0)(0)(0)>[T] *pList<s(0)(0)(0)>[&], int nodenum<s(0)(0)(0)>[&]);(D1:nodenum:0)
extern NODE<s(0)(0)(0)>[T] *	lstPrevious<s(0)(0)(0)>[&] (NODE<s(0)(0)(0)>[T] *pNode<s(0)(0)(0)>[&]);(D1:pNode:0)
extern int 	lstCount<s(0)(0)(0)>[&] (LIST<s(0)(0)(0)>[T] *pList<s(0)(0)(0)>[&]);(D1:pList:0)
extern int 	lstFind<s(0)(0)(0)>[&] (LIST<s(0)(0)(0)>[T] *pList<s(0)(0)(0)>[&], NODE<s(0)(0)(0)>[T] *pNode<s(0)(0)(0)>[&]);(D1:pNode:0)
extern void 	lstAdd<s(0)(0)(0)>[&] (LIST<s(0)(0)(0)>[T] *pList<s(0)(0)(0)>[&], NODE<s(0)(0)(0)>[T] *pNode<s(0)(0)(0)>[&]);(D1:pNode:0)
extern void 	lstConcat<s(0)(0)(0)>[&] (LIST<s(0)(0)(0)>[T] *pDstList<s(0)(0)(0)>[&], LIST<s(0)(0)(0)>[T] *pAddList<s(0)(0)(0)>[&]);(D1:pAddList:0)
extern void 	lstDelete<s(0)(0)(0)>[&] (LIST<s(0)(0)(0)>[T] *pList<s(0)(0)(0)>[&], NODE<s(0)(0)(0)>[T] *pNode<s(0)(0)(0)>[&]);(D1:pNode:0)
extern void 	lstExtract<s(0)(0)(0)>[&] (LIST<s(0)(0)(0)>[T] *pSrcList<s(0)(0)(0)>[&], NODE<s(0)(0)(0)>[T] *pStartNode<s(0)(0)(0)>[&], NODE<s(0)(0)(0)>[T] *pEndNode<s(0)(0)(0)>[&],
	  		    LIST<s(0)(0)(0)>[T] *pDstList<s(0)(0)(0)>[&]);(D1:pDstList:0)
extern void 	lstFree<s(0)(0)(0)>[&] (LIST<s(0)(0)(0)>[T] *pList<s(0)(0)(0)>[&]);(D1:pList:0)
extern void 	lstInit<s(0)(0)(0)>[&] (LIST<s(0)(0)(0)>[T] *pList<s(0)(0)(0)>[&]);(D1:pList:0)
extern void 	lstInsert<s(0)(0)(0)>[&] (LIST<s(0)(0)(0)>[T] *pList<s(0)(0)(0)>[&], NODE<s(0)(0)(0)>[T] *pPrev<s(0)(0)(0)>[&], NODE<s(0)(0)(0)>[T] *pNode<s(0)(0)(0)>[&]);(D1:pNode:0)




















struct acb<s(1)(0)(1)>[&] {
    applId_tt<s(1)(1)(0)>[T] applId<s(1)(1)(0)>[&];
    char applname<s(1)(1)(0)>[&][23  + 1];
     

    int fd<s(1)(1)(0)>[&];                      
    int qid<s(1)(1)(0)>[&];                     

    int          fd_qid<s(1)(1)(0)>[&];  
    unsigned int logFlags<s(1)(1)(0)>[&];
    unsigned int cfg_options<s(1)(1)(0)>[&];
    unsigned int swping_counter<s(1)(1)(0)>[&];
    unsigned int swping_max<s(1)(1)(0)>[&];
    unsigned int waiting<s(1)(1)(0)>[&];
    unsigned int malloc_memory<s(1)(1)(0)>[&];  
    unsigned int malloc_buffs<s(1)(1)(0)>[&];   
    unsigned int Malloc_buffs<s(1)(1)(0)>[&];   
    unsigned int Malloc_memory<s(1)(1)(0)>[&];  
    int tid<s(1)(1)(0)>[&];                     
    void *applPrivate<s(1)(1)(0)>[&];           
    void *PrivateAreaAddr<s(1)(1)(0)>[&];       
    int   PrivateAreaSize<s(1)(1)(0)>[&];            
    int   PrivateAreaOpen<s(1)(1)(0)>[&];          
    int          tasksSpawned<s(1)(1)(0)>[&];      
};


struct taskMemStat<s(1)(0)(1)>[&]
{ 
 int taskId<s(1)(1)(0)>[&];
 int AppNo<s(1)(1)(0)>[&];
 char taskName<s(1)(1)(0)>[&][12 ];
 unsigned int dynMemReqSum<s(1)(1)(0)>[&];  
 unsigned int dynMemUsingNow<s(1)(1)(0)>[&];  
 unsigned int dynMemTUsingNow<s(1)(1)(0)>[&];   
 unsigned int  fixedMemReqSum<s(1)(1)(0)>[&];  
 unsigned int fixedMemUsingNow<s(1)(1)(0)>[&];   
 unsigned int fixedMemTUsingNow<s(1)(1)(0)>[&];  
 
};

struct MemUsedInTaskInit<s(1)(0)(1)>[&]
{ 
   char mod_or_app_Name<s(1)(1)(0)>[&][12 ];
  unsigned int malloc_size_used_in_load<s(1)(1)(0)>[&];  
  unsigned int malloc_size_used_in_active<s(1)(1)(0)>[&];  
};


struct taskCB<s(1)(0)(1)>[&] {
    int taskNum<s(1)(1)(0)>[&];
    char taskname<s(1)(1)(0)>[&][10  + 1];
    void *taskPrivate<s(1)(1)(0)>[&];
    char            *mibAccessPtr<s(1)(1)(0)>[&];  
};


extern struct taskCB<s(1)(0)(1)>[&] *taskCB<s(0)(0)(0)>[&];(D1:taskCB:0)
extern struct acb<s(1)(0)(1)>[&] *acb<s(0)(0)(0)>[&];(D1:acb:0)
extern struct acb<s(1)(0)(1)>[&] *applicationACBs<s(0)(0)(0)>[&][];(D1:applicationACBs:0)

extern struct taskMemStat<s(1)(0)(1)>[&] gTaskMemStat<s(1)(0)(1)>[&][];(D1:gTaskMemStat:0)









 

 


































 




















 

 

 


































 






























 

 

 


































 



















 









struct	arphdr<s(1)(0)(1)>[&] {
	u_short<s(1)(1)(0)>[T]	ar_hrd<s(1)(1)(0)>[&];		 


	u_short<s(1)(1)(0)>[T]	ar_pro<s(1)(1)(0)>[&];		 
	u_char<s(1)(1)(0)>[T]	ar_hln<s(1)(1)(0)>[&];		 
	u_char<s(1)(1)(0)>[T]	ar_pln<s(1)(1)(0)>[&];		 
	u_short<s(1)(1)(0)>[T]	ar_op<s(1)(1)(0)>[&];		 






 









};

 


struct arpreq<s(1)(0)(1)>[&] {
	struct	sockaddr<s(2)(1)(1)>[&] arp_pa<s(2)(1)(1)>[&];		 
	struct	sockaddr<s(2)(1)(1)>[&] arp_ha<s(2)(1)(1)>[&];		 
	int	arp_flags<s(1)(1)(0)>[&];			 
};
 

















 

 

 


































 




















 

 
 













 





































 

 

 





































 





typedef enum
    {
    SELREAD<s(0)(0)(0)>[&],
    SELWRITE<s(0)(0)(0)>[&]
    } SELECT_TYPE<s(0)(0)(0)>[&];(D1:SELECT_TYPE:1)[[TYPENAME:SELECT_TYPE]]

 

 

 
















typedef struct selWkNode<s(1)(0)(1)>[&]
    {
    NODE<s(1)(1)(0)>[T]		linkedListHooks<s(1)(1)(0)>[&]; 
    BOOL<s(1)(1)(0)>[T]		dontFree<s(1)(1)(0)>[&];	 
    int			taskId<s(1)(1)(0)>[&];		 
    int			fd<s(1)(1)(0)>[&];		 
    SELECT_TYPE<s(1)(1)(0)>[T]		type<s(1)(1)(0)>[&];		 
    } SEL_WAKEUP_NODE<s(0)(0)(0)>[&];(D1:SEL_WAKEUP_NODE:1)[[TYPENAME:SEL_WAKEUP_NODE]]

typedef struct
    {
    SEMAPHORE<s(1)(1)(0)>[T]		listMutex<s(1)(1)(0)>[&];	 
    SEL_WAKEUP_NODE<s(1)(1)(0)>[T]	firstNode<s(1)(1)(0)>[&];	 
    LIST<s(1)(1)(0)>[T]		wakeupList<s(1)(1)(0)>[&];	 
    } SEL_WAKEUP_LIST<s(0)(0)(0)>[&];(D1:SEL_WAKEUP_LIST:1)[[TYPENAME:SEL_WAKEUP_LIST]]

typedef struct selContext<s(1)(0)(1)>[&]
    {
    SEMAPHORE<s(1)(1)(0)>[T]	wakeupSem<s(1)(1)(0)>[&];		 
    BOOL<s(1)(1)(0)>[T]     	pendedOnSelect<s(1)(1)(0)>[&];		 

    fd_set<s(1)(1)(0)>[T]     *pReadFds<s(1)(1)(0)>[&];		 
    fd_set<s(1)(1)(0)>[T]     *pWriteFds<s(1)(1)(0)>[&];		 

     

    fd_set<s(1)(1)(0)>[T]     *pOrigReadFds<s(1)(1)(0)>[&];		 
    fd_set<s(1)(1)(0)>[T]     *pOrigWriteFds<s(1)(1)(0)>[&];		 
    int		width<s(1)(1)(0)>[&];			 

     











    } SEL_CONTEXT<s(0)(0)(0)>[&];(D1:SEL_CONTEXT:1)[[TYPENAME:SEL_CONTEXT]]


 



extern void	selectInit<s(0)(0)(0)>[&]		(int numFiles<s(0)(0)(0)>[&]);(D1:numFiles:0)
extern void	selTaskDeleteHookAdd<s(0)(0)(0)>[&] 	(void);(D1:selTaskDeleteHookAdd:0)

















 



extern SELECT_TYPE<s(0)(0)(0)>[T]  selWakeupType<s(0)(0)(0)>[&] 	(SEL_WAKEUP_NODE<s(0)(0)(0)>[T] *pWakeupNode<s(0)(0)(0)>[&]);(D1:pWakeupNode:0)
extern STATUS<s(0)(0)(0)>[T] 	    selNodeAdd<s(0)(0)(0)>[&] 	      	(SEL_WAKEUP_LIST<s(0)(0)(0)>[T] *pWakeupList<s(0)(0)(0)>[&],
			    		 SEL_WAKEUP_NODE<s(0)(0)(0)>[T] *pWakeupNode<s(0)(0)(0)>[&]);(D1:pWakeupNode:0)
extern STATUS<s(0)(0)(0)>[T] 	    selNodeDelete<s(0)(0)(0)>[&] 	(SEL_WAKEUP_LIST<s(0)(0)(0)>[T] *pWakeupList<s(0)(0)(0)>[&],
			       		 SEL_WAKEUP_NODE<s(0)(0)(0)>[T] *pWakeupNode<s(0)(0)(0)>[&]);(D1:pWakeupNode:0)
extern int 	    selWakeupListLen<s(0)(0)(0)>[&] 	(SEL_WAKEUP_LIST<s(0)(0)(0)>[T] *pWakeupList<s(0)(0)(0)>[&]);(D1:pWakeupList:0)
extern void 	    selWakeup<s(0)(0)(0)>[&] 		(SEL_WAKEUP_NODE<s(0)(0)(0)>[T] *pWakeupNode<s(0)(0)(0)>[&]);(D1:pWakeupNode:0)
extern void 	    selWakeupAll<s(0)(0)(0)>[&] 	(SEL_WAKEUP_LIST<s(0)(0)(0)>[T] *pWakeupList<s(0)(0)(0)>[&], 
					 SELECT_TYPE<s(0)(0)(0)>[T] type<s(0)(0)(0)>[&]);(D1:type:0)
extern void 	    selWakeupListInit<s(0)(0)(0)>[&] 	(SEL_WAKEUP_LIST<s(0)(0)(0)>[T] *pWakeupList<s(0)(0)(0)>[&]);(D1:pWakeupList:0)
extern void 	    selWakeupListTerm<s(0)(0)(0)>[&] 	(SEL_WAKEUP_LIST<s(0)(0)(0)>[T] *pWakeupList<s(0)(0)(0)>[&]);(D1:pWakeupList:0)
extern int	    select<s(0)(0)(0)>[&] 		(int width<s(0)(0)(0)>[&], fd_set<s(0)(0)(0)>[T] *pReadFds<s(0)(0)(0)>[&], 
					 fd_set<s(0)(0)(0)>[T] *pWriteFds<s(0)(0)(0)>[&], fd_set<s(0)(0)(0)>[T] *pExceptFds<s(0)(0)(0)>[&],
					 struct timeval<s(1)(0)(1)>[&] *pTimeOut<s(0)(0)(0)>[&]);(D1:pTimeOut:0)









 

 

 


































 





















struct iovec<s(1)(0)(1)>[&] {
	caddr_t<s(1)(1)(0)>[T]	iov_base<s(1)(1)(0)>[&];
	int	iov_len<s(1)(1)(0)>[&];
};

enum	uio_rw<s(0)(0)(0)>[&] { UIO_READ<s(0)(0)(0)>[&], UIO_WRITE<s(0)(0)(0)>[&] };

 
enum uio_seg<s(0)(0)(0)>[&] {
	UIO_USERSPACE<s(0)(0)(0)>[&],		 
	UIO_SYSSPACE<s(0)(0)(0)>[&],		 
	UIO_USERISPACE<s(0)(0)(0)>[&]		 
};

struct uio<s(1)(0)(1)>[&] {
	struct	iovec<s(2)(1)(1)>[&] *uio_iov<s(1)(1)(0)>[&];
	int	uio_iovcnt<s(1)(1)(0)>[&];
	off_t<s(1)(1)(0)>[T]	uio_offset<s(1)(1)(0)>[&];
	int	uio_resid<s(1)(1)(0)>[&];
	enum	uio_seg<s(1)(1)(0)>[&] uio_segflg<s(1)(1)(0)>[&];
	enum	uio_rw<s(1)(1)(0)>[&] uio_rw<s(1)(1)(0)>[&];



};
















 

 

 


































 































 

 
 
























 

















 































            
 



extern int 	splnet<s(0)(0)(0)>[&] (void);(D1:splnet:0)
extern int 	splimp<s(0)(0)(0)>[&] (void);(D1:splimp:0)
extern void 	splx<s(0)(0)(0)>[&] (int x<s(0)(0)(0)>[&]);(D1:x:0)
extern void 	panic<s(0)(0)(0)>[&] (char *msg<s(0)(0)(0)>[&]);(D1:msg:0)
extern void 	wakeup<s(0)(0)(0)>[&] (SEM_ID<s(0)(0)(0)>[T] semId<s(0)(0)(0)>[&]);(D1:semId:0)
extern void 	ksleep<s(0)(0)(0)>[&] (SEM_ID<s(0)(0)(0)>[T] semId<s(0)(0)(0)>[&]);(D1:semId:0)
extern char *	_netMalloc<s(0)(0)(0)>[&] (int bufSize<s(0)(0)(0)>[&], UCHAR<s(0)(0)(0)>[T] type<s(0)(0)(0)>[&], int canWait<s(0)(0)(0)>[&]);(D1:canWait:0) 
extern void	_netFree<s(0)(0)(0)>[&] (char * pBuf<s(0)(0)(0)>[&]);(D1:pBuf:0) 
extern void * 	hashinit<s(0)(0)(0)>[&] (int 	elements<s(0)(0)(0)>[&], int type<s(0)(0)(0)>[&], u_long<s(0)(0)(0)>[T] * hashmask<s(0)(0)(0)>[&]);(D1:hashmask:0)












 

 

 



























extern void *	memchr<s(0)(0)(0)>[&] (const void *__s<s(0)(0)(0)>[&], int __c<s(0)(0)(0)>[&], size_t<s(0)(0)(0)>[T] __n<s(0)(0)(0)>[&]);(D1:__n:0)
extern int 	memcmp<s(0)(0)(0)>[&] (const void *__s1<s(0)(0)(0)>[&], const void *__s2<s(0)(0)(0)>[&], size_t<s(0)(0)(0)>[T] __n<s(0)(0)(0)>[&]);(D1:__n:0)
extern void *	memcpy<s(0)(0)(0)>[&] (void *__s1<s(0)(0)(0)>[&], const void *__s2<s(0)(0)(0)>[&], size_t<s(0)(0)(0)>[T] __n<s(0)(0)(0)>[&]);(D1:__n:0)
extern void *	memmove<s(0)(0)(0)>[&] (void *__s1<s(0)(0)(0)>[&], const void *__s2<s(0)(0)(0)>[&], size_t<s(0)(0)(0)>[T] __n<s(0)(0)(0)>[&]);(D1:__n:0)
extern void *	memset<s(0)(0)(0)>[&] (void *__s<s(0)(0)(0)>[&], int __c<s(0)(0)(0)>[&], size_t<s(0)(0)(0)>[T] __n<s(0)(0)(0)>[&]);(D1:__n:0)

extern char *	strcat<s(0)(0)(0)>[&] (char *__s1<s(0)(0)(0)>[&], const char *__s2<s(0)(0)(0)>[&]);(D1:__s2:0)
extern char *	strchr<s(0)(0)(0)>[&] (const char *__s<s(0)(0)(0)>[&], int __c<s(0)(0)(0)>[&]);(D1:__c:0)
extern int 	strcmp<s(0)(0)(0)>[&] (const char *__s1<s(0)(0)(0)>[&], const char *__s2<s(0)(0)(0)>[&]);(D1:__s2:0)
extern int 	strcoll<s(0)(0)(0)>[&] (const char *__s1<s(0)(0)(0)>[&], const char *__s2<s(0)(0)(0)>[&]);(D1:__s2:0)
extern char *	strcpy<s(0)(0)(0)>[&] (char *__s1<s(0)(0)(0)>[&], const char *__s2<s(0)(0)(0)>[&]);(D1:__s2:0)
extern size_t<s(0)(0)(0)>[T] 	strcspn<s(0)(0)(0)>[&] (const char *__s1<s(0)(0)(0)>[&], const char *__s2<s(0)(0)(0)>[&]);(D1:__s2:0)
extern size_t<s(0)(0)(0)>[T] 	strlen<s(0)(0)(0)>[&] (const char *__s<s(0)(0)(0)>[&]);(D1:__s:0)
extern char *	strncat<s(0)(0)(0)>[&] (char *__s1<s(0)(0)(0)>[&], const char *__s2<s(0)(0)(0)>[&], size_t<s(0)(0)(0)>[T] __n<s(0)(0)(0)>[&]);(D1:__n:0)
extern int 	strncmp<s(0)(0)(0)>[&] (const char *__s1<s(0)(0)(0)>[&], const char *__s2<s(0)(0)(0)>[&], size_t<s(0)(0)(0)>[T] __n<s(0)(0)(0)>[&]);(D1:__n:0)
extern char *	strncpy<s(0)(0)(0)>[&] (char *__s1<s(0)(0)(0)>[&], const char *__s2<s(0)(0)(0)>[&], size_t<s(0)(0)(0)>[T] __n<s(0)(0)(0)>[&]);(D1:__n:0)
extern char *	strpbrk<s(0)(0)(0)>[&] (const char *__s1<s(0)(0)(0)>[&], const char *__s2<s(0)(0)(0)>[&]);(D1:__s2:0)
extern char *	strrchr<s(0)(0)(0)>[&] (const char *__s<s(0)(0)(0)>[&], int __c<s(0)(0)(0)>[&]);(D1:__c:0)
extern size_t<s(0)(0)(0)>[T] 	strspn<s(0)(0)(0)>[&] (const char *__s1<s(0)(0)(0)>[&], const char *__s2<s(0)(0)(0)>[&]);(D1:__s2:0)
extern char *	strstr<s(0)(0)(0)>[&] (const char *__s1<s(0)(0)(0)>[&], const char *__s2<s(0)(0)(0)>[&]);(D1:__s2:0)
extern char *	strtok<s(0)(0)(0)>[&] (char *__s<s(0)(0)(0)>[&], const char *__sep<s(0)(0)(0)>[&]);(D1:__sep:0)
extern size_t<s(0)(0)(0)>[T] 	strxfrm<s(0)(0)(0)>[&] (char *__s1<s(0)(0)(0)>[&], const char *__s2<s(0)(0)(0)>[&], size_t<s(0)(0)(0)>[T] __n<s(0)(0)(0)>[&]);(D1:__n:0)
extern char *	strerror<s(0)(0)(0)>[&](int __errcode<s(0)(0)(0)>[&]);(D1:__errcode:0)


extern char *	strtok_r<s(0)(0)(0)>[&] (char *__s<s(0)(0)(0)>[&], const char *__sep<s(0)(0)(0)>[&], char **__ppLast<s(0)(0)(0)>[&]);(D1:__ppLast:0)



extern int	strerror_r<s(0)(0)(0)>[&] (int __errcode<s(0)(0)(0)>[&], char *__buf<s(0)(0)(0)>[&]);(D1:__buf:0)
extern void 	bcopy<s(0)(0)(0)>[&] (const char *source<s(0)(0)(0)>[&], char *dest<s(0)(0)(0)>[&], int nbytes<s(0)(0)(0)>[&]);(D1:nbytes:0)
extern void 	bcopyBytes<s(0)(0)(0)>[&] (char *source<s(0)(0)(0)>[&], char *dest<s(0)(0)(0)>[&], int nbytes<s(0)(0)(0)>[&]);(D1:nbytes:0)
extern void 	bcopyWords<s(0)(0)(0)>[&] (char *source<s(0)(0)(0)>[&], char *dest<s(0)(0)(0)>[&], int nwords<s(0)(0)(0)>[&]);(D1:nwords:0)
extern void 	bcopyLongs<s(0)(0)(0)>[&] (char *source<s(0)(0)(0)>[&], char *dest<s(0)(0)(0)>[&], int nlongs<s(0)(0)(0)>[&]);(D1:nlongs:0)
extern void 	bfill<s(0)(0)(0)>[&] (char *buf<s(0)(0)(0)>[&], int nbytes<s(0)(0)(0)>[&], int ch<s(0)(0)(0)>[&]);(D1:ch:0)
extern void 	bfillBytes<s(0)(0)(0)>[&] (char *buf<s(0)(0)(0)>[&], int nbytes<s(0)(0)(0)>[&], int ch<s(0)(0)(0)>[&]);(D1:ch:0)
extern void 	bzero<s(0)(0)(0)>[&] (char *buffer<s(0)(0)(0)>[&], int nbytes<s(0)(0)(0)>[&]);(D1:nbytes:0)
extern int 	bcmp<s(0)(0)(0)>[&] (char *buf1<s(0)(0)(0)>[&], char *buf2<s(0)(0)(0)>[&], int nbytes<s(0)(0)(0)>[&]);(D1:nbytes:0)
extern void 	binvert<s(0)(0)(0)>[&] (char *buf<s(0)(0)(0)>[&], int nbytes<s(0)(0)(0)>[&]);(D1:nbytes:0)
extern void 	bswap<s(0)(0)(0)>[&] (char *buf1<s(0)(0)(0)>[&], char *buf2<s(0)(0)(0)>[&], int nbytes<s(0)(0)(0)>[&]);(D1:nbytes:0)
extern void 	uswab<s(0)(0)(0)>[&] (char *source<s(0)(0)(0)>[&], char *destination<s(0)(0)(0)>[&], int nbytes<s(0)(0)(0)>[&]);(D1:nbytes:0)
extern void 	swab<s(0)(0)(0)>[&] (char *source<s(0)(0)(0)>[&], char *dest<s(0)(0)(0)>[&], int nbytes<s(0)(0)(0)>[&]);(D1:nbytes:0)
extern char *	index<s(0)(0)(0)>[&] (const char *s<s(0)(0)(0)>[&], int c<s(0)(0)(0)>[&]);(D1:c:0)
extern char *	rindex<s(0)(0)(0)>[&] (const char *s<s(0)(0)(0)>[&], int c<s(0)(0)(0)>[&]);(D1:c:0)










 

 

 

































 













	
	
	








 


































 













 
 
 

 



























 











 







































 























 






 




 

 









 




 



 








 



 



 



 





    











                    











                    



                    








 









typedef struct
    {
    int		mBlkNum<s(1)(1)(0)>[&];		 
    int		clBlkNum<s(1)(1)(0)>[&];		 
    char * 	memArea<s(1)(1)(0)>[&];		 
    int		memSize<s(1)(1)(0)>[&];		 
    } M_CL_CONFIG<s(0)(0)(0)>[&];(D1:M_CL_CONFIG:1)[[TYPENAME:M_CL_CONFIG]]

 







typedef struct clDesc<s(1)(0)(1)>[&]
    {
    int		clSize<s(1)(1)(0)>[&];			 
    int		clNum<s(1)(1)(0)>[&];			 
    char *	memArea<s(1)(1)(0)>[&];		 
    int		memSize<s(1)(1)(0)>[&];		 
    } CL_DESC<s(0)(0)(0)>[&];(D1:CL_DESC:1)[[TYPENAME:CL_DESC]] 

 

typedef struct clBuff<s(1)(0)(1)>[&]
    {
    struct clBuff<s(2)(1)(1)>[&] *	pClNext<s(1)(1)(0)>[&]; 	 
    } CL_BUF<s(0)(0)(0)>[&];(D1:CL_BUF:1)[[TYPENAME:CL_BUF]]

typedef CL_BUF<s(0)(0)(0)>[T] * CL_BUF_ID<s(0)(0)(0)>[&];(D1:CL_BUF_ID:1)[[TYPENAME:CL_BUF_ID]] 

 

typedef struct clPool<s(1)(0)(1)>[&]
    {
    int			clSize<s(1)(1)(0)>[&];		 
    int			clLg2<s(1)(1)(0)>[&];		 
    int			clNum<s(1)(1)(0)>[&]; 		 
    int			clNumFree<s(1)(1)(0)>[&]; 	 
    int			clUsage<s(1)(1)(0)>[&];	 
    CL_BUF_ID<s(1)(1)(0)>[T]		pClHead<s(1)(1)(0)>[&];	 
    struct netPool<s(2)(1)(1)>[&] *	pNetPool<s(1)(1)(0)>[&];	 
    } CL_POOL<s(0)(0)(0)>[&];(D1:CL_POOL:1)[[TYPENAME:CL_POOL]] 

typedef CL_POOL<s(0)(0)(0)>[T] * CL_POOL_ID<s(0)(0)(0)>[&];(D1:CL_POOL_ID:1)[[TYPENAME:CL_POOL_ID]] 

 

typedef struct mHdr<s(1)(0)(1)>[&]
    {
    struct mBlk<s(2)(1)(1)>[&] *	mNext<s(1)(1)(0)>[&];		 
    struct mBlk<s(2)(1)(1)>[&] *	mNextPkt<s(1)(1)(0)>[&];	 
    char *		mData<s(1)(1)(0)>[&];		 
    int			mLen<s(1)(1)(0)>[&];		 
    UCHAR<s(1)(1)(0)>[T]		mType<s(1)(1)(0)>[&];		 
    UCHAR<s(1)(1)(0)>[T]		mFlags<s(1)(1)(0)>[&];		 
    USHORT<s(1)(1)(0)>[T]		reserved<s(1)(1)(0)>[&]; 
    } M_BLK_HDR<s(0)(0)(0)>[&];(D1:M_BLK_HDR:1)[[TYPENAME:M_BLK_HDR]]

 

typedef struct	pktHdr<s(1)(0)(1)>[&]
    {
    struct ifnet<s(2)(1)(1)>[&] *	rcvif<s(1)(1)(0)>[&];		 
    int			len<s(1)(1)(0)>[&];		 
    } M_PKT_HDR<s(0)(0)(0)>[&];(D1:M_PKT_HDR:1)[[TYPENAME:M_PKT_HDR]]

typedef union clBlkList<s(1)(0)(1)>[&]
    {
    struct clBlk<s(2)(1)(1)>[&] * 	pClBlkNext<s(1)(1)(0)>[&];	 
    char * 		pClBuf<s(1)(1)(0)>[&];		 
    } CL_BLK_LIST<s(0)(0)(0)>[&];(D1:CL_BLK_LIST:1)[[TYPENAME:CL_BLK_LIST]]
    
 

typedef struct clBlk<s(1)(0)(1)>[&]
    {
    CL_BLK_LIST<s(1)(1)(0)>[T] 	clNode<s(1)(1)(0)>[&];		 
    UINT<s(1)(1)(0)>[T]		clSize<s(1)(1)(0)>[&];		 
    int			clRefCnt<s(1)(1)(0)>[&];	 
    FUNCPTR<s(1)(1)(0)>[T]		pClFreeRtn<s(1)(1)(0)>[&];	 
    int			clFreeArg1<s(1)(1)(0)>[&];	 
    int			clFreeArg2<s(1)(1)(0)>[&];	 
    int			clFreeArg3<s(1)(1)(0)>[&];	 
    struct netPool<s(2)(1)(1)>[&] *	pNetPool<s(1)(1)(0)>[&];	 
    } CL_BLK<s(0)(0)(0)>[&];(D1:CL_BLK:1)[[TYPENAME:CL_BLK]]

 

typedef struct mBlk<s(1)(0)(1)>[&]
    {
    M_BLK_HDR<s(1)(1)(0)>[T] 	mBlkHdr<s(1)(1)(0)>[&]; 		 
    M_PKT_HDR<s(1)(1)(0)>[T]	mBlkPktHdr<s(1)(1)(0)>[&];		 
    CL_BLK<s(1)(1)(0)>[T] *	pClBlk<s(1)(1)(0)>[&];			 
    } M_BLK<s(0)(0)(0)>[&];(D1:M_BLK:1)[[TYPENAME:M_BLK]]

 

typedef struct mbstat<s(1)(0)(1)>[&]
    {
    ULONG<s(1)(1)(0)>[T]	mNum<s(1)(1)(0)>[&];			 
    ULONG<s(1)(1)(0)>[T]	mDrops<s(1)(1)(0)>[&];			 
    ULONG<s(1)(1)(0)>[T]	mWait<s(1)(1)(0)>[&];			 
    ULONG<s(1)(1)(0)>[T]	mDrain<s(1)(1)(0)>[&];			 
    ULONG<s(1)(1)(0)>[T]	mTypes<s(1)(1)(0)>[&][256];		 
    } M_STAT<s(0)(0)(0)>[&];(D1:M_STAT:1)[[TYPENAME:M_STAT]]

typedef M_BLK<s(0)(0)(0)>[T] * 	M_BLK_ID<s(0)(0)(0)>[&];(D1:M_BLK_ID:1)[[TYPENAME:M_BLK_ID]]
typedef CL_BLK<s(0)(0)(0)>[T] *	CL_BLK_ID<s(0)(0)(0)>[&];(D1:CL_BLK_ID:1)[[TYPENAME:CL_BLK_ID]]
typedef struct netPool<s(1)(0)(1)>[&] 	NET_POOL<s(1)(0)(1)>[&];(D1:NET_POOL:1)[[TYPENAME:NET_POOL]]
typedef struct poolFunc<s(1)(0)(1)>[&] POOL_FUNC<s(1)(0)(1)>[&];(D1:POOL_FUNC:1)[[TYPENAME:POOL_FUNC]]
typedef NET_POOL<s(0)(0)(0)>[T] * 	NET_POOL_ID<s(0)(0)(0)>[&];(D1:NET_POOL_ID:1)[[TYPENAME:NET_POOL_ID]]

struct	poolFunc<s(1)(0)(1)>[&]			 
    {
     
    STATUS<s(1)(1)(0)>[T]	(*pInitRtn<s(1)(1)(0)>[&]) (NET_POOL_ID<s(1)(1)(0)>[T] pNetPool<s(1)(1)(0)>[&], M_CL_CONFIG<s(1)(1)(0)>[T] * pMclBlkConfig<s(1)(1)(0)>[&],
                             CL_DESC<s(1)(1)(0)>[T] * pClDescTbl<s(1)(1)(0)>[&], int clDescTblNumEnt<s(1)(1)(0)>[&],
			     BOOL<s(1)(1)(0)>[T] fromKheap<s(1)(1)(0)>[&]);

     
    void	(*pMblkFreeRtn<s(1)(1)(0)>[&]) (NET_POOL_ID<s(1)(1)(0)>[T] pNetPool<s(1)(1)(0)>[&], M_BLK_ID<s(1)(1)(0)>[T] pMblk<s(1)(1)(0)>[&]);

     
    void	(*pClBlkFreeRtn<s(1)(1)(0)>[&]) (CL_BLK_ID<s(1)(1)(0)>[T] pClBlk<s(1)(1)(0)>[&]);

     
    void	(*pClFreeRtn<s(1)(1)(0)>[&]) (NET_POOL_ID<s(1)(1)(0)>[T] pNetPool<s(1)(1)(0)>[&], char * pClBuf<s(1)(1)(0)>[&]);

     
    M_BLK_ID<s(1)(1)(0)>[T] 	(*pMblkClFreeRtn<s(1)(1)(0)>[&]) (NET_POOL_ID<s(1)(1)(0)>[T] pNetPool<s(1)(1)(0)>[&], M_BLK_ID<s(1)(1)(0)>[T] pMblk<s(1)(1)(0)>[&]);

     
    M_BLK_ID<s(1)(1)(0)>[T]	(*pMblkGetRtn<s(1)(1)(0)>[&]) (NET_POOL_ID<s(1)(1)(0)>[T] pNetPool<s(1)(1)(0)>[&], int canWait<s(1)(1)(0)>[&], UCHAR<s(1)(1)(0)>[T] type<s(1)(1)(0)>[&]);

     
    CL_BLK_ID<s(1)(1)(0)>[T]	(*pClBlkGetRtn<s(1)(1)(0)>[&]) (NET_POOL_ID<s(1)(1)(0)>[T] pNetPool<s(1)(1)(0)>[&], int canWait<s(1)(1)(0)>[&]);
    
     
    char *	(*pClGetRtn<s(1)(1)(0)>[&]) (NET_POOL_ID<s(1)(1)(0)>[T] pNetPool<s(1)(1)(0)>[&], CL_POOL_ID<s(1)(1)(0)>[T] pClPool<s(1)(1)(0)>[&]);

     
    STATUS<s(1)(1)(0)>[T]	(*pMblkClGetRtn<s(1)(1)(0)>[&]) (NET_POOL_ID<s(1)(1)(0)>[T] pNetPool<s(1)(1)(0)>[&], M_BLK_ID<s(1)(1)(0)>[T] pMblk<s(1)(1)(0)>[&],
                                  int bufSize<s(1)(1)(0)>[&], int canWait<s(1)(1)(0)>[&], BOOL<s(1)(1)(0)>[T] bestFit<s(1)(1)(0)>[&]);

     
    CL_POOL_ID<s(1)(1)(0)>[T]	(*pClPoolIdGetRtn<s(1)(1)(0)>[&]) (NET_POOL_ID<s(1)(1)(0)>[T] pNetPool<s(1)(1)(0)>[&], int	bufSize<s(1)(1)(0)>[&],
                                    BOOL<s(1)(1)(0)>[T] bestFit<s(1)(1)(0)>[&]);
    };

struct netPool<s(1)(0)(1)>[&]				 
    {
    M_BLK_ID<s(1)(1)(0)>[T]	pmBlkHead<s(1)(1)(0)>[&];		 
    CL_BLK_ID<s(1)(1)(0)>[T]	pClBlkHead<s(1)(1)(0)>[&];		 
    int		mBlkCnt<s(1)(1)(0)>[&];		 
    int		mBlkFree<s(1)(1)(0)>[&];		 


    int		clMask<s(1)(1)(0)>[&];			 
    int		clLg2Max<s(1)(1)(0)>[&];		 
    int		clSizeMax<s(1)(1)(0)>[&];		 
    int		clLg2Min<s(1)(1)(0)>[&];		 
    int		clSizeMin<s(1)(1)(0)>[&];		 
    CL_POOL<s(1)(1)(0)>[T] * 	clTbl<s(1)(1)(0)>[&] [((16   - 6  )  + 1) ];	 
    M_STAT<s(1)(1)(0)>[T] *	pPoolStat<s(1)(1)(0)>[&];		 
    POOL_FUNC<s(1)(1)(0)>[T] *	pFuncTbl<s(1)(1)(0)>[&];		 
    };

                     
                    
extern  STATUS<s(0)(0)(0)>[T] 		netBufLibInit<s(0)(0)(0)>[&] (void);(D1:netBufLibInit:0)
extern  STATUS<s(0)(0)(0)>[T] 		netPoolInit<s(0)(0)(0)>[&] (NET_POOL_ID<s(0)(0)(0)>[T] pNetPool<s(0)(0)(0)>[&],
                                     M_CL_CONFIG<s(0)(0)(0)>[T] * pMclBlkConfig<s(0)(0)(0)>[&],
                                     CL_DESC<s(0)(0)(0)>[T] * pClDescTbl<s(0)(0)(0)>[&], int clDescTblNumEnt<s(0)(0)(0)>[&],
                                     POOL_FUNC<s(0)(0)(0)>[T] * pFuncTbl<s(0)(0)(0)>[&]);(D1:pFuncTbl:0)
extern  STATUS<s(0)(0)(0)>[T]		netPoolDelete<s(0)(0)(0)>[&] (NET_POOL_ID<s(0)(0)(0)>[T]);(D1:NET_POOL_ID:0)
extern  void		netMblkFree<s(0)(0)(0)>[&] (NET_POOL_ID<s(0)(0)(0)>[T] pNetPool<s(0)(0)(0)>[&], M_BLK_ID<s(0)(0)(0)>[T] pMblk<s(0)(0)(0)>[&]);(D1:pMblk:0)
extern  void		netClBlkFree<s(0)(0)(0)>[&] (NET_POOL_ID<s(0)(0)(0)>[T] pNetPool<s(0)(0)(0)>[&], CL_BLK_ID<s(0)(0)(0)>[T] pClBlk<s(0)(0)(0)>[&]);(D1:pClBlk:0)
extern  void 		netClFree<s(0)(0)(0)>[&] (NET_POOL_ID<s(0)(0)(0)>[T] pNetPool<s(0)(0)(0)>[&], UCHAR<s(0)(0)(0)>[T] * pClBuf<s(0)(0)(0)>[&]);(D1:pClBuf:0)
extern  M_BLK_ID<s(0)(0)(0)>[T] 	netMblkClFree<s(0)(0)(0)>[&] (M_BLK_ID<s(0)(0)(0)>[T] pMblk<s(0)(0)(0)>[&]);(D1:pMblk:0)
extern  void		netMblkClChainFree<s(0)(0)(0)>[&] (M_BLK_ID<s(0)(0)(0)>[T] pMblk<s(0)(0)(0)>[&]);(D1:pMblk:0)
extern  M_BLK_ID<s(0)(0)(0)>[T] 	netMblkGet<s(0)(0)(0)>[&] (NET_POOL_ID<s(0)(0)(0)>[T] pNetPool<s(0)(0)(0)>[&], int canWait<s(0)(0)(0)>[&],
                                    UCHAR<s(0)(0)(0)>[T] type<s(0)(0)(0)>[&]);(D1:type:0)
extern  CL_BLK_ID<s(0)(0)(0)>[T]	netClBlkGet<s(0)(0)(0)>[&] (NET_POOL_ID<s(0)(0)(0)>[T] pNetPool<s(0)(0)(0)>[&], int canWait<s(0)(0)(0)>[&]);(D1:canWait:0)
extern  char *	 	netClusterGet<s(0)(0)(0)>[&] (NET_POOL_ID<s(0)(0)(0)>[T] pNetPool<s(0)(0)(0)>[&],
                                       CL_POOL_ID<s(0)(0)(0)>[T] pClPool<s(0)(0)(0)>[&]);(D1:pClPool:0)
extern  STATUS<s(0)(0)(0)>[T] 	 	netMblkClGet<s(0)(0)(0)>[&] (NET_POOL_ID<s(0)(0)(0)>[T] pNetPool<s(0)(0)(0)>[&], M_BLK_ID<s(0)(0)(0)>[T] pMblk<s(0)(0)(0)>[&],
                                      int bufSize<s(0)(0)(0)>[&], int canWait<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bestFit<s(0)(0)(0)>[&]);(D1:bestFit:0)
extern  M_BLK_ID<s(0)(0)(0)>[T] 	netTupleGet<s(0)(0)(0)>[&] (NET_POOL_ID<s(0)(0)(0)>[T] pNetPool<s(0)(0)(0)>[&], int bufSize<s(0)(0)(0)>[&],
                                     int canWait<s(0)(0)(0)>[&], UCHAR<s(0)(0)(0)>[T] type<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bestFit<s(0)(0)(0)>[&]);(D1:bestFit:0)

extern  M_BLK_ID<s(0)(0)(0)>[T] 	netTupleGet2<s(0)(0)(0)>[&] (NET_POOL_ID<s(0)(0)(0)>[T], int, int);(D1:NET_POOL_ID:0)

extern  CL_BLK_ID<s(0)(0)(0)>[T]  	netClBlkJoin<s(0)(0)(0)>[&] (CL_BLK_ID<s(0)(0)(0)>[T] pClBlk<s(0)(0)(0)>[&], char * pClBuf<s(0)(0)(0)>[&],
                                      int size<s(0)(0)(0)>[&], FUNCPTR<s(0)(0)(0)>[T] pFreeRtn<s(0)(0)(0)>[&], int arg1<s(0)(0)(0)>[&],
                                      int arg2<s(0)(0)(0)>[&], int arg3<s(0)(0)(0)>[&]);(D1:arg3:0)
extern  M_BLK_ID<s(0)(0)(0)>[T]  	netMblkClJoin<s(0)(0)(0)>[&] (M_BLK_ID<s(0)(0)(0)>[T] pMblk<s(0)(0)(0)>[&], CL_BLK_ID<s(0)(0)(0)>[T] pClBlk<s(0)(0)(0)>[&]);(D1:pClBlk:0)
extern  CL_POOL_ID<s(0)(0)(0)>[T] 	netClPoolIdGet<s(0)(0)(0)>[&] (NET_POOL_ID<s(0)(0)(0)>[T] pNetPool<s(0)(0)(0)>[&], int bufSize<s(0)(0)(0)>[&],
                                        BOOL<s(0)(0)(0)>[T] bestFit<s(0)(0)(0)>[&]);(D1:bestFit:0)

extern  int 		netMblkToBufCopy<s(0)(0)(0)>[&] (M_BLK_ID<s(0)(0)(0)>[T] pMblk<s(0)(0)(0)>[&], char * pBuf<s(0)(0)(0)>[&],
                                          FUNCPTR<s(0)(0)(0)>[T] pCopyRtn<s(0)(0)(0)>[&]);(D1:pCopyRtn:0)
extern  int		netMblkOffsetToBufCopy<s(0)(0)(0)>[&] (M_BLK_ID<s(0)(0)(0)>[T] pMblk<s(0)(0)(0)>[&], int offset<s(0)(0)(0)>[&],
                                                char * pBuf<s(0)(0)(0)>[&], int len<s(0)(0)(0)>[&],
                                                FUNCPTR<s(0)(0)(0)>[T]	pCopyRtn<s(0)(0)(0)>[&]);(D1:pCopyRtn:0)
extern  M_BLK_ID<s(0)(0)(0)>[T] 	netMblkDup<s(0)(0)(0)>[&] (M_BLK_ID<s(0)(0)(0)>[T] pSrcMblk<s(0)(0)(0)>[&], M_BLK_ID<s(0)(0)(0)>[T]	pDestMblk<s(0)(0)(0)>[&]);(D1:pDestMblk:0)
extern  M_BLK_ID<s(0)(0)(0)>[T] 	netMblkChainDup<s(0)(0)(0)>[&] (NET_POOL_ID<s(0)(0)(0)>[T] pNetPool<s(0)(0)(0)>[&], M_BLK_ID<s(0)(0)(0)>[T]	pMblk<s(0)(0)(0)>[&],
                                         int offset<s(0)(0)(0)>[&], int len<s(0)(0)(0)>[&], int canWait<s(0)(0)(0)>[&]);(D1:canWait:0)

















 























 



 


 













 





 





 





 





 






 










 










 








 















 

 












 






















        




    
 















 

extern  struct mbstat<s(1)(0)(1)>[&] 	mbstat<s(1)(0)(1)>[&];(D1:mbstat:0)			 
extern  M_CL_CONFIG<s(0)(0)(0)>[T]	mClBlkConfig<s(0)(0)(0)>[&];(D1:mClBlkConfig:0)		 
extern  CL_DESC<s(0)(0)(0)>[T] 		clDescTbl<s(0)(0)(0)>[&] [];(D1:clDescTbl:0)		 
extern  int		clDescTblNumEnt<s(0)(0)(0)>[&];(D1:clDescTblNumEnt:0) 	 
extern  M_CL_CONFIG<s(0)(0)(0)>[T]	sysMclBlkConfig<s(0)(0)(0)>[&];(D1:sysMclBlkConfig:0)	 
extern  CL_DESC<s(0)(0)(0)>[T] 		sysClDescTbl<s(0)(0)(0)>[&] [];(D1:sysClDescTbl:0)	 
extern  int		sysClDescTblNumEnt<s(0)(0)(0)>[&];(D1:sysClDescTblNumEnt:0) 	 


extern  NET_POOL_ID<s(0)(0)(0)>[T]	_pNetDpool<s(0)(0)(0)>[&];(D1:_pNetDpool:0)		 
extern  NET_POOL_ID<s(0)(0)(0)>[T]	_pNetSysPool<s(0)(0)(0)>[&];(D1:_pNetSysPool:0)		 


 

extern int max_linkhdr<s(0)(0)(0)>[&];(D1:max_linkhdr:0)		 
extern int max_protohdr<s(0)(0)(0)>[&];(D1:max_protohdr:0)	 
extern int max_hdr<s(0)(0)(0)>[&];(D1:max_hdr:0)		 
extern int max_datalen<s(0)(0)(0)>[&];(D1:max_datalen:0)		 

extern struct	mBlk<s(1)(0)(1)>[&]  * netMblkClFree<s(0)(0)(0)>[&]( struct mBlk<s(1)(0)(1)>[&]  * ) ;(D1:mBlk:0)
extern struct	mBlk<s(1)(0)(1)>[&]  *m_getclr<s(0)(0)(0)>[&] (int, UCHAR<s(0)(0)(0)>[T], int, BOOL<s(0)(0)(0)>[T]);(D1:BOOL:0)
extern struct	mBlk<s(1)(0)(1)>[&]  *m_prepend<s(0)(0)(0)>[&] (struct mBlk<s(1)(0)(1)>[&]  *, int, int);(D1:mBlk:0)
extern struct	mBlk<s(1)(0)(1)>[&]  *m_pullup<s(0)(0)(0)>[&] (struct mBlk<s(1)(0)(1)>[&]  *, int);(D1:mBlk:0)
extern void	m_adj<s(0)(0)(0)>[&] (struct mBlk<s(1)(0)(1)>[&]  *, int);(D1:mBlk:0)
extern void	netMblkClChainFree<s(0)(0)(0)>[&]( struct mBlk<s(1)(0)(1)>[&]  * ) ;(D1:mBlk:0)
extern void 	m_cat<s(0)(0)(0)>[&] (struct mBlk<s(1)(0)(1)>[&]  *, struct mBlk<s(1)(0)(1)>[&]  *);(D1:mBlk:0)
extern struct 	mBlk<s(1)(0)(1)>[&]  *m_devget<s(0)(0)(0)>[&] (char *, int, int, struct ifnet<s(1)(0)(1)>[&] *,
				void (*copy<s(0)(0)(0)>[&])());(D1:copy:0)
struct mBlk<s(1)(0)(1)>[&]  *	mBufClGet<s(0)(0)(0)>[&] (int, UCHAR<s(0)(0)(0)>[T], register  int, BOOL<s(0)(0)(0)>[T]);(D1:BOOL:0) 
struct mBlk<s(1)(0)(1)>[&]  * 	mHdrClGet<s(0)(0)(0)>[&] (int, UCHAR<s(0)(0)(0)>[T], register  int, BOOL<s(0)(0)(0)>[T]);(D1:BOOL:0) 

extern  struct mBlk<s(1)(0)(1)>[&]  * bcopy_to_mbufs<s(0)(0)(0)>[&] (u_char<s(0)(0)(0)>[T] * buf<s(0)(0)(0)>[&], int totlen<s(0)(0)(0)>[&], int off0<s(0)(0)(0)>[&],
                                     struct ifnet<s(1)(0)(1)>[&] * ifp<s(0)(0)(0)>[&], int width<s(0)(0)(0)>[&]);(D1:width:0)
extern  struct mBlk<s(1)(0)(1)>[&]  * build_cluster<s(0)(0)(0)>[&] (u_char<s(0)(0)(0)>[T] * buf<s(0)(0)(0)>[&], int totlen<s(0)(0)(0)>[&],
                                    struct ifnet<s(1)(0)(1)>[&] * ifp<s(0)(0)(0)>[&], u_char<s(0)(0)(0)>[T] ctype<s(0)(0)(0)>[&],
                                    u_char<s(0)(0)(0)>[T] * pRefcnt<s(0)(0)(0)>[&], FUNCPTR<s(0)(0)(0)>[T] freeRtn<s(0)(0)(0)>[&],
                                    int arg1<s(0)(0)(0)>[&], int arg2<s(0)(0)(0)>[&], int arg3<s(0)(0)(0)>[&]);(D1:arg3:0)
extern  int	copyFromMbufs<s(0)(0)(0)>[&] (char * pIobuf<s(0)(0)(0)>[&], struct mBlk<s(1)(0)(1)>[&]  * pMbuf<s(0)(0)(0)>[&], int width<s(0)(0)(0)>[&]);(D1:width:0)












 






struct socket<s(1)(0)(1)>[&]
    {
    short	so_type<s(1)(1)(0)>[&];		 
    short	so_options<s(1)(1)(0)>[&];		 
    short	so_linger<s(1)(1)(0)>[&];		 
    short	so_state<s(1)(1)(0)>[&];		 
    caddr_t<s(1)(1)(0)>[T]	so_pcb<s(1)(1)(0)>[&];			 
    struct	protosw<s(2)(1)(1)>[&] *so_proto<s(1)(1)(0)>[&];	 

     



    int		so_userArg<s(1)(1)(0)>[&];		 
    SEM_ID<s(1)(1)(0)>[T]	so_timeoSem<s(1)(1)(0)>[&];		 
    int		so_fd<s(1)(1)(0)>[&];			 

     











    struct	socket<s(2)(1)(1)>[&] *so_head<s(1)(1)(0)>[&];	 
    struct	socket<s(2)(1)(1)>[&] *so_q0<s(1)(1)(0)>[&];		 
    struct	socket<s(2)(1)(1)>[&] *so_q<s(1)(1)(0)>[&];		 
    short	so_q0len<s(1)(1)(0)>[&];		 
    short	so_qlen<s(1)(1)(0)>[&];		 
    short	so_qlimit<s(1)(1)(0)>[&];		 
    short	so_timeo<s(1)(1)(0)>[&];		 
    u_short<s(1)(1)(0)>[T]	so_error<s(1)(1)(0)>[&];		 
    short	so_pgrp<s(1)(1)(0)>[&];		 
    u_long<s(1)(1)(0)>[T]	so_oobmark<s(1)(1)(0)>[&];		 

     

    struct	sockbuf<s(2)(1)(1)>[&]
	{
	u_long<s(2)(1)(0)>[T]		sb_cc<s(2)(1)(0)>[&];		 
	u_long<s(2)(1)(0)>[T]		sb_hiwat<s(2)(1)(0)>[&];	 
	u_long<s(2)(1)(0)>[T]		sb_mbcnt<s(2)(1)(0)>[&];	 
	u_long<s(2)(1)(0)>[T]		sb_mbmax<s(2)(1)(0)>[&];	 
	u_long<s(2)(1)(0)>[T]		sb_lowat<s(2)(1)(0)>[&];	 
	struct		mBlk<s(3)(1)(1)>[&]  *sb_mb<s(2)(1)(0)>[&];	 
	struct		proc<s(3)(1)(1)>[&] *sb_sel<s(2)(1)(0)>[&];	 
	short		sb_timeo<s(2)(1)(0)>[&];	 
	short		sb_flags<s(2)(1)(0)>[&];	 

	SEM_ID<s(2)(1)(0)>[T]		sb_Sem<s(2)(1)(0)>[&];		 
	int		sb_want<s(2)(1)(0)>[&];	 
	} so_rcv<s(1)(0)(0)>[&], so_snd<s(1)(0)(0)>[&];










    void	(*so_upcall<s(1)(0)(0)>[&]) (struct socket<s(2)(0)(1)>[&] *so<s(1)(0)(0)>[&], caddr_t<s(1)(0)(0)>[T] arg<s(1)(0)(0)>[&], int waitf<s(1)(0)(0)>[&]);
    caddr_t<s(1)(0)(0)>[T]	so_upcallarg<s(1)(0)(0)>[&];		 
    BOOL<s(1)(0)(0)>[T] 	selectFlag<s(1)(0)(0)>[&]; 		 
    SEL_WAKEUP_LIST<s(1)(0)(0)>[T] so_selWakeupList<s(1)(0)(0)>[&];  
    int         vsid<s(1)(0)(0)>[&];                  
    };






 















 



 









 



 





 







 







 







 








 















extern  VOIDFUNCPTR<s(0)(0)(0)>[T] sowakeupHook<s(0)(0)(0)>[&];(D1:sowakeupHook:0)

extern u_long<s(0)(0)(0)>[T]	sb_max<s(0)(0)(0)>[&];(D1:sb_max:0)

 


 
extern	char netio<s(0)(0)(0)>[&][],(D1:netio:0) netcon<s(0)(0)(0)>[&][],(D1:netcon:0) netcls<s(0)(0)(0)>[&][];(D1:netcls:0)

 


extern int soo_ioctl<s(0)(0)(0)>[&] (struct socket<s(1)(0)(1)>[&] * so<s(0)(0)(0)>[&], int cmd<s(0)(0)(0)>[&], caddr_t<s(0)(0)(0)>[T] data<s(0)(0)(0)>[&]);(D1:data:0)
extern int soo_select<s(0)(0)(0)>[&] (struct socket<s(1)(0)(1)>[&] *so<s(0)(0)(0)>[&], SEL_WAKEUP_NODE<s(0)(0)(0)>[T] *wakeupNode<s(0)(0)(0)>[&]);(D1:wakeupNode:0)
extern int soo_unselect<s(0)(0)(0)>[&] (struct socket<s(1)(0)(1)>[&] *so<s(0)(0)(0)>[&], SEL_WAKEUP_NODE<s(0)(0)(0)>[T] *wakeupNode<s(0)(0)(0)>[&]);(D1:wakeupNode:0) 

struct mBlk<s(1)(0)(1)>[&] ;
struct sockaddr<s(1)(0)(1)>[&];

extern void	sbappend<s(0)(0)(0)>[&] (struct sockbuf<s(1)(0)(1)>[&] *sb<s(0)(0)(0)>[&], struct mBlk<s(1)(0)(1)>[&]  *m<s(0)(0)(0)>[&]);(D1:m:0)
extern int	sbappendaddr<s(0)(0)(0)>[&] (struct sockbuf<s(1)(0)(1)>[&] *sb<s(0)(0)(0)>[&], struct sockaddr<s(1)(0)(1)>[&] *asa<s(0)(0)(0)>[&],
	    struct mBlk<s(1)(0)(1)>[&]  *m0<s(0)(0)(0)>[&], struct mBlk<s(1)(0)(1)>[&]  *control<s(0)(0)(0)>[&]);(D1:control:0)
extern int	sbappendcontrol<s(0)(0)(0)>[&] (struct sockbuf<s(1)(0)(1)>[&] *sb<s(0)(0)(0)>[&], struct mBlk<s(1)(0)(1)>[&]  *m0<s(0)(0)(0)>[&],
	    struct mBlk<s(1)(0)(1)>[&]  *control<s(0)(0)(0)>[&]);(D1:control:0)
extern void	sbappendrecord<s(0)(0)(0)>[&] (struct sockbuf<s(1)(0)(1)>[&] *sb<s(0)(0)(0)>[&], struct mBlk<s(1)(0)(1)>[&]  *m0<s(0)(0)(0)>[&]);(D1:m0:0)
extern void	sbcheck<s(0)(0)(0)>[&] (struct sockbuf<s(1)(0)(1)>[&] *sb<s(0)(0)(0)>[&]);(D1:sb:0)
extern void	sbcompress<s(0)(0)(0)>[&] (struct sockbuf<s(1)(0)(1)>[&] *sb<s(0)(0)(0)>[&], struct mBlk<s(1)(0)(1)>[&]  *m<s(0)(0)(0)>[&], struct mBlk<s(1)(0)(1)>[&]  *n<s(0)(0)(0)>[&]);(D1:n:0)
extern void	sbdrop<s(0)(0)(0)>[&] (struct sockbuf<s(1)(0)(1)>[&] *sb<s(0)(0)(0)>[&], int len<s(0)(0)(0)>[&]);(D1:len:0)
extern void	sbdroprecord<s(0)(0)(0)>[&] (struct sockbuf<s(1)(0)(1)>[&] *sb<s(0)(0)(0)>[&]);(D1:sb:0)
extern void	sbflush<s(0)(0)(0)>[&] (struct sockbuf<s(1)(0)(1)>[&] *sb<s(0)(0)(0)>[&]);(D1:sb:0)
extern void	sbinsertoob<s(0)(0)(0)>[&] (struct sockbuf<s(1)(0)(1)>[&] *sb<s(0)(0)(0)>[&], struct mBlk<s(1)(0)(1)>[&]  *m0<s(0)(0)(0)>[&]);(D1:m0:0)
extern void	sbrelease<s(0)(0)(0)>[&] (struct sockbuf<s(1)(0)(1)>[&] *sb<s(0)(0)(0)>[&]);(D1:sb:0)
extern int	sbreserve<s(0)(0)(0)>[&] (struct sockbuf<s(1)(0)(1)>[&] *sb<s(0)(0)(0)>[&], u_long<s(0)(0)(0)>[T] cc<s(0)(0)(0)>[&]);(D1:cc:0)
extern void	sbwait<s(0)(0)(0)>[&] (struct sockbuf<s(1)(0)(1)>[&] *sb<s(0)(0)(0)>[&]);(D1:sb:0)
extern void	sbwakeup<s(0)(0)(0)>[&](struct socket<s(1)(0)(1)>[&] *so<s(0)(0)(0)>[&], struct sockbuf<s(1)(0)(1)>[&] *sb<s(0)(0)(0)>[&],
			 SELECT_TYPE<s(0)(0)(0)>[T] wakeupType<s(0)(0)(0)>[&]);(D1:wakeupType:0)
extern int	sb_lock<s(0)(0)(0)>[&] (struct sockbuf<s(1)(0)(1)>[&] *sb<s(0)(0)(0)>[&]);(D1:sb:0)
extern int	soabort<s(0)(0)(0)>[&] (struct socket<s(1)(0)(1)>[&] *so<s(0)(0)(0)>[&]);(D1:so:0)
extern int	soaccept<s(0)(0)(0)>[&] (struct socket<s(1)(0)(1)>[&] *so<s(0)(0)(0)>[&], struct mBlk<s(1)(0)(1)>[&]  *nam<s(0)(0)(0)>[&]);(D1:nam:0)
extern int	sobind<s(0)(0)(0)>[&] (struct socket<s(1)(0)(1)>[&] *so<s(0)(0)(0)>[&], struct mBlk<s(1)(0)(1)>[&]  *nam<s(0)(0)(0)>[&]);(D1:nam:0)
extern void	socantrcvmore<s(0)(0)(0)>[&] (struct socket<s(1)(0)(1)>[&] *so<s(0)(0)(0)>[&]);(D1:so:0)
extern void	socantsendmore<s(0)(0)(0)>[&] (struct socket<s(1)(0)(1)>[&] *so<s(0)(0)(0)>[&]);(D1:so:0)
extern int	soclose<s(0)(0)(0)>[&] (struct socket<s(1)(0)(1)>[&] *so<s(0)(0)(0)>[&]);(D1:so:0)
extern int	soconnect<s(0)(0)(0)>[&] (struct socket<s(1)(0)(1)>[&] *so<s(0)(0)(0)>[&], struct mBlk<s(1)(0)(1)>[&]  *nam<s(0)(0)(0)>[&]);(D1:nam:0)
extern int	soconnect2<s(0)(0)(0)>[&] (struct socket<s(1)(0)(1)>[&] *so1<s(0)(0)(0)>[&], struct socket<s(1)(0)(1)>[&] *so2<s(0)(0)(0)>[&]);(D1:so2:0)
extern int	socreate<s(0)(0)(0)>[&] (int dom<s(0)(0)(0)>[&], struct socket<s(1)(0)(1)>[&] **aso<s(0)(0)(0)>[&], int type<s(0)(0)(0)>[&], int proto<s(0)(0)(0)>[&]);(D1:proto:0)
extern int	sodisconnect<s(0)(0)(0)>[&] (struct socket<s(1)(0)(1)>[&] *so<s(0)(0)(0)>[&]);(D1:so:0)
extern void	sofree<s(0)(0)(0)>[&] (struct socket<s(1)(0)(1)>[&] *so<s(0)(0)(0)>[&]);(D1:so:0)
extern int	sogetopt<s(0)(0)(0)>[&] (struct socket<s(1)(0)(1)>[&] *so<s(0)(0)(0)>[&], int level<s(0)(0)(0)>[&], int optname<s(0)(0)(0)>[&],
	    struct mBlk<s(1)(0)(1)>[&]  **mp<s(0)(0)(0)>[&]);(D1:mp:0)
extern void	sohasoutofband<s(0)(0)(0)>[&] (struct socket<s(1)(0)(1)>[&] *so<s(0)(0)(0)>[&]);(D1:so:0)
extern void	soisconnected<s(0)(0)(0)>[&] (struct socket<s(1)(0)(1)>[&] *so<s(0)(0)(0)>[&]);(D1:so:0)
extern void	soisconnecting<s(0)(0)(0)>[&] (struct socket<s(1)(0)(1)>[&] *so<s(0)(0)(0)>[&]);(D1:so:0)
extern void	soisdisconnected<s(0)(0)(0)>[&] (struct socket<s(1)(0)(1)>[&] *so<s(0)(0)(0)>[&]);(D1:so:0)
extern void	soisdisconnecting<s(0)(0)(0)>[&] (struct socket<s(1)(0)(1)>[&] *so<s(0)(0)(0)>[&]);(D1:so:0)
extern int	solisten<s(0)(0)(0)>[&] (struct socket<s(1)(0)(1)>[&] *so<s(0)(0)(0)>[&], int backlog<s(0)(0)(0)>[&]);(D1:backlog:0)
extern struct socket<s(1)(0)(1)>[&] *
	sonewconn1<s(0)(0)(0)>[&] (struct socket<s(1)(0)(1)>[&] *head<s(0)(0)(0)>[&], int connstatus<s(0)(0)(0)>[&]);(D1:connstatus:0)
extern void	soqinsque<s(0)(0)(0)>[&] (struct socket<s(1)(0)(1)>[&] *head<s(0)(0)(0)>[&], struct socket<s(1)(0)(1)>[&] *so<s(0)(0)(0)>[&], int q<s(0)(0)(0)>[&]);(D1:q:0)
extern int	soqremque<s(0)(0)(0)>[&] (struct socket<s(1)(0)(1)>[&] *so<s(0)(0)(0)>[&], int q<s(0)(0)(0)>[&]);(D1:q:0)
extern int	soreceive<s(0)(0)(0)>[&] (struct socket<s(1)(0)(1)>[&] *so<s(0)(0)(0)>[&], struct mBlk<s(1)(0)(1)>[&]  **paddr<s(0)(0)(0)>[&], 
			   struct uio<s(1)(0)(1)>[&] *pUio<s(0)(0)(0)>[&], struct mBlk<s(1)(0)(1)>[&]  **mp0<s(0)(0)(0)>[&], struct mBlk<s(1)(0)(1)>[&]  **
			   controlp<s(0)(0)(0)>[&], int *flagsp<s(0)(0)(0)>[&]);(D1:flagsp:0)
extern int	soreserve<s(0)(0)(0)>[&] (struct socket<s(1)(0)(1)>[&] *so<s(0)(0)(0)>[&], u_long<s(0)(0)(0)>[T] sndcc<s(0)(0)(0)>[&], u_long<s(0)(0)(0)>[T] rcvcc<s(0)(0)(0)>[&]);(D1:rcvcc:0)
extern void	sorflush<s(0)(0)(0)>[&] (struct socket<s(1)(0)(1)>[&] *so<s(0)(0)(0)>[&]);(D1:so:0)
extern int	sosend<s(0)(0)(0)>[&] (struct socket<s(1)(0)(1)>[&] *so<s(0)(0)(0)>[&], struct mBlk<s(1)(0)(1)>[&]  *addr<s(0)(0)(0)>[&], struct uio<s(1)(0)(1)>[&] *uio<s(0)(0)(0)>[&],
	    struct mBlk<s(1)(0)(1)>[&]  *top<s(0)(0)(0)>[&], struct mBlk<s(1)(0)(1)>[&]  *control<s(0)(0)(0)>[&], int flags<s(0)(0)(0)>[&]);(D1:flags:0)
extern int	sosetopt<s(0)(0)(0)>[&] (struct socket<s(1)(0)(1)>[&] *so<s(0)(0)(0)>[&], int level<s(0)(0)(0)>[&], int optname<s(0)(0)(0)>[&],
	    struct mBlk<s(1)(0)(1)>[&]  *m0<s(0)(0)(0)>[&]);(D1:m0:0)
extern int	soshutdown<s(0)(0)(0)>[&] (struct socket<s(1)(0)(1)>[&] *so<s(0)(0)(0)>[&], int how<s(0)(0)(0)>[&]);(D1:how:0)
extern void	sowakeup<s(0)(0)(0)>[&] (struct socket<s(1)(0)(1)>[&] *so<s(0)(0)(0)>[&], struct sockbuf<s(1)(0)(1)>[&] *sb<s(0)(0)(0)>[&], 
			  SELECT_TYPE<s(0)(0)(0)>[T] wakeupType<s(0)(0)(0)>[&]);(D1:wakeupType:0)







 

 

 


































 






















 



struct radix_node<s(1)(0)(1)>[&] {
	struct	radix_mask<s(2)(1)(1)>[&] *rn_mklist<s(1)(1)(0)>[&];	 
	struct	radix_node<s(2)(1)(1)>[&] *rn_p<s(1)(1)(0)>[&];	 
	short	rn_b<s(1)(1)(0)>[&];			 
	char	rn_bmask<s(1)(1)(0)>[&];		 
	u_char<s(1)(1)(0)>[T]	rn_flags<s(1)(1)(0)>[&];		 




	union {
		struct {			 
			caddr_t<s(3)(1)(0)>[T]	rn_Key<s(3)(1)(0)>[&];	 
			caddr_t<s(3)(1)(0)>[T]	rn_Mask<s(3)(1)(0)>[&];	 
			struct	radix_node<s(4)(1)(1)>[&] *rn_Dupedkey<s(3)(1)(0)>[&];
		} rn_leaf<s(2)(0)(0)>[&];
		struct {			 
			int	rn_Off<s(3)(1)(0)>[&];		 
			struct	radix_node<s(4)(1)(1)>[&] *rn_L<s(3)(1)(0)>[&]; 
			struct	radix_node<s(4)(1)(1)>[&] *rn_R<s(3)(1)(0)>[&]; 
		}rn_node<s(2)(0)(0)>[&];
	}		rn_u<s(1)(0)(0)>[&];





};








 



extern struct radix_mask<s(1)(0)(1)>[&] {
	short	rm_b<s(1)(1)(0)>[&];			 
	char	rm_unused<s(1)(1)(0)>[&];		 
	u_char<s(1)(1)(0)>[T]	rm_flags<s(1)(1)(0)>[&];		 
	struct	radix_mask<s(2)(1)(1)>[&] *rm_mklist<s(1)(1)(0)>[&];	 
	union	{
		caddr_t<s(2)(1)(0)>[T]	rmu_mask<s(2)(1)(0)>[&];		 
		struct	radix_node<s(3)(1)(1)>[&] *rmu_leaf<s(2)(1)(0)>[&];	 
	}	rm_rmu<s(1)(0)(0)>[&];
	int	rm_refs<s(1)(0)(0)>[&];		 
} *rn_mkfreelist<s(0)(0)(0)>[&];(D1:rn_mkfreelist:0)













struct radix_node_head<s(1)(0)(1)>[&] {
	struct	radix_node<s(2)(1)(1)>[&] *rnh_treetop<s(1)(1)(0)>[&];
	int	rnh_addrsize<s(1)(1)(0)>[&];		 
	int	rnh_pktsize<s(1)(1)(0)>[&];		 
	struct	radix_node<s(2)(1)(1)>[&] *(*rnh_addaddr<s(1)(1)(0)>[&])	 
		(void *v<s(1)(1)(0)>[&], void *mask<s(1)(1)(0)>[&],
		     struct radix_node_head<s(2)(1)(1)>[&] *head<s(1)(1)(0)>[&], struct radix_node<s(2)(1)(1)>[&] nodes<s(2)(1)(1)>[&][]);
	struct	radix_node<s(2)(1)(1)>[&] *(*rnh_addpkt<s(1)(1)(0)>[&])	 
		(void *v<s(1)(1)(0)>[&], void *mask<s(1)(1)(0)>[&],
		     struct radix_node_head<s(2)(1)(1)>[&] *head<s(1)(1)(0)>[&], struct radix_node<s(2)(1)(1)>[&] nodes<s(2)(1)(1)>[&][]);
	struct	radix_node<s(2)(1)(1)>[&] *(*rnh_deladdr<s(1)(1)(0)>[&])	 
		(void *v<s(1)(1)(0)>[&], void *mask<s(1)(1)(0)>[&], struct radix_node_head<s(2)(1)(1)>[&] *head<s(1)(1)(0)>[&]);
	struct	radix_node<s(2)(1)(1)>[&] *(*rnh_delpkt<s(1)(1)(0)>[&])	 
		(void *v<s(1)(1)(0)>[&], void *mask<s(1)(1)(0)>[&], struct radix_node_head<s(2)(1)(1)>[&] *head<s(1)(1)(0)>[&]);
	struct	radix_node<s(2)(1)(1)>[&] *(*rnh_matchaddr<s(1)(1)(0)>[&])	 
		(void *v<s(1)(1)(0)>[&], struct radix_node_head<s(2)(1)(1)>[&] *head<s(1)(1)(0)>[&], int);
        struct  radix_node<s(2)(1)(1)>[&] *(*rnh_lookup<s(1)(1)(0)>[&])        
                (void *v<s(1)(1)(0)>[&], void *mask<s(1)(1)(0)>[&], struct radix_node_head<s(2)(1)(1)>[&] *head<s(1)(1)(0)>[&]);
	struct	radix_node<s(2)(1)(1)>[&] *(*rnh_matchpkt<s(1)(1)(0)>[&])	 
		(void *v<s(1)(1)(0)>[&], struct radix_node_head<s(2)(1)(1)>[&] *head<s(1)(1)(0)>[&]);
	int	(*rnh_walktree<s(1)(1)(0)>[&])			 
		(struct radix_node_head<s(2)(1)(1)>[&] *head<s(1)(1)(0)>[&], int (*f<s(1)(1)(0)>[&])(), void *w<s(1)(1)(0)>[&]);
	struct	radix_node<s(2)(1)(1)>[&] rnh_nodes<s(2)(1)(1)>[&][3];	 
};















void	 rn_init<s(0)(0)(0)>[&] (void);(D1:rn_init:0)

int	 rn_inithead<s(0)(0)(0)>[&] (struct radix_node_head<s(1)(0)(1)>[&] **, int);(D1:radix_node_head:0)
int	 rn_destroyhead<s(0)(0)(0)>[&] (struct radix_node_head<s(1)(0)(1)>[&] *);(D1:radix_node_head:0)
int	 rn_refines<s(0)(0)(0)>[&] (void *, void *);(D1:rn_refines:0)
int	 rn_walksubtree<s(0)(0)(0)>[&] (struct radix_node_head<s(1)(0)(1)>[&] *, void *, void *,
                         int (*)(), void *);(D1:radix_node_head:0)
int	 rn_walktree<s(0)(0)(0)>[&] (struct radix_node_head<s(1)(0)(1)>[&] *, int (*)(), void *);(D1:radix_node_head:0)
struct radix_node<s(1)(0)(1)>[&]
	 *rn_addmask<s(0)(0)(0)>[&] (void *, int, int),(D1:rn_addmask:0)
	 *rn_addroute<s(0)(0)(0)>[&] (void *, void *, struct radix_node_head<s(1)(0)(1)>[&] *,
			struct radix_node<s(1)(0)(1)>[&] [2]),(D1:radix_node:0)
	 *rn_delete<s(0)(0)(0)>[&] (void *, void *, struct radix_node_head<s(1)(0)(1)>[&] *),(D1:radix_node_head:0)
	 *rn_insert<s(0)(0)(0)>[&] (void *, struct radix_node_head<s(1)(0)(1)>[&] *, int *,
			struct radix_node<s(1)(0)(1)>[&] [2]),(D1:radix_node:0)
	 *rn_match<s(0)(0)(0)>[&] (void *, struct radix_node_head<s(1)(0)(1)>[&] *, int),(D1:radix_node_head:0)
	 *rn_newpair<s(0)(0)(0)>[&] (void *, int, struct radix_node<s(1)(0)(1)>[&][2]),(D1:radix_node:0)
	 *rn_search<s(0)(0)(0)>[&] (void *, struct radix_node<s(1)(0)(1)>[&] *),(D1:radix_node:0)
	 *rn_search_m<s(0)(0)(0)>[&] (void *, struct radix_node<s(1)(0)(1)>[&] *, void *);(D1:radix_node:0)














 






 




struct route<s(1)(0)(1)>[&]
    {
    struct	rtentry<s(2)(1)(1)>[&] *ro_rt<s(1)(1)(0)>[&];
    struct	sockaddr<s(2)(1)(1)>[&] ro_dst<s(2)(1)(1)>[&];
    };

 



struct rt_metrics<s(1)(0)(1)>[&] {
	u_long<s(1)(1)(0)>[T]	rmx_locks<s(1)(1)(0)>[&];	 
	u_long<s(1)(1)(0)>[T]	rmx_mtu<s(1)(1)(0)>[&];	 
	u_long<s(1)(1)(0)>[T]	rmx_expire<s(1)(1)(0)>[&];	 
	u_long<s(1)(1)(0)>[T]	rmx_recvpipe<s(1)(1)(0)>[&];	 
	u_long<s(1)(1)(0)>[T]	rmx_sendpipe<s(1)(1)(0)>[&];	 
	u_long<s(1)(1)(0)>[T]	rmx_ssthresh<s(1)(1)(0)>[&];	 
	u_long<s(1)(1)(0)>[T]	rmx_rtt<s(1)(1)(0)>[&];	 
	u_long<s(1)(1)(0)>[T]	rmx_rttvar<s(1)(1)(0)>[&];	 
	u_short<s(1)(1)(0)>[T]	rmx_hopcount<s(1)(1)(0)>[&];	 
        u_short<s(1)(1)(0)>[T] rmx_mss<s(1)(1)(0)>[&]; 	 

         

        long 	value1<s(1)(1)(0)>[&];
        long 	value2<s(1)(1)(0)>[&];
        long 	value3<s(1)(1)(0)>[&];
        long 	value4<s(1)(1)(0)>[&];
        long 	value5<s(1)(1)(0)>[&];
        long 	routeTag<s(1)(1)(0)>[&];
        u_char<s(1)(1)(0)>[T]  weight<s(1)(1)(0)>[&];
};

 






struct sockaddr_gate<s(1)(0)(1)>[&]
    {
    u_char<s(1)(1)(0)>[T]         gate_len<s(1)(1)(0)>[&];
    u_char<s(1)(1)(0)>[T]         gate_family<s(1)(1)(0)>[&];
    u_char<s(1)(1)(0)>[T]         routeProto<s(1)(1)(0)>[&];
    u_char<s(1)(1)(0)>[T]         weight<s(1)(1)(0)>[&];
    u_long<s(1)(1)(0)>[T]         gate_addr<s(1)(1)(0)>[&];
    long           value1<s(1)(1)(0)>[&];
    long           value2<s(1)(1)(0)>[&];
    long           value3<s(1)(1)(0)>[&];
    long           value4<s(1)(1)(0)>[&];
    long           value5<s(1)(1)(0)>[&];
    long           routeTag<s(1)(1)(0)>[&];
    };

 







 










struct rtentry<s(1)(0)(1)>[&] {
	struct	radix_node<s(2)(1)(1)>[&] rt_nodes<s(2)(1)(1)>[&][2];	 


	struct	sockaddr<s(2)(1)(1)>[&] *rt_gateway<s(1)(1)(0)>[&];	 
	short	rt_flags<s(1)(1)(0)>[&];		 
	short	rt_refcnt<s(1)(1)(0)>[&];		 
	u_long<s(1)(1)(0)>[T]	rt_use<s(1)(1)(0)>[&];			 
	struct	ifnet<s(2)(1)(1)>[&] *rt_ifp<s(1)(1)(0)>[&];		 
	struct	ifaddr<s(2)(1)(1)>[&] *rt_ifa<s(1)(1)(0)>[&];		 
	struct	sockaddr<s(2)(1)(1)>[&] *rt_genmask<s(1)(1)(0)>[&];	 
	caddr_t<s(1)(1)(0)>[T]	rt_llinfo<s(1)(1)(0)>[&];		 
	struct	rtentry<s(2)(1)(1)>[&] *rt_gwroute<s(1)(1)(0)>[&];	 
        int	rt_mod<s(1)(1)(0)>[&];			  
	struct	rt_metrics<s(2)(1)(1)>[&] rt_rmx<s(2)(1)(1)>[&];	 
        struct  rtentry<s(2)(1)(1)>[&] *rt_parent<s(1)(1)(0)>[&];      
};

 



struct ortentry<s(1)(0)(1)>[&] {
	u_long<s(1)(1)(0)>[T]	rt_hash<s(1)(1)(0)>[&];		 
	struct	sockaddr<s(2)(1)(1)>[&] rt_dst<s(2)(1)(1)>[&];	 
	struct	sockaddr<s(2)(1)(1)>[&] rt_gateway<s(2)(1)(1)>[&];	 
	short	rt_flags<s(1)(1)(0)>[&];		 
	short	rt_refcnt<s(1)(1)(0)>[&];		 
	u_long<s(1)(1)(0)>[T]	rt_use<s(1)(1)(0)>[&];			 
	struct	ifnet<s(2)(1)(1)>[&] *rt_ifp<s(1)(1)(0)>[&];		 
        int	rt_mod<s(1)(1)(0)>[&];			 
};
























 

struct	rtstat<s(1)(0)(1)>[&]
    {
    short	rts_badredirect<s(1)(1)(0)>[&];	 
    short	rts_dynamic<s(1)(1)(0)>[&];		 
    short	rts_newgateway<s(1)(1)(0)>[&];		 
    short	rts_unreach<s(1)(1)(0)>[&];		 
    short	rts_wildcard<s(1)(1)(0)>[&];		 
    };

 


struct rt_msghdr<s(1)(0)(1)>[&] {
	u_short<s(1)(1)(0)>[T]	rtm_msglen<s(1)(1)(0)>[&];	 
	u_char<s(1)(1)(0)>[T]	rtm_version<s(1)(1)(0)>[&];	 
	u_char<s(1)(1)(0)>[T]	rtm_type<s(1)(1)(0)>[&];	 
	u_short<s(1)(1)(0)>[T]	rtm_index<s(1)(1)(0)>[&];	 
	int	rtm_flags<s(1)(1)(0)>[&];	 
	int	rtm_addrs<s(1)(1)(0)>[&];	 
	pid_t<s(1)(1)(0)>[T]	rtm_pid<s(1)(1)(0)>[&];	 
	int	rtm_seq<s(1)(1)(0)>[&];	 
	int	rtm_errno<s(1)(1)(0)>[&];	 
	int	rtm_use<s(1)(1)(0)>[&];	 
	u_long<s(1)(1)(0)>[T]	rtm_inits<s(1)(1)(0)>[&];	 
	struct	rt_metrics<s(2)(1)(1)>[&] rtm_rmx<s(2)(1)(1)>[&];  
};































 











 












 










struct rt_addrinfo<s(1)(0)(1)>[&] {
	int	rti_addrs<s(1)(1)(0)>[&];
	struct	sockaddr<s(2)(1)(1)>[&] *rti_info<s(1)(1)(0)>[&][8 ];
};

struct route_cb<s(1)(0)(1)>[&] {
	int	ip_count<s(1)(1)(0)>[&];
	int	ns_count<s(1)(1)(0)>[&];
	int	iso_count<s(1)(1)(0)>[&];
	int	any_count<s(1)(1)(0)>[&];
};











extern	struct	rtstat<s(1)(0)(1)>[&]	rtstat<s(1)(0)(1)>[&];(D1:rtstat:0)
extern	struct	radix_node_head<s(1)(0)(1)>[&] *rt_tables<s(0)(0)(0)>[&][];(D1:rt_tables:0)
extern  int	rtmodified<s(0)(0)(0)>[&];(D1:rtmodified:0) 




int	 route_init<s(0)(0)(0)>[&] (void);(D1:route_init:0)

void	 rt_maskedcopy<s(0)(0)(0)>[&] (struct sockaddr<s(1)(0)(1)>[&] *,
	    struct sockaddr<s(1)(0)(1)>[&] *, struct sockaddr<s(1)(0)(1)>[&] *);(D1:sockaddr:0)
int	 rt_setgate<s(0)(0)(0)>[&] (struct rtentry<s(1)(0)(1)>[&] *,
	    struct sockaddr<s(1)(0)(1)>[&] *, struct sockaddr<s(1)(0)(1)>[&] *);(D1:sockaddr:0)
void	 rtable_init<s(0)(0)(0)>[&] (void **);(D1:rtable_init:0)
void	 rtalloc<s(0)(0)(0)>[&] (struct route<s(1)(0)(1)>[&] *);(D1:route:0)
struct rtentry<s(1)(0)(1)>[&] *
	 rtalloc1<s(0)(0)(0)>[&] (struct sockaddr<s(1)(0)(1)>[&] *, int, int);(D1:sockaddr:0)
void	 rtfree<s(0)(0)(0)>[&] (struct rtentry<s(1)(0)(1)>[&] *);(D1:rtentry:0)
int	 rtinit<s(0)(0)(0)>[&] (struct ifaddr<s(1)(0)(1)>[&] *, int, int);(D1:ifaddr:0)
int	 rtioctl<s(0)(0)(0)>[&] (int, caddr_t<s(0)(0)(0)>[T]);(D1:caddr_t:0)
int	 rtredirect<s(0)(0)(0)>[&] (struct sockaddr<s(1)(0)(1)>[&] *, struct sockaddr<s(1)(0)(1)>[&] *,
	    struct sockaddr<s(1)(0)(1)>[&] *, int, struct sockaddr<s(1)(0)(1)>[&] *, struct rtentry<s(1)(0)(1)>[&] **);(D1:rtentry:0)
int	 rtrequest<s(0)(0)(0)>[&] (int, struct sockaddr<s(1)(0)(1)>[&] *,
	    struct sockaddr<s(1)(0)(1)>[&] *, struct sockaddr<s(1)(0)(1)>[&] *, int, struct rtentry<s(1)(0)(1)>[&] **);(D1:rtentry:0)
int	 rtrequest11<s(0)(0)(0)>[&] (int, struct sockaddr<s(1)(0)(1)>[&] *,
	    struct sockaddr<s(1)(0)(1)>[&] *, struct sockaddr<s(1)(0)(1)>[&] *, int, struct rtentry<s(1)(0)(1)>[&] **);(D1:rtentry:0)







 

 

 




















 


extern STATUS<s(0)(0)(0)>[T]   ifAddrAdd<s(0)(0)(0)>[&] (char *interfaceName<s(0)(0)(0)>[&], char *interfaceAddress<s(0)(0)(0)>[&],
                           char *broadcastAddress<s(0)(0)(0)>[&], int subnetMask<s(0)(0)(0)>[&]);(D1:subnetMask:0)
extern STATUS<s(0)(0)(0)>[T] 	ifAddrSet<s(0)(0)(0)>[&] (char *interfaceName<s(0)(0)(0)>[&], char *interfaceAddress<s(0)(0)(0)>[&]);(D1:interfaceAddress:0)
extern STATUS<s(0)(0)(0)>[T] 	ifAddrDelete<s(0)(0)(0)>[&] (char *interfaceName<s(0)(0)(0)>[&], char *interfaceAddress<s(0)(0)(0)>[&]);(D1:interfaceAddress:0)
extern STATUS<s(0)(0)(0)>[T] 	ifAddrGet<s(0)(0)(0)>[&] (char *interfaceName<s(0)(0)(0)>[&], char *interfaceAddress<s(0)(0)(0)>[&]);(D1:interfaceAddress:0)
extern STATUS<s(0)(0)(0)>[T] 	ifBroadcastSet<s(0)(0)(0)>[&] (char *interfaceName<s(0)(0)(0)>[&], char *broadcastAddress<s(0)(0)(0)>[&]);(D1:broadcastAddress:0)
extern STATUS<s(0)(0)(0)>[T] 	ifBroadcastGet<s(0)(0)(0)>[&] (char *interfaceName<s(0)(0)(0)>[&], char *broadcastAddress<s(0)(0)(0)>[&]);(D1:broadcastAddress:0)
extern STATUS<s(0)(0)(0)>[T] 	ifDstAddrSet<s(0)(0)(0)>[&] (char *interfaceName<s(0)(0)(0)>[&], char *dstAddress<s(0)(0)(0)>[&]);(D1:dstAddress:0)
extern STATUS<s(0)(0)(0)>[T] 	ifDstAddrGet<s(0)(0)(0)>[&] (char *interfaceName<s(0)(0)(0)>[&], char *dstAddress<s(0)(0)(0)>[&]);(D1:dstAddress:0)
extern STATUS<s(0)(0)(0)>[T] 	ifMaskSet<s(0)(0)(0)>[&] (char *interfaceName<s(0)(0)(0)>[&], int netMask<s(0)(0)(0)>[&]);(D1:netMask:0)
extern STATUS<s(0)(0)(0)>[T] 	ifMaskGet<s(0)(0)(0)>[&] (char *interfaceName<s(0)(0)(0)>[&], int *netMask<s(0)(0)(0)>[&]);(D1:netMask:0)
extern STATUS<s(0)(0)(0)>[T] 	ifFlagChange<s(0)(0)(0)>[&] (char *interfaceName<s(0)(0)(0)>[&], int flags<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] on<s(0)(0)(0)>[&]);(D1:on:0)
extern STATUS<s(0)(0)(0)>[T] 	ifFlagSet<s(0)(0)(0)>[&] (char *interfaceName<s(0)(0)(0)>[&], int flags<s(0)(0)(0)>[&]);(D1:flags:0)
extern STATUS<s(0)(0)(0)>[T] 	ifFlagGet<s(0)(0)(0)>[&] (char *interfaceName<s(0)(0)(0)>[&], int *flags<s(0)(0)(0)>[&]);(D1:flags:0)
extern STATUS<s(0)(0)(0)>[T] 	ifMetricSet<s(0)(0)(0)>[&] (char *interfaceName<s(0)(0)(0)>[&], int metric<s(0)(0)(0)>[&]);(D1:metric:0)
extern STATUS<s(0)(0)(0)>[T] 	ifMetricGet<s(0)(0)(0)>[&] (char *interfaceName<s(0)(0)(0)>[&], int *pMetric<s(0)(0)(0)>[&]);(D1:pMetric:0)
extern int 	ifRouteDelete<s(0)(0)(0)>[&] (char *ifName<s(0)(0)(0)>[&], int unit<s(0)(0)(0)>[&]);(D1:unit:0)
extern struct 	ifnet<s(1)(0)(1)>[&] *ifunit<s(0)(0)(0)>[&] (char *ifname<s(0)(0)(0)>[&]);(D1:ifname:0)
extern struct	ifnet<s(1)(0)(1)>[&] *ifIndexToIfpNoLock<s(0)(0)(0)>[&] (int ifIndex<s(0)(0)(0)>[&]);(D1:ifIndex:0)
extern struct	ifnet<s(1)(0)(1)>[&] *ifIndexToIfp<s(0)(0)(0)>[&] (int ifIndex<s(0)(0)(0)>[&]);(D1:ifIndex:0)
extern unsigned short	ifNameToIfIndex<s(0)(0)(0)>[&] (char *ifname<s(0)(0)(0)>[&]);(D1:ifname:0)
extern STATUS<s(0)(0)(0)>[T]	ifIndexToIfName<s(0)(0)(0)>[&] (unsigned short ifIndex<s(0)(0)(0)>[&], char *ifname<s(0)(0)(0)>[&]);(D1:ifname:0)
extern STATUS<s(0)(0)(0)>[T]	ifUnnumberedSet<s(0)(0)(0)>[&](char *, char *, char *, char *);(D1:ifUnnumberedSet:0)
extern int 	ifAllRoutesDelete<s(0)(0)(0)>[&] (char *, int);(D1:ifAllRoutesDelete:0)












 
























struct	ifqueue<s(1)(0)(1)>[&] {
	struct	mBlk<s(2)(1)(1)>[&]  *ifq_head<s(1)(1)(0)>[&];
	struct	mBlk<s(2)(1)(1)>[&]  *ifq_tail<s(1)(1)(0)>[&];
	int	ifq_len<s(1)(1)(0)>[&];
	int	ifq_maxlen<s(1)(1)(0)>[&];
	int	ifq_drops<s(1)(1)(0)>[&];
};

struct mBlk<s(1)(0)(1)>[&] ;
struct proc<s(1)(0)(1)>[&];
struct rtentry<s(1)(0)(1)>[&];
struct socket<s(1)(0)(1)>[&];
struct ether_header<s(1)(0)(1)>[&];

 



struct	if_data<s(1)(0)(1)>[&] {
	 
	u_char<s(1)(1)(0)>[T]	ifi_type<s(1)(1)(0)>[&];		 
	u_char<s(1)(1)(0)>[T]	ifi_addrlen<s(1)(1)(0)>[&];		 
	u_char<s(1)(1)(0)>[T]	ifi_hdrlen<s(1)(1)(0)>[&];		 
	u_long<s(1)(1)(0)>[T]	ifi_mtu<s(1)(1)(0)>[&];		 
	u_long<s(1)(1)(0)>[T]	ifi_metric<s(1)(1)(0)>[&];		 
	u_long<s(1)(1)(0)>[T]	ifi_baudrate<s(1)(1)(0)>[&];		 
	 
	u_long<s(1)(1)(0)>[T]	ifi_ipackets<s(1)(1)(0)>[&];		 
	u_long<s(1)(1)(0)>[T]	ifi_ierrors<s(1)(1)(0)>[&];		 
	u_long<s(1)(1)(0)>[T]	ifi_opackets<s(1)(1)(0)>[&];		 
	u_long<s(1)(1)(0)>[T]	ifi_oerrors<s(1)(1)(0)>[&];		 
	u_long<s(1)(1)(0)>[T]	ifi_collisions<s(1)(1)(0)>[&];		 
	u_long<s(1)(1)(0)>[T]	ifi_ibytes<s(1)(1)(0)>[&];		 
	u_long<s(1)(1)(0)>[T]	ifi_obytes<s(1)(1)(0)>[&];		 
	u_long<s(1)(1)(0)>[T]	ifi_imcasts<s(1)(1)(0)>[&];		 
	u_long<s(1)(1)(0)>[T]	ifi_omcasts<s(1)(1)(0)>[&];		 
	u_long<s(1)(1)(0)>[T]	ifi_iqdrops<s(1)(1)(0)>[&];		 
	u_long<s(1)(1)(0)>[T]	ifi_noproto<s(1)(1)(0)>[&];		 
	u_long<s(1)(1)(0)>[T]  ifi_lastchange<s(1)(1)(0)>[&];		 
};

 





struct ifnet<s(1)(0)(1)>[&] {
	char	*if_name<s(1)(1)(0)>[&];		 
	struct	ifnet<s(2)(1)(1)>[&] *if_next<s(1)(1)(0)>[&];		 
	struct	ifaddr<s(2)(1)(1)>[&] *if_addrlist<s(1)(1)(0)>[&];	 
	int	if_pcount<s(1)(1)(0)>[&];		 
	caddr_t<s(1)(1)(0)>[T]	if_bpf<s(1)(1)(0)>[&];			 
	u_short<s(1)(1)(0)>[T]	if_index<s(1)(1)(0)>[&];		 
	short	if_unit<s(1)(1)(0)>[&];		 
	short	if_timer<s(1)(1)(0)>[&];		 
	short	if_flags<s(1)(1)(0)>[&];		 
	struct	if_data<s(2)(1)(1)>[&] if_data<s(2)(1)(1)>[&];	 
	struct	mBlk<s(2)(1)(1)>[&] *	pInmMblk<s(1)(1)(0)>[&]; 	 
	int	(*if_init<s(1)(1)(0)>[&]) 
		(int unit<s(1)(1)(0)>[&]);		 
	int	(*if_output<s(1)(1)(0)>[&])		 
		(struct ifnet<s(2)(1)(1)>[&] *, struct mBlk<s(2)(1)(1)>[&]  *, struct sockaddr<s(2)(1)(1)>[&] *, 
		 struct rtentry<s(2)(1)(1)>[&] *);	
	int	(*if_start<s(1)(1)(0)>[&]) 		 
    		(struct ifnet<s(2)(1)(1)>[&] *);
	int	(*if_ioctl<s(1)(1)(0)>[&])		 
		(struct ifnet<s(2)(1)(1)>[&] *, int cmd<s(1)(1)(0)>[&], caddr_t<s(1)(1)(0)>[T] data<s(1)(1)(0)>[&]);
	int	(*if_reset<s(1)(1)(0)>[&])		 
		(int unit<s(1)(1)(0)>[&]);	
	int	(*if_resolve<s(1)(1)(0)>[&])();	 
	void	(*if_watchdog<s(1)(1)(0)>[&])		 
		(int unit<s(1)(1)(0)>[&]);
	struct	ifqueue<s(2)(1)(1)>[&] if_snd<s(2)(1)(1)>[&];		 
        void * 	pCookie<s(1)(1)(0)>[&]; 		 



};














































 







 
















 














 





struct ifaddr<s(1)(0)(1)>[&] {
	struct	sockaddr<s(2)(1)(1)>[&] *ifa_addr<s(1)(1)(0)>[&];	 
	struct	sockaddr<s(2)(1)(1)>[&] *ifa_dstaddr<s(1)(1)(0)>[&];	 

	struct	sockaddr<s(2)(1)(1)>[&] *ifa_netmask<s(1)(1)(0)>[&];	 
	struct	ifnet<s(2)(1)(1)>[&] *ifa_ifp<s(1)(1)(0)>[&];		 
	struct	ifaddr<s(2)(1)(1)>[&] *ifa_next<s(1)(1)(0)>[&];	 
	void	(*ifa_rtrequest<s(1)(1)(0)>[&])();	 
	u_short<s(1)(1)(0)>[T]	ifa_flags<s(1)(1)(0)>[&];		 
	short	ifa_refcnt<s(1)(1)(0)>[&];		 
	int	ifa_metric<s(1)(1)(0)>[&];		 
};


 



struct if_msghdr<s(1)(0)(1)>[&] {
	u_short<s(1)(1)(0)>[T]	ifm_msglen<s(1)(1)(0)>[&];	 
	u_char<s(1)(1)(0)>[T]	ifm_version<s(1)(1)(0)>[&];	 
	u_char<s(1)(1)(0)>[T]	ifm_type<s(1)(1)(0)>[&];	 
	int	ifm_addrs<s(1)(1)(0)>[&];	 
	int	ifm_flags<s(1)(1)(0)>[&];	 
	u_short<s(1)(1)(0)>[T]	ifm_index<s(1)(1)(0)>[&];	 
	struct	if_data<s(2)(1)(1)>[&] ifm_data<s(2)(1)(1)>[&]; 
};

 



struct ifa_msghdr<s(1)(0)(1)>[&] {
	u_short<s(1)(1)(0)>[T]	ifam_msglen<s(1)(1)(0)>[&];	 
	u_char<s(1)(1)(0)>[T]	ifam_version<s(1)(1)(0)>[&];	 
	u_char<s(1)(1)(0)>[T]	ifam_type<s(1)(1)(0)>[&];	 
	int	ifam_addrs<s(1)(1)(0)>[&];	 
	int	ifam_flags<s(1)(1)(0)>[&];	 
	u_short<s(1)(1)(0)>[T]	ifam_index<s(1)(1)(0)>[&];	 
	int	ifam_metric<s(1)(1)(0)>[&];	 
};

 





struct	ifreq<s(1)(0)(1)>[&] {

	char	ifr_name<s(1)(1)(0)>[&][16 ];		 
	union {
		struct	sockaddr<s(3)(1)(1)>[&] ifru_addr<s(3)(1)(1)>[&];
		struct	sockaddr<s(3)(1)(1)>[&] ifru_dstaddr<s(3)(1)(1)>[&];
		struct	sockaddr<s(3)(1)(1)>[&] ifru_broadaddr<s(3)(1)(1)>[&];
		short	ifru_flags<s(2)(1)(0)>[&];
		int	ifru_metric<s(2)(1)(0)>[&];
		caddr_t<s(2)(1)(0)>[T]	ifru_data<s(2)(1)(0)>[&];
	} ifr_ifru<s(1)(0)(0)>[&];






};

struct ifaliasreq<s(1)(0)(1)>[&] {
	char	ifra_name<s(1)(1)(0)>[&][16 ];		 
	struct	sockaddr<s(2)(1)(1)>[&] ifra_addr<s(2)(1)(1)>[&];
	struct	sockaddr<s(2)(1)(1)>[&] ifra_broadaddr<s(2)(1)(1)>[&];
	struct	sockaddr<s(2)(1)(1)>[&] ifra_mask<s(2)(1)(1)>[&];
};

 



struct	ifmreq<s(1)(0)(1)>[&] {

	char	ifr_name<s(1)(1)(0)>[&][16 ];		 
	int	ifr_tableLen<s(1)(1)(0)>[&];
	char 	*ifr_table<s(1)(1)(0)>[&];
};

 





struct	ifconf<s(1)(0)(1)>[&] {
	int	ifc_len<s(1)(1)(0)>[&];		 
	union {
		caddr_t<s(2)(1)(0)>[T]	ifcu_buf<s(2)(1)(0)>[&];
		struct	ifreq<s(3)(1)(1)>[&] *ifcu_req<s(2)(1)(0)>[&];
	} ifc_ifcu<s(1)(0)(0)>[&];


};

 




typedef struct mtuQuery_t<s(1)(0)(1)>[&] 
	{
	UCHAR<s(1)(1)(0)>[T] family<s(1)(1)(0)>[&];
	UINT32<s(1)(1)(0)>[T] dstIpAddr<s(1)(1)(0)>[&];
	UINT32<s(1)(1)(0)>[T] mtu<s(1)(1)(0)>[&];
	} MTU_QUERY<s(0)(0)(0)>[&];(D1:MTU_QUERY:1)[[TYPENAME:MTU_QUERY]]











extern struct ifnet<s(1)(0)(1)>[&] * 	ifnet<s(0)(0)(0)>[&];(D1:ifnet:0)		 
extern struct ifqueue<s(1)(0)(1)>[&] 	rawintrq<s(1)(0)(1)>[&];(D1:rawintrq:0)	 

extern STATUS<s(0)(0)(0)>[T]		if_attach<s(0)(0)(0)>[&] (struct ifnet<s(1)(0)(1)>[&] *);(D1:ifnet:0)
extern void		if_down<s(0)(0)(0)>[&] (struct ifnet<s(1)(0)(1)>[&] *);(D1:ifnet:0)
extern void		if_qflush<s(0)(0)(0)>[&] (struct ifqueue<s(1)(0)(1)>[&] *);(D1:ifqueue:0)


extern void		if_slowtimo<s(0)(0)(0)>[&] (void);(D1:if_slowtimo:0)




extern void		if_up<s(0)(0)(0)>[&] (struct ifnet<s(1)(0)(1)>[&] *);(D1:ifnet:0)
extern int		ifconf<s(0)(0)(0)>[&] (int, caddr_t<s(0)(0)(0)>[T]);(D1:caddr_t:0)
extern void		ifinit<s(0)(0)(0)>[&] (void);(D1:ifinit:0)
extern int		ifioctl<s(0)(0)(0)>[&] (struct socket<s(1)(0)(1)>[&] *, u_long<s(0)(0)(0)>[T], caddr_t<s(0)(0)(0)>[T]);(D1:caddr_t:0)
extern int		ifpromisc<s(0)(0)(0)>[&] (struct ifnet<s(1)(0)(1)>[&] *, int);(D1:ifnet:0)
extern struct ifaddr<s(1)(0)(1)>[&] *	ifa_ifwithaddr<s(0)(0)(0)>[&] (struct sockaddr<s(1)(0)(1)>[&] *);(D1:sockaddr:0)
extern struct ifaddr<s(1)(0)(1)>[&] *	ifa_ifwithaf<s(0)(0)(0)>[&] (int);(D1:ifa_ifwithaf:0)
extern struct ifaddr<s(1)(0)(1)>[&] *	ifa_ifwithdstaddr<s(0)(0)(0)>[&] (struct sockaddr<s(1)(0)(1)>[&] *);(D1:sockaddr:0)
extern struct ifaddr<s(1)(0)(1)>[&] *	ifa_ifwithnet<s(0)(0)(0)>[&] (struct sockaddr<s(1)(0)(1)>[&] *);(D1:sockaddr:0)
extern struct ifaddr<s(1)(0)(1)>[&] *	ifaof_ifpforaddr<s(0)(0)(0)>[&] (struct sockaddr<s(1)(0)(1)>[&] *, struct ifnet<s(1)(0)(1)>[&] *);(D1:ifnet:0)
extern struct ifaddr<s(1)(0)(1)>[&] *	ifa_ifwithroute<s(0)(0)(0)>[&](int, struct sockaddr<s(1)(0)(1)>[&] *, 
					struct sockaddr<s(1)(0)(1)>[&]*);(D1:sockaddr:0)
extern void		ifafree<s(0)(0)(0)>[&] (struct ifaddr<s(1)(0)(1)>[&] *);(D1:ifaddr:0)
extern void		link_rtrequest<s(0)(0)(0)>[&] (int, struct rtentry<s(1)(0)(1)>[&] *,
                                        struct sockaddr<s(1)(0)(1)>[&] *);(D1:sockaddr:0)

struct port_enable_info<s(1)(0)(1)>[&]{
	int port<s(1)(1)(0)>[&];
	int disable<s(1)(1)(0)>[&];
	int protocol<s(1)(1)(0)>[&];	 
	char description<s(1)(1)(0)>[&][64];
	int hitcount<s(1)(1)(0)>[&];
	struct port_enable_info<s(2)(1)(1)>[&] *pnext<s(1)(1)(0)>[&];
};

typedef struct portUsing_hash<s(1)(0)(1)>[&]{
	int count<s(1)(1)(0)>[&];
	struct port_enable_info<s(2)(1)(1)>[&] *pnext<s(1)(1)(0)>[&];
}portUsing_Hash<s(0)(0)(0)>[&];(D1:portUsing_Hash:1)[[TYPENAME:portUsing_Hash]]	 













 




 





















 









 


struct in_addr<s(1)(0)(1)>[&] {
	u_long<s(1)(1)(0)>[T] s_addr<s(1)(1)(0)>[&];
};

 










































 


struct sockaddr_in<s(1)(0)(1)>[&] {
	u_char<s(1)(1)(0)>[T]	sin_len<s(1)(1)(0)>[&];
	u_char<s(1)(1)(0)>[T]	sin_family<s(1)(1)(0)>[&];
	u_short<s(1)(1)(0)>[T]	sin_port<s(1)(1)(0)>[&];
	struct	in_addr<s(2)(1)(1)>[&] sin_addr<s(2)(1)(1)>[&];
	char	sin_zero<s(1)(1)(0)>[&][8];
};

 





struct sockaddr_rt<s(1)(0)(1)>[&] {
	u_char<s(1)(1)(0)>[T]	srt_len<s(1)(1)(0)>[&];
	u_char<s(1)(1)(0)>[T]	srt_family<s(1)(1)(0)>[&];
        u_char<s(1)(1)(0)>[T]  srt_proto<s(1)(1)(0)>[&];
        u_char<s(1)(1)(0)>[T]  srt_tos<s(1)(1)(0)>[&];          
	struct	in_addr<s(2)(1)(1)>[&] srt_addr<s(2)(1)(1)>[&];
	char	sin_zero<s(1)(1)(0)>[&][8];
        };












 






struct ip_opts<s(1)(0)(1)>[&] {
	struct	in_addr<s(2)(1)(1)>[&] ip_dst<s(2)(1)(1)>[&];		 
	char	opts<s(1)(1)(0)>[&][40];		 
};

 



















 






 









struct ip_mreq<s(1)(0)(1)>[&] {
 struct in_addr<s(2)(1)(1)>[&] imr_multiaddr<s(2)(1)(1)>[&];  
   union {
     struct in_addr<s(3)(1)(1)>[&] u_imr_interface<s(3)(1)(1)>[&]; 
     int       u_imr_index<s(2)(1)(0)>[&];       
 } imr_arg<s(1)(0)(0)>[&];
};







 









 



















 


















extern	struct domain<s(1)(0)(1)>[&] inetdomain<s(1)(0)(1)>[&];(D1:inetdomain:0)
extern  BOOL<s(0)(0)(0)>[T] inet_netmatch<s(0)(0)(0)>[&](struct sockaddr_in<s(1)(0)(1)>[&] *sin1<s(0)(0)(0)>[&], struct sockaddr_in<s(1)(0)(1)>[&] *sin2<s(0)(0)(0)>[&]);(D1:sin2:0)
extern  void in_makeaddr_b<s(0)(0)(0)>[&](u_long<s(0)(0)(0)>[T] net<s(0)(0)(0)>[&], u_long<s(0)(0)(0)>[T] host<s(0)(0)(0)>[&], struct in_addr<s(1)(0)(1)>[&] * pAddr<s(0)(0)(0)>[&]);(D1:pAddr:0)
extern 	u_long<s(0)(0)(0)>[T] in_lnaof<s(0)(0)(0)>[&]();(D1:in_lnaof:0)
extern	void in_ifaddr_remove<s(0)(0)(0)>[&]();(D1:in_ifaddr_remove:0)
extern	int in_broadcast<s(0)(0)(0)>[&] (struct in_addr<s(1)(0)(1)>[&], struct ifnet<s(1)(0)(1)>[&] *);(D1:ifnet:0)
extern	int in_canforward<s(0)(0)(0)>[&] (struct in_addr<s(1)(0)(1)>[&]);(D1:in_addr:0)
extern	int in_cksum<s(0)(0)(0)>[&] (struct mBlk<s(1)(0)(1)>[&]  *, int);(D1:mBlk:0)
extern	int in_localaddr<s(0)(0)(0)>[&] (struct in_addr<s(1)(0)(1)>[&]);(D1:in_addr:0)
extern	u_long<s(0)(0)(0)>[T] in_netof<s(0)(0)(0)>[&] (struct in_addr<s(1)(0)(1)>[&]);(D1:in_addr:0)
extern	void in_socktrim<s(0)(0)(0)>[&] (struct sockaddr_in<s(1)(0)(1)>[&] *);(D1:sockaddr_in:0)
extern  struct in_ifaddr<s(1)(0)(1)>[&] *in_iaonnetof<s(0)(0)(0)>[&](u_long<s(0)(0)(0)>[T] net<s(0)(0)(0)>[&]);(D1:net:0)
















 





 










 













 
 


 



























 










 
extern void tmd_init<s(0)(0)(0)>[&](void *bp<s(0)(0)(0)>[&]);(D1:bp:0)

 


struct sirocco_bootp_req_info<s(1)(0)(1)>[&] {
    char serial_number<s(1)(1)(0)>[&][12];
    int slot_number<s(1)(1)(0)>[&];
    short int board_style<s(1)(1)(0)>[&];
    short int card_function<s(1)(1)(0)>[&];
};

 


struct sirocco_bootp_resp_info<s(1)(0)(1)>[&] {
    struct in_addr<s(2)(1)(1)>[&] scm_addr<s(2)(1)(1)>[&];
    struct in_addr<s(2)(1)(1)>[&] scm_mask<s(2)(1)(1)>[&];
    struct in_addr<s(2)(1)(1)>[&] sca_addr<s(2)(1)(1)>[&];
    struct in_addr<s(2)(1)(1)>[&] sca_mask<s(2)(1)(1)>[&];
    struct in_addr<s(2)(1)(1)>[&] gate_addr<s(2)(1)(1)>[&];
};

union sirocco_bootp_vend_info<s(1)(0)(1)>[&] {
    struct sirocco_bootp_req_info<s(2)(1)(1)>[&] req_info<s(2)(1)(1)>[&];
    struct sirocco_bootp_resp_info<s(2)(1)(1)>[&] resp_info<s(2)(1)(1)>[&];
};





extern int Inital_load_complete<s(0)(0)(0)>[&];(D1:Inital_load_complete:0)
extern unsigned int InitialTextLoadAddr<s(0)(0)(0)>[&];(D1:InitialTextLoadAddr:0)
extern unsigned int TextLoadAddr<s(0)(0)(0)>[&];(D1:TextLoadAddr:0)


 
int getSlotNumber<s(0)(0)(0)>[&](void);(D1:getSlotNumber:0)









extern int sysShutdown<s(0)(0)(0)>[&];(D1:sysShutdown:0)
extern int sysPoweroff<s(0)(0)(0)>[&];(D1:sysPoweroff:0)

typedef enum {
    INIT_ERROR_NONE<s(0)(0)(0)>[&],
    INIT_ERROR_MINOR<s(0)(0)(0)>[&],
    INIT_ERROR_MAJOR<s(0)(0)(0)>[&],
    INIT_ERROR_FATAL<s(0)(0)(0)>[&]
} InitErrorEnum<s(0)(0)(0)>[&];(D1:InitErrorEnum:1)[[TYPENAME:InitErrorEnum]]

struct globals<s(1)(0)(1)>[&] {
     



    char externalDevName<s(1)(1)(0)>[&][10 ];   
    unsigned long externalIPAddress<s(1)(1)(0)>[&];     
    unsigned long externalNetmask<s(1)(1)(0)>[&];   
    unsigned long externalBroadcast<s(1)(1)(0)>[&];     
    unsigned long gatewayIpAddress<s(1)(1)(0)>[&];  
    unsigned long nodeIPAddress<s(1)(1)(0)>[&];     
    unsigned long nodeIPNetmask<s(1)(1)(0)>[&];     
    char serialNumber<s(1)(1)(0)>[&][12 ];   
    unsigned long physicalSlot<s(1)(1)(0)>[&];  
    unsigned long logicalSlot<s(1)(1)(0)>[&];   

    int cardFunction<s(1)(1)(0)>[&];            
    int boardStyle<s(1)(1)(0)>[&];              
    int cardState<s(1)(1)(0)>[&];               
    int warmStart<s(1)(1)(0)>[&];               
    int coldStart<s(1)(1)(0)>[&];               
    
    struct acb<s(2)(1)(1)>[&] **applicationACBs<s(1)(1)(0)>[&];

    InitErrorEnum<s(1)(1)(0)>[T] ErrorLevel<s(1)(1)(0)>[&];    

    int activeInterface<s(1)(1)(0)>[&];         
    char actIfName<s(1)(1)(0)>[&][10 ];     
    unsigned long activeIpAddr<s(1)(1)(0)>[&];  
    char loadPath<s(1)(1)(0)>[&][100 ];  
    int chassisType<s(1)(1)(0)>[&];             

    void *moduleInfo<s(1)(1)(0)>[&];            
    void *logQueue<s(1)(1)(0)>[&];              
    unsigned int *sizes<s(1)(1)(0)>[&];         
    unsigned int *npool<s(1)(1)(0)>[&];         
    unsigned int *nused<s(1)(1)(0)>[&];         
    unsigned long memRatio<s(1)(1)(0)>[&];

    unsigned long externalIPAddressSec<s(1)(1)(0)>[&];
    unsigned long externalNetmaskSec<s(1)(1)(0)>[&];
    int ethernetEnable<s(1)(1)(0)>[&];

     



    unsigned long GmplsIPAddress<s(1)(1)(0)>[&]; 
    unsigned long GmplsIPNetmask<s(1)(1)(0)>[&]; 

};



 





 










 















extern struct globals<s(1)(0)(1)>[&] globals<s(1)(0)(1)>[&];(D1:globals:0)

extern short getPortNumber<s(0)(0)(0)>[&](void);(D1:getPortNumber:0)






 









typedef unsigned char Uint8<s(0)(0)(0)>[&];(D1:Uint8:1)[[TYPENAME:Uint8]]
typedef signed char Int8<s(0)(0)(0)>[&];(D1:Int8:1)[[TYPENAME:Int8]]

typedef unsigned short Uint16<s(0)(0)(0)>[&];(D1:Uint16:1)[[TYPENAME:Uint16]]
typedef short Int16<s(0)(0)(0)>[&];(D1:Int16:1)[[TYPENAME:Int16]]

typedef unsigned int Uint32<s(0)(0)(0)>[&];(D1:Uint32:1)[[TYPENAME:Uint32]]
typedef int Int32<s(0)(0)(0)>[&];(D1:Int32:1)[[TYPENAME:Int32]]


typedef unsigned char Boolean<s(0)(0)(0)>[&];(D1:Boolean:1)[[TYPENAME:Boolean]]





 












 
 
 
 




   
typedef struct
{
    short proxy_slot_list<s(1)(1)(0)>[&][40 +1];      
} fdrProxyList_t<s(0)(0)(0)>[&];(D1:fdrProxyList_t:1)[[TYPENAME:fdrProxyList_t]]

 
 
 
 
 
 
 
 
struct cmndSlotUpdate<s(1)(0)(1)>[&]
{
    command_tt<s(1)(1)(0)>[T] head<s(1)(1)(0)>[&];
    int reg_flags<s(1)(1)(0)>[&];                       
    int physical_slot<s(1)(1)(0)>[&];                   
    int board_function<s(1)(1)(0)>[&];                  

    int card_function<s(1)(1)(0)>[&];                   
    int card_style<s(1)(1)(0)>[&];                      
    int card_state<s(1)(1)(0)>[&];                      
    int last_card_style<s(1)(1)(0)>[&];                 
    int isCardSmart<s(1)(1)(0)>[&];                     
    int proxy_slot<s(1)(1)(0)>[&];                      

    int response_required<s(1)(1)(0)>[&];               
    int logical_slot<s(1)(1)(0)>[&];                    
    unsigned int sparedslots_bitmask<s(1)(1)(0)>[&];    
};
typedef struct cmndSlotUpdate<s(1)(0)(1)>[&] cmndSlotUpdate_t<s(1)(0)(1)>[&];(D1:cmndSlotUpdate_t:1)[[TYPENAME:cmndSlotUpdate_t]]

 
 
 

 
 
 
 
 












 
 
 
 
 









extern STATUS<s(0)(0)(0)>[T] fdrcoll_Register_Notification<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] physical_slot<s(0)(0)(0)>[&], int reg_flags<s(0)(0)(0)>[&]);(D1:reg_flags:0)
extern STATUS<s(0)(0)(0)>[T] fdrcoll_UnRegister_Notification<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] physical_slot<s(0)(0)(0)>[&],
                                              int reg_flags<s(0)(0)(0)>[&]);(D1:reg_flags:0)
 
 
 
 
 
extern int fdr_poll_slot_state<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] phys_slot<s(0)(0)(0)>[&]);(D1:phys_slot:0)
extern int fdr_poll_slot_style<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] phys_slot<s(0)(0)(0)>[&]);(D1:phys_slot:0)
extern int fdr_poll_last_slot_style<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] phys_slot<s(0)(0)(0)>[&]);(D1:phys_slot:0)
extern int fdr_poll_slot_function<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] phys_slot<s(0)(0)(0)>[&]);(D1:phys_slot:0)
extern int fdr_poll_slot_operational_function<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] phys_slot<s(0)(0)(0)>[&]);(D1:phys_slot:0)
extern int fdr_poll_slot_running_function<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] phys_slot<s(0)(0)(0)>[&]);(D1:phys_slot:0)
extern int fdr_poll_proxy_slot<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] phys_slot<s(0)(0)(0)>[&]);(D1:phys_slot:0)
extern int fdr_poll_slot_is_card_smart<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] phys_slot<s(0)(0)(0)>[&]);(D1:phys_slot:0)
extern int fdr_get_logical_slot_of_physical_slot<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] phys_slot<s(0)(0)(0)>[&]);(D1:phys_slot:0)
extern int fdr_get_physical_slot_of_logical_slot<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] logical_slot<s(0)(0)(0)>[&]);(D1:logical_slot:0)
extern int fdr_fetch_proxy_slots_for_card<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] phys_slot<s(0)(0)(0)>[&],
                                          fdrProxyList_t<s(0)(0)(0)>[T] *proxylist<s(0)(0)(0)>[&]);(D1:proxylist:0)
extern int fdr_poll_all_info_for_slot<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] pslot<s(0)(0)(0)>[&], cmndSlotUpdate_t<s(0)(0)(0)>[T] *csu<s(0)(0)(0)>[&]);(D1:csu:0)

 
 
 
 
 
extern int fdrcoll_get_local_card_state<s(0)(0)(0)>[&](void);(D1:fdrcoll_get_local_card_state:0)
extern STATUS<s(0)(0)(0)>[T] fdrcoll_Register_Mapping_Notification<s(0)(0)(0)>[&](void);(D1:fdrcoll_Register_Mapping_Notification:0)
extern void fdr_transmit_slot_notification_response<s(0)(0)(0)>[&](cmndSlotUpdate_t<s(0)(0)(0)>[T] *msg<s(0)(0)(0)>[&]);(D1:msg:0)
extern unsigned int fdrcoll_what_was_last_Eval_broadcast_key<s(0)(0)(0)>[&](void);(D1:fdrcoll_what_was_last_Eval_broadcast_key:0)
extern int fdr_poll_slot_is_soft_synchronized<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] phys_slot<s(0)(0)(0)>[&]);(D1:phys_slot:0)


 

   

















 
 
 

 
    typedef struct {
        command_tt<s(1)(1)(0)>[T] head<s(1)(1)(0)>[&];
        applId_tt<s(1)(1)(0)>[T] applId<s(1)(1)(0)>[&];
        unsigned int new_state<s(1)(1)(0)>[&];
        unsigned int failure_mode<s(1)(1)(0)>[&];
        unsigned int slot_event_key<s(1)(1)(0)>[&];
    } cmndFmtFDRcommand_t<s(0)(0)(0)>[&];(D1:cmndFmtFDRcommand_t:1)[[TYPENAME:cmndFmtFDRcommand_t]]

    typedef struct {
        command_tt<s(1)(1)(0)>[T] head<s(1)(1)(0)>[&];
        unsigned int card_state<s(1)(1)(0)>[&];
        unsigned int slot_event_key<s(1)(1)(0)>[&];

    } cmndFdrCardStateChange_t<s(0)(0)(0)>[&];(D1:cmndFdrCardStateChange_t:1)[[TYPENAME:cmndFdrCardStateChange_t]]

    typedef struct {
        command_tt<s(1)(1)(0)>[T] head<s(1)(1)(0)>[&];
        int board_type<s(1)(1)(0)>[&];
        int board_function<s(1)(1)(0)>[&];
        int card_state<s(1)(1)(0)>[&];
        int phys_slot<s(1)(1)(0)>[&];
        unsigned int slot_event_key<s(1)(1)(0)>[&];
    } cmndFdrQuery_t<s(0)(0)(0)>[&];(D1:cmndFdrQuery_t:1)[[TYPENAME:cmndFdrQuery_t]]

    typedef struct {
        command_tt<s(1)(1)(0)>[T] head<s(1)(1)(0)>[&];
        unsigned int slot_event_key<s(1)(1)(0)>[&];
        char i2cAddr<s(1)(1)(0)>[&][30];
        int phys_slot<s(1)(1)(0)>[&];
        unsigned int entity_id_number<s(1)(1)(0)>[&];
        short entity_index<s(1)(1)(0)>[&];
    } cmndFdrBackplaneQuery_t<s(0)(0)(0)>[&];(D1:cmndFdrBackplaneQuery_t:1)[[TYPENAME:cmndFdrBackplaneQuery_t]]

    typedef struct {
        command_tt<s(1)(1)(0)>[T] head<s(1)(1)(0)>[&];
        int physical_slot<s(1)(1)(0)>[&];
        int prior_card_type<s(1)(1)(0)>[&];
    } cmndFdrRemoveIntf_t<s(0)(0)(0)>[&];(D1:cmndFdrRemoveIntf_t:1)[[TYPENAME:cmndFdrRemoveIntf_t]]

    typedef struct {
        command_tt<s(1)(1)(0)>[T] head<s(1)(1)(0)>[&];
        int physical_slot<s(1)(1)(0)>[&];
        char i2cAddr<s(1)(1)(0)>[&][30];
        unsigned int slot_event_key<s(1)(1)(0)>[&];

    } cmndFdrDumbCardQuery_t<s(0)(0)(0)>[&];(D1:cmndFdrDumbCardQuery_t:1)[[TYPENAME:cmndFdrDumbCardQuery_t]]

 
    typedef struct {
        command_tt<s(1)(1)(0)>[T] head<s(1)(1)(0)>[&];
        int notified_card_state<s(1)(1)(0)>[&];
    } cmndFdrMapNotify_t<s(0)(0)(0)>[&];(D1:cmndFdrMapNotify_t:1)[[TYPENAME:cmndFdrMapNotify_t]]

    typedef struct {
        command_tt<s(1)(1)(0)>[T] head<s(1)(1)(0)>[&];
        int applnum<s(1)(1)(0)>[&];
        char applname<s(1)(1)(0)>[&][30];
        int notification<s(1)(1)(0)>[&];
        int status<s(1)(1)(0)>[&];
        int flag_fdr_reports<s(1)(1)(0)>[&];
        int options<s(1)(1)(0)>[&];
    } cmndFdrCollReg_t<s(0)(0)(0)>[&];(D1:cmndFdrCollReg_t:1)[[TYPENAME:cmndFdrCollReg_t]]

 







 
 
 




































 





 
 
 
 





 






 









 







enum
{
    CMM_LEVEL_ERR<s(0)(0)(0)>[&] = 0,
    CMM_LEVEL_CMC<s(0)(0)(0)>[&],
    CMM_LEVEL_SLOT<s(0)(0)(0)>[&],
    CMM_LEVEL_STATE<s(0)(0)(0)>[&],
    CMM_LEVEL_ALMEVT<s(0)(0)(0)>[&]
};

enum
{
    CMM_LEVEL_CAI<s(0)(0)(0)>[&] = 0,
    CMM_LEVEL_CMI<s(0)(0)(0)>[&]
};

enum
{
    CMM_LEVEL_CAD<s(0)(0)(0)>[&] = 0,
    CAD_LEVEL_ALMEVT<s(0)(0)(0)>[&],
    CAD_LEVEL_ERR<s(0)(0)(0)>[&]
};
enum
{
    CMND_CM_DATA_INIT_COMPLETE<s(0)(0)(0)>[&] = 0x3800 ,
    CMND_CM_CARDPROV<s(0)(0)(0)>[&],
    CMND_CM_CARDSTATECHG<s(0)(0)(0)>[&],
    CMND_CM_READYTOINIT<s(0)(0)(0)>[&],
    CMND_CM_READYTOACT<s(0)(0)(0)>[&],
    CMND_CM_PREPARETOACT<s(0)(0)(0)>[&],
    CMND_CM_DEINIT<s(0)(0)(0)>[&],
    CMND_CM_DEACT<s(0)(0)(0)>[&],
    CMND_CM_INITDRV<s(0)(0)(0)>[&],
    CMND_CM_RESTOREAPP<s(0)(0)(0)>[&],
    CMND_CM_INITAPP<s(0)(0)(0)>[&],
    CMND_CM_ACTDRV<s(0)(0)(0)>[&],
    CMND_CM_ACTAPP<s(0)(0)(0)>[&],
    CMND_CM_INITDRVOK<s(0)(0)(0)>[&],
    CMND_CM_INITDRVFAIL<s(0)(0)(0)>[&],
    CMND_CM_INITAPPOK<s(0)(0)(0)>[&],
    CMND_CM_INITAPPFAIL<s(0)(0)(0)>[&],
    CMND_CM_ACTDRVOK<s(0)(0)(0)>[&],
    CMND_CM_ACTDRVFAIL<s(0)(0)(0)>[&],
    CMND_CM_ACTAPPOK<s(0)(0)(0)>[&],
    CMND_CM_ACTAPPFAIL<s(0)(0)(0)>[&],
    CMND_CM_CHECKSTATE<s(0)(0)(0)>[&],          
    CMND_CM_CHECKSTATE_ACK<s(0)(0)(0)>[&],          
    CMND_CM_DRVSTAE<s(0)(0)(0)>[&],             
    CMND_CM_INSERT<s(0)(0)(0)>[&],
    CMND_CM_REMOVE<s(0)(0)(0)>[&],
    CMND_CM_FAIL<s(0)(0)(0)>[&],
    CMND_CM_FAILCLR<s(0)(0)(0)>[&],
    CMND_CM_ACTIVECC<s(0)(0)(0)>[&],
    CMND_CM_PHYINSERT<s(0)(0)(0)>[&],
    CMND_CM_APP_QUERY_MIBCARD<s(0)(0)(0)>[&],
    CMND_CM_MIBCARD<s(0)(0)(0)>[&],
    CMND_CM_MIBCARD_ACK<s(0)(0)(0)>[&],
    CMND_CM_CARDSTATE<s(0)(0)(0)>[&],
    CMND_CM_CARDSTATE_ACK<s(0)(0)(0)>[&],
    CMND_CM_MIBCARD_INIT_FINISH<s(0)(0)(0)>[&],
    CMND_CM_CMI_STARTED<s(0)(0)(0)>[&],
    CMND_CM_MIBCARD_ACT_FINISH<s(0)(0)(0)>[&],
    CMND_CM_RESTORE_CARD<s(0)(0)(0)>[&],
    CMND_CM_ADD_CARD<s(0)(0)(0)>[&],
    CMND_CM_DEL_CARD<s(0)(0)(0)>[&],
    CMND_CM_CARD_DOWN<s(0)(0)(0)>[&],
    CMND_CM_CARD_UP<s(0)(0)(0)>[&],
    CMND_CM_DELCARD<s(0)(0)(0)>[&],
    CMND_CM_RESETCARD<s(0)(0)(0)>[&],
    CMND_CM_REBOOT<s(0)(0)(0)>[&],
    CMND_CM_HALT<s(0)(0)(0)>[&],
    CMND_CM_HALT_ACK<s(0)(0)(0)>[&],
    CMND_CM_LATCH_STATE<s(0)(0)(0)>[&],
    CMND_CM_ACTIVECCDOWN<s(0)(0)(0)>[&],
    CMND_CM_ACTIVECCUP<s(0)(0)(0)>[&],
    CMND_CM_REPORT_CARD_DEFECT<s(0)(0)(0)>[&],
    CMND_CM_REPORT_CARD_PRESENCE<s(0)(0)(0)>[&],
    CMND_CM_DISABLECARD<s(0)(0)(0)>[&],
    CMND_CM_ENABLECARD<s(0)(0)(0)>[&],
    CMND_CM_TASK_READY<s(0)(0)(0)>[&],
    CMND_CM_TASK_READY_ACK<s(0)(0)(0)>[&],
    CMND_CM_SLOT_UPDATE<s(0)(0)(0)>[&],
    CMND_CM_CC_CAPABILITY_QUERY<s(0)(0)(0)>[&],   
    CMND_CM_CC_CAPABILITY<s(0)(0)(0)>[&],         
    CMND_CM_CC_CAPABILITY_ACK<s(0)(0)(0)>[&],     
    CMND_CM_CPC_LOCC_CAPACITY<s(0)(0)(0)>[&],      
    CMND_CM_CPC_HOCC_PHYSTATE<s(0)(0)(0)>[&],     
    CMND_CM_CPC_HOCC_PHYSTATE_ACK<s(0)(0)(0)>[&],  
    CMND_CM_CC_QUERY_ACTIVECC<s(0)(0)(0)>[&],         
    CMND_CM_APP_QUERY_CARDSTATE<s(0)(0)(0)>[&],        
    CMND_CM_APP_QUERY_CARDSTATE_RESPD<s(0)(0)(0)>[&],        
    CMND_CM_CARD_REBOOT<s(0)(0)(0)>[&],
    CMND_CM_RESETCPU<s(0)(0)(0)>[&],                         
    CMND_CM_SET_TEMPTH<s(0)(0)(0)>[&],          
    CMND_CM_QUERY_LATCHSTATE<s(0)(0)(0)>[&],
    CMND_CM_POLLING_STATE<s(0)(0)(0)>[&],          
    CMND_CM_MIBCARD_CHECKSTATE_FINISHED<s(0)(0)(0)>[&],    
    CMND_CM_UNITFAIL<s(0)(0)(0)>[&],                     
    CMND_CM_PCM_NOVALIDMIBCC<s(0)(0)(0)>[&],         
    CMND_CM_SWFPGAVS<s(0)(0)(0)>[&],              
    CMND_CM_VCXOOCXOFAIL<s(0)(0)(0)>[&],         
    CMND_CM_CHECKMIBACTFINISH<s(0)(0)(0)>[&],     
    CMND_CM_SETSILED<s(0)(0)(0)>[&],     
    CMND_CM_SHUTDOWNLAMP<s(0)(0)(0)>[&],     
    CMND_CM_SETLAMP<s(0)(0)(0)>[&],     
    CMND_CM_STOPSLAVECCCHECK<s(0)(0)(0)>[&],     
    CMND_CM_HOCC_POWER_FAIL<s(0)(0)(0)>[&],       
    CMND_CM_QUERY_TEMP_THRESHOLD<s(0)(0)(0)>[&],  
    CMND_CM_TEMP_THRESHOLD_ACK<s(0)(0)(0)>[&],    
    CMND_CM_SET_CARDTYPE<s(0)(0)(0)>[&],     
    CMND_CM_SET_HOCC_AIS<s(0)(0)(0)>[&],
    CMND_CM_SET_PORT_STATUS<s(0)(0)(0)>[&],
    CMND_CM_ACTIVE_HOCC_COLD_REBOOT<s(0)(0)(0)>[&],
    CMND_CM_ALL_LCCARD_ACTIVE<s(0)(0)(0)>[&],
    CMND_CM_FAN_PWR_INFO_QUERY<s(0)(0)(0)>[&],
    CMND_CM_FAN_PWR_INFO_RESP<s(0)(0)(0)>[&],
    CMND_CM_FAN_FAILED<s(0)(0)(0)>[&]
};

typedef enum _CM_CARDBASESTATE_T<s(0)(0)(0)>[&]
{
    CM_BASSTATE_NONE<s(0)(0)(0)>[&]=0,          
    CM_BASSTATE_UP<s(0)(0)(0)>[&] = 1,          
    CM_BASSTATE_DOWN<s(0)(0)(0)>[&] = 2,        
    CM_BASSTATE_UNKNOWN<s(0)(0)(0)>[&] = 3      
} CM_CARDBASESTATE_T<s(0)(0)(0)>[&];(D1:CM_CARDBASESTATE_T:1)[[TYPENAME:CM_CARDBASESTATE_T]]

typedef struct _CM_CARDINFO_T<s(1)(0)(1)>[&]
{
    UINT32<s(1)(1)(0)>[T] slot<s(1)(1)(0)>[&];     
    UINT32<s(1)(1)(0)>[T] style<s(1)(1)(0)>[&];    
    UINT32<s(1)(1)(0)>[T] option<s(1)(1)(0)>[&];   
    BOOL<s(1)(1)(0)>[T]   warm<s(1)(1)(0)>[&];     
    BOOL<s(1)(1)(0)>[T]   cancfg<s(1)(1)(0)>[&];   
    BOOL<s(1)(1)(0)>[T]   suspended<s(1)(1)(0)>[&];  
} CM_CARDINFO_T<s(0)(0)(0)>[&];(D1:CM_CARDINFO_T:1)[[TYPENAME:CM_CARDINFO_T]]

struct CM_INFO_CC_QURY_CPC_T<s(1)(0)(1)>[&]
{
    UINT32<s(1)(1)(0)>[T] slot<s(1)(1)(0)>[&];
};

struct CM_RESET_CPU_T<s(1)(0)(1)>[&]
{
    UINT32<s(1)(1)(0)>[T] Pslot<s(1)(1)(0)>[&];
};

struct CM_POLL_STATE_T<s(1)(0)(1)>[&]
{
    UINT32<s(1)(1)(0)>[T] Pslot<s(1)(1)(0)>[&];
};


typedef struct _CM_ACTIVECC_DATA_T<s(1)(0)(1)>[&]
{
    UINT32<s(1)(1)(0)>[T]                ActiveCC<s(1)(1)(0)>[&];
} CM_ACTIVECC_DATA_T<s(0)(0)(0)>[&];(D1:CM_ACTIVECC_DATA_T:1)[[TYPENAME:CM_ACTIVECC_DATA_T]]

typedef struct _CM_HOCC_PHYSTATE_T<s(1)(0)(1)>[&]
{
    SLOT_NUMBER_T<s(1)(1)(0)>[T] slot<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] ispresent<s(1)(1)(0)>[&];
}CM_HOCC_PHYSTATE_T<s(0)(0)(0)>[&];(D1:CM_HOCC_PHYSTATE_T:1)[[TYPENAME:CM_HOCC_PHYSTATE_T]]

typedef struct _CM_CPC_CCPHYSTATE_T<s(1)(0)(1)>[&]
{
    command_tt<s(1)(1)(0)>[T]            head<s(1)(1)(0)>[&];   
    CM_HOCC_PHYSTATE_T<s(1)(1)(0)>[T]    info<s(1)(1)(0)>[&];   
} CM_CPC_CCPHYSTATE_T<s(0)(0)(0)>[&];(D1:CM_CPC_CCPHYSTATE_T:1)[[TYPENAME:CM_CPC_CCPHYSTATE_T]]

typedef struct _CM_CCS_CPC_READY_T<s(1)(0)(1)>[&]
{
    command_tt<s(1)(1)(0)>[T]            head<s(1)(1)(0)>[&];   
    UINT32<s(1)(1)(0)>[T]                slot<s(1)(1)(0)>[&];   
} CM_CCS_CPC_READY_T<s(0)(0)(0)>[&];(D1:CM_CCS_CPC_READY_T:1)[[TYPENAME:CM_CCS_CPC_READY_T]]


typedef struct _CM_CARDSTATE_DATA_T<s(1)(0)(1)>[&]
{
    CM_CARDINFO_T<s(1)(1)(0)>[T]         card<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]                cmd<s(1)(1)(0)>[&];
} CM_CARDSTATE_DATA_T<s(0)(0)(0)>[&];(D1:CM_CARDSTATE_DATA_T:1)[[TYPENAME:CM_CARDSTATE_DATA_T]]

typedef struct _CM_CARDSTATE_ACK_DATA_T<s(1)(0)(1)>[&]
{
    CM_CARDINFO_T<s(1)(1)(0)>[T]         card<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]                cmd<s(1)(1)(0)>[&];
    PB_ERROR_CODE_T<s(1)(1)(0)>[T]       result<s(1)(1)(0)>[&];
} CM_CARDSTATE_ACK_DATA_T<s(0)(0)(0)>[&];(D1:CM_CARDSTATE_ACK_DATA_T:1)[[TYPENAME:CM_CARDSTATE_ACK_DATA_T]]

typedef struct _CM_MIBCARD_DATA_T<s(1)(0)(1)>[&]
{
    CM_CARDINFO_T<s(1)(1)(0)>[T]         card<s(1)(1)(0)>[&][SLOT_NUMBER_MAX<s(1)(1)(0)>[&] ];
} CM_MIBCARD_DATA_T<s(0)(0)(0)>[&];(D1:CM_MIBCARD_DATA_T:1)[[TYPENAME:CM_MIBCARD_DATA_T]]


typedef struct _CM_CARDSTATE_ARRY_T<s(1)(0)(1)>[&]
{
    CM_CARDSTATE_DATA_T<s(1)(1)(0)>[T]         state<s(1)(1)(0)>[&][SLOT_NUMBER_MAX<s(1)(1)(0)>[&] ];
} CM_CARDSTATE_ARRY_T<s(0)(0)(0)>[&];(D1:CM_CARDSTATE_ARRY_T:1)[[TYPENAME:CM_CARDSTATE_ARRY_T]]

typedef struct _CM_REPORT_CARD_DEFECT_DATA_T<s(1)(0)(1)>[&]
{
    UINT32<s(1)(1)(0)>[T] slot<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] ur<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] miscard<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] uf<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] initing<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] misslot<s(1)(1)(0)>[&];
} CM_REPORT_CARD_DEFECT_DATA_T<s(0)(0)(0)>[&];(D1:CM_REPORT_CARD_DEFECT_DATA_T:1)[[TYPENAME:CM_REPORT_CARD_DEFECT_DATA_T]]

typedef struct _CM_HALT_DATA_T<s(1)(0)(1)>[&]
{
    BOOL<s(1)(1)(0)>[T]       warm<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]      type<s(1)(1)(0)>[&];    
} CM_HALT_DATA_T<s(0)(0)(0)>[&];(D1:CM_HALT_DATA_T:1)[[TYPENAME:CM_HALT_DATA_T]]

typedef enum
{
    TMS_NO_FAULTY_ALARM<s(0)(0)(0)>[&] = 0,
    TMS_VCXO_FAIL<s(0)(0)(0)>[&],
    TMS_OCXO_FAIL<s(0)(0)(0)>[&],
    TMS_HOCC_POWER_FAIL<s(0)(0)(0)>[&]
}CM_VCXOOCXO_FAULTY_TYPE<s(0)(0)(0)>[&];(D1:CM_VCXOOCXO_FAULTY_TYPE:1)[[TYPENAME:CM_VCXOOCXO_FAULTY_TYPE]]
 
typedef struct
{
    UINT8<s(1)(1)(0)>[T]                   slot<s(1)(1)(0)>[&];
    CM_VCXOOCXO_FAULTY_TYPE<s(1)(1)(0)>[T]    faultyType<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T]                       vcxofail<s(1)(1)(0)>[&];
}CM_RECV_VOCXO_MSG_T<s(0)(0)(0)>[&];(D1:CM_RECV_VOCXO_MSG_T:1)[[TYPENAME:CM_RECV_VOCXO_MSG_T]]


 
 
typedef struct
{
    command_tt<s(1)(1)(0)>[T]              head<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]                   slot<s(1)(1)(0)>[&];
    CM_VCXOOCXO_FAULTY_TYPE<s(1)(1)(0)>[T]    faultyType<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T]                       vcxofail<s(1)(1)(0)>[&];
} CM_VCXOOCXO_FAIL_IND_MSG_T<s(0)(0)(0)>[&];(D1:CM_VCXOOCXO_FAIL_IND_MSG_T:1)[[TYPENAME:CM_VCXOOCXO_FAIL_IND_MSG_T]]

typedef struct
{
    UINT8<s(1)(1)(0)>[T]           high<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]           low<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]           slot<s(1)(1)(0)>[&];
}CM_TEMP_THRESHOLD_T<s(0)(0)(0)>[&];(D1:CM_TEMP_THRESHOLD_T:1)[[TYPENAME:CM_TEMP_THRESHOLD_T]]


 
typedef struct
{
    command_tt<s(1)(1)(0)>[T]              head<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]           high<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]           low<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]           slot<s(1)(1)(0)>[&];
} CM_TEMP_THRESHOLD_MSG_T<s(0)(0)(0)>[&];(D1:CM_TEMP_THRESHOLD_MSG_T:1)[[TYPENAME:CM_TEMP_THRESHOLD_MSG_T]]

 
typedef struct _CM_ACTIVECC_T<s(1)(0)(1)>[&]
{
    command_tt<s(1)(1)(0)>[T]            head<s(1)(1)(0)>[&];     
    UINT32<s(1)(1)(0)>[T]                ActiveCC<s(1)(1)(0)>[&]; 
                                    
} CM_ACTIVECC_T<s(0)(0)(0)>[&];(D1:CM_ACTIVECC_T:1)[[TYPENAME:CM_ACTIVECC_T]]

 
typedef struct _CM_CARDSTATE_T<s(1)(0)(1)>[&]
{
    command_tt<s(1)(1)(0)>[T]            head<s(1)(1)(0)>[&];   

    CM_CARDINFO_T<s(1)(1)(0)>[T]         card<s(1)(1)(0)>[&];   
    UINT32<s(1)(1)(0)>[T]                cmd<s(1)(1)(0)>[&];    
                                  
                                  
                                  
                                  
                                  
} CM_CARDSTATE_T<s(0)(0)(0)>[&];(D1:CM_CARDSTATE_T:1)[[TYPENAME:CM_CARDSTATE_T]]

 
typedef struct _CM_CARDSTATE_ACK_T<s(1)(0)(1)>[&]
{
    command_tt<s(1)(1)(0)>[T]            head<s(1)(1)(0)>[&];  
  
    CM_CARDINFO_T<s(1)(1)(0)>[T]         card<s(1)(1)(0)>[&];  
    UINT32<s(1)(1)(0)>[T]                cmd<s(1)(1)(0)>[&];   
    PB_ERROR_CODE_T<s(1)(1)(0)>[T]       result<s(1)(1)(0)>[&]; 
} CM_CARDSTATE_ACK_T<s(0)(0)(0)>[&];(D1:CM_CARDSTATE_ACK_T:1)[[TYPENAME:CM_CARDSTATE_ACK_T]]

 
typedef struct _CM_APP_QUERY_CARDSTATE_T<s(1)(0)(1)>[&]
{
    command_tt<s(1)(1)(0)>[T]            head<s(1)(1)(0)>[&];
} CM_APP_QUERY_CARDSTATE_T<s(0)(0)(0)>[&];(D1:CM_APP_QUERY_CARDSTATE_T:1)[[TYPENAME:CM_APP_QUERY_CARDSTATE_T]]

 
typedef struct _CM_APP_QUERY_CARDSTATE_REPD_T<s(1)(0)(1)>[&]
{
    command_tt<s(1)(1)(0)>[T]            head<s(1)(1)(0)>[&];
    CM_CARDSTATE_ARRY_T<s(1)(1)(0)>[T]         state<s(1)(1)(0)>[&];  
}CM_APP_QUERY_CARDSTATE_REPD_T<s(0)(0)(0)>[&];(D1:CM_APP_QUERY_CARDSTATE_REPD_T:1)[[TYPENAME:CM_APP_QUERY_CARDSTATE_REPD_T]]

 
typedef struct _CM_MIBCARD_T<s(1)(0)(1)>[&]
{
    command_tt<s(1)(1)(0)>[T]            head<s(1)(1)(0)>[&];
    CM_CARDINFO_T<s(1)(1)(0)>[T]         card<s(1)(1)(0)>[&][SLOT_NUMBER_MAX<s(1)(1)(0)>[&] ];  
} CM_MIBCARD_T<s(0)(0)(0)>[&];(D1:CM_MIBCARD_T:1)[[TYPENAME:CM_MIBCARD_T]]

 
typedef struct _CM_MIBCARD_ACK_T<s(1)(0)(1)>[&]
{
    command_tt<s(1)(1)(0)>[T]            head<s(1)(1)(0)>[&];
} CM_MIBCARD_ACK_T<s(0)(0)(0)>[&];(D1:CM_MIBCARD_ACK_T:1)[[TYPENAME:CM_MIBCARD_ACK_T]]

 
typedef struct _CM_APP_QUERY_MIBCARD_T<s(1)(0)(1)>[&]
{
    command_tt<s(1)(1)(0)>[T]            head<s(1)(1)(0)>[&];
} CM_APP_QUERY_MIBCARD_T<s(0)(0)(0)>[&];(D1:CM_APP_QUERY_MIBCARD_T:1)[[TYPENAME:CM_APP_QUERY_MIBCARD_T]]


typedef struct _CM_REPORT_CARD_DEFECT_T<s(1)(0)(1)>[&]
{
    command_tt<s(1)(1)(0)>[T] head<s(1)(1)(0)>[&];

    UINT32<s(1)(1)(0)>[T] slot<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] ur<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] miscard<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] uf<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] initing<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] misslot<s(1)(1)(0)>[&];
} CM_REPORT_CARD_DEFECT_T<s(0)(0)(0)>[&];(D1:CM_REPORT_CARD_DEFECT_T:1)[[TYPENAME:CM_REPORT_CARD_DEFECT_T]]



typedef struct _CM_HALT_T<s(1)(0)(1)>[&]
{
    command_tt<s(1)(1)(0)>[T] head<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T]       warm<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]      type<s(1)(1)(0)>[&];  
} CM_HALT_T<s(0)(0)(0)>[&];(D1:CM_HALT_T:1)[[TYPENAME:CM_HALT_T]]

typedef struct _CM_LATCH_T<s(1)(0)(1)>[&]
{
    command_tt<s(1)(1)(0)>[T]          head<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]                 slot<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]                 state<s(1)(1)(0)>[&];
} CM_LATCH_T<s(0)(0)(0)>[&];(D1:CM_LATCH_T:1)[[TYPENAME:CM_LATCH_T]]

typedef enum{
    NE_HOCC_CAPABILITY_UNKNOW<s(0)(0)(0)>[&] = 0,      
    NE_HOCC_CAPABILITY_340G<s(0)(0)(0)>[&]   = 1,      
    NE_HOCC_CAPABILITY_680G<s(0)(0)(0)>[&]  = 2       
}eNeHOCCCapability<s(0)(0)(0)>[&];(D1:eNeHOCCCapability:1)[[TYPENAME:eNeHOCCCapability]]

typedef enum{
    NE_LOCC_CAPABILITY_UNKNOW<s(0)(0)(0)>[&] = 0,      
    NE_LOCC_CAPABILITY_NONE<s(0)(0)(0)>[&]     =1,     
    NE_LOCC_CAPABILITY_20G<s(0)(0)(0)>[&]    = 2,      
    NE_LOCC_CAPABILITY_40G<s(0)(0)(0)>[&]  = 3       
}eNeLOCCCapability<s(0)(0)(0)>[&];(D1:eNeLOCCCapability:1)[[TYPENAME:eNeLOCCCapability]]

typedef struct _CM_CC_CAPABILITY_T<s(1)(0)(1)>[&]
{
    command_tt<s(1)(1)(0)>[T]            head<s(1)(1)(0)>[&];
    eNeHOCCCapability<s(1)(1)(0)>[T]       eHOCCCapability<s(1)(1)(0)>[&];
    eNeLOCCCapability<s(1)(1)(0)>[T]       eLOCCCapability<s(1)(1)(0)>[&];
} CM_CC_CAPABILITY_T<s(0)(0)(0)>[&];(D1:CM_CC_CAPABILITY_T:1)[[TYPENAME:CM_CC_CAPABILITY_T]]

typedef struct _CM_REBOOTCARD_T<s(1)(0)(1)>[&]
{
    command_tt<s(1)(1)(0)>[T]          head<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T] slot<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T]   warm<s(1)(1)(0)>[&];
} CM_REBOOTCARD_T<s(0)(0)(0)>[&];(D1:CM_REBOOTCARD_T:1)[[TYPENAME:CM_REBOOTCARD_T]]














 








 

 
 
 
 
 
 
 
 
 
 
 




 








 




 



 
extern MIBDid_t<s(0)(0)(0)>[T] iso_Did<s(0)(0)(0)>[&];(D1:iso_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] org_Did<s(0)(0)(0)>[&];(D1:org_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] dod_Did<s(0)(0)(0)>[&];(D1:dod_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] internet_Did<s(0)(0)(0)>[&];(D1:internet_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] mgmt_Did<s(0)(0)(0)>[&];(D1:mgmt_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] private_Did<s(0)(0)(0)>[&];(D1:private_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpV2_Did<s(0)(0)(0)>[&];(D1:snmpV2_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpModules_Did<s(0)(0)(0)>[&];(D1:snmpModules_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] enterprises_Did<s(0)(0)(0)>[&];(D1:enterprises_Did:0)

   








 




 



 
extern MIBDid_t<s(0)(0)(0)>[T] mib_2_Did<s(0)(0)(0)>[&];(D1:mib_2_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] at_Did<s(0)(0)(0)>[&];(D1:at_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] ip_Did<s(0)(0)(0)>[&];(D1:ip_Did:0)

   
typedef enum {
	ipForwarding_forwarding<s(0)(0)(0)>[&]=1,
	ipForwarding_not_forwarding<s(0)(0)(0)>[&]=2
} ipForwarding_Tval<s(0)(0)(0)>[&];(D1:ipForwarding_Tval:1)[[TYPENAME:ipForwarding_Tval]]

typedef struct
{
	ipForwarding_Tval<s(1)(1)(0)>[T] ipForwarding<s(1)(1)(0)>[&];
	int		ipDefaultTTL<s(1)(1)(0)>[&];
	unsigned int	ipInReceives<s(1)(1)(0)>[&];
	unsigned int	ipInHdrErrors<s(1)(1)(0)>[&];
	unsigned int	ipInAddrErrors<s(1)(1)(0)>[&];
	unsigned int	ipForwDatagrams<s(1)(1)(0)>[&];
	unsigned int	ipInUnknownProtos<s(1)(1)(0)>[&];
	unsigned int	ipInDiscards<s(1)(1)(0)>[&];
	unsigned int	ipInDelivers<s(1)(1)(0)>[&];
	unsigned int	ipOutRequests<s(1)(1)(0)>[&];
	unsigned int	ipOutDiscards<s(1)(1)(0)>[&];
	unsigned int	ipOutNoRoutes<s(1)(1)(0)>[&];
	int		ipReasmTimeout<s(1)(1)(0)>[&];
	unsigned int	ipReasmReqds<s(1)(1)(0)>[&];
	unsigned int	ipReasmOKs<s(1)(1)(0)>[&];
	unsigned int	ipReasmFails<s(1)(1)(0)>[&];
	unsigned int	ipFragOKs<s(1)(1)(0)>[&];
	unsigned int	ipFragFails<s(1)(1)(0)>[&];
	unsigned int	ipFragCreates<s(1)(1)(0)>[&];
	unsigned int	ipRoutingDiscards<s(1)(1)(0)>[&];
}MIBip_t<s(0)(0)(0)>[&];(D1:MIBip_t:1)[[TYPENAME:MIBip_t]]

























 



 
extern MIBDid_t<s(0)(0)(0)>[T] icmp_Did<s(0)(0)(0)>[&];(D1:icmp_Did:0)

   
typedef struct
{
	unsigned int	icmpInMsgs<s(1)(1)(0)>[&];
	unsigned int	icmpInErrors<s(1)(1)(0)>[&];
	unsigned int	icmpInDestUnreachs<s(1)(1)(0)>[&];
	unsigned int	icmpInTimeExcds<s(1)(1)(0)>[&];
	unsigned int	icmpInParmProbs<s(1)(1)(0)>[&];
	unsigned int	icmpInSrcQuenchs<s(1)(1)(0)>[&];
	unsigned int	icmpInRedirects<s(1)(1)(0)>[&];
	unsigned int	icmpInEchos<s(1)(1)(0)>[&];
	unsigned int	icmpInEchoReps<s(1)(1)(0)>[&];
	unsigned int	icmpInTimestamps<s(1)(1)(0)>[&];
	unsigned int	icmpInTimestampReps<s(1)(1)(0)>[&];
	unsigned int	icmpInAddrMasks<s(1)(1)(0)>[&];
	unsigned int	icmpInAddrMaskReps<s(1)(1)(0)>[&];
	unsigned int	icmpOutMsgs<s(1)(1)(0)>[&];
	unsigned int	icmpOutErrors<s(1)(1)(0)>[&];
	unsigned int	icmpOutDestUnreachs<s(1)(1)(0)>[&];
	unsigned int	icmpOutTimeExcds<s(1)(1)(0)>[&];
	unsigned int	icmpOutParmProbs<s(1)(1)(0)>[&];
	unsigned int	icmpOutSrcQuenchs<s(1)(1)(0)>[&];
	unsigned int	icmpOutRedirects<s(1)(1)(0)>[&];
	unsigned int	icmpOutEchos<s(1)(1)(0)>[&];
	unsigned int	icmpOutEchoReps<s(1)(1)(0)>[&];
	unsigned int	icmpOutTimestamps<s(1)(1)(0)>[&];
	unsigned int	icmpOutTimestampReps<s(1)(1)(0)>[&];
	unsigned int	icmpOutAddrMasks<s(1)(1)(0)>[&];
	unsigned int	icmpOutAddrMaskReps<s(1)(1)(0)>[&];
}MIBicmp_t<s(0)(0)(0)>[&];(D1:MIBicmp_t:1)[[TYPENAME:MIBicmp_t]]































 



 
extern MIBDid_t<s(0)(0)(0)>[T] tcp_Did<s(0)(0)(0)>[&];(D1:tcp_Did:0)

   
typedef enum {
	tcpRtoAlgorithm_other<s(0)(0)(0)>[&]=1,
	tcpRtoAlgorithm_constant<s(0)(0)(0)>[&]=2,
	tcpRtoAlgorithm_rsre<s(0)(0)(0)>[&]=3,
	tcpRtoAlgorithm_vanj<s(0)(0)(0)>[&]=4
} tcpRtoAlgorithm_Tval<s(0)(0)(0)>[&];(D1:tcpRtoAlgorithm_Tval:1)[[TYPENAME:tcpRtoAlgorithm_Tval]]

typedef struct
{
	tcpRtoAlgorithm_Tval<s(1)(1)(0)>[T] tcpRtoAlgorithm<s(1)(1)(0)>[&];
	int		tcpRtoMin<s(1)(1)(0)>[&];
	int		tcpRtoMax<s(1)(1)(0)>[&];
	int		tcpMaxConn<s(1)(1)(0)>[&];
	unsigned int	tcpActiveOpens<s(1)(1)(0)>[&];
	unsigned int	tcpPassiveOpens<s(1)(1)(0)>[&];
	unsigned int	tcpAttemptFails<s(1)(1)(0)>[&];
	unsigned int	tcpEstabResets<s(1)(1)(0)>[&];
	unsigned int	tcpCurrEstab<s(1)(1)(0)>[&];
	unsigned int	tcpInSegs<s(1)(1)(0)>[&];
	unsigned int	tcpOutSegs<s(1)(1)(0)>[&];
	unsigned int	tcpRetransSegs<s(1)(1)(0)>[&];
	unsigned int	tcpInErrs<s(1)(1)(0)>[&];
	unsigned int	tcpOutRsts<s(1)(1)(0)>[&];
}MIBtcp_t<s(0)(0)(0)>[&];(D1:MIBtcp_t:1)[[TYPENAME:MIBtcp_t]]



















 



 
extern MIBDid_t<s(0)(0)(0)>[T] udp_Did<s(0)(0)(0)>[&];(D1:udp_Did:0)

   
typedef struct
{
	unsigned int	udpInDatagrams<s(1)(1)(0)>[&];
	unsigned int	udpNoPorts<s(1)(1)(0)>[&];
	unsigned int	udpInErrors<s(1)(1)(0)>[&];
	unsigned int	udpOutDatagrams<s(1)(1)(0)>[&];
}MIBudp_t<s(0)(0)(0)>[&];(D1:MIBudp_t:1)[[TYPENAME:MIBudp_t]]









 



 
extern MIBDid_t<s(0)(0)(0)>[T] egp_Did<s(0)(0)(0)>[&];(D1:egp_Did:0)

   
typedef struct
{
	unsigned int	egpInMsgs<s(1)(1)(0)>[&];
	unsigned int	egpInErrors<s(1)(1)(0)>[&];
	unsigned int	egpOutMsgs<s(1)(1)(0)>[&];
	unsigned int	egpOutErrors<s(1)(1)(0)>[&];
	int		egpAs<s(1)(1)(0)>[&];
}MIBegp_t<s(0)(0)(0)>[&];(D1:MIBegp_t:1)[[TYPENAME:MIBegp_t]]










 



 
extern MIBDid_t<s(0)(0)(0)>[T] transmission_Did<s(0)(0)(0)>[&];(D1:transmission_Did:0)

   


 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] egpNeighTable_Did<s(0)(0)(0)>[&];(D1:egpNeighTable_Did:0)

   
typedef enum {
	egpNeighState_idle<s(0)(0)(0)>[&]=1,
	egpNeighState_acquisition<s(0)(0)(0)>[&]=2,
	egpNeighState_down<s(0)(0)(0)>[&]=3,
	egpNeighState_up<s(0)(0)(0)>[&]=4,
	egpNeighState_cease<s(0)(0)(0)>[&]=5
} egpNeighState_Tval<s(0)(0)(0)>[&];(D1:egpNeighState_Tval:1)[[TYPENAME:egpNeighState_Tval]]

typedef enum {
	egpNeighMode_active<s(0)(0)(0)>[&]=1,
	egpNeighMode_passive<s(0)(0)(0)>[&]=2
} egpNeighMode_Tval<s(0)(0)(0)>[&];(D1:egpNeighMode_Tval:1)[[TYPENAME:egpNeighMode_Tval]]

typedef enum {
	egpNeighEventTrigger_start<s(0)(0)(0)>[&]=1,
	egpNeighEventTrigger_stop<s(0)(0)(0)>[&]=2
} egpNeighEventTrigger_Tval<s(0)(0)(0)>[&];(D1:egpNeighEventTrigger_Tval:1)[[TYPENAME:egpNeighEventTrigger_Tval]]

typedef struct
{
	unsigned int	egpNeighAddr<s(1)(1)(0)>[&];                                    
	egpNeighState_Tval<s(1)(1)(0)>[T] egpNeighState<s(1)(1)(0)>[&];
	int		egpNeighAs<s(1)(1)(0)>[&];
	unsigned int	egpNeighInMsgs<s(1)(1)(0)>[&];
	unsigned int	egpNeighInErrs<s(1)(1)(0)>[&];
	unsigned int	egpNeighOutMsgs<s(1)(1)(0)>[&];
	unsigned int	egpNeighOutErrs<s(1)(1)(0)>[&];
	unsigned int	egpNeighInErrMsgs<s(1)(1)(0)>[&];
	unsigned int	egpNeighOutErrMsgs<s(1)(1)(0)>[&];
	unsigned int	egpNeighStateUps<s(1)(1)(0)>[&];
	unsigned int	egpNeighStateDowns<s(1)(1)(0)>[&];
	int		egpNeighIntervalHello<s(1)(1)(0)>[&];
	int		egpNeighIntervalPoll<s(1)(1)(0)>[&];
	egpNeighMode_Tval<s(1)(1)(0)>[T] egpNeighMode<s(1)(1)(0)>[&];
	egpNeighEventTrigger_Tval<s(1)(1)(0)>[T] egpNeighEventTrigger<s(1)(1)(0)>[&];
}MIBegpNeighTable_t<s(0)(0)(0)>[&];(D1:MIBegpNeighTable_t:1)[[TYPENAME:MIBegpNeighTable_t]]






















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] udpTable_Did<s(0)(0)(0)>[&];(D1:udpTable_Did:0)

   
typedef struct
{
	unsigned int	udpLocalAddress<s(1)(1)(0)>[&];                     
	int		udpLocalPort<s(1)(1)(0)>[&];                                
}MIBudpTable_t<s(0)(0)(0)>[&];(D1:MIBudpTable_t:1)[[TYPENAME:MIBudpTable_t]]









 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] tcpConnTable_Did<s(0)(0)(0)>[&];(D1:tcpConnTable_Did:0)

   
typedef enum {
	tcpConnState_closed<s(0)(0)(0)>[&]=1,
	tcpConnState_listen<s(0)(0)(0)>[&]=2,
	tcpConnState_synSent<s(0)(0)(0)>[&]=3,
	tcpConnState_synReceived<s(0)(0)(0)>[&]=4,
	tcpConnState_established<s(0)(0)(0)>[&]=5,
	tcpConnState_finWait1<s(0)(0)(0)>[&]=6,
	tcpConnState_finWait2<s(0)(0)(0)>[&]=7,
	tcpConnState_closeWait<s(0)(0)(0)>[&]=8,
	tcpConnState_lastAck<s(0)(0)(0)>[&]=9,
	tcpConnState_closing<s(0)(0)(0)>[&]=10,
	tcpConnState_timeWait<s(0)(0)(0)>[&]=11,
	tcpConnState_deleteTCB<s(0)(0)(0)>[&]=12
} tcpConnState_Tval<s(0)(0)(0)>[&];(D1:tcpConnState_Tval:1)[[TYPENAME:tcpConnState_Tval]]

typedef struct
{
	unsigned int	tcpConnLocalAddress<s(1)(1)(0)>[&];                         
	int		tcpConnLocalPort<s(1)(1)(0)>[&];                                    
	unsigned int	tcpConnRemAddress<s(1)(1)(0)>[&];                           
	int		tcpConnRemPort<s(1)(1)(0)>[&];                                      
	tcpConnState_Tval<s(1)(1)(0)>[T] tcpConnState<s(1)(1)(0)>[&];
}MIBtcpConnTable_t<s(0)(0)(0)>[&];(D1:MIBtcpConnTable_t:1)[[TYPENAME:MIBtcpConnTable_t]]












 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] ipAddrTable_Did<s(0)(0)(0)>[&];(D1:ipAddrTable_Did:0)

   
typedef struct
{
	unsigned int	ipAdEntAddr<s(1)(1)(0)>[&];                                 
	int		ipAdEntIfIndex<s(1)(1)(0)>[&];
	unsigned int	ipAdEntNetMask<s(1)(1)(0)>[&];
	unsigned int	ipAdEntBcastAddr<s(1)(1)(0)>[&];
	int		ipAdEntReasmMaxSize<s(1)(1)(0)>[&];
}MIBipAddrTable_t<s(0)(0)(0)>[&];(D1:MIBipAddrTable_t:1)[[TYPENAME:MIBipAddrTable_t]]












 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] ipRouteTable_Did<s(0)(0)(0)>[&];(D1:ipRouteTable_Did:0)

   
typedef enum {
	ipRouteType_other<s(0)(0)(0)>[&]=1,
	ipRouteType_invalid<s(0)(0)(0)>[&]=2,
	ipRouteType_direct<s(0)(0)(0)>[&]=3,
	ipRouteType_indirect<s(0)(0)(0)>[&]=4
} ipRouteType_Tval<s(0)(0)(0)>[&];(D1:ipRouteType_Tval:1)[[TYPENAME:ipRouteType_Tval]]

typedef enum {
	ipRouteProto_other<s(0)(0)(0)>[&]=1,
	ipRouteProto_local<s(0)(0)(0)>[&]=2,
	ipRouteProto_netmgmt<s(0)(0)(0)>[&]=3,
	ipRouteProto_icmp<s(0)(0)(0)>[&]=4,
	ipRouteProto_egp<s(0)(0)(0)>[&]=5,
	ipRouteProto_ggp<s(0)(0)(0)>[&]=6,
	ipRouteProto_hello<s(0)(0)(0)>[&]=7,
	ipRouteProto_rip<s(0)(0)(0)>[&]=8,
	ipRouteProto_is_is<s(0)(0)(0)>[&]=9,
	ipRouteProto_es_is<s(0)(0)(0)>[&]=10,
	ipRouteProto_ciscoIgrp<s(0)(0)(0)>[&]=11,
	ipRouteProto_bbnSpfIgp<s(0)(0)(0)>[&]=12,
	ipRouteProto_ospf<s(0)(0)(0)>[&]=13,
	ipRouteProto_bgp<s(0)(0)(0)>[&]=14
} ipRouteProto_Tval<s(0)(0)(0)>[&];(D1:ipRouteProto_Tval:1)[[TYPENAME:ipRouteProto_Tval]]

typedef struct
{
	unsigned int	ipRouteDest<s(1)(1)(0)>[&];                       
	int		ipRouteIfIndex<s(1)(1)(0)>[&];
	int		ipRouteMetric1<s(1)(1)(0)>[&];
	int		ipRouteMetric2<s(1)(1)(0)>[&];
	int		ipRouteMetric3<s(1)(1)(0)>[&];
	int		ipRouteMetric4<s(1)(1)(0)>[&];
	unsigned int	ipRouteNextHop<s(1)(1)(0)>[&];
	ipRouteType_Tval<s(1)(1)(0)>[T] ipRouteType<s(1)(1)(0)>[&];
	ipRouteProto_Tval<s(1)(1)(0)>[T] ipRouteProto<s(1)(1)(0)>[&];
	int		ipRouteAge<s(1)(1)(0)>[&];
	unsigned int	ipRouteMask<s(1)(1)(0)>[&];
	int		ipRouteMetric5<s(1)(1)(0)>[&];
	OIDValue<s(1)(1)(0)>[T]	ipRouteInfo<s(1)(1)(0)>[&];
}MIBipRouteTable_t<s(0)(0)(0)>[&];(D1:MIBipRouteTable_t:1)[[TYPENAME:MIBipRouteTable_t]]




















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] ipNetToMediaTable_Did<s(0)(0)(0)>[&];(D1:ipNetToMediaTable_Did:0)

   
typedef enum {
	ipNetToMediaType_other<s(0)(0)(0)>[&]=1,
	ipNetToMediaType_invalid<s(0)(0)(0)>[&]=2,
	ipNetToMediaType_dynamic<s(0)(0)(0)>[&]=3,
	ipNetToMediaType_static<s(0)(0)(0)>[&]=4
} ipNetToMediaType_Tval<s(0)(0)(0)>[&];(D1:ipNetToMediaType_Tval:1)[[TYPENAME:ipNetToMediaType_Tval]]

typedef struct
{
	int		ipNetToMediaIfIndex<s(1)(1)(0)>[&];                                         
	unsigned int	ipNetToMediaNetAddress<s(1)(1)(0)>[&];                              
	int		ipNetToMediaPhysAddress_len<s(1)(1)(0)>[&];
	char		ipNetToMediaPhysAddress<s(1)(1)(0)>[&][255];
	ipNetToMediaType_Tval<s(1)(1)(0)>[T] ipNetToMediaType<s(1)(1)(0)>[&];
}MIBipNetToMediaTable_t<s(0)(0)(0)>[&];(D1:MIBipNetToMediaTable_t:1)[[TYPENAME:MIBipNetToMediaTable_t]]











 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] atTable_Did<s(0)(0)(0)>[&];(D1:atTable_Did:0)

   
typedef struct
{
	int		atIfIndex<s(1)(1)(0)>[&];                               
	int		atNetAddress_len<s(1)(1)(0)>[&];
	char		atNetAddress<s(1)(1)(0)>[&][8];                        
	int		atPhysAddress_len<s(1)(1)(0)>[&];
	char		atPhysAddress<s(1)(1)(0)>[&][255];
}MIBatTable_t<s(0)(0)(0)>[&];(D1:MIBatTable_t:1)[[TYPENAME:MIBatTable_t]]















 




 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpMIB_Did<s(0)(0)(0)>[&];(D1:snmpMIB_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpMIBObjects_Did<s(0)(0)(0)>[&];(D1:snmpMIBObjects_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpMIBConformance_Did<s(0)(0)(0)>[&];(D1:snmpMIBConformance_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpMIBCompliances_Did<s(0)(0)(0)>[&];(D1:snmpMIBCompliances_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpMIBGroups_Did<s(0)(0)(0)>[&];(D1:snmpMIBGroups_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpTrap_Did<s(0)(0)(0)>[&];(D1:snmpTrap_Did:0)

   
typedef struct
{
	OIDValue<s(1)(1)(0)>[T]	snmpTrapOID<s(1)(1)(0)>[&];
	OIDValue<s(1)(1)(0)>[T]	snmpTrapEnterprise<s(1)(1)(0)>[&];
}MIBsnmpTrap_t<s(0)(0)(0)>[&];(D1:MIBsnmpTrap_t:1)[[TYPENAME:MIBsnmpTrap_t]]







 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpTraps_Did<s(0)(0)(0)>[&];(D1:snmpTraps_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpSet_Did<s(0)(0)(0)>[&];(D1:snmpSet_Did:0)

   
typedef struct
{
	unsigned int	snmpSetSerialNo<s(1)(1)(0)>[&];
}MIBsnmpSet_t<s(0)(0)(0)>[&];(D1:MIBsnmpSet_t:1)[[TYPENAME:MIBsnmpSet_t]]






 



 
extern MIBDid_t<s(0)(0)(0)>[T] system_Did<s(0)(0)(0)>[&];(D1:system_Did:0)

   
typedef struct
{
	char		sysDescr<s(1)(1)(0)>[&][255];
	OIDValue<s(1)(1)(0)>[T]	sysObjectID<s(1)(1)(0)>[&];
	unsigned int	sysUpTime<s(1)(1)(0)>[&];
	char		sysContact<s(1)(1)(0)>[&][255];
	char		sysName<s(1)(1)(0)>[&][255];
	char		sysLocation<s(1)(1)(0)>[&][255];
	int		sysServices<s(1)(1)(0)>[&];
	unsigned int	sysORLastChange<s(1)(1)(0)>[&];
}MIBsystem_t<s(0)(0)(0)>[&];(D1:MIBsystem_t:1)[[TYPENAME:MIBsystem_t]]













 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmp_Did<s(0)(0)(0)>[&];(D1:snmp_Did:0)

   
typedef enum {
	snmpEnableAuthenTraps_enabled<s(0)(0)(0)>[&]=1,
	snmpEnableAuthenTraps_disabled<s(0)(0)(0)>[&]=2
} snmpEnableAuthenTraps_Tval<s(0)(0)(0)>[&];(D1:snmpEnableAuthenTraps_Tval:1)[[TYPENAME:snmpEnableAuthenTraps_Tval]]

typedef struct
{
	unsigned int	snmpInPkts<s(1)(1)(0)>[&];
	unsigned int	snmpInBadVersions<s(1)(1)(0)>[&];
	unsigned int	snmpOutPkts<s(1)(1)(0)>[&];
	unsigned int	snmpInBadCommunityNames<s(1)(1)(0)>[&];
	unsigned int	snmpInBadCommunityUses<s(1)(1)(0)>[&];
	unsigned int	snmpInASNParseErrs<s(1)(1)(0)>[&];
	snmpEnableAuthenTraps_Tval<s(1)(1)(0)>[T] snmpEnableAuthenTraps<s(1)(1)(0)>[&];
	unsigned int	snmpOutTraps<s(1)(1)(0)>[&];
	unsigned int	snmpOutGetResponses<s(1)(1)(0)>[&];
	unsigned int	snmpOutSetRequests<s(1)(1)(0)>[&];
	unsigned int	snmpOutGetNexts<s(1)(1)(0)>[&];
	unsigned int	snmpOutGetRequests<s(1)(1)(0)>[&];
	unsigned int	snmpOutGenErrs<s(1)(1)(0)>[&];
	unsigned int	snmpOutBadValues<s(1)(1)(0)>[&];
	unsigned int	snmpOutNoSuchNames<s(1)(1)(0)>[&];
	unsigned int	snmpOutTooBigs<s(1)(1)(0)>[&];
	unsigned int	snmpInTraps<s(1)(1)(0)>[&];
	unsigned int	snmpInGetResponses<s(1)(1)(0)>[&];
	unsigned int	snmpInSetRequests<s(1)(1)(0)>[&];
	unsigned int	snmpInGetNexts<s(1)(1)(0)>[&];
	unsigned int	snmpInGetRequests<s(1)(1)(0)>[&];
	unsigned int	snmpInTotalSetVars<s(1)(1)(0)>[&];
	unsigned int	snmpInTotalReqVars<s(1)(1)(0)>[&];
	unsigned int	snmpInGenErrs<s(1)(1)(0)>[&];
	unsigned int	snmpInReadOnlys<s(1)(1)(0)>[&];
	unsigned int	snmpInBadValues<s(1)(1)(0)>[&];
	unsigned int	snmpInNoSuchNames<s(1)(1)(0)>[&];
	unsigned int	snmpInTooBigs<s(1)(1)(0)>[&];
	unsigned int	snmpSilentDrops<s(1)(1)(0)>[&];
	unsigned int	snmpProxyDrops<s(1)(1)(0)>[&];
}MIBsnmp_t<s(0)(0)(0)>[&];(D1:MIBsnmp_t:1)[[TYPENAME:MIBsnmp_t]]



































 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] sysORTable_Did<s(0)(0)(0)>[&];(D1:sysORTable_Did:0)

   
typedef struct
{
	int		sysORIndex<s(1)(1)(0)>[&];                          
	OIDValue<s(1)(1)(0)>[T]	sysORID<s(1)(1)(0)>[&];
	char		sysORDescr<s(1)(1)(0)>[&][255];
	unsigned int	sysORUpTime<s(1)(1)(0)>[&];
}MIBsysORTable_t<s(0)(0)(0)>[&];(D1:MIBsysORTable_t:1)[[TYPENAME:MIBsysORTable_t]]
















 




 



 
extern MIBDid_t<s(0)(0)(0)>[T] ianaifType_Did<s(0)(0)(0)>[&];(D1:ianaifType_Did:0)

   







 




 



 
extern MIBDid_t<s(0)(0)(0)>[T] interfaces_Did<s(0)(0)(0)>[&];(D1:interfaces_Did:0)

   
typedef struct
{
	int		ifNumber<s(1)(1)(0)>[&];
}MIBinterfaces_t<s(0)(0)(0)>[&];(D1:MIBinterfaces_t:1)[[TYPENAME:MIBinterfaces_t]]






 



 
extern MIBDid_t<s(0)(0)(0)>[T] ifMIB_Did<s(0)(0)(0)>[&];(D1:ifMIB_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] ifMIBObjects_Did<s(0)(0)(0)>[&];(D1:ifMIBObjects_Did:0)

   
typedef struct
{
	unsigned int	ifTableLastChange<s(1)(1)(0)>[&];
	unsigned int	ifStackLastChange<s(1)(1)(0)>[&];
}MIBifMIBObjects_t<s(0)(0)(0)>[&];(D1:MIBifMIBObjects_t:1)[[TYPENAME:MIBifMIBObjects_t]]







 



 
extern MIBDid_t<s(0)(0)(0)>[T] ifConformance_Did<s(0)(0)(0)>[&];(D1:ifConformance_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] ifGroups_Did<s(0)(0)(0)>[&];(D1:ifGroups_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] ifCompliances_Did<s(0)(0)(0)>[&];(D1:ifCompliances_Did:0)

   


 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] ifXTable_Did<s(0)(0)(0)>[&];(D1:ifXTable_Did:0)

   
typedef enum {
	ifLinkUpDownTrapEnable_enabled<s(0)(0)(0)>[&]=1,
	ifLinkUpDownTrapEnable_disabled<s(0)(0)(0)>[&]=2
} ifLinkUpDownTrapEnable_Tval<s(0)(0)(0)>[&];(D1:ifLinkUpDownTrapEnable_Tval:1)[[TYPENAME:ifLinkUpDownTrapEnable_Tval]]

typedef struct
{
	int		ifIndex<s(1)(1)(0)>[&];                                                           
	char		ifName<s(1)(1)(0)>[&][255];
	unsigned int	ifInMulticastPkts<s(1)(1)(0)>[&];
	unsigned int	ifInBroadcastPkts<s(1)(1)(0)>[&];
	unsigned int	ifOutMulticastPkts<s(1)(1)(0)>[&];
	unsigned int	ifOutBroadcastPkts<s(1)(1)(0)>[&];
	unsigned int	ifHCInOctets<s(1)(1)(0)>[&][2];
	unsigned int	ifHCInUcastPkts<s(1)(1)(0)>[&][2];
	unsigned int	ifHCInMulticastPkts<s(1)(1)(0)>[&][2];
	unsigned int	ifHCInBroadcastPkts<s(1)(1)(0)>[&][2];
	unsigned int	ifHCOutOctets<s(1)(1)(0)>[&][2];
	unsigned int	ifHCOutUcastPkts<s(1)(1)(0)>[&][2];
	unsigned int	ifHCOutMulticastPkts<s(1)(1)(0)>[&][2];
	unsigned int	ifHCOutBroadcastPkts<s(1)(1)(0)>[&][2];
	ifLinkUpDownTrapEnable_Tval<s(1)(1)(0)>[T] ifLinkUpDownTrapEnable<s(1)(1)(0)>[&];
	unsigned int	ifHighSpeed<s(1)(1)(0)>[&];
	TruthValue_Tval<s(1)(1)(0)>[T] ifPromiscuousMode<s(1)(1)(0)>[&];
	TruthValue_Tval<s(1)(1)(0)>[T] ifConnectorPresent<s(1)(1)(0)>[&];
	char		ifAlias<s(1)(1)(0)>[&][64];
	unsigned int	ifCounterDiscontinuityTime<s(1)(1)(0)>[&];
}MIBifXTable_t<s(0)(0)(0)>[&];(D1:MIBifXTable_t:1)[[TYPENAME:MIBifXTable_t]]



























 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] ifTestTable_Did<s(0)(0)(0)>[&];(D1:ifTestTable_Did:0)

   
typedef enum {
	ifTestStatus_notInUse<s(0)(0)(0)>[&]=1,
	ifTestStatus_inUse<s(0)(0)(0)>[&]=2
} ifTestStatus_Tval<s(0)(0)(0)>[&];(D1:ifTestStatus_Tval:1)[[TYPENAME:ifTestStatus_Tval]]

typedef enum {
	ifTestResult_none<s(0)(0)(0)>[&]=1,
	ifTestResult_success<s(0)(0)(0)>[&]=2,
	ifTestResult_inProgress<s(0)(0)(0)>[&]=3,
	ifTestResult_notSupported<s(0)(0)(0)>[&]=4,
	ifTestResult_unAbleToRun<s(0)(0)(0)>[&]=5,
	ifTestResult_aborted<s(0)(0)(0)>[&]=6,
	ifTestResult_failed<s(0)(0)(0)>[&]=7
} ifTestResult_Tval<s(0)(0)(0)>[&];(D1:ifTestResult_Tval:1)[[TYPENAME:ifTestResult_Tval]]

typedef struct
{
	int		ifIndex<s(1)(1)(0)>[&];                               
	unsigned int	ifTestId<s(1)(1)(0)>[&];
	ifTestStatus_Tval<s(1)(1)(0)>[T] ifTestStatus<s(1)(1)(0)>[&];
	OIDValue<s(1)(1)(0)>[T]	ifTestType<s(1)(1)(0)>[&];
	ifTestResult_Tval<s(1)(1)(0)>[T] ifTestResult<s(1)(1)(0)>[&];
	OIDValue<s(1)(1)(0)>[T]	ifTestCode<s(1)(1)(0)>[&];
	int		ifTestOwner_len<s(1)(1)(0)>[&];
	char		ifTestOwner<s(1)(1)(0)>[&][255];
}MIBifTestTable_t<s(0)(0)(0)>[&];(D1:MIBifTestTable_t:1)[[TYPENAME:MIBifTestTable_t]]














 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] ifRcvAddressTable_Did<s(0)(0)(0)>[&];(D1:ifRcvAddressTable_Did:0)

   
typedef enum {
	ifRcvAddressType_other<s(0)(0)(0)>[&]=1,
	ifRcvAddressType_volatile<s(0)(0)(0)>[&]=2,
	ifRcvAddressType_nonVolatile<s(0)(0)(0)>[&]=3
} ifRcvAddressType_Tval<s(0)(0)(0)>[&];(D1:ifRcvAddressType_Tval:1)[[TYPENAME:ifRcvAddressType_Tval]]

typedef struct
{
	int		ifIndex<s(1)(1)(0)>[&];                                             
	int		ifRcvAddressAddress_len<s(1)(1)(0)>[&];
	char		ifRcvAddressAddress<s(1)(1)(0)>[&][255];                           
	RowStatus_Tval<s(1)(1)(0)>[T] ifRcvAddressStatus<s(1)(1)(0)>[&];
	ifRcvAddressType_Tval<s(1)(1)(0)>[T] ifRcvAddressType<s(1)(1)(0)>[&];
}MIBifRcvAddressTable_t<s(0)(0)(0)>[&];(D1:MIBifRcvAddressTable_t:1)[[TYPENAME:MIBifRcvAddressTable_t]]











 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] ifStackTable_Did<s(0)(0)(0)>[&];(D1:ifStackTable_Did:0)

   
typedef struct
{
	int		ifStackHigherLayer<s(1)(1)(0)>[&];                                
	int		ifStackLowerLayer<s(1)(1)(0)>[&];                                 
	RowStatus_Tval<s(1)(1)(0)>[T] ifStackStatus<s(1)(1)(0)>[&];
}MIBifStackTable_t<s(0)(0)(0)>[&];(D1:MIBifStackTable_t:1)[[TYPENAME:MIBifStackTable_t]]










 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] ifTable_Did<s(0)(0)(0)>[&];(D1:ifTable_Did:0)

   
typedef enum {
	ifAdminStatus_up<s(0)(0)(0)>[&]=1,
	ifAdminStatus_down<s(0)(0)(0)>[&]=2,
	ifAdminStatus_testing<s(0)(0)(0)>[&]=3
} ifAdminStatus_Tval<s(0)(0)(0)>[&];(D1:ifAdminStatus_Tval:1)[[TYPENAME:ifAdminStatus_Tval]]

typedef enum {
	ifOperStatus_up<s(0)(0)(0)>[&]=1,
	ifOperStatus_down<s(0)(0)(0)>[&]=2,
	ifOperStatus_testing<s(0)(0)(0)>[&]=3,
	ifOperStatus_unknown<s(0)(0)(0)>[&]=4,
	ifOperStatus_dormant<s(0)(0)(0)>[&]=5,
	ifOperStatus_notPresent<s(0)(0)(0)>[&]=6,
	ifOperStatus_lowerLayerDown<s(0)(0)(0)>[&]=7
} ifOperStatus_Tval<s(0)(0)(0)>[&];(D1:ifOperStatus_Tval:1)[[TYPENAME:ifOperStatus_Tval]]

typedef struct
{
	int		ifIndex<s(1)(1)(0)>[&];                                         
	char		ifDescr<s(1)(1)(0)>[&][255];
	IANAifType_Tval<s(1)(1)(0)>[T] ifType<s(1)(1)(0)>[&];
	int		ifMtu<s(1)(1)(0)>[&];
	unsigned int	ifSpeed<s(1)(1)(0)>[&];
	int		ifPhysAddress_len<s(1)(1)(0)>[&];
	char		ifPhysAddress<s(1)(1)(0)>[&][255];
	ifAdminStatus_Tval<s(1)(1)(0)>[T] ifAdminStatus<s(1)(1)(0)>[&];
	ifOperStatus_Tval<s(1)(1)(0)>[T] ifOperStatus<s(1)(1)(0)>[&];
	unsigned int	ifLastChange<s(1)(1)(0)>[&];
	unsigned int	ifInOctets<s(1)(1)(0)>[&];
	unsigned int	ifInUcastPkts<s(1)(1)(0)>[&];
	unsigned int	ifInNUcastPkts<s(1)(1)(0)>[&];
	unsigned int	ifInDiscards<s(1)(1)(0)>[&];
	unsigned int	ifInErrors<s(1)(1)(0)>[&];
	unsigned int	ifInUnknownProtos<s(1)(1)(0)>[&];
	unsigned int	ifOutOctets<s(1)(1)(0)>[&];
	unsigned int	ifOutUcastPkts<s(1)(1)(0)>[&];
	unsigned int	ifOutNUcastPkts<s(1)(1)(0)>[&];
	unsigned int	ifOutDiscards<s(1)(1)(0)>[&];
	unsigned int	ifOutErrors<s(1)(1)(0)>[&];
	unsigned int	ifOutQLen<s(1)(1)(0)>[&];
	OIDValue<s(1)(1)(0)>[T]	ifSpecific<s(1)(1)(0)>[&];
}MIBifTable_t<s(0)(0)(0)>[&];(D1:MIBifTable_t:1)[[TYPENAME:MIBifTable_t]]


































 




 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpFrameworkMIB_Did<s(0)(0)(0)>[&];(D1:snmpFrameworkMIB_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpFrameworkAdmin_Did<s(0)(0)(0)>[&];(D1:snmpFrameworkAdmin_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpFrameworkMIBObjects_Did<s(0)(0)(0)>[&];(D1:snmpFrameworkMIBObjects_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpFrameworkMIBConformance_Did<s(0)(0)(0)>[&];(D1:snmpFrameworkMIBConformance_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpFrameworkMIBCompliances_Did<s(0)(0)(0)>[&];(D1:snmpFrameworkMIBCompliances_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpFrameworkMIBGroups_Did<s(0)(0)(0)>[&];(D1:snmpFrameworkMIBGroups_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpEngine_Did<s(0)(0)(0)>[&];(D1:snmpEngine_Did:0)

   
typedef struct
{
	int		snmpEngineID_len<s(1)(1)(0)>[&];
	char		snmpEngineID<s(1)(1)(0)>[&][32];
	int		snmpEngineBoots<s(1)(1)(0)>[&];
	int		snmpEngineTime<s(1)(1)(0)>[&];
	int		snmpEngineMaxMessageSize<s(1)(1)(0)>[&];
}MIBsnmpEngine_t<s(0)(0)(0)>[&];(D1:MIBsnmpEngine_t:1)[[TYPENAME:MIBsnmpEngine_t]]









 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpAuthProtocols_Did<s(0)(0)(0)>[&];(D1:snmpAuthProtocols_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpPrivProtocols_Did<s(0)(0)(0)>[&];(D1:snmpPrivProtocols_Did:0)

   







 




 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpMPDMIB_Did<s(0)(0)(0)>[&];(D1:snmpMPDMIB_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpMPDAdmin_Did<s(0)(0)(0)>[&];(D1:snmpMPDAdmin_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpMPDMIBObjects_Did<s(0)(0)(0)>[&];(D1:snmpMPDMIBObjects_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpMPDMIBConformance_Did<s(0)(0)(0)>[&];(D1:snmpMPDMIBConformance_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpMPDMIBCompliances_Did<s(0)(0)(0)>[&];(D1:snmpMPDMIBCompliances_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpMPDMIBGroups_Did<s(0)(0)(0)>[&];(D1:snmpMPDMIBGroups_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpMPDStats_Did<s(0)(0)(0)>[&];(D1:snmpMPDStats_Did:0)

   
typedef struct
{
	unsigned int	snmpUnknownSecurityModels<s(1)(1)(0)>[&];
	unsigned int	snmpInvalidMsgs<s(1)(1)(0)>[&];
	unsigned int	snmpUnknownPDUHandlers<s(1)(1)(0)>[&];
}MIBsnmpMPDStats_t<s(0)(0)(0)>[&];(D1:MIBsnmpMPDStats_t:1)[[TYPENAME:MIBsnmpMPDStats_t]]













 




 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpTargetMIB_Did<s(0)(0)(0)>[&];(D1:snmpTargetMIB_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpTargetObjects_Did<s(0)(0)(0)>[&];(D1:snmpTargetObjects_Did:0)

   
typedef struct
{
	unsigned int	snmpTargetSpinLock<s(1)(1)(0)>[&];
	unsigned int	snmpUnavailableContexts<s(1)(1)(0)>[&];
	unsigned int	snmpUnknownContexts<s(1)(1)(0)>[&];
}MIBsnmpTargetObjects_t<s(0)(0)(0)>[&];(D1:MIBsnmpTargetObjects_t:1)[[TYPENAME:MIBsnmpTargetObjects_t]]








 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpTargetConformance_Did<s(0)(0)(0)>[&];(D1:snmpTargetConformance_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpTargetCompliances_Did<s(0)(0)(0)>[&];(D1:snmpTargetCompliances_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpTargetGroups_Did<s(0)(0)(0)>[&];(D1:snmpTargetGroups_Did:0)

   


 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] snmpTargetAddrTable_Did<s(0)(0)(0)>[&];(D1:snmpTargetAddrTable_Did:0)

   
typedef struct
{
	char		snmpTargetAddrName<s(1)(1)(0)>[&][32];                                         
	OIDValue<s(1)(1)(0)>[T]	snmpTargetAddrTDomain<s(1)(1)(0)>[&];
	int		snmpTargetAddrTAddress_len<s(1)(1)(0)>[&];
	char		snmpTargetAddrTAddress<s(1)(1)(0)>[&][255];
	int		snmpTargetAddrTimeout<s(1)(1)(0)>[&];
	int		snmpTargetAddrRetryCount<s(1)(1)(0)>[&];
	int		snmpTargetAddrTagList_len<s(1)(1)(0)>[&];
	char		snmpTargetAddrTagList<s(1)(1)(0)>[&][255];
	char		snmpTargetAddrParams<s(1)(1)(0)>[&][32];
	StorageType_Tval<s(1)(1)(0)>[T] snmpTargetAddrStorageType<s(1)(1)(0)>[&];
	RowStatus_Tval<s(1)(1)(0)>[T] snmpTargetAddrRowStatus<s(1)(1)(0)>[&];
}MIBsnmpTargetAddrTable_t<s(0)(0)(0)>[&];(D1:MIBsnmpTargetAddrTable_t:1)[[TYPENAME:MIBsnmpTargetAddrTable_t]]
















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] snmpTargetParamsTable_Did<s(0)(0)(0)>[&];(D1:snmpTargetParamsTable_Did:0)

   
typedef struct
{
	char		snmpTargetParamsName<s(1)(1)(0)>[&][32];                                               
	int		snmpTargetParamsMPModel<s(1)(1)(0)>[&];
	int		snmpTargetParamsSecurityModel<s(1)(1)(0)>[&];
	char		snmpTargetParamsSecurityName<s(1)(1)(0)>[&][255];
	SnmpSecurityLevel_Tval<s(1)(1)(0)>[T] snmpTargetParamsSecurityLevel<s(1)(1)(0)>[&];
	StorageType_Tval<s(1)(1)(0)>[T] snmpTargetParamsStorageType<s(1)(1)(0)>[&];
	RowStatus_Tval<s(1)(1)(0)>[T] snmpTargetParamsRowStatus<s(1)(1)(0)>[&];
}MIBsnmpTargetParamsTable_t<s(0)(0)(0)>[&];(D1:MIBsnmpTargetParamsTable_t:1)[[TYPENAME:MIBsnmpTargetParamsTable_t]]



















 




 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpNotificationMIB_Did<s(0)(0)(0)>[&];(D1:snmpNotificationMIB_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpNotifyObjects_Did<s(0)(0)(0)>[&];(D1:snmpNotifyObjects_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpNotifyConformance_Did<s(0)(0)(0)>[&];(D1:snmpNotifyConformance_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpNotifyCompliances_Did<s(0)(0)(0)>[&];(D1:snmpNotifyCompliances_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpNotifyGroups_Did<s(0)(0)(0)>[&];(D1:snmpNotifyGroups_Did:0)

   


 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] snmpNotifyTable_Did<s(0)(0)(0)>[&];(D1:snmpNotifyTable_Did:0)

   
typedef enum {
	snmpNotifyType_trap<s(0)(0)(0)>[&]=1,
	snmpNotifyType_inform<s(0)(0)(0)>[&]=2
} snmpNotifyType_Tval<s(0)(0)(0)>[&];(D1:snmpNotifyType_Tval:1)[[TYPENAME:snmpNotifyType_Tval]]

typedef struct
{
	char		snmpNotifyName<s(1)(1)(0)>[&][32];                                     
	int		snmpNotifyTag_len<s(1)(1)(0)>[&];
	char		snmpNotifyTag<s(1)(1)(0)>[&][255];
	snmpNotifyType_Tval<s(1)(1)(0)>[T] snmpNotifyType<s(1)(1)(0)>[&];
	StorageType_Tval<s(1)(1)(0)>[T] snmpNotifyStorageType<s(1)(1)(0)>[&];
	RowStatus_Tval<s(1)(1)(0)>[T] snmpNotifyRowStatus<s(1)(1)(0)>[&];
}MIBsnmpNotifyTable_t<s(0)(0)(0)>[&];(D1:MIBsnmpNotifyTable_t:1)[[TYPENAME:MIBsnmpNotifyTable_t]]












 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] snmpNotifyFilterProfileTable_Did<s(0)(0)(0)>[&];(D1:snmpNotifyFilterProfileTable_Did:0)

   
typedef struct
{
	char		snmpTargetParamsName<s(1)(1)(0)>[&][32];                                                     
	char		snmpNotifyFilterProfileName<s(1)(1)(0)>[&][32];
	StorageType_Tval<s(1)(1)(0)>[T] snmpNotifyFilterProfileStorType<s(1)(1)(0)>[&];
	RowStatus_Tval<s(1)(1)(0)>[T] snmpNotifyFilterProfileRowStatus<s(1)(1)(0)>[&];
}MIBsnmpNotifyFilterProfileTable_t<s(0)(0)(0)>[&];(D1:MIBsnmpNotifyFilterProfileTable_t:1)[[TYPENAME:MIBsnmpNotifyFilterProfileTable_t]]











 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] snmpNotifyFilterTable_Did<s(0)(0)(0)>[&];(D1:snmpNotifyFilterTable_Did:0)

   
typedef enum {
	snmpNotifyFilterType_included<s(0)(0)(0)>[&]=1,
	snmpNotifyFilterType_excluded<s(0)(0)(0)>[&]=2
} snmpNotifyFilterType_Tval<s(0)(0)(0)>[&];(D1:snmpNotifyFilterType_Tval:1)[[TYPENAME:snmpNotifyFilterType_Tval]]

typedef struct
{
	char		snmpNotifyFilterProfileName<s(1)(1)(0)>[&][32];                                    
	OIDValue<s(1)(1)(0)>[T]	snmpNotifyFilterSubtree<s(1)(1)(0)>[&];                                         
	int		snmpNotifyFilterMask_len<s(1)(1)(0)>[&];
	char		snmpNotifyFilterMask<s(1)(1)(0)>[&][16];
	snmpNotifyFilterType_Tval<s(1)(1)(0)>[T] snmpNotifyFilterType<s(1)(1)(0)>[&];
	StorageType_Tval<s(1)(1)(0)>[T] snmpNotifyFilterStorageType<s(1)(1)(0)>[&];
	RowStatus_Tval<s(1)(1)(0)>[T] snmpNotifyFilterRowStatus<s(1)(1)(0)>[&];
}MIBsnmpNotifyFilterTable_t<s(0)(0)(0)>[&];(D1:MIBsnmpNotifyFilterTable_t:1)[[TYPENAME:MIBsnmpNotifyFilterTable_t]]


















 




 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpUsmMIB_Did<s(0)(0)(0)>[&];(D1:snmpUsmMIB_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] usmMIBObjects_Did<s(0)(0)(0)>[&];(D1:usmMIBObjects_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] usmMIBConformance_Did<s(0)(0)(0)>[&];(D1:usmMIBConformance_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] usmMIBCompliances_Did<s(0)(0)(0)>[&];(D1:usmMIBCompliances_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] usmMIBGroups_Did<s(0)(0)(0)>[&];(D1:usmMIBGroups_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] usmStats_Did<s(0)(0)(0)>[&];(D1:usmStats_Did:0)

   
typedef struct
{
	unsigned int	usmStatsUnsupportedSecLevels<s(1)(1)(0)>[&];
	unsigned int	usmStatsNotInTimeWindows<s(1)(1)(0)>[&];
	unsigned int	usmStatsUnknownUserNames<s(1)(1)(0)>[&];
	unsigned int	usmStatsUnknownEngineIDs<s(1)(1)(0)>[&];
	unsigned int	usmStatsWrongDigests<s(1)(1)(0)>[&];
	unsigned int	usmStatsDecryptionErrors<s(1)(1)(0)>[&];
}MIBusmStats_t<s(0)(0)(0)>[&];(D1:MIBusmStats_t:1)[[TYPENAME:MIBusmStats_t]]











 



 
extern MIBDid_t<s(0)(0)(0)>[T] usmUser_Did<s(0)(0)(0)>[&];(D1:usmUser_Did:0)

   
typedef struct
{
	unsigned int	usmUserSpinLock<s(1)(1)(0)>[&];
}MIBusmUser_t<s(0)(0)(0)>[&];(D1:MIBusmUser_t:1)[[TYPENAME:MIBusmUser_t]]






 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] usmUserTable_Did<s(0)(0)(0)>[&];(D1:usmUserTable_Did:0)

   
typedef struct
{
	int		usmUserEngineID_len<s(1)(1)(0)>[&];
	char		usmUserEngineID<s(1)(1)(0)>[&][32];                                        
	char		usmUserName<s(1)(1)(0)>[&][32];                                            
	char		usmUserSecurityName<s(1)(1)(0)>[&][255];
	OIDValue<s(1)(1)(0)>[T]	usmUserCloneFrom<s(1)(1)(0)>[&];
	OIDValue<s(1)(1)(0)>[T]	usmUserAuthProtocol<s(1)(1)(0)>[&];
	int		usmUserAuthKeyChange_len<s(1)(1)(0)>[&];
	char		usmUserAuthKeyChange<s(1)(1)(0)>[&][255];
	int		usmUserOwnAuthKeyChange_len<s(1)(1)(0)>[&];
	char		usmUserOwnAuthKeyChange<s(1)(1)(0)>[&][255];
	OIDValue<s(1)(1)(0)>[T]	usmUserPrivProtocol<s(1)(1)(0)>[&];
	int		usmUserPrivKeyChange_len<s(1)(1)(0)>[&];
	char		usmUserPrivKeyChange<s(1)(1)(0)>[&][255];
	int		usmUserOwnPrivKeyChange_len<s(1)(1)(0)>[&];
	char		usmUserOwnPrivKeyChange<s(1)(1)(0)>[&][255];
	int		usmUserPublic_len<s(1)(1)(0)>[&];
	char		usmUserPublic<s(1)(1)(0)>[&][32];
	StorageType_Tval<s(1)(1)(0)>[T] usmUserStorageType<s(1)(1)(0)>[&];
	RowStatus_Tval<s(1)(1)(0)>[T] usmUserStatus<s(1)(1)(0)>[&];
}MIBusmUserTable_t<s(0)(0)(0)>[&];(D1:MIBusmUserTable_t:1)[[TYPENAME:MIBusmUserTable_t]]




















 



 
extern MIBDid_t<s(0)(0)(0)>[T] usmNoPrivProtocol_Did<s(0)(0)(0)>[&];(D1:usmNoPrivProtocol_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] usmDESPrivProtocol_Did<s(0)(0)(0)>[&];(D1:usmDESPrivProtocol_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] usmNoAuthProtocol_Did<s(0)(0)(0)>[&];(D1:usmNoAuthProtocol_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] usmHMACMD5AuthProtocol_Did<s(0)(0)(0)>[&];(D1:usmHMACMD5AuthProtocol_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] usmHMACSHAAuthProtocol_Did<s(0)(0)(0)>[&];(D1:usmHMACSHAAuthProtocol_Did:0)

   







 




 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpVacmMIB_Did<s(0)(0)(0)>[&];(D1:snmpVacmMIB_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] vacmMIBObjects_Did<s(0)(0)(0)>[&];(D1:vacmMIBObjects_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] vacmMIBConformance_Did<s(0)(0)(0)>[&];(D1:vacmMIBConformance_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] vacmMIBCompliances_Did<s(0)(0)(0)>[&];(D1:vacmMIBCompliances_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] vacmMIBGroups_Did<s(0)(0)(0)>[&];(D1:vacmMIBGroups_Did:0)

   


 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] vacmContextTable_Did<s(0)(0)(0)>[&];(D1:vacmContextTable_Did:0)

   
typedef struct
{
	char		vacmContextName<s(1)(1)(0)>[&][32];                        
}MIBvacmContextTable_t<s(0)(0)(0)>[&];(D1:MIBvacmContextTable_t:1)[[TYPENAME:MIBvacmContextTable_t]]








 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] vacmSecurityToGroupTable_Did<s(0)(0)(0)>[&];(D1:vacmSecurityToGroupTable_Did:0)

   
typedef struct
{
	int		vacmSecurityModel<s(1)(1)(0)>[&];                                                         
	char		vacmSecurityName<s(1)(1)(0)>[&][32];                                                     
	char		vacmGroupName<s(1)(1)(0)>[&][32];
	StorageType_Tval<s(1)(1)(0)>[T] vacmSecurityToGroupStorageType<s(1)(1)(0)>[&];
	RowStatus_Tval<s(1)(1)(0)>[T] vacmSecurityToGroupStatus<s(1)(1)(0)>[&];
}MIBvacmSecurityToGroupTable_t<s(0)(0)(0)>[&];(D1:MIBvacmSecurityToGroupTable_t:1)[[TYPENAME:MIBvacmSecurityToGroupTable_t]]












 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] vacmAccessTable_Did<s(0)(0)(0)>[&];(D1:vacmAccessTable_Did:0)

   
typedef enum {
	vacmAccessContextMatch_exact<s(0)(0)(0)>[&]=1,
	vacmAccessContextMatch_prefix<s(0)(0)(0)>[&]=2
} vacmAccessContextMatch_Tval<s(0)(0)(0)>[&];(D1:vacmAccessContextMatch_Tval:1)[[TYPENAME:vacmAccessContextMatch_Tval]]

typedef struct
{
	char		vacmGroupName<s(1)(1)(0)>[&][32];                                            
	char		vacmAccessContextPrefix<s(1)(1)(0)>[&][32];                                  
	int		vacmAccessSecurityModel<s(1)(1)(0)>[&];                                       
	SnmpSecurityLevel_Tval<s(1)(1)(0)>[T] vacmAccessSecurityLevel<s(1)(1)(0)>[&];                     
	vacmAccessContextMatch_Tval<s(1)(1)(0)>[T] vacmAccessContextMatch<s(1)(1)(0)>[&];
	char		vacmAccessReadViewName<s(1)(1)(0)>[&][32];
	char		vacmAccessWriteViewName<s(1)(1)(0)>[&][32];
	char		vacmAccessNotifyViewName<s(1)(1)(0)>[&][32];
	StorageType_Tval<s(1)(1)(0)>[T] vacmAccessStorageType<s(1)(1)(0)>[&];
	RowStatus_Tval<s(1)(1)(0)>[T] vacmAccessStatus<s(1)(1)(0)>[&];
}MIBvacmAccessTable_t<s(0)(0)(0)>[&];(D1:MIBvacmAccessTable_t:1)[[TYPENAME:MIBvacmAccessTable_t]]

















 



 
extern MIBDid_t<s(0)(0)(0)>[T] vacmMIBViews_Did<s(0)(0)(0)>[&];(D1:vacmMIBViews_Did:0)

   
typedef struct
{
	unsigned int	vacmViewSpinLock<s(1)(1)(0)>[&];
}MIBvacmMIBViews_t<s(0)(0)(0)>[&];(D1:MIBvacmMIBViews_t:1)[[TYPENAME:MIBvacmMIBViews_t]]






 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] vacmViewTreeFamilyTable_Did<s(0)(0)(0)>[&];(D1:vacmViewTreeFamilyTable_Did:0)

   
typedef enum {
	vacmViewTreeFamilyType_included<s(0)(0)(0)>[&]=1,
	vacmViewTreeFamilyType_excluded<s(0)(0)(0)>[&]=2
} vacmViewTreeFamilyType_Tval<s(0)(0)(0)>[&];(D1:vacmViewTreeFamilyType_Tval:1)[[TYPENAME:vacmViewTreeFamilyType_Tval]]

typedef struct
{
	char		vacmViewTreeFamilyViewName<s(1)(1)(0)>[&][32];                                         
	OIDValue<s(1)(1)(0)>[T]	vacmViewTreeFamilySubtree<s(1)(1)(0)>[&];                                           
	int		vacmViewTreeFamilyMask_len<s(1)(1)(0)>[&];
	char		vacmViewTreeFamilyMask<s(1)(1)(0)>[&][16];
	vacmViewTreeFamilyType_Tval<s(1)(1)(0)>[T] vacmViewTreeFamilyType<s(1)(1)(0)>[&];
	StorageType_Tval<s(1)(1)(0)>[T] vacmViewTreeFamilyStorageType<s(1)(1)(0)>[&];
	RowStatus_Tval<s(1)(1)(0)>[T] vacmViewTreeFamilyStatus<s(1)(1)(0)>[&];
}MIBvacmViewTreeFamilyTable_t<s(0)(0)(0)>[&];(D1:MIBvacmViewTreeFamilyTable_t:1)[[TYPENAME:MIBvacmViewTreeFamilyTable_t]]


















 




 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpCommunityMIB_Did<s(0)(0)(0)>[&];(D1:snmpCommunityMIB_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpCommunityMIBObjects_Did<s(0)(0)(0)>[&];(D1:snmpCommunityMIBObjects_Did:0)

   
typedef struct
{
	unsigned int	snmpTrapAddress<s(1)(1)(0)>[&];
	int		snmpTrapCommunity_len<s(1)(1)(0)>[&];
	char		snmpTrapCommunity<s(1)(1)(0)>[&][255];
}MIBsnmpCommunityMIBObjects_t<s(0)(0)(0)>[&];(D1:MIBsnmpCommunityMIBObjects_t:1)[[TYPENAME:MIBsnmpCommunityMIBObjects_t]]







 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpCommunityMIBConformance_Did<s(0)(0)(0)>[&];(D1:snmpCommunityMIBConformance_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpCommunityMIBCompliances_Did<s(0)(0)(0)>[&];(D1:snmpCommunityMIBCompliances_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpCommunityMIBGroups_Did<s(0)(0)(0)>[&];(D1:snmpCommunityMIBGroups_Did:0)

   


 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] snmpCommunityTable_Did<s(0)(0)(0)>[&];(D1:snmpCommunityTable_Did:0)

   
typedef struct
{
	char		snmpCommunityIndex<s(1)(1)(0)>[&][32];                                               
	int		snmpCommunityName_len<s(1)(1)(0)>[&];
	char		snmpCommunityName<s(1)(1)(0)>[&][255];
	char		snmpCommunitySecurityName<s(1)(1)(0)>[&][32];
	int		snmpCommunityContextEngineID_len<s(1)(1)(0)>[&];
	char		snmpCommunityContextEngineID<s(1)(1)(0)>[&][32];
	char		snmpCommunityContextName<s(1)(1)(0)>[&][32];
	int		snmpCommunityTransportTag_len<s(1)(1)(0)>[&];
	char		snmpCommunityTransportTag<s(1)(1)(0)>[&][255];
	StorageType_Tval<s(1)(1)(0)>[T] snmpCommunityStorageType<s(1)(1)(0)>[&];
	RowStatus_Tval<s(1)(1)(0)>[T] snmpCommunityStatus<s(1)(1)(0)>[&];
}MIBsnmpCommunityTable_t<s(0)(0)(0)>[&];(D1:MIBsnmpCommunityTable_t:1)[[TYPENAME:MIBsnmpCommunityTable_t]]















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] snmpTargetAddrExtTable_Did<s(0)(0)(0)>[&];(D1:snmpTargetAddrExtTable_Did:0)

   
typedef struct
{
	char		snmpTargetAddrName<s(1)(1)(0)>[&][32];                             
	int		snmpTargetAddrTMask_len<s(1)(1)(0)>[&];
	char		snmpTargetAddrTMask<s(1)(1)(0)>[&][255];
	int		snmpTargetAddrMMS<s(1)(1)(0)>[&];
}MIBsnmpTargetAddrExtTable_t<s(0)(0)(0)>[&];(D1:MIBsnmpTargetAddrExtTable_t:1)[[TYPENAME:MIBsnmpTargetAddrExtTable_t]]















 




 



 
extern MIBDid_t<s(0)(0)(0)>[T] agentxMIB_Did<s(0)(0)(0)>[&];(D1:agentxMIB_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] agentxObjects_Did<s(0)(0)(0)>[&];(D1:agentxObjects_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] agentxConformance_Did<s(0)(0)(0)>[&];(D1:agentxConformance_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] agentxMIBGroups_Did<s(0)(0)(0)>[&];(D1:agentxMIBGroups_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] agentxMIBCompliances_Did<s(0)(0)(0)>[&];(D1:agentxMIBCompliances_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] agentxGeneral_Did<s(0)(0)(0)>[&];(D1:agentxGeneral_Did:0)

   
typedef struct
{
	int		agentxDefaultTimeout<s(1)(1)(0)>[&];
	int		agentxMasterAgentXVer<s(1)(1)(0)>[&];
}MIBagentxGeneral_t<s(0)(0)(0)>[&];(D1:MIBagentxGeneral_t:1)[[TYPENAME:MIBagentxGeneral_t]]







 



 
extern MIBDid_t<s(0)(0)(0)>[T] agentxConnection_Did<s(0)(0)(0)>[&];(D1:agentxConnection_Did:0)

   
typedef struct
{
	unsigned int	agentxConnTableLastChange<s(1)(1)(0)>[&];
}MIBagentxConnection_t<s(0)(0)(0)>[&];(D1:MIBagentxConnection_t:1)[[TYPENAME:MIBagentxConnection_t]]






 



 
extern MIBDid_t<s(0)(0)(0)>[T] agentxSession_Did<s(0)(0)(0)>[&];(D1:agentxSession_Did:0)

   
typedef struct
{
	unsigned int	agentxSessionTableLastChange<s(1)(1)(0)>[&];
}MIBagentxSession_t<s(0)(0)(0)>[&];(D1:MIBagentxSession_t:1)[[TYPENAME:MIBagentxSession_t]]






 



 
extern MIBDid_t<s(0)(0)(0)>[T] agentxRegistration_Did<s(0)(0)(0)>[&];(D1:agentxRegistration_Did:0)

   
typedef struct
{
	unsigned int	agentxRegistrationTableLastChange<s(1)(1)(0)>[&];
}MIBagentxRegistration_t<s(0)(0)(0)>[&];(D1:MIBagentxRegistration_t:1)[[TYPENAME:MIBagentxRegistration_t]]






 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] agentxRegistrationTable_Did<s(0)(0)(0)>[&];(D1:agentxRegistrationTable_Did:0)

   
typedef struct
{
	unsigned int	agentxConnIndex<s(1)(1)(0)>[&];                             
	unsigned int	agentxSessionIndex<s(1)(1)(0)>[&];                          
	unsigned int	agentxRegIndex<s(1)(1)(0)>[&];                              
	int		agentxRegContext_len<s(1)(1)(0)>[&];
	char		agentxRegContext<s(1)(1)(0)>[&][255];
	OIDValue<s(1)(1)(0)>[T]	agentxRegStart<s(1)(1)(0)>[&];
	unsigned int	agentxRegRangeSubId<s(1)(1)(0)>[&];
	unsigned int	agentxRegUpperBound<s(1)(1)(0)>[&];
	unsigned int	agentxRegPriority<s(1)(1)(0)>[&];
	int		agentxRegTimeout<s(1)(1)(0)>[&];
	TruthValue_Tval<s(1)(1)(0)>[T] agentxRegInstance<s(1)(1)(0)>[&];
}MIBagentxRegistrationTable_t<s(0)(0)(0)>[&];(D1:MIBagentxRegistrationTable_t:1)[[TYPENAME:MIBagentxRegistrationTable_t]]

















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] agentxSessionTable_Did<s(0)(0)(0)>[&];(D1:agentxSessionTable_Did:0)

   
typedef enum {
	agentxSessionAdminStatus_up<s(0)(0)(0)>[&]=1,
	agentxSessionAdminStatus_down<s(0)(0)(0)>[&]=2
} agentxSessionAdminStatus_Tval<s(0)(0)(0)>[&];(D1:agentxSessionAdminStatus_Tval:1)[[TYPENAME:agentxSessionAdminStatus_Tval]]

typedef struct
{
	unsigned int	agentxConnIndex<s(1)(1)(0)>[&];                                       
	unsigned int	agentxSessionIndex<s(1)(1)(0)>[&];                                    
	OIDValue<s(1)(1)(0)>[T]	agentxSessionObjectID<s(1)(1)(0)>[&];
	char		agentxSessionDescr<s(1)(1)(0)>[&][255];
	agentxSessionAdminStatus_Tval<s(1)(1)(0)>[T] agentxSessionAdminStatus<s(1)(1)(0)>[&];
	unsigned int	agentxSessionOpenTime<s(1)(1)(0)>[&];
	int		agentxSessionAgentXVer<s(1)(1)(0)>[&];
	int		agentxSessionTimeout<s(1)(1)(0)>[&];
}MIBagentxSessionTable_t<s(0)(0)(0)>[&];(D1:MIBagentxSessionTable_t:1)[[TYPENAME:MIBagentxSessionTable_t]]















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] agentxConnectionTable_Did<s(0)(0)(0)>[&];(D1:agentxConnectionTable_Did:0)

   
typedef struct
{
	unsigned int	agentxConnIndex<s(1)(1)(0)>[&];                                           
	unsigned int	agentxConnOpenTime<s(1)(1)(0)>[&];
	OIDValue<s(1)(1)(0)>[T]	agentxConnTransportDomain<s(1)(1)(0)>[&];
	int		agentxConnTransportAddress_len<s(1)(1)(0)>[&];
	char		agentxConnTransportAddress<s(1)(1)(0)>[&][255];
}MIBagentxConnectionTable_t<s(0)(0)(0)>[&];(D1:MIBagentxConnectionTable_t:1)[[TYPENAME:MIBagentxConnectionTable_t]]
















 




 



 
extern MIBDid_t<s(0)(0)(0)>[T] enterpriseRoot_Did<s(0)(0)(0)>[&];(D1:enterpriseRoot_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] enterpriseCommonRoot_Did<s(0)(0)(0)>[&];(D1:enterpriseCommonRoot_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] enterpriseReg_Did<s(0)(0)(0)>[&];(D1:enterpriseReg_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] enterpriseGeneric_Did<s(0)(0)(0)>[&];(D1:enterpriseGeneric_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] enterpriseProducts_Did<s(0)(0)(0)>[&];(D1:enterpriseProducts_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] enterpriseCaps_Did<s(0)(0)(0)>[&];(D1:enterpriseCaps_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] enterpriseReqs_Did<s(0)(0)(0)>[&];(D1:enterpriseReqs_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] enterpriseExpr_Did<s(0)(0)(0)>[&];(D1:enterpriseExpr_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] productSeries1Products_Did<s(0)(0)(0)>[&];(D1:productSeries1Products_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] productSeries1Common_Did<s(0)(0)(0)>[&];(D1:productSeries1Common_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] enterpriseModules_Did<s(0)(0)(0)>[&];(D1:enterpriseModules_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] enterpriseNetworkingProducts_Did<s(0)(0)(0)>[&];(D1:enterpriseNetworkingProducts_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] product1Reg_Did<s(0)(0)(0)>[&];(D1:product1Reg_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] enterpriseGlobalRegModule_Did<s(0)(0)(0)>[&];(D1:enterpriseGlobalRegModule_Did:0)

   







 




 



 
extern MIBDid_t<s(0)(0)(0)>[T] productSeries1CmnConf_Did<s(0)(0)(0)>[&];(D1:productSeries1CmnConf_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] productSeries1CmnObjs_Did<s(0)(0)(0)>[&];(D1:productSeries1CmnObjs_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] productSeries1CmnEvents_Did<s(0)(0)(0)>[&];(D1:productSeries1CmnEvents_Did:0)

   
typedef struct
{
	unsigned int	pbTrapTimeStamp<s(1)(1)(0)>[&];
}MIBproductSeries1CmnEvents_t<s(0)(0)(0)>[&];(D1:MIBproductSeries1CmnEvents_t:1)[[TYPENAME:MIBproductSeries1CmnEvents_t]]






 



 
extern MIBDid_t<s(0)(0)(0)>[T] productSeries1CmnTCs_Did<s(0)(0)(0)>[&];(D1:productSeries1CmnTCs_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] productSeries1TrapGroup_Did<s(0)(0)(0)>[&];(D1:productSeries1TrapGroup_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbNode_Did<s(0)(0)(0)>[&];(D1:pbNode_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbEvents_Did<s(0)(0)(0)>[&];(D1:pbEvents_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbCircuitBasedTransport_Did<s(0)(0)(0)>[&];(D1:pbCircuitBasedTransport_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbTMS_Did<s(0)(0)(0)>[&];(D1:pbTMS_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbOspf_Did<s(0)(0)(0)>[&];(D1:pbOspf_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbMoln_Did<s(0)(0)(0)>[&];(D1:pbMoln_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbDcc_Did<s(0)(0)(0)>[&];(D1:pbDcc_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbEthernet_Did<s(0)(0)(0)>[&];(D1:pbEthernet_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbDiagnostics_Did<s(0)(0)(0)>[&];(D1:pbDiagnostics_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbOpticsMonitor_Did<s(0)(0)(0)>[&];(D1:pbOpticsMonitor_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbPowerCircuitMonitor_Did<s(0)(0)(0)>[&];(D1:pbPowerCircuitMonitor_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbOr_Did<s(0)(0)(0)>[&];(D1:pbOr_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbTrunk_Did<s(0)(0)(0)>[&];(D1:pbTrunk_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbXcExtend_Did<s(0)(0)(0)>[&];(D1:pbXcExtend_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbRpr_Did<s(0)(0)(0)>[&];(D1:pbRpr_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbOAObjects_Did<s(0)(0)(0)>[&];(D1:pbOAObjects_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbOsi_Did<s(0)(0)(0)>[&];(D1:pbOsi_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbIpTunnel_Did<s(0)(0)(0)>[&];(D1:pbIpTunnel_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbProtection_Did<s(0)(0)(0)>[&];(D1:pbProtection_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbSecurity_Did<s(0)(0)(0)>[&];(D1:pbSecurity_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbDigitalTransport_Did<s(0)(0)(0)>[&];(D1:pbDigitalTransport_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] productSeries1MibModule_Did<s(0)(0)(0)>[&];(D1:productSeries1MibModule_Did:0)

   







 




 



 
extern MIBDid_t<s(0)(0)(0)>[T] enterpriseGlobalTCModule_Did<s(0)(0)(0)>[&];(D1:enterpriseGlobalTCModule_Did:0)

   







 




 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbOATable_Did<s(0)(0)(0)>[&];(D1:pbOATable_Did:0)

   
typedef enum {
	pbOAModuleConfiguration_singlePump<s(0)(0)(0)>[&]=0,
	pbOAModuleConfiguration_dualPump<s(0)(0)(0)>[&]=1
} pbOAModuleConfiguration_Tval<s(0)(0)(0)>[&];(D1:pbOAModuleConfiguration_Tval:1)[[TYPENAME:pbOAModuleConfiguration_Tval]]

typedef enum {
	pbOAModuleType_amplet<s(0)(0)(0)>[&]=0,
	pbOAModuleType_boosterAmplifier<s(0)(0)(0)>[&]=1,
	pbOAModuleType_lineAmplifier<s(0)(0)(0)>[&]=2,
	pbOAModuleType_preAmplifier<s(0)(0)(0)>[&]=3
} pbOAModuleType_Tval<s(0)(0)(0)>[&];(D1:pbOAModuleType_Tval:1)[[TYPENAME:pbOAModuleType_Tval]]

typedef enum {
	pbOAOperationMode_constantCurrent<s(0)(0)(0)>[&]=0,
	pbOAOperationMode_constantGain<s(0)(0)(0)>[&]=1,
	pbOAOperationMode_constantPower<s(0)(0)(0)>[&]=2
} pbOAOperationMode_Tval<s(0)(0)(0)>[&];(D1:pbOAOperationMode_Tval:1)[[TYPENAME:pbOAOperationMode_Tval]]

typedef enum {
	pbOAAutoShutdown_disable<s(0)(0)(0)>[&]=0,
	pbOAAutoShutdown_enable<s(0)(0)(0)>[&]=1
} pbOAAutoShutdown_Tval<s(0)(0)(0)>[&];(D1:pbOAAutoShutdown_Tval:1)[[TYPENAME:pbOAAutoShutdown_Tval]]

typedef enum {
	pbOARealOperationMode_constantCurrent<s(0)(0)(0)>[&]=0,
	pbOARealOperationMode_constantGain<s(0)(0)(0)>[&]=1,
	pbOARealOperationMode_constantPower<s(0)(0)(0)>[&]=2
} pbOARealOperationMode_Tval<s(0)(0)(0)>[&];(D1:pbOARealOperationMode_Tval:1)[[TYPENAME:pbOARealOperationMode_Tval]]

typedef enum {
	pbOARealAutoShutdown_disable<s(0)(0)(0)>[&]=0,
	pbOARealAutoShutdown_enable<s(0)(0)(0)>[&]=1
} pbOARealAutoShutdown_Tval<s(0)(0)(0)>[&];(D1:pbOARealAutoShutdown_Tval:1)[[TYPENAME:pbOARealAutoShutdown_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbOASlotNo<s(1)(1)(0)>[&];                                            
	int		pbOAPortNo<s(1)(1)(0)>[&];                                                             
	pbOAModuleConfiguration_Tval<s(1)(1)(0)>[T] pbOAModuleConfiguration<s(1)(1)(0)>[&];   
	pbOAModuleType_Tval<s(1)(1)(0)>[T] pbOAModuleType<s(1)(1)(0)>[&];   
	char		pbOAHWVersion<s(1)(1)(0)>[&][10];   
	char		pbOASWVersion<s(1)(1)(0)>[&][10];   
	char		pbOASerialNumber<s(1)(1)(0)>[&][10];   
	int		pbOAInputPower<s(1)(1)(0)>[&];   
	int		pbOACurrentOutputPower<s(1)(1)(0)>[&];   
	int		pbOACurrentModuleGain<s(1)(1)(0)>[&];   
	int		pbOAPump1Power<s(1)(1)(0)>[&];   
	int		pbOAPump2Power<s(1)(1)(0)>[&];   
	int		pbOATemperature<s(1)(1)(0)>[&];   
	int		pbOAPump1DriveCurrent<s(1)(1)(0)>[&];   
	int		pbOAPump2DriveCurrent<s(1)(1)(0)>[&];   
	int		pbOAPowerSupplyVoltage<s(1)(1)(0)>[&];   
	pbOAOperationMode_Tval<s(1)(1)(0)>[T] pbOAOperationMode<s(1)(1)(0)>[&];   
	int		pbOAExpectedOutputPower<s(1)(1)(0)>[&];   
	int		pbOAExpectedModuleGain<s(1)(1)(0)>[&];   
	int		pbOAInputThreshold<s(1)(1)(0)>[&];   
	int		pbOAOutputThreshold<s(1)(1)(0)>[&];   
	int		pbOAShutdownThreshold<s(1)(1)(0)>[&];   
	int		pbOALowTThreshold<s(1)(1)(0)>[&];   
	int		pbOAHighTThreshold<s(1)(1)(0)>[&];   
	pbOAAutoShutdown_Tval<s(1)(1)(0)>[T] pbOAAutoShutdown<s(1)(1)(0)>[&];   
	int		pbOAMaxoutputpower<s(1)(1)(0)>[&];   
	int		pbOAMaxPump1Current<s(1)(1)(0)>[&];   
	int		pbOAMaxPump2Current<s(1)(1)(0)>[&];   
	pbOARealOperationMode_Tval<s(1)(1)(0)>[T] pbOARealOperationMode<s(1)(1)(0)>[&];   
	int		pbOARealExpectedOutputPower<s(1)(1)(0)>[&];   
	int		pbOARealExpectedModuleGain<s(1)(1)(0)>[&];   
	int		pbOARealInputThreshold<s(1)(1)(0)>[&];   
	int		pbOARealOutputThreshold<s(1)(1)(0)>[&];   
	int		pbOARealShutdownThreshold<s(1)(1)(0)>[&];   
	int		pbOARealLowTThreshold<s(1)(1)(0)>[&];   
	int		pbOARealHighTThreshold<s(1)(1)(0)>[&];   
	pbOARealAutoShutdown_Tval<s(1)(1)(0)>[T] pbOARealAutoShutdown<s(1)(1)(0)>[&];   
	int		pbOARealCoolPumpTemp<s(1)(1)(0)>[&];   
}MIBpbOATable_t<s(0)(0)(0)>[&];(D1:MIBpbOATable_t:1)[[TYPENAME:MIBpbOATable_t]]













































 



 
extern MIBDid_t<s(0)(0)(0)>[T] enterpriseOAModule_Did<s(0)(0)(0)>[&];(D1:enterpriseOAModule_Did:0)

   







 




 



 
extern MIBDid_t<s(0)(0)(0)>[T] addressGroup_Did<s(0)(0)(0)>[&];(D1:addressGroup_Did:0)

   
typedef enum {
	pbEthernetEnable_disable<s(0)(0)(0)>[&]=1,
	pbEthernetEnable_enable<s(0)(0)(0)>[&]=2
} pbEthernetEnable_Tval<s(0)(0)(0)>[&];(D1:pbEthernetEnable_Tval:1)[[TYPENAME:pbEthernetEnable_Tval]]

typedef enum {
	pbMgmtPort1Status_down<s(0)(0)(0)>[&]=0,
	pbMgmtPort1Status_up<s(0)(0)(0)>[&]=1
} pbMgmtPort1Status_Tval<s(0)(0)(0)>[&];(D1:pbMgmtPort1Status_Tval:1)[[TYPENAME:pbMgmtPort1Status_Tval]]

typedef enum {
	pbMgmtPort2Status_down<s(0)(0)(0)>[&]=0,
	pbMgmtPort2Status_up<s(0)(0)(0)>[&]=1
} pbMgmtPort2Status_Tval<s(0)(0)(0)>[&];(D1:pbMgmtPort2Status_Tval:1)[[TYPENAME:pbMgmtPort2Status_Tval]]

typedef struct
{
	unsigned int	pbIpAddress<s(1)(1)(0)>[&];   
	unsigned int	pbIpMask<s(1)(1)(0)>[&];   
	unsigned int	pbGatewayAddress<s(1)(1)(0)>[&];   
	unsigned int	pbEthernetAddress<s(1)(1)(0)>[&];   
	unsigned int	pbEthernetMask<s(1)(1)(0)>[&];   
	int		pbSystemMacAddress_len<s(1)(1)(0)>[&];
	char		pbSystemMacAddress<s(1)(1)(0)>[&][6];   
	unsigned int	pbSlaveEthernetAddress<s(1)(1)(0)>[&];   
	unsigned int	pbEthernetAddressSecondary<s(1)(1)(0)>[&];   
	unsigned int	pbEthernetMaskSecondary<s(1)(1)(0)>[&];   
	pbEthernetEnable_Tval<s(1)(1)(0)>[T] pbEthernetEnable<s(1)(1)(0)>[&];   
	unsigned int	pbGMPLSIPAddress<s(1)(1)(0)>[&];   
	unsigned int	pbGMPLSIPMask<s(1)(1)(0)>[&];
	pbMgmtPort1Status_Tval<s(1)(1)(0)>[T] pbMgmtPort1Status<s(1)(1)(0)>[&];
	pbMgmtPort2Status_Tval<s(1)(1)(0)>[T] pbMgmtPort2Status<s(1)(1)(0)>[&];
}MIBaddressGroup_t<s(0)(0)(0)>[&];(D1:MIBaddressGroup_t:1)[[TYPENAME:MIBaddressGroup_t]]



















 



 
extern MIBDid_t<s(0)(0)(0)>[T] systemGroup_Did<s(0)(0)(0)>[&];(D1:systemGroup_Did:0)

   
typedef struct
{
	PbNodeMode_Tval<s(1)(1)(0)>[T] pbMode<s(1)(1)(0)>[&];   
	char		pbLabel<s(1)(1)(0)>[&][255];   
	char		pbLocation<s(1)(1)(0)>[&][255];   
	char		pbDescription<s(1)(1)(0)>[&][255];   
	char		pbContact<s(1)(1)(0)>[&][255];   
	char		pbSerialNumber<s(1)(1)(0)>[&][255];   
	char		pbRelease<s(1)(1)(0)>[&][20];   
	char		pbBootImageVersion<s(1)(1)(0)>[&][20];   
	char		pbBackplaneHwVersion<s(1)(1)(0)>[&][17];   
	char		pbBackplaneCode<s(1)(1)(0)>[&][64];   
}MIBsystemGroup_t<s(0)(0)(0)>[&];(D1:MIBsystemGroup_t:1)[[TYPENAME:MIBsystemGroup_t]]















 



 
extern MIBDid_t<s(0)(0)(0)>[T] ledGroup_Did<s(0)(0)(0)>[&];(D1:ledGroup_Did:0)

   
typedef struct
{
	TruthValue_Tval<s(1)(1)(0)>[T] pbLedTest<s(1)(1)(0)>[&];   
}MIBledGroup_t<s(0)(0)(0)>[&];(D1:MIBledGroup_t:1)[[TYPENAME:MIBledGroup_t]]






 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbSlotTable_Did<s(0)(0)(0)>[&];(D1:pbSlotTable_Did:0)

   
typedef enum {
	pbCardState_none<s(0)(0)(0)>[&]=0,
	pbCardState_provisioning<s(0)(0)(0)>[&]=1,
	pbCardState_initializing<s(0)(0)(0)>[&]=2,
	pbCardState_faulty<s(0)(0)(0)>[&]=3,
	pbCardState_operational<s(0)(0)(0)>[&]=4,
	pbCardState_absent<s(0)(0)(0)>[&]=5,
	pbCardState_disabled<s(0)(0)(0)>[&]=6,
	pbCardState_mismatch<s(0)(0)(0)>[&]=7,
	pbCardState_available<s(0)(0)(0)>[&]=8,
	pbCardState_active<s(0)(0)(0)>[&]=9,
	pbCardState_standby<s(0)(0)(0)>[&]=10,
	pbCardState_mirroring<s(0)(0)(0)>[&]=11,
	pbCardState_tracking<s(0)(0)(0)>[&]=12,
	pbCardState_reset<s(0)(0)(0)>[&]=13,
	pbCardState_max<s(0)(0)(0)>[&]=14
} pbCardState_Tval<s(0)(0)(0)>[&];(D1:pbCardState_Tval:1)[[TYPENAME:pbCardState_Tval]]

typedef enum {
	pbCardDesiredState_auto<s(0)(0)(0)>[&]=1,
	pbCardDesiredState_active<s(0)(0)(0)>[&]=2,
	pbCardDesiredState_standby<s(0)(0)(0)>[&]=3
} pbCardDesiredState_Tval<s(0)(0)(0)>[&];(D1:pbCardDesiredState_Tval:1)[[TYPENAME:pbCardDesiredState_Tval]]

typedef enum {
	pbSlotResetDuration_permanent<s(0)(0)(0)>[&]=1,
	pbSlotResetDuration_transient<s(0)(0)(0)>[&]=2
} pbSlotResetDuration_Tval<s(0)(0)(0)>[&];(D1:pbSlotResetDuration_Tval:1)[[TYPENAME:pbSlotResetDuration_Tval]]

typedef enum {
	pbDiagMode_none<s(0)(0)(0)>[&]=1,
	pbDiagMode_once<s(0)(0)(0)>[&]=2,
	pbDiagMode_always<s(0)(0)(0)>[&]=3,
	pbDiagMode_ess<s(0)(0)(0)>[&]=4,
	pbDiagMode_burnIn<s(0)(0)(0)>[&]=5
} pbDiagMode_Tval<s(0)(0)(0)>[&];(D1:pbDiagMode_Tval:1)[[TYPENAME:pbDiagMode_Tval]]

typedef enum {
	pbForceResetSlot_none<s(0)(0)(0)>[&]=1,
	pbForceResetSlot_warm<s(0)(0)(0)>[&]=2,
	pbForceResetSlot_cold<s(0)(0)(0)>[&]=3
} pbForceResetSlot_Tval<s(0)(0)(0)>[&];(D1:pbForceResetSlot_Tval:1)[[TYPENAME:pbForceResetSlot_Tval]]

typedef enum {
	pbLatchState_na<s(0)(0)(0)>[&]=0,
	pbLatchState_off<s(0)(0)(0)>[&]=1,
	pbLatchState_on<s(0)(0)(0)>[&]=2
} pbLatchState_Tval<s(0)(0)(0)>[&];(D1:pbLatchState_Tval:1)[[TYPENAME:pbLatchState_Tval]]

typedef enum {
	slotMaxDCCNumber_ports_8<s(0)(0)(0)>[&]=0,
	slotMaxDCCNumber_ports_16<s(0)(0)(0)>[&]=1
} slotMaxDCCNumber_Tval<s(0)(0)(0)>[&];(D1:slotMaxDCCNumber_Tval:1)[[TYPENAME:slotMaxDCCNumber_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                                  
	PbSlotType_Tval<s(1)(1)(0)>[T] pbSlotType<s(1)(1)(0)>[&];   
	PbBoardStyle_Tval<s(1)(1)(0)>[T] pbBoardType<s(1)(1)(0)>[&];   
	PbBoardFunction_Tval<s(1)(1)(0)>[T] pbBoardFunction<s(1)(1)(0)>[&];   
	pbCardState_Tval<s(1)(1)(0)>[T] pbCardState<s(1)(1)(0)>[&];   
	pbCardDesiredState_Tval<s(1)(1)(0)>[T] pbCardDesiredState<s(1)(1)(0)>[&];   
	char		pbSlotNumberDisplay<s(1)(1)(0)>[&][10];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbSlotReset<s(1)(1)(0)>[&];   
	int		pbSlotNoFailuresTotal<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbSlotResetNoFailures<s(1)(1)(0)>[&];   
	pbSlotResetDuration_Tval<s(1)(1)(0)>[T] pbSlotResetDuration<s(1)(1)(0)>[&];   
	char		pbSlotName<s(1)(1)(0)>[&][255];   
	char		pbSlotDescr<s(1)(1)(0)>[&][255];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbSlotIfCardDumb<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbSlotCrashDumpAvail<s(1)(1)(0)>[&];   
	PbBoardStyle_Tval<s(1)(1)(0)>[T] pbSlotLastBoardType<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbSlotBoardTypeDifference<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbSlotExplicitDeletion<s(1)(1)(0)>[&];   
	PbBoardStyle_Tval<s(1)(1)(0)>[T] pbProvisionedCardType<s(1)(1)(0)>[&];   
	char		pbSlotCardSpecificInfo<s(1)(1)(0)>[&][255];   
	int		pbSlotTemperatureThreshold<s(1)(1)(0)>[&];   
	int		pbSlotTemperatureHysteresis<s(1)(1)(0)>[&];   
	int		pbSlotTemperatureCleanThreshold<s(1)(1)(0)>[&];   
	PbBoardFunction_Tval<s(1)(1)(0)>[T] pbSlotLastBoardFunction<s(1)(1)(0)>[&];   
	pbDiagMode_Tval<s(1)(1)(0)>[T] pbDiagMode<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbDiagActive<s(1)(1)(0)>[&];   
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbLogicalSlotNumber<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbSlotDisable<s(1)(1)(0)>[&];   
	pbForceResetSlot_Tval<s(1)(1)(0)>[T] pbForceResetSlot<s(1)(1)(0)>[&];   
	PbLedColor_Tval<s(1)(1)(0)>[T] pbSlotFailureLedColor<s(1)(1)(0)>[&];   
	PbLedColor_Tval<s(1)(1)(0)>[T] pbSlotActiveLedColor<s(1)(1)(0)>[&];   
	char		pbBoardSerialNumber<s(1)(1)(0)>[&][255];   
	int		pbBoardOption<s(1)(1)(0)>[&];   
	char		pbCode<s(1)(1)(0)>[&][64];   
	pbLatchState_Tval<s(1)(1)(0)>[T] pbLatchState<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbSlotAlarmDisable<s(1)(1)(0)>[&];   
	PbBoardFunction_Tval<s(1)(1)(0)>[T] provisionedCardFunction<s(1)(1)(0)>[&];
	int		slotConfigOption<s(1)(1)(0)>[&];   
	char		cardSoftwareVersion<s(1)(1)(0)>[&][33];   
	char		cardBootVersion<s(1)(1)(0)>[&][21];   
	char		cardBootDatetime<s(1)(1)(0)>[&][255];   
	char		cardHardwareVersion<s(1)(1)(0)>[&][17];   
	char		cardFusionVersion<s(1)(1)(0)>[&][17];   
	char		cardFpgaVersion<s(1)(1)(0)>[&][255];   
	int		macAddress_len<s(1)(1)(0)>[&];
	char		macAddress<s(1)(1)(0)>[&][6];
	slotMaxDCCNumber_Tval<s(1)(1)(0)>[T] slotMaxDCCNumber<s(1)(1)(0)>[&];
	int		slotMapValue<s(1)(1)(0)>[&];
}MIBpbSlotTable_t<s(0)(0)(0)>[&];(D1:MIBpbSlotTable_t:1)[[TYPENAME:MIBpbSlotTable_t]]






















































 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbMibSaveRestoreGroup_Did<s(0)(0)(0)>[&];(D1:pbMibSaveRestoreGroup_Did:0)

   
typedef enum {
	pbConfigType_ascii<s(0)(0)(0)>[&]=1,
	pbConfigType_binary<s(0)(0)(0)>[&]=2
} pbConfigType_Tval<s(0)(0)(0)>[&];(D1:pbConfigType_Tval:1)[[TYPENAME:pbConfigType_Tval]]

typedef struct
{
	PbOnOff_Tval<s(1)(1)(0)>[T] pbAutoSaver<s(1)(1)(0)>[&];   
	int		pbAutoSaverFirstTimer<s(1)(1)(0)>[&];   
	int		pbAutoSaverLastTimer<s(1)(1)(0)>[&];   
	pbConfigType_Tval<s(1)(1)(0)>[T] pbConfigType<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbSaveMib<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbClearMibSet<s(1)(1)(0)>[&];   
}MIBpbMibSaveRestoreGroup_t<s(0)(0)(0)>[&];(D1:MIBpbMibSaveRestoreGroup_t:1)[[TYPENAME:MIBpbMibSaveRestoreGroup_t]]











 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbInterfaceGroup_Did<s(0)(0)(0)>[&];(D1:pbInterfaceGroup_Did:0)

   
typedef struct
{
	TruthValue_Tval<s(1)(1)(0)>[T] pbAutoLinkStarted<s(1)(1)(0)>[&];   
}MIBpbInterfaceGroup_t<s(0)(0)(0)>[&];(D1:MIBpbInterfaceGroup_t:1)[[TYPENAME:MIBpbInterfaceGroup_t]]






 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbUpgradeGroup_Did<s(0)(0)(0)>[&];(D1:pbUpgradeGroup_Did:0)

   
typedef struct
{
	char		pbUpgradeCurrRelease<s(1)(1)(0)>[&][30];   
	char		pbUpgradeBackupRelease<s(1)(1)(0)>[&][30];   
	unsigned int	pbUpgradeHostIP<s(1)(1)(0)>[&];   
	char		pbUpgradeHostUsername<s(1)(1)(0)>[&][20];   
	char		pbUpgradeHostPassword<s(1)(1)(0)>[&][20];   
	char		pbUpgradeHostFileName<s(1)(1)(0)>[&][255];   
	TypeUpgradeCmnd_Tval<s(1)(1)(0)>[T] pbUpgradeCommand<s(1)(1)(0)>[&];   
	PbCmndState_Tval<s(1)(1)(0)>[T] pbUpgradeCmndState<s(1)(1)(0)>[&];   
	char		pbUpgradeStateDescr<s(1)(1)(0)>[&][255];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbUpgradeLoadCancel<s(1)(1)(0)>[&];   
	TypeUpgradeCmnd_Tval<s(1)(1)(0)>[T] nodeUpgradeLastCommand<s(1)(1)(0)>[&];   
	TypeSoftUpgFailedIndex_Tval<s(1)(1)(0)>[T] nodeUpgradeFailedIndex<s(1)(1)(0)>[&];   
	int		nodeUpgradeSwitchPhySlot<s(1)(1)(0)>[&];   
}MIBpbUpgradeGroup_t<s(0)(0)(0)>[&];(D1:MIBpbUpgradeGroup_t:1)[[TYPENAME:MIBpbUpgradeGroup_t]]


















 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbConfigCmndGroup_Did<s(0)(0)(0)>[&];(D1:pbConfigCmndGroup_Did:0)

   
typedef enum {
	nodeMibNmsOperateArea_none<s(0)(0)(0)>[&]=0,
	nodeMibNmsOperateArea_flash<s(0)(0)(0)>[&]=1,
	nodeMibNmsOperateArea_cf<s(0)(0)(0)>[&]=2,
	nodeMibNmsOperateArea_ramdisc<s(0)(0)(0)>[&]=3
} nodeMibNmsOperateArea_Tval<s(0)(0)(0)>[&];(D1:nodeMibNmsOperateArea_Tval:1)[[TYPENAME:nodeMibNmsOperateArea_Tval]]

typedef enum {
	pbBackupMIBState_invalid<s(0)(0)(0)>[&]=0,
	pbBackupMIBState_valid<s(0)(0)(0)>[&]=1
} pbBackupMIBState_Tval<s(0)(0)(0)>[&];(D1:pbBackupMIBState_Tval:1)[[TYPENAME:pbBackupMIBState_Tval]]

typedef struct
{
	TypeMibCmnd_Tval<s(1)(1)(0)>[T] nodeMibCmnd<s(1)(1)(0)>[&];   
	PbCmndState_Tval<s(1)(1)(0)>[T] nodeMibCmndState<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] nodeMibCmndCancel<s(1)(1)(0)>[&];   
	nodeMibNmsOperateArea_Tval<s(1)(1)(0)>[T] nodeMibNmsOperateArea<s(1)(1)(0)>[&];   
	TypeMibUpDownLoadStatus_Tval<s(1)(1)(0)>[T] nodeMibUpDownLoadStatus<s(1)(1)(0)>[&];   
	TypeMibCmnd_Tval<s(1)(1)(0)>[T] nodeMibLastCommand<s(1)(1)(0)>[&];   
	TypeMibUpgFailedIndex_Tval<s(1)(1)(0)>[T] nodeMibFailedIndex<s(1)(1)(0)>[&];   
	pbBackupMIBState_Tval<s(1)(1)(0)>[T] pbBackupMIBState<s(1)(1)(0)>[&];   
	DateTime<s(1)(1)(0)>[T]	pbMIBOperationDateTimeStamp<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] nodeMIBFilesNoCheck<s(1)(1)(0)>[&];   
}MIBpbConfigCmndGroup_t<s(0)(0)(0)>[&];(D1:MIBpbConfigCmndGroup_t:1)[[TYPENAME:MIBpbConfigCmndGroup_t]]















 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbStatsGroup_Did<s(0)(0)(0)>[&];(D1:pbStatsGroup_Did:0)

   
typedef struct
{
	int		pbNumberOfReboots<s(1)(1)(0)>[&];   
	DateTime<s(1)(1)(0)>[T]	pbNodeDownDTS<s(1)(1)(0)>[&];   
}MIBpbStatsGroup_t<s(0)(0)(0)>[&];(D1:MIBpbStatsGroup_t:1)[[TYPENAME:MIBpbStatsGroup_t]]







 



 
extern MIBDid_t<s(0)(0)(0)>[T] alarmGroup_Did<s(0)(0)(0)>[&];(D1:alarmGroup_Did:0)

   
typedef struct
{
	PbEnableDisable_Tval<s(1)(1)(0)>[T] pbNodeAlarmEnabling<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbAISEnabled<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbRDIEnabled<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbAlarmSuppress<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbAlarmCutOff<s(1)(1)(0)>[&];   
	int		pbDataExcDegTpNum<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbSEFEnabled<s(1)(1)(0)>[&];
}MIBalarmGroup_t<s(0)(0)(0)>[&];(D1:MIBalarmGroup_t:1)[[TYPENAME:MIBalarmGroup_t]]












 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbNodeGroup_Did<s(0)(0)(0)>[&];(D1:pbNodeGroup_Did:0)

   
typedef enum {
	pbNodeType_hiT7065<s(0)(0)(0)>[&]=11
} pbNodeType_Tval<s(0)(0)(0)>[&];(D1:pbNodeType_Tval:1)[[TYPENAME:pbNodeType_Tval]]

typedef struct
{
	pbNodeType_Tval<s(1)(1)(0)>[T] pbNodeType<s(1)(1)(0)>[&];   
	char		pbNodeSoftwareVersion<s(1)(1)(0)>[&][255];   
	int		pbNodeIntSoftwareVersion<s(1)(1)(0)>[&];   
	int		pbDatabaseVersion<s(1)(1)(0)>[&];   
}MIBpbNodeGroup_t<s(0)(0)(0)>[&];(D1:MIBpbNodeGroup_t:1)[[TYPENAME:MIBpbNodeGroup_t]]









 



 
extern MIBDid_t<s(0)(0)(0)>[T] nodeControlGroup_Did<s(0)(0)(0)>[&];(D1:nodeControlGroup_Did:0)

   
typedef struct
{
	TruthValue_Tval<s(1)(1)(0)>[T] pbWarmRebootNode<s(1)(1)(0)>[&];   
	PbColdRebootNodeState_Tval<s(1)(1)(0)>[T] pbColdRebootNode<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbResetNode<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbNodeShutDown<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbNodePowerOff<s(1)(1)(0)>[&];   
}MIBnodeControlGroup_t<s(0)(0)(0)>[&];(D1:MIBnodeControlGroup_t:1)[[TYPENAME:MIBnodeControlGroup_t]]










 



 
extern MIBDid_t<s(0)(0)(0)>[T] ntpGroup_Did<s(0)(0)(0)>[&];(D1:ntpGroup_Did:0)

   
typedef struct
{
	TruthValue_Tval<s(1)(1)(0)>[T] pbNTPEnabled<s(1)(1)(0)>[&];   
	unsigned int	pbNTPIpAddress<s(1)(1)(0)>[&];   
	int		pbNTPRequestPeriods<s(1)(1)(0)>[&];   
}MIBntpGroup_t<s(0)(0)(0)>[&];(D1:MIBntpGroup_t:1)[[TYPENAME:MIBntpGroup_t]]








 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbDateTimeStampGroup_Did<s(0)(0)(0)>[&];(D1:pbDateTimeStampGroup_Did:0)

   
typedef struct
{
	DateTime<s(1)(1)(0)>[T]	pbDateTimeStampSet<s(1)(1)(0)>[&];   
	DateTime<s(1)(1)(0)>[T]	pbDateTimeStampGet<s(1)(1)(0)>[&];   
	PbTimeZone_Tval<s(1)(1)(0)>[T] pbTimeZone<s(1)(1)(0)>[&];   
}MIBpbDateTimeStampGroup_t<s(0)(0)(0)>[&];(D1:MIBpbDateTimeStampGroup_t:1)[[TYPENAME:MIBpbDateTimeStampGroup_t]]








 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbCFCardGroup_Did<s(0)(0)(0)>[&];(D1:pbCFCardGroup_Did:0)

   
typedef enum {
	pbCFCardMIBValidity_cfcf<s(0)(0)(0)>[&]=1,
	pbCFCardMIBValidity_cfmc<s(0)(0)(0)>[&]=2,
	pbCFCardMIBValidity_mccf<s(0)(0)(0)>[&]=3,
	pbCFCardMIBValidity_mcmc<s(0)(0)(0)>[&]=4,
	pbCFCardMIBValidity_cffailed<s(0)(0)(0)>[&]=5
} pbCFCardMIBValidity_Tval<s(0)(0)(0)>[&];(D1:pbCFCardMIBValidity_Tval:1)[[TYPENAME:pbCFCardMIBValidity_Tval]]

typedef struct
{
	PbCFCardState_Tval<s(1)(1)(0)>[T] pbCFCardStatus<s(1)(1)(0)>[&];   
	pbCFCardMIBValidity_Tval<s(1)(1)(0)>[T] pbCFCardMIBValidity<s(1)(1)(0)>[&];   
	PbCFCardState_Tval<s(1)(1)(0)>[T] pbStandbyCFCardStatus<s(1)(1)(0)>[&];   
}MIBpbCFCardGroup_t<s(0)(0)(0)>[&];(D1:MIBpbCFCardGroup_t:1)[[TYPENAME:MIBpbCFCardGroup_t]]








 



 
extern MIBDid_t<s(0)(0)(0)>[T] flashSpaceGroup_Did<s(0)(0)(0)>[&];(D1:flashSpaceGroup_Did:0)

   
typedef struct
{
	int		boardFlashFreeSpace<s(1)(1)(0)>[&];   
	int		cfCardFreeSpace<s(1)(1)(0)>[&];   
}MIBflashSpaceGroup_t<s(0)(0)(0)>[&];(D1:MIBflashSpaceGroup_t:1)[[TYPENAME:MIBflashSpaceGroup_t]]







 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbExtensionShelfTable_Did<s(0)(0)(0)>[&];(D1:pbExtensionShelfTable_Did:0)

   
typedef struct
{
	int		pbExtensionShelfID<s(1)(1)(0)>[&];                                                   
	unsigned int	pbMainShelfIP<s(1)(1)(0)>[&];   
	char		pbMainShelfReadString<s(1)(1)(0)>[&][255];   
	char		pbMainShelfWriteString<s(1)(1)(0)>[&][255];   
	int		pbMainShelfSlot<s(1)(1)(0)>[&];   
	int		pbMainShelfPort<s(1)(1)(0)>[&];   
	unsigned int	pbExtesionShelfIP<s(1)(1)(0)>[&];   
	char		pbExtesionShelfReadString<s(1)(1)(0)>[&][255];   
	char		pbExtesionShelfWriteString<s(1)(1)(0)>[&][255];   
	int		pbExtesionShelfSlot<s(1)(1)(0)>[&];   
	int		pbExtesionShelfPort<s(1)(1)(0)>[&];   
	char		pbExtesionShelfLabel<s(1)(1)(0)>[&][255];   
	char		pbExtesionShelfDesc<s(1)(1)(0)>[&][255];   
	RowStatus_Tval<s(1)(1)(0)>[T] pbExtesionShelfRowStatus<s(1)(1)(0)>[&];   
}MIBpbExtensionShelfTable_t<s(0)(0)(0)>[&];(D1:MIBpbExtensionShelfTable_t:1)[[TYPENAME:MIBpbExtensionShelfTable_t]]





















 



 
extern MIBDid_t<s(0)(0)(0)>[T] nodePropertyGroup_Did<s(0)(0)(0)>[&];(D1:nodePropertyGroup_Did:0)

   
typedef enum {
	nodeHoccCapability_capability_340g<s(0)(0)(0)>[&]=1,
	nodeHoccCapability_capability_680g<s(0)(0)(0)>[&]=2
} nodeHoccCapability_Tval<s(0)(0)(0)>[&];(D1:nodeHoccCapability_Tval:1)[[TYPENAME:nodeHoccCapability_Tval]]

typedef enum {
	nodeLoccCapability_capability_none<s(0)(0)(0)>[&]=1,
	nodeLoccCapability_capability_20g<s(0)(0)(0)>[&]=2,
	nodeLoccCapability_capability_40g<s(0)(0)(0)>[&]=3
} nodeLoccCapability_Tval<s(0)(0)(0)>[&];(D1:nodeLoccCapability_Tval:1)[[TYPENAME:nodeLoccCapability_Tval]]

typedef struct
{
	nodeHoccCapability_Tval<s(1)(1)(0)>[T] nodeHoccCapability<s(1)(1)(0)>[&];   
	nodeLoccCapability_Tval<s(1)(1)(0)>[T] nodeLoccCapability<s(1)(1)(0)>[&];   
}MIBnodePropertyGroup_t<s(0)(0)(0)>[&];(D1:MIBnodePropertyGroup_t:1)[[TYPENAME:MIBnodePropertyGroup_t]]







 



 
extern MIBDid_t<s(0)(0)(0)>[T] eowFunctionGroup_Did<s(0)(0)(0)>[&];(D1:eowFunctionGroup_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] gmplsLicenseGroup_Did<s(0)(0)(0)>[&];(D1:gmplsLicenseGroup_Did:0)

   
typedef enum {
	gmplsLicenseStatus_unknown<s(0)(0)(0)>[&]=1,
	gmplsLicenseStatus_license_not_exist<s(0)(0)(0)>[&]=2,
	gmplsLicenseStatus_license_invalid<s(0)(0)(0)>[&]=3,
	gmplsLicenseStatus_ospf_only<s(0)(0)(0)>[&]=4,
	gmplsLicenseStatus_gmpls<s(0)(0)(0)>[&]=5
} gmplsLicenseStatus_Tval<s(0)(0)(0)>[&];(D1:gmplsLicenseStatus_Tval:1)[[TYPENAME:gmplsLicenseStatus_Tval]]

typedef struct
{
	gmplsLicenseStatus_Tval<s(1)(1)(0)>[T] gmplsLicenseStatus<s(1)(1)(0)>[&];
	TruthValue_Tval<s(1)(1)(0)>[T] gmplsLicenseSyncFlag<s(1)(1)(0)>[&];
}MIBgmplsLicenseGroup_t<s(0)(0)(0)>[&];(D1:MIBgmplsLicenseGroup_t:1)[[TYPENAME:MIBgmplsLicenseGroup_t]]







 



 
extern MIBDid_t<s(0)(0)(0)>[T] e2romConfigGroup_Did<s(0)(0)(0)>[&];(D1:e2romConfigGroup_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] systemMonitorGroup_Did<s(0)(0)(0)>[&];(D1:systemMonitorGroup_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] cpuUtilEventGroup_Did<s(0)(0)(0)>[&];(D1:cpuUtilEventGroup_Did:0)

   
typedef struct
{
	int		cpuUtilThreshold<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] cpuUtilEventEnable<s(1)(1)(0)>[&];   
}MIBcpuUtilEventGroup_t<s(0)(0)(0)>[&];(D1:MIBcpuUtilEventGroup_t:1)[[TYPENAME:MIBcpuUtilEventGroup_t]]







 



 
extern MIBDid_t<s(0)(0)(0)>[T] memUtilEventGroup_Did<s(0)(0)(0)>[&];(D1:memUtilEventGroup_Did:0)

   
typedef struct
{
	int		memUtilThreshold<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] memUtilEventEnable<s(1)(1)(0)>[&];   
}MIBmemUtilEventGroup_t<s(0)(0)(0)>[&];(D1:MIBmemUtilEventGroup_t:1)[[TYPENAME:MIBmemUtilEventGroup_t]]







 



 
extern MIBDid_t<s(0)(0)(0)>[T] cfCardUtilEventGroup_Did<s(0)(0)(0)>[&];(D1:cfCardUtilEventGroup_Did:0)

   
typedef struct
{
	int		cfCardUtilThreshold<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] cfCardUtilEventEnable<s(1)(1)(0)>[&];   
}MIBcfCardUtilEventGroup_t<s(0)(0)(0)>[&];(D1:MIBcfCardUtilEventGroup_t:1)[[TYPENAME:MIBcfCardUtilEventGroup_t]]







 



 
extern MIBDid_t<s(0)(0)(0)>[T] flashUtilEventGroup_Did<s(0)(0)(0)>[&];(D1:flashUtilEventGroup_Did:0)

   
typedef struct
{
	int		flashUtilThreshold<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] flashUtilEventEnable<s(1)(1)(0)>[&];   
}MIBflashUtilEventGroup_t<s(0)(0)(0)>[&];(D1:MIBflashUtilEventGroup_t:1)[[TYPENAME:MIBflashUtilEventGroup_t]]







 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbE2RomConfigTable_Did<s(0)(0)(0)>[&];(D1:pbE2RomConfigTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];             
	int		pbE2RomPageNo<s(1)(1)(0)>[&];                             
	int		pbE2RomTlvData_len<s(1)(1)(0)>[&];
	char		pbE2RomTlvData<s(1)(1)(0)>[&][253];
}MIBpbE2RomConfigTable_t<s(0)(0)(0)>[&];(D1:MIBpbE2RomConfigTable_t:1)[[TYPENAME:MIBpbE2RomConfigTable_t]]










 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] eowOhccTable_Did<s(0)(0)(0)>[&];(D1:eowOhccTable_Did:0)

   
typedef struct
{
	int		eowOhccDestination<s(1)(1)(0)>[&];                                   
	int		eowOhccSource<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] eowOhccRingManaged<s(1)(1)(0)>[&];   
}MIBeowOhccTable_t<s(0)(0)(0)>[&];(D1:MIBeowOhccTable_t:1)[[TYPENAME:MIBeowOhccTable_t]]










 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] siGlobalTable_Did<s(0)(0)(0)>[&];(D1:siGlobalTable_Did:0)

   
typedef enum {
	siClipper_clip0<s(0)(0)(0)>[&]=0,
	siClipper_clip4<s(0)(0)(0)>[&]=4,
	siClipper_clip8<s(0)(0)(0)>[&]=8,
	siClipper_clip16<s(0)(0)(0)>[&]=16,
	siClipper_clip32<s(0)(0)(0)>[&]=32
} siClipper_Tval<s(0)(0)(0)>[&];(D1:siClipper_Tval:1)[[TYPENAME:siClipper_Tval]]

typedef enum {
	siEnsThreshold_thresh0<s(0)(0)(0)>[&]=0,
	siEnsThreshold_thresh1<s(0)(0)(0)>[&]=1,
	siEnsThreshold_thresh3<s(0)(0)(0)>[&]=3,
	siEnsThreshold_thresh5<s(0)(0)(0)>[&]=5,
	siEnsThreshold_thresh7<s(0)(0)(0)>[&]=7,
	siEnsThreshold_thresh255<s(0)(0)(0)>[&]=255
} siEnsThreshold_Tval<s(0)(0)(0)>[&];(D1:siEnsThreshold_Tval:1)[[TYPENAME:siEnsThreshold_Tval]]

typedef enum {
	siErmAtt_is6dB<s(0)(0)(0)>[&]=0,
	siErmAtt_is9dB<s(0)(0)(0)>[&]=1
} siErmAtt_Tval<s(0)(0)(0)>[&];(D1:siErmAtt_Tval:1)[[TYPENAME:siErmAtt_Tval]]

typedef enum {
	siWorkingMode_normalMode<s(0)(0)(0)>[&]=1,
	siWorkingMode_boxMode<s(0)(0)(0)>[&]=2
} siWorkingMode_Tval<s(0)(0)(0)>[&];(D1:siWorkingMode_Tval:1)[[TYPENAME:siWorkingMode_Tval]]

typedef enum {
	siUpdateDsp_inactive<s(0)(0)(0)>[&]=0,
	siUpdateDsp_update<s(0)(0)(0)>[&]=1,
	siUpdateDsp_cancel<s(0)(0)(0)>[&]=2
} siUpdateDsp_Tval<s(0)(0)(0)>[&];(D1:siUpdateDsp_Tval:1)[[TYPENAME:siUpdateDsp_Tval]]

typedef enum {
	siUpdateDspState_successfully<s(0)(0)(0)>[&]=0,
	siUpdateDspState_failed<s(0)(0)(0)>[&]=1,
	siUpdateDspState_updating<s(0)(0)(0)>[&]=2,
	siUpdateDspState_unknown<s(0)(0)(0)>[&]=3
} siUpdateDspState_Tval<s(0)(0)(0)>[&];(D1:siUpdateDspState_Tval:1)[[TYPENAME:siUpdateDspState_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                 
	int		ifIdx<s(1)(1)(0)>[&];                                            
	char		siName<s(1)(1)(0)>[&][33];   
	char		siPhoneNum<s(1)(1)(0)>[&][4];   
	siClipper_Tval<s(1)(1)(0)>[T] siClipper<s(1)(1)(0)>[&];   
	siEnsThreshold_Tval<s(1)(1)(0)>[T] siEnsThreshold<s(1)(1)(0)>[&];   
	int		siErmThreshold<s(1)(1)(0)>[&];   
	siErmAtt_Tval<s(1)(1)(0)>[T] siErmAtt<s(1)(1)(0)>[&];   
	int		siErmStep<s(1)(1)(0)>[&];   
	siWorkingMode_Tval<s(1)(1)(0)>[T] siWorkingMode<s(1)(1)(0)>[&];   
	siUpdateDsp_Tval<s(1)(1)(0)>[T] siUpdateDsp<s(1)(1)(0)>[&];   
	siUpdateDspState_Tval<s(1)(1)(0)>[T] siUpdateDspState<s(1)(1)(0)>[&];   
}MIBsiGlobalTable_t<s(0)(0)(0)>[&];(D1:MIBsiGlobalTable_t:1)[[TYPENAME:MIBsiGlobalTable_t]]



















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] siChannelManageTable_Did<s(0)(0)(0)>[&];(D1:siChannelManageTable_Did:0)

   
typedef enum {
	siChannelRingManageDelta_greaterThan12dB<s(0)(0)(0)>[&]=0,
	siChannelRingManageDelta_lessThan6dB<s(0)(0)(0)>[&]=1
} siChannelRingManageDelta_Tval<s(0)(0)(0)>[&];(D1:siChannelRingManageDelta_Tval:1)[[TYPENAME:siChannelRingManageDelta_Tval]]

typedef enum {
	siChannelRingManageSwitch_dBMode<s(0)(0)(0)>[&]=0,
	siChannelRingManageSwitch_ooMode<s(0)(0)(0)>[&]=1
} siChannelRingManageSwitch_Tval<s(0)(0)(0)>[&];(D1:siChannelRingManageSwitch_Tval:1)[[TYPENAME:siChannelRingManageSwitch_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                   
	int		ifIdx<s(1)(1)(0)>[&];                                                           
	int		siChannelID<s(1)(1)(0)>[&];                                                        
	int		siChannelGroup<s(1)(1)(0)>[&];                                                     
	char		siChannelName<s(1)(1)(0)>[&][16];   
	TruthValue_Tval<s(1)(1)(0)>[T] siChannelEnable<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] siChannelNoiseDetect<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] siChannelNoiseState<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] siChannelRingManage<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] siChannelRingManageState<s(1)(1)(0)>[&];   
	siChannelRingManageDelta_Tval<s(1)(1)(0)>[T] siChannelRingManageDelta<s(1)(1)(0)>[&];   
	siChannelRingManageSwitch_Tval<s(1)(1)(0)>[T] siChannelRingManageSwitch<s(1)(1)(0)>[&];   
	int		siChannelGroupSetting<s(1)(1)(0)>[&];   
}MIBsiChannelManageTable_t<s(0)(0)(0)>[&];(D1:MIBsiChannelManageTable_t:1)[[TYPENAME:MIBsiChannelManageTable_t]]




















 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbACOGroup_Did<s(0)(0)(0)>[&];(D1:pbACOGroup_Did:0)

   
typedef struct
{
	PbOnOff_Tval<s(1)(1)(0)>[T] pbAudibleACO<s(1)(1)(0)>[&];   
	PbOnOff_Tval<s(1)(1)(0)>[T] pbVisualACO<s(1)(1)(0)>[&];   
	PbEnableDisable_Tval<s(1)(1)(0)>[T] pbExtAudible<s(1)(1)(0)>[&];   
	PbEnableDisable_Tval<s(1)(1)(0)>[T] pbExtVisual<s(1)(1)(0)>[&];   
}MIBpbACOGroup_t<s(0)(0)(0)>[&];(D1:MIBpbACOGroup_t:1)[[TYPENAME:MIBpbACOGroup_t]]









 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbIoaTable_Did<s(0)(0)(0)>[&];(D1:pbIoaTable_Did:0)

   
typedef struct
{
	int		pbIoaIndexNo<s(1)(1)(0)>[&];                                       
	char		pbIoaLabel<s(1)(1)(0)>[&][32];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbIoaEnableStatus<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbIoaStatus<s(1)(1)(0)>[&];   
}MIBpbIoaTable_t<s(0)(0)(0)>[&];(D1:MIBpbIoaTable_t:1)[[TYPENAME:MIBpbIoaTable_t]]











 



 
extern MIBDid_t<s(0)(0)(0)>[T] alarmRuleSwitchGroup_Did<s(0)(0)(0)>[&];(D1:alarmRuleSwitchGroup_Did:0)

   
typedef struct
{
	PbEnableDisable_Tval<s(1)(1)(0)>[T] lofMonitoringSwitch<s(1)(1)(0)>[&];
	PbEnableDisable_Tval<s(1)(1)(0)>[T] lomMonitoringSwitch<s(1)(1)(0)>[&];
	PbEnableDisable_Tval<s(1)(1)(0)>[T] lopMonitoringSwitch<s(1)(1)(0)>[&];
}MIBalarmRuleSwitchGroup_t<s(0)(0)(0)>[&];(D1:MIBalarmRuleSwitchGroup_t:1)[[TYPENAME:MIBalarmRuleSwitchGroup_t]]








 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] upgradeSoftwareInfoTable_Did<s(0)(0)(0)>[&];(D1:upgradeSoftwareInfoTable_Did:0)

   
typedef enum {
	upgradeSoftwareIndication_boardfirst<s(0)(0)(0)>[&]=1,
	upgradeSoftwareIndication_boardsecond<s(0)(0)(0)>[&]=2,
	upgradeSoftwareIndication_cffirst<s(0)(0)(0)>[&]=3,
	upgradeSoftwareIndication_cfsecond<s(0)(0)(0)>[&]=4
} upgradeSoftwareIndication_Tval<s(0)(0)(0)>[&];(D1:upgradeSoftwareIndication_Tval:1)[[TYPENAME:upgradeSoftwareIndication_Tval]]

typedef enum {
	upgradeSoftwareRole_active<s(0)(0)(0)>[&]=1,
	upgradeSoftwareRole_backup<s(0)(0)(0)>[&]=2
} upgradeSoftwareRole_Tval<s(0)(0)(0)>[&];(D1:upgradeSoftwareRole_Tval:1)[[TYPENAME:upgradeSoftwareRole_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] upgradeSoftwareSlotNumber<s(1)(1)(0)>[&];                         
	upgradeSoftwareIndication_Tval<s(1)(1)(0)>[T] upgradeSoftwareIndication<s(1)(1)(0)>[&];                
	upgradeSoftwareRole_Tval<s(1)(1)(0)>[T] upgradeSoftwareRole<s(1)(1)(0)>[&];   
	char		upgradeSoftwareName<s(1)(1)(0)>[&][33];   
	DateTime<s(1)(1)(0)>[T]	upgradeSoftwareDatetime<s(1)(1)(0)>[&];   
}MIBupgradeSoftwareInfoTable_t<s(0)(0)(0)>[&];(D1:MIBupgradeSoftwareInfoTable_t:1)[[TYPENAME:MIBupgradeSoftwareInfoTable_t]]












 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbPhysicalAdjacencyTable_Did<s(0)(0)(0)>[&];(D1:pbPhysicalAdjacencyTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbLocalSlotNumber<s(1)(1)(0)>[&];                                             
	int		pbLocalPortNumber<s(1)(1)(0)>[&];                                                              
	PbUpDown_Tval<s(1)(1)(0)>[T] pbRemoteNodeMolnAdjacencyStatus<s(1)(1)(0)>[&];   
	unsigned int	pbRemoteNodeIPAddress<s(1)(1)(0)>[&];   
	int		pbRemoteSlotNumber<s(1)(1)(0)>[&];   
	int		pbRemotePortNumber<s(1)(1)(0)>[&];   
	PbUpDown_Tval<s(1)(1)(0)>[T] pbLinkOperationalStatus<s(1)(1)(0)>[&];   
	char		pbInterfaceDescr<s(1)(1)(0)>[&][64];   
	PbLinkGeneralType_Tval<s(1)(1)(0)>[T] pbLinkGeneralType<s(1)(1)(0)>[&];   
	RowStatus_Tval<s(1)(1)(0)>[T] pbLinkRowStatus<s(1)(1)(0)>[&];   
}MIBpbPhysicalAdjacencyTable_t<s(0)(0)(0)>[&];(D1:MIBpbPhysicalAdjacencyTable_t:1)[[TYPENAME:MIBpbPhysicalAdjacencyTable_t]]

















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbAutoLinkTable_Did<s(0)(0)(0)>[&];(D1:pbAutoLinkTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbLocalSlot<s(1)(1)(0)>[&];                       
	int		pbLocalPort<s(1)(1)(0)>[&];                                        
	unsigned int	pbRemoteIPAddress<s(1)(1)(0)>[&];   
	int		pbRemoteSlot<s(1)(1)(0)>[&];   
	int		pbRemotePort<s(1)(1)(0)>[&];   
}MIBpbAutoLinkTable_t<s(0)(0)(0)>[&];(D1:MIBpbAutoLinkTable_t:1)[[TYPENAME:MIBpbAutoLinkTable_t]]












 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbLedTable_Did<s(0)(0)(0)>[&];(D1:pbLedTable_Did:0)

   
typedef enum {
	pbLedColor_off<s(0)(0)(0)>[&]=0,
	pbLedColor_green<s(0)(0)(0)>[&]=1,
	pbLedColor_yellow<s(0)(0)(0)>[&]=2,
	pbLedColor_red<s(0)(0)(0)>[&]=3,
	pbLedColor_orange<s(0)(0)(0)>[&]=4,
	pbLedColor_blinkingGreen<s(0)(0)(0)>[&]=5,
	pbLedColor_blinkingYellow<s(0)(0)(0)>[&]=6,
	pbLedColor_blinkingRed<s(0)(0)(0)>[&]=7,
	pbLedColor_blinkingOrange<s(0)(0)(0)>[&]=8
} pbLedColor_Tval<s(0)(0)(0)>[&];(D1:pbLedColor_Tval:1)[[TYPENAME:pbLedColor_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbLedSlotNo<s(1)(1)(0)>[&];             
	int		pbLedIndexNo<s(1)(1)(0)>[&];                             
	char		pbLedLabel<s(1)(1)(0)>[&][32];   
	pbLedColor_Tval<s(1)(1)(0)>[T] pbLedColor<s(1)(1)(0)>[&];   
}MIBpbLedTable_t<s(0)(0)(0)>[&];(D1:MIBpbLedTable_t:1)[[TYPENAME:MIBpbLedTable_t]]











 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbNodeModule_Did<s(0)(0)(0)>[&];(D1:pbNodeModule_Did:0)

   








 




 



 
extern MIBDid_t<s(0)(0)(0)>[T] rprGeneral_Did<s(0)(0)(0)>[&];(D1:rprGeneral_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] rprProtocols_Did<s(0)(0)(0)>[&];(D1:rprProtocols_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] rprService_Did<s(0)(0)(0)>[&];(D1:rprService_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] rprWan_Did<s(0)(0)(0)>[&];(D1:rprWan_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] rprHwPassThrough_Did<s(0)(0)(0)>[&];(D1:rprHwPassThrough_Did:0)

   


 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] rprHwpXcTable_Did<s(0)(0)(0)>[&];(D1:rprHwpXcTable_Did:0)

   
typedef enum {
	rprHwpXcCircuitDirection_bidirection<s(0)(0)(0)>[&]=1,
	rprHwpXcCircuitDirection_unidirection<s(0)(0)(0)>[&]=2,
	rprHwpXcCircuitDirection_multicast<s(0)(0)(0)>[&]=3
} rprHwpXcCircuitDirection_Tval<s(0)(0)(0)>[&];(D1:rprHwpXcCircuitDirection_Tval:1)[[TYPENAME:rprHwpXcCircuitDirection_Tval]]

typedef enum {
	rprHwpXcCcsRpmMsgType_client<s(0)(0)(0)>[&]=1,
	rprHwpXcCcsRpmMsgType_ems<s(0)(0)(0)>[&]=2,
	rprHwpXcCcsRpmMsgType_snm<s(0)(0)(0)>[&]=3,
	rprHwpXcCcsRpmMsgType_gmpls<s(0)(0)(0)>[&]=4,
	rprHwpXcCcsRpmMsgType_rpr<s(0)(0)(0)>[&]=5
} rprHwpXcCcsRpmMsgType_Tval<s(0)(0)(0)>[&];(D1:rprHwpXcCcsRpmMsgType_Tval:1)[[TYPENAME:rprHwpXcCcsRpmMsgType_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                   
	RprXcCapacity_Tval<s(1)(1)(0)>[T] rprHwpXcCapacity<s(1)(1)(0)>[&];                                     
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] rprHwpXcSrcSlot<s(1)(1)(0)>[&];                                   
	int		rprHwpXcSrcPort<s(1)(1)(0)>[&];                                                    
	RprTpNumberType_Tval<s(1)(1)(0)>[T] rprHwpXcSource<s(1)(1)(0)>[&];                                     
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] rprHwpXcDstSlot<s(1)(1)(0)>[&];                                   
	int		rprHwpXcDstPort<s(1)(1)(0)>[&];                                                    
	RprTpNumberType_Tval<s(1)(1)(0)>[T] rprHwpXcDestination<s(1)(1)(0)>[&];                                
	PbPortType_Tval<s(1)(1)(0)>[T] rprHwpXcSrcPortType<s(1)(1)(0)>[&];   
	PbPortType_Tval<s(1)(1)(0)>[T] rprHwpXcDstPortType<s(1)(1)(0)>[&];   
	int		rprHwpXcConnectId<s(1)(1)(0)>[&];   
	rprHwpXcCircuitDirection_Tval<s(1)(1)(0)>[T] rprHwpXcCircuitDirection<s(1)(1)(0)>[&];   
	rprHwpXcCcsRpmMsgType_Tval<s(1)(1)(0)>[T] rprHwpXcCcsRpmMsgType<s(1)(1)(0)>[&];   
	RprXcMsgStatus_Tval<s(1)(1)(0)>[T] rprHwpXcCcsRpmMsgState<s(1)(1)(0)>[&];   
	int		rprHwpXcCcsRpmMsgPriority<s(1)(1)(0)>[&];   
	PbBoardStyle_Tval<s(1)(1)(0)>[T] rprHwpXcSrcSlotCard<s(1)(1)(0)>[&];   
	PbBoardStyle_Tval<s(1)(1)(0)>[T] rprHwpXcDstSlotCard<s(1)(1)(0)>[&];   
	RprXcFailReason_Tval<s(1)(1)(0)>[T] rprHwpXcReason<s(1)(1)(0)>[&];   
	RprXcRowStatus_Tval<s(1)(1)(0)>[T] rprHwpXcRowStatus<s(1)(1)(0)>[&];   
	RprXcTableClass_Tval<s(1)(1)(0)>[T] rprHwpXcTableClass<s(1)(1)(0)>[&];   
}MIBrprHwpXcTable_t<s(0)(0)(0)>[&];(D1:MIBrprHwpXcTable_t:1)[[TYPENAME:MIBrprHwpXcTable_t]]



























 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbRprWanConfigTable_Did<s(0)(0)(0)>[&];(D1:pbRprWanConfigTable_Did:0)

   
typedef enum {
	pbRprWanPortXVType_vc4<s(0)(0)(0)>[&]=0,
	pbRprWanPortXVType_vc12<s(0)(0)(0)>[&]=1
} pbRprWanPortXVType_Tval<s(0)(0)(0)>[&];(D1:pbRprWanPortXVType_Tval:1)[[TYPENAME:pbRprWanPortXVType_Tval]]

typedef enum {
	pbRprWanGFPFCS_disable<s(0)(0)(0)>[&]=0,
	pbRprWanGFPFCS_enable<s(0)(0)(0)>[&]=1
} pbRprWanGFPFCS_Tval<s(0)(0)(0)>[&];(D1:pbRprWanGFPFCS_Tval:1)[[TYPENAME:pbRprWanGFPFCS_Tval]]

typedef enum {
	pbRprWanGFPFCSAutoDetect_disable<s(0)(0)(0)>[&]=0,
	pbRprWanGFPFCSAutoDetect_enable<s(0)(0)(0)>[&]=1
} pbRprWanGFPFCSAutoDetect_Tval<s(0)(0)(0)>[&];(D1:pbRprWanGFPFCSAutoDetect_Tval:1)[[TYPENAME:pbRprWanGFPFCSAutoDetect_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                       
	int		pbPortNo<s(1)(1)(0)>[&];                                                            
	char		pbRprWanPortLabel<s(1)(1)(0)>[&][255];   
	int		pbRprWanPortCapacity<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbRprWanPortMonitored<s(1)(1)(0)>[&];   
	pbRprWanPortXVType_Tval<s(1)(1)(0)>[T] pbRprWanPortXVType<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbRprWanLCASSupport<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbRprWanPortCapacityTrigger<s(1)(1)(0)>[&];   
	pbRprWanGFPFCS_Tval<s(1)(1)(0)>[T] pbRprWanGFPFCS<s(1)(1)(0)>[&];   
	pbRprWanGFPFCSAutoDetect_Tval<s(1)(1)(0)>[T] pbRprWanGFPFCSAutoDetect<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbRprWanFlowControl<s(1)(1)(0)>[&];   
}MIBpbRprWanConfigTable_t<s(0)(0)(0)>[&];(D1:MIBpbRprWanConfigTable_t:1)[[TYPENAME:MIBpbRprWanConfigTable_t]]


















 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbRprLCASBase_Did<s(0)(0)(0)>[&];(D1:pbRprLCASBase_Did:0)

   


 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbRprSOLCASConfigTable_Did<s(0)(0)(0)>[&];(D1:pbRprSOLCASConfigTable_Did:0)

   
typedef enum {
	pbRprSOLCASActive_none<s(0)(0)(0)>[&]=0,
	pbRprSOLCASActive_active<s(0)(0)(0)>[&]=1,
	pbRprSOLCASActive_deactive<s(0)(0)(0)>[&]=2
} pbRprSOLCASActive_Tval<s(0)(0)(0)>[&];(D1:pbRprSOLCASActive_Tval:1)[[TYPENAME:pbRprSOLCASActive_Tval]]

typedef enum {
	pbRprSOLCASState_fixed<s(0)(0)(0)>[&]=0,
	pbRprSOLCASState_add<s(0)(0)(0)>[&]=1,
	pbRprSOLCASState_normal<s(0)(0)(0)>[&]=2,
	pbRprSOLCASState_eos<s(0)(0)(0)>[&]=3,
	pbRprSOLCASState_idle<s(0)(0)(0)>[&]=5,
	pbRprSOLCASState_dnu<s(0)(0)(0)>[&]=15
} pbRprSOLCASState_Tval<s(0)(0)(0)>[&];(D1:pbRprSOLCASState_Tval:1)[[TYPENAME:pbRprSOLCASState_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                     
	int		pbPortNo<s(1)(1)(0)>[&];                                          
	PbTPType_Tval<s(1)(1)(0)>[T] pbTpType<s(1)(1)(0)>[&];                                 
	int		pbTpIndex<s(1)(1)(0)>[&];                                         
	pbRprSOLCASActive_Tval<s(1)(1)(0)>[T] pbRprSOLCASActive<s(1)(1)(0)>[&];   
	int		pbRprSOLCASWanPort<s(1)(1)(0)>[&];   
	pbRprSOLCASState_Tval<s(1)(1)(0)>[T] pbRprSOLCASState<s(1)(1)(0)>[&];   
}MIBpbRprSOLCASConfigTable_t<s(0)(0)(0)>[&];(D1:MIBpbRprSOLCASConfigTable_t:1)[[TYPENAME:MIBpbRprSOLCASConfigTable_t]]














 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbRprSKLCASConfigTable_Did<s(0)(0)(0)>[&];(D1:pbRprSKLCASConfigTable_Did:0)

   
typedef enum {
	pbRprSKLCASState_fixed<s(0)(0)(0)>[&]=0,
	pbRprSKLCASState_idle<s(0)(0)(0)>[&]=1,
	pbRprSKLCASState_ok<s(0)(0)(0)>[&]=2,
	pbRprSKLCASState_fail<s(0)(0)(0)>[&]=3
} pbRprSKLCASState_Tval<s(0)(0)(0)>[&];(D1:pbRprSKLCASState_Tval:1)[[TYPENAME:pbRprSKLCASState_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                     
	int		pbPortNo<s(1)(1)(0)>[&];                                          
	PbTPType_Tval<s(1)(1)(0)>[T] pbTpType<s(1)(1)(0)>[&];                                 
	int		pbTpIndex<s(1)(1)(0)>[&];                                         
	int		pbRprSKLCASWanPort<s(1)(1)(0)>[&];   
	pbRprSKLCASState_Tval<s(1)(1)(0)>[T] pbRprSKLCASState<s(1)(1)(0)>[&];   
}MIBpbRprSKLCASConfigTable_t<s(0)(0)(0)>[&];(D1:MIBpbRprSKLCASConfigTable_t:1)[[TYPENAME:MIBpbRprSKLCASConfigTable_t]]













 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] rprServiceTable_Did<s(0)(0)(0)>[&];(D1:rprServiceTable_Did:0)

   
typedef enum {
	rprSvcClassifyType_port<s(0)(0)(0)>[&]=0,
	rprSvcClassifyType_portVlan<s(0)(0)(0)>[&]=1,
	rprSvcClassifyType_portVlanVpri<s(0)(0)(0)>[&]=2
} rprSvcClassifyType_Tval<s(0)(0)(0)>[&];(D1:rprSvcClassifyType_Tval:1)[[TYPENAME:rprSvcClassifyType_Tval]]

typedef enum {
	rprSvcMode_basic<s(0)(0)(0)>[&]=1,
	rprSvcMode_share<s(0)(0)(0)>[&]=2,
	rprSvcMode_cross<s(0)(0)(0)>[&]=3
} rprSvcMode_Tval<s(0)(0)(0)>[&];(D1:rprSvcMode_Tval:1)[[TYPENAME:rprSvcMode_Tval]]

typedef enum {
	rprSvcTtlMode_auto<s(0)(0)(0)>[&]=1,
	rprSvcTtlMode_autoAdvanced<s(0)(0)(0)>[&]=2,
	rprSvcTtlMode_manualCloseRing<s(0)(0)(0)>[&]=3,
	rprSvcTtlMode_manualAll<s(0)(0)(0)>[&]=4,
	rprSvcTtlMode_manualMac<s(0)(0)(0)>[&]=5,
	rprSvcTtlMode_manualMacAdv<s(0)(0)(0)>[&]=6
} rprSvcTtlMode_Tval<s(0)(0)(0)>[&];(D1:rprSvcTtlMode_Tval:1)[[TYPENAME:rprSvcTtlMode_Tval]]

typedef enum {
	rprGmiiSel_gmii0<s(0)(0)(0)>[&]=0,
	rprGmiiSel_gmii1<s(0)(0)(0)>[&]=1
} rprGmiiSel_Tval<s(0)(0)(0)>[&];(D1:rprGmiiSel_Tval:1)[[TYPENAME:rprGmiiSel_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                             
	int		rprIfIndex<s(1)(1)(0)>[&];                                                
	int		rprServiceId<s(1)(1)(0)>[&];                                                 
	int		rprLocalEthPortNo<s(1)(1)(0)>[&];                                            
	int		rprLocalVID<s(1)(1)(0)>[&];                                                  
	int		rprLocalVPrio<s(1)(1)(0)>[&];                                                
	rprSvcClassifyType_Tval<s(1)(1)(0)>[T] rprSvcClassifyType<s(1)(1)(0)>[&];                        
	RprServiceType_Tval<s(1)(1)(0)>[T] rprServiceType<s(1)(1)(0)>[&];   
	rprSvcMode_Tval<s(1)(1)(0)>[T] rprSvcMode<s(1)(1)(0)>[&];   
	char		rprRmtStationMac<s(1)(1)(0)>[&][20];   
	RprRingletID_Tval<s(1)(1)(0)>[T] rprSvcRingletSel<s(1)(1)(0)>[&];   
	RprRingletID_Tval<s(1)(1)(0)>[T] rprSvcRealRingletSel<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] rprSvcAutoRingletSelEn<s(1)(1)(0)>[&];   
	RprServiceCos_Tval<s(1)(1)(0)>[T] rprSvcCos<s(1)(1)(0)>[&];   
	rprSvcTtlMode_Tval<s(1)(1)(0)>[T] rprSvcTtlMode<s(1)(1)(0)>[&];   
	int		rprSvcTtl0<s(1)(1)(0)>[&];   
	int		rprSvcTtl1<s(1)(1)(0)>[&];   
	int		rprSvcRealTtl0<s(1)(1)(0)>[&];   
	int		rprSvcRealTtl1<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] rprSvcWe<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] rprSvcSteered<s(1)(1)(0)>[&];   
	int		rprSvcRateProfIndex<s(1)(1)(0)>[&];   
	int		rprSvcTokenRate<s(1)(1)(0)>[&];   
	int		rprSvcBurstSize<s(1)(1)(0)>[&];   
	int		rprSvcMaxDelay<s(1)(1)(0)>[&];   
	int		rprSvcMaxJitter<s(1)(1)(0)>[&];   
	int		rprSvcWeight<s(1)(1)(0)>[&];   
	rprGmiiSel_Tval<s(1)(1)(0)>[T] rprGmiiSel<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] rprDoubleVlanEn<s(1)(1)(0)>[&];   
	int		rprDoubleVID<s(1)(1)(0)>[&];   
	int		rprDoubleVPrio<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] rprSvcLoop<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] rprSvcActive<s(1)(1)(0)>[&];   
	RprSvcStatus_Tval<s(1)(1)(0)>[T] rprSvcCurStatus<s(1)(1)(0)>[&];   
	RprSvcFailReason_Tval<s(1)(1)(0)>[T] rprSvcReason<s(1)(1)(0)>[&];   
	char		rprSvcLabel<s(1)(1)(0)>[&][32];   
	int		rprFlowRuleID<s(1)(1)(0)>[&];   
	int		rprSvcMulBrdCastID<s(1)(1)(0)>[&];
	TruthValue_Tval<s(1)(1)(0)>[T] rprSvcMulBrdCastEn<s(1)(1)(0)>[&];
	RowStatus_Tval<s(1)(1)(0)>[T] rprSvcRowStatus<s(1)(1)(0)>[&];   
}MIBrprServiceTable_t<s(0)(0)(0)>[&];(D1:MIBrprServiceTable_t:1)[[TYPENAME:MIBrprServiceTable_t]]















































 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] rprRateProfileTable_Did<s(0)(0)(0)>[&];(D1:rprRateProfileTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                     
	int		rprIfIndex<s(1)(1)(0)>[&];                                        
	int		rprRateProfNo<s(1)(1)(0)>[&];                                        
	int		rprTokenRate<s(1)(1)(0)>[&];   
	int		rprBurstSize<s(1)(1)(0)>[&];   
	int		rprExcessBurstSize<s(1)(1)(0)>[&];   
}MIBrprRateProfileTable_t<s(0)(0)(0)>[&];(D1:MIBrprRateProfileTable_t:1)[[TYPENAME:MIBrprRateProfileTable_t]]













 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbRprMultiCastTable_Did<s(0)(0)(0)>[&];(D1:pbRprMultiCastTable_Did:0)

   
typedef enum {
	rprMultiCastGMRP_yes<s(0)(0)(0)>[&]=0,
	rprMultiCastGMRP_no<s(0)(0)(0)>[&]=1
} rprMultiCastGMRP_Tval<s(0)(0)(0)>[&];(D1:rprMultiCastGMRP_Tval:1)[[TYPENAME:rprMultiCastGMRP_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                 
	int		rprIfIndex<s(1)(1)(0)>[&];                                                    
	int		rprServiceId<s(1)(1)(0)>[&];                                                  
	char		rprMultiCastMacAddress<s(1)(1)(0)>[&][20];                                      
	int		rprMultiCastDoubleVlanId<s(1)(1)(0)>[&];   
	char		rprMultiCastPortsList<s(1)(1)(0)>[&][64];   
	rprMultiCastGMRP_Tval<s(1)(1)(0)>[T] rprMultiCastGMRP<s(1)(1)(0)>[&];   
	RowStatus_Tval<s(1)(1)(0)>[T] rprMultiCastRowStatus<s(1)(1)(0)>[&];   
}MIBpbRprMultiCastTable_t<s(0)(0)(0)>[&];(D1:MIBpbRprMultiCastTable_t:1)[[TYPENAME:MIBpbRprMultiCastTable_t]]















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbRprAclTable_Did<s(0)(0)(0)>[&];(D1:pbRprAclTable_Did:0)

   
typedef enum {
	rprAclMacType_destinationMac<s(0)(0)(0)>[&]=1,
	rprAclMacType_sourceMac<s(0)(0)(0)>[&]=2
} rprAclMacType_Tval<s(0)(0)(0)>[&];(D1:rprAclMacType_Tval:1)[[TYPENAME:rprAclMacType_Tval]]

typedef enum {
	rprAclMode_filter<s(0)(0)(0)>[&]=1,
	rprAclMode_forward<s(0)(0)(0)>[&]=2
} rprAclMode_Tval<s(0)(0)(0)>[&];(D1:rprAclMode_Tval:1)[[TYPENAME:rprAclMode_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                     
	int		rprIfIndex<s(1)(1)(0)>[&];                                        
	int		rprServiceId<s(1)(1)(0)>[&];                                      
	char		rprAclMacAddress<s(1)(1)(0)>[&][20];                                
	rprAclMacType_Tval<s(1)(1)(0)>[T] rprAclMacType<s(1)(1)(0)>[&];   
	int		rprAclDoubleVlanId<s(1)(1)(0)>[&];   
	char		rprAclPortsList<s(1)(1)(0)>[&][64];   
	rprAclMode_Tval<s(1)(1)(0)>[T] rprAclMode<s(1)(1)(0)>[&];   
	RowStatus_Tval<s(1)(1)(0)>[T] rprAclRowStatus<s(1)(1)(0)>[&];   
	int		rprAclTblIdx<s(1)(1)(0)>[&];   
}MIBpbRprAclTable_t<s(0)(0)(0)>[&];(D1:MIBpbRprAclTable_t:1)[[TYPENAME:MIBpbRprAclTable_t]]

















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbRprMultiBroadCastTable_Did<s(0)(0)(0)>[&];(D1:pbRprMultiBroadCastTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                                 
	int		rprIfIndex<s(1)(1)(0)>[&];                                                                    
	int		rprMultiBroadCastId<s(1)(1)(0)>[&];                                                              
	int		rprMultiBroadCastTimeInterval<s(1)(1)(0)>[&];   
	int		rprMultiBroadCastPacketsInterval<s(1)(1)(0)>[&];   
}MIBpbRprMultiBroadCastTable_t<s(0)(0)(0)>[&];(D1:MIBpbRprMultiBroadCastTable_t:1)[[TYPENAME:MIBpbRprMultiBroadCastTable_t]]












 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] rprTopoImageTable_Did<s(0)(0)(0)>[&];(D1:rprTopoImageTable_Did:0)

   
typedef enum {
	rprTopoImageCapability_default<s(0)(0)(0)>[&]=0,
	rprTopoImageCapability_jbStrNspconsfair<s(0)(0)(0)>[&]=1,
	rprTopoImageCapability_regWrpNspconsfair<s(0)(0)(0)>[&]=2,
	rprTopoImageCapability_jbWrpNspconsfair<s(0)(0)(0)>[&]=3,
	rprTopoImageCapability_regStrSpconsfair<s(0)(0)(0)>[&]=4,
	rprTopoImageCapability_jbStrSpconsfair<s(0)(0)(0)>[&]=5,
	rprTopoImageCapability_regWrpSpconsfair<s(0)(0)(0)>[&]=6,
	rprTopoImageCapability_jbWrpSpconsfair<s(0)(0)(0)>[&]=7
} rprTopoImageCapability_Tval<s(0)(0)(0)>[&];(D1:rprTopoImageCapability_Tval:1)[[TYPENAME:rprTopoImageCapability_Tval]]

typedef enum {
	rprTopoImageStatus_reachableRinglet0<s(0)(0)(0)>[&]=1,
	rprTopoImageStatus_reachableRinglet1<s(0)(0)(0)>[&]=2,
	rprTopoImageStatus_reachableRinglet0Ringlet1<s(0)(0)(0)>[&]=3,
	rprTopoImageStatus_wrapActiveWest<s(0)(0)(0)>[&]=4,
	rprTopoImageStatus_wrapActiveEast<s(0)(0)(0)>[&]=8,
	rprTopoImageStatus_receivedBadFcs<s(0)(0)(0)>[&]=16,
	rprTopoImageStatus_receivBadFcsReachableR0R1<s(0)(0)(0)>[&]=19,
	rprTopoImageStatus_receivedMultichokeFairness<s(0)(0)(0)>[&]=32
} rprTopoImageStatus_Tval<s(0)(0)(0)>[&];(D1:rprTopoImageStatus_Tval:1)[[TYPENAME:rprTopoImageStatus_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                                 
	int		rprIfIndex<s(1)(1)(0)>[&];                                                                    
	char		rprTopoImageMacAddress<s(1)(1)(0)>[&][20];                                                      
	char		rprTopoImageSecMacAddress1<s(1)(1)(0)>[&][20];   
	char		rprTopoImageSecMacAddress2<s(1)(1)(0)>[&][20];   
	int		rprTopoImageStationIfIndex<s(1)(1)(0)>[&];   
	char		rprTopoImageStationName<s(1)(1)(0)>[&][255];   
	rprTopoImageCapability_Tval<s(1)(1)(0)>[T] rprTopoImageCapability<s(1)(1)(0)>[&];   
	int		rprTopoImageRinglet0Hops<s(1)(1)(0)>[&];   
	int		rprTopoImageRinglet0ReservedRate<s(1)(1)(0)>[&];   
	int		rprTopoImageRinglet1Hops<s(1)(1)(0)>[&];   
	int		rprTopoImageRinglet1ReservedRate<s(1)(1)(0)>[&];   
	RprProtectionStatus_Tval<s(1)(1)(0)>[T] rprTopoImageWestProtectionStatus<s(1)(1)(0)>[&];   
	int		rprTopoImageWestWeight<s(1)(1)(0)>[&];   
	RprProtectionStatus_Tval<s(1)(1)(0)>[T] rprTopoImageEastProtectionStatus<s(1)(1)(0)>[&];   
	int		rprTopoImageEastWeight<s(1)(1)(0)>[&];   
	rprTopoImageStatus_Tval<s(1)(1)(0)>[T] rprTopoImageStatus<s(1)(1)(0)>[&];   
	char		rprTopoImageRemoteNEAddress<s(1)(1)(0)>[&][20];   
	int		rprTopoImageRemoteSlotNumber<s(1)(1)(0)>[&];   
}MIBrprTopoImageTable_t<s(0)(0)(0)>[&];(D1:MIBrprTopoImageTable_t:1)[[TYPENAME:MIBrprTopoImageTable_t]]


























 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] rprFairnessTable_Did<s(0)(0)(0)>[&];(D1:rprFairnessTable_Did:0)

   
typedef enum {
	rprFairnessRinglet_ringlet0<s(0)(0)(0)>[&]=1,
	rprFairnessRinglet_ringlet1<s(0)(0)(0)>[&]=2
} rprFairnessRinglet_Tval<s(0)(0)(0)>[&];(D1:rprFairnessRinglet_Tval:1)[[TYPENAME:rprFairnessRinglet_Tval]]

typedef enum {
	rprFairnessResetWaterMarks_idle<s(0)(0)(0)>[&]=1,
	rprFairnessResetWaterMarks_resetWaterMarks<s(0)(0)(0)>[&]=2
} rprFairnessResetWaterMarks_Tval<s(0)(0)(0)>[&];(D1:rprFairnessResetWaterMarks_Tval:1)[[TYPENAME:rprFairnessResetWaterMarks_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                           
	int		rprIfIndex<s(1)(1)(0)>[&];                                                              
	rprFairnessRinglet_Tval<s(1)(1)(0)>[T] rprFairnessRinglet<s(1)(1)(0)>[&];                                      
	int		rprFairnessRingletWeight<s(1)(1)(0)>[&];   
	int		rprFairnessReservedRate<s(1)(1)(0)>[&];   
	int		rprFairnessMaxAllowed<s(1)(1)(0)>[&];   
	int		rprFairnessAgeCoef<s(1)(1)(0)>[&];   
	int		rprFairnessLpCoef<s(1)(1)(0)>[&];   
	int		rprFairnessAdvertisementRatio<s(1)(1)(0)>[&];   
	int		rprFairnessMcffReportCoef<s(1)(1)(0)>[&];   
	int		rprFairnessActiveWeightsCoef<s(1)(1)(0)>[&];   
	int		rprFairnessSTQHighThreshold<s(1)(1)(0)>[&];   
	int		rprFairnessSTQMedThreshold<s(1)(1)(0)>[&];   
	int		rprFairnessSTQLowThreshold<s(1)(1)(0)>[&];   
	int		rprFairnessRateHighThreshold<s(1)(1)(0)>[&];   
	int		rprFairnessRateLowThreshold<s(1)(1)(0)>[&];   
	rprFairnessResetWaterMarks_Tval<s(1)(1)(0)>[T] rprFairnessResetWaterMarks<s(1)(1)(0)>[&];   
	int		rprFairnessSTQHighWaterMark<s(1)(1)(0)>[&];   
	int		rprFairnessSTQLowWaterMark<s(1)(1)(0)>[&];   
	int		rprFairnessRampUpCoef<s(1)(1)(0)>[&];   
	int		rprFairnessRampDnCoef<s(1)(1)(0)>[&];   
}MIBrprFairnessTable_t<s(0)(0)(0)>[&];(D1:MIBrprFairnessTable_t:1)[[TYPENAME:MIBrprFairnessTable_t]]




























 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] rprOamTable_Did<s(0)(0)(0)>[&];(D1:rprOamTable_Did:0)

   
typedef enum {
	rprOamActionType_echo<s(0)(0)(0)>[&]=1,
	rprOamActionType_flush<s(0)(0)(0)>[&]=2
} rprOamActionType_Tval<s(0)(0)(0)>[&];(D1:rprOamActionType_Tval:1)[[TYPENAME:rprOamActionType_Tval]]

typedef enum {
	rprOamClassOfService_classA<s(0)(0)(0)>[&]=1,
	rprOamClassOfService_classB<s(0)(0)(0)>[&]=2,
	rprOamClassOfService_classC<s(0)(0)(0)>[&]=3
} rprOamClassOfService_Tval<s(0)(0)(0)>[&];(D1:rprOamClassOfService_Tval:1)[[TYPENAME:rprOamClassOfService_Tval]]

typedef enum {
	rprOamControl_idle<s(0)(0)(0)>[&]=1,
	rprOamControl_active<s(0)(0)(0)>[&]=2,
	rprOamControl_abort<s(0)(0)(0)>[&]=3
} rprOamControl_Tval<s(0)(0)(0)>[&];(D1:rprOamControl_Tval:1)[[TYPENAME:rprOamControl_Tval]]

typedef enum {
	rprOamResponseStatus_unknown<s(0)(0)(0)>[&]=1,
	rprOamResponseStatus_inProcess<s(0)(0)(0)>[&]=2,
	rprOamResponseStatus_error<s(0)(0)(0)>[&]=3,
	rprOamResponseStatus_success<s(0)(0)(0)>[&]=4
} rprOamResponseStatus_Tval<s(0)(0)(0)>[&];(D1:rprOamResponseStatus_Tval:1)[[TYPENAME:rprOamResponseStatus_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                           
	int		rprIfIndex<s(1)(1)(0)>[&];                                              
	rprOamActionType_Tval<s(1)(1)(0)>[T] rprOamActionType<s(1)(1)(0)>[&];   
	char		rprOamDestAddress<s(1)(1)(0)>[&][20];   
	RprOamRinglet_Tval<s(1)(1)(0)>[T] rprOamRequestRinglet<s(1)(1)(0)>[&];   
	RprOamRinglet_Tval<s(1)(1)(0)>[T] rprOamResponseRinglet<s(1)(1)(0)>[&];   
	rprOamClassOfService_Tval<s(1)(1)(0)>[T] rprOamClassOfService<s(1)(1)(0)>[&];   
	char		rprOamUserData<s(1)(1)(0)>[&][20];   
	TruthValue_Tval<s(1)(1)(0)>[T] rprOamProtected<s(1)(1)(0)>[&];   
	int		rprOamRequestCount<s(1)(1)(0)>[&];   
	int		rprOamTimeout<s(1)(1)(0)>[&];   
	rprOamControl_Tval<s(1)(1)(0)>[T] rprOamControl<s(1)(1)(0)>[&];   
	int		rprOamResponseCount<s(1)(1)(0)>[&];   
	int		rprOamAvResponseTime<s(1)(1)(0)>[&];   
	rprOamResponseStatus_Tval<s(1)(1)(0)>[T] rprOamResponseStatus<s(1)(1)(0)>[&];   
}MIBrprOamTable_t<s(0)(0)(0)>[&];(D1:MIBrprOamTable_t:1)[[TYPENAME:MIBrprOamTable_t]]






















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] rprTopoRingInfoTable_Did<s(0)(0)(0)>[&];(D1:rprTopoRingInfoTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                 
	int		rprIfIndex<s(1)(1)(0)>[&];                                                    
	TruthValue_Tval<s(1)(1)(0)>[T] rprRingMultiChoke0<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] rprRingMultiChoke1<s(1)(1)(0)>[&];   
	int		rprRingMtuSize<s(1)(1)(0)>[&];   
	int		rprRingTotalHopsTx0<s(1)(1)(0)>[&];   
	int		rprRingTotalHopsTx1<s(1)(1)(0)>[&];   
	char		rprRingLastNeighborMac0<s(1)(1)(0)>[&][20];   
	char		rprRingLastNeighborMac1<s(1)(1)(0)>[&][20];   
	int		rprRingCheckSum<s(1)(1)(0)>[&];   
	int		rprRingNeighborCheckSum0<s(1)(1)(0)>[&];   
	int		rprRingNeighborCheckSum1<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] rprRingCheckSumValid<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] rprRingNeighborCksValid0<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] rprRingNeighborCksValid1<s(1)(1)(0)>[&];   
}MIBrprTopoRingInfoTable_t<s(0)(0)(0)>[&];(D1:MIBrprTopoRingInfoTable_t:1)[[TYPENAME:MIBrprTopoRingInfoTable_t]]






















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] rprIfTable_Did<s(0)(0)(0)>[&];(D1:rprIfTable_Did:0)

   
typedef enum {
	rprIfFairnessMode_aggressive<s(0)(0)(0)>[&]=1,
	rprIfFairnessMode_conservative<s(0)(0)(0)>[&]=2,
	rprIfFairnessMode_others<s(0)(0)(0)>[&]=3
} rprIfFairnessMode_Tval<s(0)(0)(0)>[&];(D1:rprIfFairnessMode_Tval:1)[[TYPENAME:rprIfFairnessMode_Tval]]

typedef enum {
	rprIfMacOperModes_default<s(0)(0)(0)>[&]=0,
	rprIfMacOperModes_strctorderNdrpbadfcs<s(0)(0)(0)>[&]=1,
	rprIfMacOperModes_regorderDrpbadfcs<s(0)(0)(0)>[&]=2,
	rprIfMacOperModes_strctorderDrpbadfcs<s(0)(0)(0)>[&]=3
} rprIfMacOperModes_Tval<s(0)(0)(0)>[&];(D1:rprIfMacOperModes_Tval:1)[[TYPENAME:rprIfMacOperModes_Tval]]

typedef enum {
	rprIfRingOperModes_default<s(0)(0)(0)>[&]=0,
	rprIfRingOperModes_jbStrClsring<s(0)(0)(0)>[&]=1,
	rprIfRingOperModes_regWrpClsring<s(0)(0)(0)>[&]=2,
	rprIfRingOperModes_jbWrpClsring<s(0)(0)(0)>[&]=3,
	rprIfRingOperModes_regStrOpenring<s(0)(0)(0)>[&]=4,
	rprIfRingOperModes_jbStrOpenring<s(0)(0)(0)>[&]=5,
	rprIfRingOperModes_regWrpOpenring<s(0)(0)(0)>[&]=6,
	rprIfRingOperModes_jbWrpOpenring<s(0)(0)(0)>[&]=7
} rprIfRingOperModes_Tval<s(0)(0)(0)>[&];(D1:rprIfRingOperModes_Tval:1)[[TYPENAME:rprIfRingOperModes_Tval]]

typedef enum {
	rprIfCurrentStatus_ok<s(0)(0)(0)>[&]=0,
	rprIfCurrentStatus_neighborInconsistency<s(0)(0)(0)>[&]=1,
	rprIfCurrentStatus_duplicateMac<s(0)(0)(0)>[&]=2,
	rprIfCurrentStatus_neiborInconsistDMAC<s(0)(0)(0)>[&]=3,
	rprIfCurrentStatus_exceedMaxStations<s(0)(0)(0)>[&]=4
} rprIfCurrentStatus_Tval<s(0)(0)(0)>[&];(D1:rprIfCurrentStatus_Tval:1)[[TYPENAME:rprIfCurrentStatus_Tval]]

typedef enum {
	rprIfMplsMode_mpls<s(0)(0)(0)>[&]=0,
	rprIfMplsMode_qinQ<s(0)(0)(0)>[&]=1,
	rprIfMplsMode_transparent<s(0)(0)(0)>[&]=2
} rprIfMplsMode_Tval<s(0)(0)(0)>[&];(D1:rprIfMplsMode_Tval:1)[[TYPENAME:rprIfMplsMode_Tval]]

typedef enum {
	rprIfHwPassThrough_disable<s(0)(0)(0)>[&]=1,
	rprIfHwPassThrough_enable<s(0)(0)(0)>[&]=2,
	rprIfHwPassThrough_force<s(0)(0)(0)>[&]=3
} rprIfHwPassThrough_Tval<s(0)(0)(0)>[&];(D1:rprIfHwPassThrough_Tval:1)[[TYPENAME:rprIfHwPassThrough_Tval]]

typedef enum {
	rprIfBandMode_auto<s(0)(0)(0)>[&]=1,
	rprIfBandMode_manual<s(0)(0)(0)>[&]=2
} rprIfBandMode_Tval<s(0)(0)(0)>[&];(D1:rprIfBandMode_Tval:1)[[TYPENAME:rprIfBandMode_Tval]]

typedef enum {
	rprIfCardProtection_disable<s(0)(0)(0)>[&]=1,
	rprIfCardProtection_enable<s(0)(0)(0)>[&]=2,
	rprIfCardProtection_force<s(0)(0)(0)>[&]=3
} rprIfCardProtection_Tval<s(0)(0)(0)>[&];(D1:rprIfCardProtection_Tval:1)[[TYPENAME:rprIfCardProtection_Tval]]

typedef enum {
	rprIfL2RateLimitMode_advanced<s(0)(0)(0)>[&]=1,
	rprIfL2RateLimitMode_basic<s(0)(0)(0)>[&]=2
} rprIfL2RateLimitMode_Tval<s(0)(0)(0)>[&];(D1:rprIfL2RateLimitMode_Tval:1)[[TYPENAME:rprIfL2RateLimitMode_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                 
	int		rprIfIndex<s(1)(1)(0)>[&];                                                    
	int		rprIfStationsOnRing<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] rprIfReversionMode<s(1)(1)(0)>[&];   
	int		rprIfProtectionWTR<s(1)(1)(0)>[&];   
	int		rprIfProtectionFastTimer<s(1)(1)(0)>[&];   
	int		rprIfProtectionSlowTimer<s(1)(1)(0)>[&];   
	int		rprIfAtdTimer<s(1)(1)(0)>[&];   
	int		rprIfKeepaliveTimeout<s(1)(1)(0)>[&];   
	rprIfFairnessMode_Tval<s(1)(1)(0)>[T] rprIfFairnessMode<s(1)(1)(0)>[&];   
	int		rprIfPtqSize<s(1)(1)(0)>[&];   
	int		rprIfStqSize<s(1)(1)(0)>[&];   
	int		rprIfSTQFullThreshold<s(1)(1)(0)>[&];   
	int		rprIfIdleThreshold<s(1)(1)(0)>[&];   
	int		rprIfSesThreshold<s(1)(1)(0)>[&];   
	RprProtectionType_Tval<s(1)(1)(0)>[T] rprIfProtectionMode<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] rprIfJumboFramePreferred<s(1)(1)(0)>[&];   
	rprIfMacOperModes_Tval<s(1)(1)(0)>[T] rprIfMacOperModes<s(1)(1)(0)>[&];   
	rprIfRingOperModes_Tval<s(1)(1)(0)>[T] rprIfRingOperModes<s(1)(1)(0)>[&];   
	rprIfCurrentStatus_Tval<s(1)(1)(0)>[T] rprIfCurrentStatus<s(1)(1)(0)>[&];   
	int		rprIfLinkRate<s(1)(1)(0)>[&];   
	rprIfMplsMode_Tval<s(1)(1)(0)>[T] rprIfMplsMode<s(1)(1)(0)>[&];   
	int		rprIfMplsTypeTag<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] rprIfVlanPrioEn<s(1)(1)(0)>[&];   
	char		rprIfMyMacAddress<s(1)(1)(0)>[&][20];   
	TruthValue_Tval<s(1)(1)(0)>[T] rprIfPassThroughEn<s(1)(1)(0)>[&];   
	rprIfHwPassThrough_Tval<s(1)(1)(0)>[T] rprIfHwPassThrough<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] rprIfHwPassThroughStatus<s(1)(1)(0)>[&];   
	int		rprIfResRateR0<s(1)(1)(0)>[&];   
	int		rprIfResRateR1<s(1)(1)(0)>[&];   
	int		rprIfA0RateR0<s(1)(1)(0)>[&];   
	int		rprIfA0RateR1<s(1)(1)(0)>[&];   
	int		rprIfA1RateR0<s(1)(1)(0)>[&];   
	int		rprIfA1RateR1<s(1)(1)(0)>[&];   
	int		rprIfBcirRateR0<s(1)(1)(0)>[&];   
	int		rprIfBcirRateR1<s(1)(1)(0)>[&];   
	int		rprIfRealA0RateR0<s(1)(1)(0)>[&];   
	int		rprIfRealA0RateR1<s(1)(1)(0)>[&];   
	int		rprIfRealA1RateR0<s(1)(1)(0)>[&];   
	int		rprIfRealA1RateR1<s(1)(1)(0)>[&];   
	int		rprIfRealBcirRateR0<s(1)(1)(0)>[&];   
	int		rprIfRealBcirRateR1<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] rprIfAlarmMon<s(1)(1)(0)>[&];   
	char		rprIfStationName<s(1)(1)(0)>[&][128];   
	TruthValue_Tval<s(1)(1)(0)>[T] rprIfInterWorking<s(1)(1)(0)>[&];   
	rprIfBandMode_Tval<s(1)(1)(0)>[T] rprIfBandMode<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] rprIfMulBrdCastEn<s(1)(1)(0)>[&];
	rprIfCardProtection_Tval<s(1)(1)(0)>[T] rprIfCardProtection<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] rprIfCardProtectionState<s(1)(1)(0)>[&];   
	rprIfL2RateLimitMode_Tval<s(1)(1)(0)>[T] rprIfL2RateLimitMode<s(1)(1)(0)>[&];   
	char		rprIfCrossPortsList<s(1)(1)(0)>[&][64];   
	TruthValue_Tval<s(1)(1)(0)>[T] rprIfLogSave<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] rprIfL2CosFlowControl<s(1)(1)(0)>[&];   
}MIBrprIfTable_t<s(0)(0)(0)>[&];(D1:MIBrprIfTable_t:1)[[TYPENAME:MIBrprIfTable_t]]




























































 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] rprSpanTable_Did<s(0)(0)(0)>[&];(D1:rprSpanTable_Did:0)

   
typedef enum {
	rprSpanCurrentStatus_ok<s(0)(0)(0)>[&]=0,
	rprSpanCurrentStatus_kaNmcNsdNsf<s(0)(0)(0)>[&]=1,
	rprSpanCurrentStatus_nkaMcNsdNsf<s(0)(0)(0)>[&]=2,
	rprSpanCurrentStatus_kaMcNsdNsf<s(0)(0)(0)>[&]=3,
	rprSpanCurrentStatus_nkaNmcSdNsf<s(0)(0)(0)>[&]=4,
	rprSpanCurrentStatus_kaNmcSdNsf<s(0)(0)(0)>[&]=5,
	rprSpanCurrentStatus_nkaMcSdNsf<s(0)(0)(0)>[&]=6,
	rprSpanCurrentStatus_kaMcSdNsf<s(0)(0)(0)>[&]=7,
	rprSpanCurrentStatus_nkaNmcNsdSf<s(0)(0)(0)>[&]=8,
	rprSpanCurrentStatus_kaNmcNsdSf<s(0)(0)(0)>[&]=9,
	rprSpanCurrentStatus_nkaMcNsdSf<s(0)(0)(0)>[&]=10,
	rprSpanCurrentStatus_kaMcNsdSf<s(0)(0)(0)>[&]=11,
	rprSpanCurrentStatus_nkaNmcSdSf<s(0)(0)(0)>[&]=12,
	rprSpanCurrentStatus_kaNmcSdSf<s(0)(0)(0)>[&]=13,
	rprSpanCurrentStatus_nkaMcSdSf<s(0)(0)(0)>[&]=14,
	rprSpanCurrentStatus_kaMcSdSf<s(0)(0)(0)>[&]=15
} rprSpanCurrentStatus_Tval<s(0)(0)(0)>[&];(D1:rprSpanCurrentStatus_Tval:1)[[TYPENAME:rprSpanCurrentStatus_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                               
	int		rprIfIndex<s(1)(1)(0)>[&];                                                                  
	RprSpan_Tval<s(1)(1)(0)>[T] rprSpanId<s(1)(1)(0)>[&];                                                           
	int		rprSpanTotalRingletReservedRate<s(1)(1)(0)>[&];   
	rprSpanCurrentStatus_Tval<s(1)(1)(0)>[T] rprSpanCurrentStatus<s(1)(1)(0)>[&];   
	int		rprSpanWanPortNo<s(1)(1)(0)>[&];   
	int		rprSpanHopsToWrap<s(1)(1)(0)>[&];   
}MIBrprSpanTable_t<s(0)(0)(0)>[&];(D1:MIBrprSpanTable_t:1)[[TYPENAME:MIBrprSpanTable_t]]














 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] rprSpanProtectionTable_Did<s(0)(0)(0)>[&];(D1:rprSpanProtectionTable_Did:0)

   
typedef enum {
	rprSpanProtectionCommand_idle<s(0)(0)(0)>[&]=1,
	rprSpanProtectionCommand_manualSwitch<s(0)(0)(0)>[&]=2,
	rprSpanProtectionCommand_forcedSwitch<s(0)(0)(0)>[&]=3
} rprSpanProtectionCommand_Tval<s(0)(0)(0)>[&];(D1:rprSpanProtectionCommand_Tval:1)[[TYPENAME:rprSpanProtectionCommand_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                                       
	int		rprIfIndex<s(1)(1)(0)>[&];                                                                          
	RprSpan_Tval<s(1)(1)(0)>[T] rprSpanId<s(1)(1)(0)>[&];                                                                   
	TruthValue_Tval<s(1)(1)(0)>[T] rprSpanProtectionNeighborValid<s(1)(1)(0)>[&];   
	int		rprSpanProtectionHoldOffTimer<s(1)(1)(0)>[&];   
	rprSpanProtectionCommand_Tval<s(1)(1)(0)>[T] rprSpanProtectionCommand<s(1)(1)(0)>[&];   
	unsigned int	rprSpanProtectionCount<s(1)(1)(0)>[&];   
	unsigned int	rprSpanProtectionDuration<s(1)(1)(0)>[&];   
	unsigned int	rprSpanProtectionLastActivationTime<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] rprSpanProtectionCountReset<s(1)(1)(0)>[&];   
}MIBrprSpanProtectionTable_t<s(0)(0)(0)>[&];(D1:MIBrprSpanProtectionTable_t:1)[[TYPENAME:MIBrprSpanProtectionTable_t]]

















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] rprCardProtectionTable_Did<s(0)(0)(0)>[&];(D1:rprCardProtectionTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                         
	int		rprIfIndex<s(1)(1)(0)>[&];                                            
	int		rprCardProtectionId<s(1)(1)(0)>[&];                                      
	int		rprCpfWorkSlot<s(1)(1)(0)>[&];   
	int		rprCpfProtSlot<s(1)(1)(0)>[&];   
	int		rprCpfActiveSlot<s(1)(1)(0)>[&];   
	int		rprCpfCoordSlot<s(1)(1)(0)>[&];   
	int		rprCpfCoordProtGroup<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] rprCpfEnable<s(1)(1)(0)>[&];   
}MIBrprCardProtectionTable_t<s(0)(0)(0)>[&];(D1:MIBrprCardProtectionTable_t:1)[[TYPENAME:MIBrprCardProtectionTable_t]]
















 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbRprModule_Did<s(0)(0)(0)>[&];(D1:pbRprModule_Did:0)

   







 




 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbSdhPmUpLoadInfo_Did<s(0)(0)(0)>[&];(D1:pbSdhPmUpLoadInfo_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbSdhMostRecentIndex_Did<s(0)(0)(0)>[&];(D1:pbSdhMostRecentIndex_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbSdhRecentUapPerfMon_Did<s(0)(0)(0)>[&];(D1:pbSdhRecentUapPerfMon_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbSdhUapPerfMon_Did<s(0)(0)(0)>[&];(D1:pbSdhUapPerfMon_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbSdhRecentPerfMon_Did<s(0)(0)(0)>[&];(D1:pbSdhRecentPerfMon_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbSdhCurPerfMon_Did<s(0)(0)(0)>[&];(D1:pbSdhCurPerfMon_Did:0)

   
typedef struct
{
	int		pbEthPmMonTimeIntervalSet<s(1)(1)(0)>[&];   
	PbEnableDisable_Tval<s(1)(1)(0)>[T] pbPdhPmSlipEventEnable<s(1)(1)(0)>[&];   
}MIBpbSdhCurPerfMon_t<s(0)(0)(0)>[&];(D1:MIBpbSdhCurPerfMon_t:1)[[TYPENAME:MIBpbSdhCurPerfMon_t]]







 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbPMFilterConfigGroup_Did<s(0)(0)(0)>[&];(D1:pbPMFilterConfigGroup_Did:0)

   
typedef struct
{
	TruthValue_Tval<s(1)(1)(0)>[T] pbPmDeleteAllFilter<s(1)(1)(0)>[&];
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbPmDeleteSlotNumber<s(1)(1)(0)>[&];
	TruthValue_Tval<s(1)(1)(0)>[T] pbPmDeleteSlotFilter<s(1)(1)(0)>[&];
	unsigned int	pbPmDeleteFilterTypeId<s(1)(1)(0)>[&];
	TruthValue_Tval<s(1)(1)(0)>[T] pbPmDeleteFilterType<s(1)(1)(0)>[&];
}MIBpbPMFilterConfigGroup_t<s(0)(0)(0)>[&];(D1:MIBpbPMFilterConfigGroup_t:1)[[TYPENAME:MIBpbPMFilterConfigGroup_t]]










 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbPMFilterTable_Did<s(0)(0)(0)>[&];(D1:pbPMFilterTable_Did:0)

   
typedef struct
{
	unsigned int	pbPmFilterType<s(1)(1)(0)>[&];                    
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];             
	PbPortType_Tval<s(1)(1)(0)>[T] pbPortType<s(1)(1)(0)>[&];                     
	int		pbPortNo<s(1)(1)(0)>[&];                                  
	PbTPType_Tval<s(1)(1)(0)>[T] pbTpType<s(1)(1)(0)>[&];                         
	int		pbTpIndex<s(1)(1)(0)>[&];                                 
	PbPmTableType_Tval<s(1)(1)(0)>[T] pbTableType<s(1)(1)(0)>[&];                 
	unsigned int	pbPmEthId<s(1)(1)(0)>[&];                         
	unsigned int	pbPmReserved<s(1)(1)(0)>[&];
}MIBpbPMFilterTable_t<s(0)(0)(0)>[&];(D1:MIBpbPMFilterTable_t:1)[[TYPENAME:MIBpbPMFilterTable_t]]
















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbSdhCurPMTable_Did<s(0)(0)(0)>[&];(D1:pbSdhCurPMTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                               
	PbPortType_Tval<s(1)(1)(0)>[T] pbPortType<s(1)(1)(0)>[&];                                       
	int		pbPortNo<s(1)(1)(0)>[&];                                                    
	PbTPType_Tval<s(1)(1)(0)>[T] pbTpType<s(1)(1)(0)>[&];                                           
	int		pbTpIndex<s(1)(1)(0)>[&];                                                   
	PbPmTableType_Tval<s(1)(1)(0)>[T] pbTableType<s(1)(1)(0)>[&];                                      
	PbActualPortType_Tval<s(1)(1)(0)>[T] pbPmActualPortType<s(1)(1)(0)>[&];   
	PbPmMonitor_Tval<s(1)(1)(0)>[T] pbSdhPmMonitor<s(1)(1)(0)>[&];   
	unsigned int	pbEsPmCounter<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbEsPmThresholdEnable<s(1)(1)(0)>[&];   
	int		pbEsPmThresholdLow<s(1)(1)(0)>[&];   
	int		pbEsPmThresholdHigh<s(1)(1)(0)>[&];   
	unsigned int	pbBbePmCounter<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbBbePmThresholdEnable<s(1)(1)(0)>[&];   
	int		pbBbePmThresholdLow<s(1)(1)(0)>[&];   
	int		pbBbePmThresholdHigh<s(1)(1)(0)>[&];   
	unsigned int	pbSesPmCounter<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbSesPmThresholdEnable<s(1)(1)(0)>[&];   
	int		pbSesPmThresholdLow<s(1)(1)(0)>[&];   
	int		pbSesPmThresholdHigh<s(1)(1)(0)>[&];   
	unsigned int	pbUasPmCounter<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbUasPmThresholdEnable<s(1)(1)(0)>[&];   
	int		pbUasPmThresholdLow<s(1)(1)(0)>[&];   
	int		pbUasPmThresholdHigh<s(1)(1)(0)>[&];   
	unsigned int	pbCsesPmCounter<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbCsesPmThresholdEnable<s(1)(1)(0)>[&];   
	int		pbCsesPmThresholdLow<s(1)(1)(0)>[&];   
	int		pbCsesPmThresholdHigh<s(1)(1)(0)>[&];   
	unsigned int	pbFcPmCounter<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbFcPmThresholdEnable<s(1)(1)(0)>[&];   
	int		pbFcPmThresholdLow<s(1)(1)(0)>[&];   
	int		pbFcPmThresholdHigh<s(1)(1)(0)>[&];   
	unsigned int	pbOfsPmCounter<s(1)(1)(0)>[&];
	TruthValue_Tval<s(1)(1)(0)>[T] pbOfsPmThresholdEnable<s(1)(1)(0)>[&];   
	int		pbOfsPmThresholdLow<s(1)(1)(0)>[&];   
	int		pbOfsPmThresholdHigh<s(1)(1)(0)>[&];   
	unsigned int	pbPpjcPmCounter<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbPpjcPmThresholdEnable<s(1)(1)(0)>[&];   
	int		pbPpjcPmThresholdLow<s(1)(1)(0)>[&];   
	int		pbPpjcPmThresholdHigh<s(1)(1)(0)>[&];   
	unsigned int	pbNpjcPmCounter<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbNpjcPmThresholdEnable<s(1)(1)(0)>[&];   
	int		pbNpjcPmThresholdLow<s(1)(1)(0)>[&];   
	int		pbNpjcPmThresholdHigh<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbPmTableReset<s(1)(1)(0)>[&];   
	char		pbPmTimeStart<s(1)(1)(0)>[&][16];   
	unsigned int	pbPmTimeElapse<s(1)(1)(0)>[&];   
	PbPmPortStatusType_Tval<s(1)(1)(0)>[T] pbPmProtStatus<s(1)(1)(0)>[&];   
	PbPmTpStatusType_Tval<s(1)(1)(0)>[T] pbPmTpStatus<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbPmSuspect<s(1)(1)(0)>[&];   
}MIBpbSdhCurPMTable_t<s(0)(0)(0)>[&];(D1:MIBpbSdhCurPMTable_t:1)[[TYPENAME:MIBpbSdhCurPMTable_t]]

























































 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbEthCurPMTable_Did<s(0)(0)(0)>[&];(D1:pbEthCurPMTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                                                   
	int		pbPortNo<s(1)(1)(0)>[&];                                                                                        
	PbPmTableType_Tval<s(1)(1)(0)>[T] pbEthTableType<s(1)(1)(0)>[&];                                                                       
	EthPortClass_Tval<s(1)(1)(0)>[T] pbEthPmPortType<s(1)(1)(0)>[&];                                                                    
	PbPmMonitor_Tval<s(1)(1)(0)>[T] pbEthPmMonitor<s(1)(1)(0)>[&];   
	char		pbEthPmTimeStart<s(1)(1)(0)>[&][16];   
	unsigned int	pbEthPmTimeElapse<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbEthPmTimeSuspect<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbEthPmTableReset<s(1)(1)(0)>[&];   
	unsigned int	pbEthInUnicastPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthInUnicastPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthInMulcastPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthInMulcastPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthInBrdcastPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthInBrdcastPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthInAllBadPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthInAllBadPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthInAllBadBytesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthInAllBadBytesLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthInAllGoodPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthInAllGoodPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthInAllGoodBytesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthInAllGoodBytesLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthInOverSizePktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthInOverSizePktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthInUnderSizePktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthInUnderSizePktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthInCRCErrPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthInCRCErrPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthOutUnicastPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthOutUnicastPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthOutMulcastPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthOutMulcastPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthOutBrdcastPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthOutBrdcastPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthOutAllGoodPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthOutAllGoodPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthOutAllGoodBytesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthOutAllGoodBytesLow<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbEthBbrEnable<s(1)(1)(0)>[&];   
	int		pbEthBbrThresholdValue<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbEthBprEnable<s(1)(1)(0)>[&];   
	int		pbEthBprThresholdValue<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurInAllBytesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurInAllBytesLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurInAllPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurInAllPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurInAllGoodPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurInAllGoodPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurInAllBadPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurInAllBadPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurInUnicastPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurInUnicastPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurInMulcastPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurInMulcastPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurInBrdcastPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurInBrdcastPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurInDropPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurInDropPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurInUndersizeGoodPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurInUndersizeGoodPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurInOversizeGoodPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurInOversizeGoodPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurIn64PktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurIn64PktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurIn65To127PktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurIn65To127PktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurIn128To255PktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurIn128To255PktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurIn256To511PktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurIn256To511PktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurIn512To1023PktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurIn512To1023PktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurIn1024To1518PktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurIn1024To1518PktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurInPausePktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurInPausePktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurInFragmentPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurInFragmentPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurInJabberPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurInJabberPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurInAlignmentErrorPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurInAlignmentErrorPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurOutAllBytesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurOutAllBytesLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurOutAllPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurOutAllPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurOutUnicastPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurOutUnicastPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurOutMulcastPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurOutMulcastPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurOutBrdcastPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurOutBrdcastPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurOutGoodPausePktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurOutGoodPausePktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurOutCollisionPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthCurOutCollisionPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbCurOutInvalidSymbolsHigh<s(1)(1)(0)>[&];
	unsigned int	pbCurOutInvalidSymbolsLow<s(1)(1)(0)>[&];
	unsigned int	pbCurOutSuperblockCrcErrorHigh<s(1)(1)(0)>[&];
	unsigned int	pbCurOutSuperblockCrcErrorLow<s(1)(1)(0)>[&];
	unsigned int	pbCurOutSuperblockCorrectableCrcErrorHigh<s(1)(1)(0)>[&];
	unsigned int	pbCurOutSuperblockCorrectableCrcErrorLow<s(1)(1)(0)>[&];
}MIBpbEthCurPMTable_t<s(0)(0)(0)>[&];(D1:MIBpbEthCurPMTable_t:1)[[TYPENAME:MIBpbEthCurPMTable_t]]














































































































 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbxSecEthPmMonTable_Did<s(0)(0)(0)>[&];(D1:pbxSecEthPmMonTable_Did:0)

   
typedef enum {
	pbxSecEthPmReportStatus_notReport<s(0)(0)(0)>[&]=1,
	pbxSecEthPmReportStatus_reportOnce<s(0)(0)(0)>[&]=2
} pbxSecEthPmReportStatus_Tval<s(0)(0)(0)>[&];(D1:pbxSecEthPmReportStatus_Tval:1)[[TYPENAME:pbxSecEthPmReportStatus_Tval]]

typedef enum {
	pbxSecEthPmMonitorStatus_notMonitor<s(0)(0)(0)>[&]=1,
	pbxSecEthPmMonitorStatus_monitor<s(0)(0)(0)>[&]=2
} pbxSecEthPmMonitorStatus_Tval<s(0)(0)(0)>[&];(D1:pbxSecEthPmMonitorStatus_Tval:1)[[TYPENAME:pbxSecEthPmMonitorStatus_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                 
	int		pbPortNo<s(1)(1)(0)>[&];                                                      
	EthPortClass_Tval<s(1)(1)(0)>[T] pbxSecEthPmPortType<s(1)(1)(0)>[&];                                 
	pbxSecEthPmReportStatus_Tval<s(1)(1)(0)>[T] pbxSecEthPmReportStatus<s(1)(1)(0)>[&];   
	pbxSecEthPmMonitorStatus_Tval<s(1)(1)(0)>[T] pbxSecEthPmMonitorStatus<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthPmFtpHostIP<s(1)(1)(0)>[&];   
	char		pbxSecEthPmFtpPath<s(1)(1)(0)>[&][64];   
	char		pbxSecEthPmFtpFileName<s(1)(1)(0)>[&][13];   
	char		pbxSecEthPmFtpUsername<s(1)(1)(0)>[&][32];   
	char		pbxSecEthPmFtpPassword<s(1)(1)(0)>[&][32];   
	char		pbxSecEthPmRequestId<s(1)(1)(0)>[&][40];   
	PbPmReportResp_Tval<s(1)(1)(0)>[T] pbxSecEthPmRespMsg<s(1)(1)(0)>[&];   
}MIBpbxSecEthPmMonTable_t<s(0)(0)(0)>[&];(D1:MIBpbxSecEthPmMonTable_t:1)[[TYPENAME:MIBpbxSecEthPmMonTable_t]]



















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbRprClientCurPMTable_Did<s(0)(0)(0)>[&];(D1:pbRprClientCurPMTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                                             
	int		rprIfIndex<s(1)(1)(0)>[&];                                                                                
	PbPmTableType_Tval<s(1)(1)(0)>[T] pbRprClientTableType<s(1)(1)(0)>[&];                                                           
	PbPmMonitor_Tval<s(1)(1)(0)>[T] pbRprClientPmMonitor<s(1)(1)(0)>[&];   
	char		pbRprClientPmTimeStart<s(1)(1)(0)>[&][16];   
	unsigned int	pbRprClientPmTimeElapse<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbRprClientPmTimeSuspect<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbRprClientPmTableReset<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientInAllFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientInAllFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutAllFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutAllFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutPassFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutPassFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutDropFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutDropFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutErrLenFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutErrLenFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutErrCrcFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutErrCrcFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientInUcastClassAFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientInUcastClassAFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientInUcastClassAOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientInUcastClassAOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientInUcastClassBCirFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientInUcastClassBCirFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientInUcastClassBCirOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientInUcastClassBCirOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientInUcastClassBEirFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientInUcastClassBEirFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientInUcastClassBEirOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientInUcastClassBEirOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientInUcastClassCFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientInUcastClassCFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientInUcastClassCOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientInUcastClassCOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientInMcastClassAFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientInMcastClassAFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientInMcastClassAOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientInMcastClassAOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientInMcastClassBCirFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientInMcastClassBCirFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientInMcastClassBCirOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientInMcastClassBCirOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientInMcastClassBEirFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientInMcastClassBEirFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientInMcastClassBEirOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientInMcastClassBEirOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientInMcastClassCFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientInMcastClassCFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientInMcastClassCOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientInMcastClassCOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutUcastClassAFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutUcastClassAFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutUcastClassAOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutUcastClassAOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutUcastClassBCirFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutUcastClassBCirFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutUcastClassBCirOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutUcastClassBCirOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutUcastClassBEirFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutUcastClassBEirFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutUcastClassBEirOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutUcastClassBEirOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutUcastClassCFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutUcastClassCFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutUcastClassCOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutUcastClassCOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutMcastClassAFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutMcastClassAFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutMcastClassAOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutMcastClassAOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutMcastClassBCirFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutMcastClassBCirFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutMcastClassBCirOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutMcastClassBCirOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutMcastClassBEirFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutMcastClassBEirFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutMcastClassBEirOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutMcastClassBEirOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutMcastClassCFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutMcastClassCFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutMcastClassCOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientOutMcastClassCOctetsLow<s(1)(1)(0)>[&];   
}MIBpbRprClientCurPMTable_t<s(0)(0)(0)>[&];(D1:MIBpbRprClientCurPMTable_t:1)[[TYPENAME:MIBpbRprClientCurPMTable_t]]



























































































 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbRprSpanCurPMTable_Did<s(0)(0)(0)>[&];(D1:pbRprSpanCurPMTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                                         
	int		rprIfIndex<s(1)(1)(0)>[&];                                                                            
	RprSpan_Tval<s(1)(1)(0)>[T] rprSpanId<s(1)(1)(0)>[&];                                                                     
	PbPmTableType_Tval<s(1)(1)(0)>[T] pbRprSpanTableType<s(1)(1)(0)>[&];                                                         
	PbPmMonitor_Tval<s(1)(1)(0)>[T] pbRprSpanPmMonitor<s(1)(1)(0)>[&];   
	char		pbRprSpanPmTimeStart<s(1)(1)(0)>[&][16];   
	unsigned int	pbRprSpanPmTimeElapse<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbRprSpanPmTimeSuspect<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbRprSpanPmTableReset<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInAllFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInAllFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInWrapFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInWrapFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInDataFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInDataFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInCtrlFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInCtrlFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInFaFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInFaFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutAllFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutAllFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutAddFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutAddFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutTransitFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutTransitFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutWrapFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutWrapFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutTpFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutTpFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutFaFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutFaFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutOamFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutOamFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanErrHecFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanErrHecFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanErrParityFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanErrParityFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanErrFcsFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanErrFcsFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanErrEdgeFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanErrEdgeFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanErrSelfSourceFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanErrSelfSourceFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInUcastClassAFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInUcastClassAFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInUcastClassAOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInUcastClassAOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInUcastClassBCirFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInUcastClassBCirFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInUcastClassBCirOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInUcastClassBCirOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInUcastClassBEirFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInUcastClassBEirFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInUcastClassBEirOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInUcastClassBEirOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInUcastClassCFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInUcastClassCFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInUcastClassCOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInUcastClassCOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInMcastClassAFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInMcastClassAFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInMcastClassAOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInMcastClassAOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInMcastClassBCirFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInMcastClassBCirFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInMcastClassBCirOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInMcastClassBCirOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInMcastClassBEirFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInMcastClassBEirFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInMcastClassBEirOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInMcastClassBEirOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInMcastClassCFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInMcastClassCFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInMcastClassCOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanInMcastClassCOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutUcastClassAFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutUcastClassAFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutUcastClassAOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutUcastClassAOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutUcastClassBCirFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutUcastClassBCirFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutUcastClassBCirOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutUcastClassBCirOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutUcastClassBEirFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutUcastClassBEirFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutUcastClassBEirOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutUcastClassBEirOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutUcastClassCFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutUcastClassCFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutUcastClassCOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutUcastClassCOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutMcastClassAFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutMcastClassAFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutMcastClassAOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutMcastClassAOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutMcastClassBCirFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutMcastClassBCirFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutMcastClassBCirOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutMcastClassBCirOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutMcastClassBEirFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutMcastClassBEirFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutMcastClassBEirOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutMcastClassBEirOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutMcastClassCFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutMcastClassCFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutMcastClassCOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanOutMcastClassCOctetsLow<s(1)(1)(0)>[&];   
}MIBpbRprSpanCurPMTable_t<s(0)(0)(0)>[&];(D1:MIBpbRprSpanCurPMTable_t:1)[[TYPENAME:MIBpbRprSpanCurPMTable_t]]


















































































































 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbPdhCurSlipTable_Did<s(0)(0)(0)>[&];(D1:pbPdhCurSlipTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                             
	PbPortType_Tval<s(1)(1)(0)>[T] pbPortType<s(1)(1)(0)>[&];                                     
	int		pbPortNo<s(1)(1)(0)>[&];                                                  
	PbPmTableType_Tval<s(1)(1)(0)>[T] pbSlipTableType<s(1)(1)(0)>[&];                                
	PbPmMonitor_Tval<s(1)(1)(0)>[T] pbSlipMonitor<s(1)(1)(0)>[&];   
	unsigned int	pbPSlipCounter<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbPSlipThresholdEnable<s(1)(1)(0)>[&];   
	int		pbPSlipThreshold<s(1)(1)(0)>[&];   
	unsigned int	pbNSlipCounter<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbNSlipThresholdEnable<s(1)(1)(0)>[&];   
	int		pbNSlipThreshold<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbSlipTableReset<s(1)(1)(0)>[&];   
	char		pbSlipTimeStart<s(1)(1)(0)>[&][16];   
	unsigned int	pbSlipTimeElapse<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbSlipSuspect<s(1)(1)(0)>[&];   
}MIBpbPdhCurSlipTable_t<s(0)(0)(0)>[&];(D1:MIBpbPdhCurSlipTable_t:1)[[TYPENAME:MIBpbPdhCurSlipTable_t]]






















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbPmMonitoredNumberTable_Did<s(0)(0)(0)>[&];(D1:pbPmMonitoredNumberTable_Did:0)

   
typedef struct
{
	unsigned int	pbSdhFtpCmndHostIP<s(1)(1)(0)>[&];                                
	int		pbPmMonitoredAll<s(1)(1)(0)>[&];   
	int		pbPmMonitoredCtp<s(1)(1)(0)>[&];   
	int		pbPmMonitoredTtp<s(1)(1)(0)>[&];   
	int		pbPmMonitoredEth<s(1)(1)(0)>[&];   
	int		pbPmMonitoredRprClient<s(1)(1)(0)>[&];   
	int		pbPmMonitoredRprSpan<s(1)(1)(0)>[&];   
	int		pbPmMonitoredAtm<s(1)(1)(0)>[&];   
	int		pbPmMonitoredPdhSlip<s(1)(1)(0)>[&];   
	int		pbPmMonitoredPdhCrc<s(1)(1)(0)>[&];   
	int		pbPmMonitoredFec<s(1)(1)(0)>[&];   
	int		pbPmMonitoredOtu<s(1)(1)(0)>[&];
}MIBpbPmMonitoredNumberTable_t<s(0)(0)(0)>[&];(D1:MIBpbPmMonitoredNumberTable_t:1)[[TYPENAME:MIBpbPmMonitoredNumberTable_t]]



















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbxSecEthPMTable_Did<s(0)(0)(0)>[&];(D1:pbxSecEthPMTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                               
	int		pbPortNo<s(1)(1)(0)>[&];                                                    
	EthPortClass_Tval<s(1)(1)(0)>[T] pbxSecEthCurPmPortType<s(1)(1)(0)>[&];                         
	RowStatus_Tval<s(1)(1)(0)>[T] pbxSecEthPmEnableStatus<s(1)(1)(0)>[&];   
	char		pbxSecEthPmTimeStart<s(1)(1)(0)>[&][16];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbxSecEthPmStartFlag<s(1)(1)(0)>[&];   
}MIBpbxSecEthPMTable_t<s(0)(0)(0)>[&];(D1:MIBpbxSecEthPMTable_t:1)[[TYPENAME:MIBpbxSecEthPMTable_t]]













 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbPdhCurPMTable_Did<s(0)(0)(0)>[&];(D1:pbPdhCurPMTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                     
	PbPortType_Tval<s(1)(1)(0)>[T] pbPortType<s(1)(1)(0)>[&];                                             
	int		pbPortNo<s(1)(1)(0)>[&];                                                          
	PbPmTableType_Tval<s(1)(1)(0)>[T] pbPdhTableType<s(1)(1)(0)>[&];                                         
	PbPmMonitor_Tval<s(1)(1)(0)>[T] pbPdhPmMonitor<s(1)(1)(0)>[&];   
	unsigned int	pbPdhEsPmCounter<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbPdhEsPmThresholdEnable<s(1)(1)(0)>[&];   
	int		pbPdhEsPmThresholdLow<s(1)(1)(0)>[&];   
	int		pbPdhEsPmThresholdHigh<s(1)(1)(0)>[&];   
	unsigned int	pbPdhBbePmCounter<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbPdhBbePmThresholdEnable<s(1)(1)(0)>[&];   
	int		pbPdhBbePmThresholdLow<s(1)(1)(0)>[&];   
	int		pbPdhBbePmThresholdHigh<s(1)(1)(0)>[&];   
	unsigned int	pbPdhSesPmCounter<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbPdhSesPmThresholdEnable<s(1)(1)(0)>[&];   
	int		pbPdhSesPmThresholdLow<s(1)(1)(0)>[&];   
	int		pbPdhSesPmThresholdHigh<s(1)(1)(0)>[&];   
	unsigned int	pbPdhUasPmCounter<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbPdhUasPmThresholdEnable<s(1)(1)(0)>[&];   
	int		pbPdhUasPmThresholdLow<s(1)(1)(0)>[&];   
	int		pbPdhUasPmThresholdHigh<s(1)(1)(0)>[&];   
	unsigned int	pbPdhCsesPmCounter<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbPdhCsesPmThresholdEnable<s(1)(1)(0)>[&];   
	int		pbPdhCsesPmThresholdLow<s(1)(1)(0)>[&];   
	int		pbPdhCsesPmThresholdHigh<s(1)(1)(0)>[&];   
	unsigned int	pbPdhFcPmCounter<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbPdhFcPmThresholdEnable<s(1)(1)(0)>[&];   
	int		pbPdhFcPmThresholdLow<s(1)(1)(0)>[&];   
	int		pbPdhFcPmThresholdHigh<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbPdhPmTableReset<s(1)(1)(0)>[&];   
	char		pbPdhPmTimeStart<s(1)(1)(0)>[&][16];   
	unsigned int	pbPdhPmTimeElapse<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbPdhPmSuspect<s(1)(1)(0)>[&];   
}MIBpbPdhCurPMTable_t<s(0)(0)(0)>[&];(D1:MIBpbPdhCurPMTable_t:1)[[TYPENAME:MIBpbPdhCurPMTable_t]]








































 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbEthVlanPMTable_Did<s(0)(0)(0)>[&];(D1:pbEthVlanPMTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                           
	int		pbPortNo<s(1)(1)(0)>[&];                                                                
	PbPmTableType_Tval<s(1)(1)(0)>[T] pbEthVlanTableType<s(1)(1)(0)>[&];                                           
	EthPortClass_Tval<s(1)(1)(0)>[T] pbEthPmPortType<s(1)(1)(0)>[&];                                            
	int		pbEthVlanNo<s(1)(1)(0)>[&];                                                             
	PbPmMonitor_Tval<s(1)(1)(0)>[T] pbEthVlanPmMonitor<s(1)(1)(0)>[&];   
	char		pbEthVlanPmTimeStart<s(1)(1)(0)>[&][16];   
	unsigned int	pbEthVlanPmTimeElapse<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbEthVlanPmTimeSuspect<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbEthVlanPmTableReset<s(1)(1)(0)>[&];   
	unsigned int	pbEthVlanInPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthVlanInPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthVlanInBytesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthVlanInBytesLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthVlanDropPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthVlanDropPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthVlanRcvUnicastFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthVlanRcvUnicastFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthVlanRcvTotalFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthVlanRcvTotalFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthVlanRcvUnicastBytesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthVlanRcvUnicastBytesLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthVlanRcvTotalBytesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthVlanRcvTotalBytesLow<s(1)(1)(0)>[&];   
	RowStatus_Tval<s(1)(1)(0)>[T] pbEthVlanPmEnableStatus<s(1)(1)(0)>[&];   
}MIBpbEthVlanPMTable_t<s(0)(0)(0)>[&];(D1:MIBpbEthVlanPMTable_t:1)[[TYPENAME:MIBpbEthVlanPMTable_t]]
































 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbxSecEthVlanPMTable_Did<s(0)(0)(0)>[&];(D1:pbxSecEthVlanPMTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                       
	int		pbPortNo<s(1)(1)(0)>[&];                                                            
	EthPortClass_Tval<s(1)(1)(0)>[T] pbEthPmPortType<s(1)(1)(0)>[&];                                        
	int		pbEthVlanNo<s(1)(1)(0)>[&];                                                         
	RowStatus_Tval<s(1)(1)(0)>[T] pbxSecEthVlanPmEnableStatus<s(1)(1)(0)>[&];   
	char		pbxSecEthVlanPmTimeStart<s(1)(1)(0)>[&][16];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbxSecEthVlanPmStartFlag<s(1)(1)(0)>[&];   
}MIBpbxSecEthVlanPMTable_t<s(0)(0)(0)>[&];(D1:MIBpbxSecEthVlanPMTable_t:1)[[TYPENAME:MIBpbxSecEthVlanPMTable_t]]














 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbEthTcaPMTable_Did<s(0)(0)(0)>[&];(D1:pbEthTcaPMTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                 
	int		pbPortNo<s(1)(1)(0)>[&];                                                      
	EthPortClass_Tval<s(1)(1)(0)>[T] pbEthPmPortType<s(1)(1)(0)>[&];                                  
	TruthValue_Tval<s(1)(1)(0)>[T] pbEthPmBbrEnable<s(1)(1)(0)>[&];   
	int		pbEthPmBbrThresholdValue<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbEthPmBprEnable<s(1)(1)(0)>[&];   
	int		pbEthPmBprThresholdValue<s(1)(1)(0)>[&];   
}MIBpbEthTcaPMTable_t<s(0)(0)(0)>[&];(D1:MIBpbEthTcaPMTable_t:1)[[TYPENAME:MIBpbEthTcaPMTable_t]]














 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbFecCurPMTable_Did<s(0)(0)(0)>[&];(D1:pbFecCurPMTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                               
	PbPortType_Tval<s(1)(1)(0)>[T] pbPortType<s(1)(1)(0)>[&];                                       
	int		pbPortNo<s(1)(1)(0)>[&];                                                    
	PbPmTableType_Tval<s(1)(1)(0)>[T] pbFecTableType<s(1)(1)(0)>[&];                                   
	PbPmMonitor_Tval<s(1)(1)(0)>[T] pbFecPmMonitor<s(1)(1)(0)>[&];   
	unsigned int	pbFecTecPmCounterHigh<s(1)(1)(0)>[&];   
	unsigned int	pbFecTecPmCounterLow<s(1)(1)(0)>[&];   
	unsigned int	pbFecZecPmCounterHigh<s(1)(1)(0)>[&];   
	unsigned int	pbFecZecPmCounterLow<s(1)(1)(0)>[&];   
	unsigned int	pbFecOecPmCounterHigh<s(1)(1)(0)>[&];   
	unsigned int	pbFecOecPmCounterLow<s(1)(1)(0)>[&];   
	unsigned int	pbFecFcPmCounter<s(1)(1)(0)>[&];
	TruthValue_Tval<s(1)(1)(0)>[T] pbFecPmTableReset<s(1)(1)(0)>[&];   
	char		pbFecPmTimeStart<s(1)(1)(0)>[&][16];   
	unsigned int	pbFecPmTimeElapse<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbFecPmSuspect<s(1)(1)(0)>[&];   
	unsigned int	pbFecUncorrectedBlkHigh<s(1)(1)(0)>[&];
	unsigned int	pbFecUncorrectedBlkLow<s(1)(1)(0)>[&];
}MIBpbFecCurPMTable_t<s(0)(0)(0)>[&];(D1:MIBpbFecCurPMTable_t:1)[[TYPENAME:MIBpbFecCurPMTable_t]]

























 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbOtuCurPMTable_Did<s(0)(0)(0)>[&];(D1:pbOtuCurPMTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                       
	PbPortType_Tval<s(1)(1)(0)>[T] pbPortType<s(1)(1)(0)>[&];                               
	int		pbPortNo<s(1)(1)(0)>[&];                                            
	PbPmTableType_Tval<s(1)(1)(0)>[T] pbOtuTableType<s(1)(1)(0)>[&];                        
	unsigned int	pbChannelID<s(1)(1)(0)>[&];                                 
	unsigned int	pbSegmentNum<s(1)(1)(0)>[&];                                
	PbPmMonitor_Tval<s(1)(1)(0)>[T] pbOtuPmMonitor<s(1)(1)(0)>[&];
	unsigned int	pbOtuEsPmCounter<s(1)(1)(0)>[&];
	unsigned int	pbOtuBbePmCounter<s(1)(1)(0)>[&];
	unsigned int	pbOtuSesPmCounter<s(1)(1)(0)>[&];
	unsigned int	pbOtuUasPmCounter<s(1)(1)(0)>[&];
	unsigned int	pbOtuCsesPmCounter<s(1)(1)(0)>[&];
	unsigned int	pbOtuFcPmCounter<s(1)(1)(0)>[&];
	unsigned int	pbOtuOfsPmCounter<s(1)(1)(0)>[&];
	unsigned int	pbOtuIaesPmCounter<s(1)(1)(0)>[&];
	unsigned int	pbOtuBiaesPmCounter<s(1)(1)(0)>[&];
	TruthValue_Tval<s(1)(1)(0)>[T] pbOtuPmTableReset<s(1)(1)(0)>[&];
	char		pbOtuPmTimeStart<s(1)(1)(0)>[&][16];
	unsigned int	pbOtuPmTimeElapse<s(1)(1)(0)>[&];
	TruthValue_Tval<s(1)(1)(0)>[T] pbOtuPmSuspect<s(1)(1)(0)>[&];
}MIBpbOtuCurPMTable_t<s(0)(0)(0)>[&];(D1:MIBpbOtuCurPMTable_t:1)[[TYPENAME:MIBpbOtuCurPMTable_t]]



























 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbSdhRecentPMTable_Did<s(0)(0)(0)>[&];(D1:pbSdhRecentPMTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                           
	PbPortType_Tval<s(1)(1)(0)>[T] pbPortType<s(1)(1)(0)>[&];                                   
	int		pbPortNo<s(1)(1)(0)>[&];                                                
	PbTPType_Tval<s(1)(1)(0)>[T] pbTpType<s(1)(1)(0)>[&];                                       
	int		pbTpIndex<s(1)(1)(0)>[&];                                               
	PbPmTableType_Tval<s(1)(1)(0)>[T] pbRecentTableType<s(1)(1)(0)>[&];                            
	int		pbRecentTimesIndex<s(1)(1)(0)>[&];                                         
	unsigned int	pbRecentEsPmCounter<s(1)(1)(0)>[&];   
	unsigned int	pbRecentBbePmCounter<s(1)(1)(0)>[&];   
	unsigned int	pbRecentSesPmCounter<s(1)(1)(0)>[&];   
	unsigned int	pbRecentUasPmCounter<s(1)(1)(0)>[&];   
	unsigned int	pbRecentCsesPmCounter<s(1)(1)(0)>[&];   
	unsigned int	pbRecentFcPmCounter<s(1)(1)(0)>[&];   
	unsigned int	pbRecentOfsPmCounter<s(1)(1)(0)>[&];   
	unsigned int	pbRecentPpjcPmCounter<s(1)(1)(0)>[&];   
	unsigned int	pbRecentNpjcPmCounter<s(1)(1)(0)>[&];   
	char		pbRecentPmTimeEnd<s(1)(1)(0)>[&][16];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbSuspect<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbComplete<s(1)(1)(0)>[&];   
}MIBpbSdhRecentPMTable_t<s(0)(0)(0)>[&];(D1:MIBpbSdhRecentPMTable_t:1)[[TYPENAME:MIBpbSdhRecentPMTable_t]]


























 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbEthRecentPMTable_Did<s(0)(0)(0)>[&];(D1:pbEthRecentPMTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                                   
	int		pbPortNo<s(1)(1)(0)>[&];                                                                        
	PbPmTableType_Tval<s(1)(1)(0)>[T] pbEthRecentTableType<s(1)(1)(0)>[&];                                                 
	EthPortClass_Tval<s(1)(1)(0)>[T] pbEthRecentPmPortType<s(1)(1)(0)>[&];                                                 
	int		pbEthRecentTimesIndex<s(1)(1)(0)>[&];                                                              
	char		pbEthRecentPmTimeEnd<s(1)(1)(0)>[&][16];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbEthRecentPmTimeSuspect<s(1)(1)(0)>[&];   
	unsigned int	pbEthRecentInUnicastPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRecentInUnicastPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRecentInMulcastPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRecentInMulcastPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRecentInBrdcastPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRecentInBrdcastPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRecentInAllBadPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRecentInAllBadPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRecentInAllBadBytesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRecentInAllBadBytesLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRecentInAllGoodPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRecentInAllGoodPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRecentInAllGoodBytesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRecentInAllGoodBytesLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRecentInOverSizePktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRecentInOverSizePktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRecentInUnderSizePktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRecentInUnderSizePktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRecentInCRCErrPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRecentInCRCErrPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRecentOutUnicastPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRecentOutUnicastPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRecentOutMulcastPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRecentOutMulcastPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRecentOutBrdcastPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRecentOutBrdcastPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRecentOutAllGoodPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRecentOutAllGoodPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRecentOutAllGoodBytesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRecentOutAllGoodBytesLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntInAllBytesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntInAllBytesLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntInAllPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntInAllPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntInAllGoodPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntInAllGoodPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntInAllBadPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntInAllBadPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntInUnicastPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntInUnicastPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntInMulcastPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntInMulcastPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntInBrdcastPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntInBrdcastPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntInDropPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntInDropPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntInUndersizeGoodPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntInUndersizeGoodPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntInOversizeGoodPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntInOversizeGoodPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntIn64PktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntIn64PktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntIn65To127PktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntIn65To127PktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntIn128To255PktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntIn128To255PktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntIn256To511PktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntIn256To511PktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntIn512To1023PktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntIn512To1023PktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntIn1024To1518PktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntIn1024To1518PktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntInPausePktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntInPausePktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntInFragmentPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntInFragmentPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntInJabberPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntInJabberPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntInAlignmentErrorPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntInAlignmentErrorPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntOutAllBytesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntOutAllBytesLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntOutAllPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntOutAllPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntOutUnicastPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntOutUnicastPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntOutMulcastPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntOutMulcastPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntOutBrdcastPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntOutBrdcastPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntOutGoodPausePktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntOutGoodPausePktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntOutCollisionPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthRcntOutCollisionPktsLow<s(1)(1)(0)>[&];   
}MIBpbEthRecentPMTable_t<s(0)(0)(0)>[&];(D1:MIBpbEthRecentPMTable_t:1)[[TYPENAME:MIBpbEthRecentPMTable_t]]


































































































 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbRprClientRecentPMTable_Did<s(0)(0)(0)>[&];(D1:pbRprClientRecentPMTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                                                         
	int		rprIfIndex<s(1)(1)(0)>[&];                                                                                            
	PbPmTableType_Tval<s(1)(1)(0)>[T] pbRprClientRecentTableType<s(1)(1)(0)>[&];                                                                 
	int		pbRprClientTableRecentTimesIndex<s(1)(1)(0)>[&];                                                                         
	char		pbRprClientRecentPmTimeEnd<s(1)(1)(0)>[&][16];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbRprClientRecentPmTimeSuspect<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentInAllFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentInAllFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutAllFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutAllFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutPassFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutPassFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutDropFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutDropFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutErrLenFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutErrLenFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutErrCrcFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutErrCrcFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentInUcastClassAFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentInUcastClassAFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentInUcastClassAOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentInUcastClassAOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentInUcastClassBCirFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentInUcastClassBCirFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentInUcastClassBCirOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentInUcastClassBCirOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentInUcastClassBEirFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentInUcastClassBEirFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentInUcastClassBEirOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentInUcastClassBEirOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentInUcastClassCFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentInUcastClassCFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentInUcastClassCOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentInUcastClassCOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentInMcastClassAFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentInMcastClassAFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentInMcastClassAOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentInMcastClassAOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentInMcastClassBCirFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentInMcastClassBCirFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentInMcastClassBCirOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentInMcastClassBCirOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentInMcastClassBEirFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentInMcastClassBEirFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentInMcastClassBEirOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentInMcastClassBEirOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentInMcastClassCFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentInMcastClassCFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentInMcastClassCOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentInMcastClassCOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutUcastClassAFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutUcastClassAFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutUcastClassAOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutUcastClassAOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutUcastClassBCirFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutUcastClassBCirFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutUcastClassBCirOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutUcastClassBCirOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutUcastClassBEirFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutUcastClassBEirFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutUcastClassBEirOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutUcastClassBEirOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutUcastClassCFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutUcastClassCFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutUcastClassCOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutUcastClassCOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutMcastClassAFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutMcastClassAFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutMcastClassAOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutMcastClassAOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutMcastClassBCirFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutMcastClassBCirFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutMcastClassBCirOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutMcastClassBCirOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutMcastClassBEirFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutMcastClassBEirFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutMcastClassBEirOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutMcastClassBEirOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutMcastClassCFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutMcastClassCFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutMcastClassCOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprClientRecentOutMcastClassCOctetsLow<s(1)(1)(0)>[&];   
}MIBpbRprClientRecentPMTable_t<s(0)(0)(0)>[&];(D1:MIBpbRprClientRecentPMTable_t:1)[[TYPENAME:MIBpbRprClientRecentPMTable_t]]

























































































 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbRprSpanRecentPMTable_Did<s(0)(0)(0)>[&];(D1:pbRprSpanRecentPMTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                                                     
	int		rprIfIndex<s(1)(1)(0)>[&];                                                                                        
	RprSpan_Tval<s(1)(1)(0)>[T] rprSpanId<s(1)(1)(0)>[&];                                                                                 
	PbPmTableType_Tval<s(1)(1)(0)>[T] pbRprSpanRecentTableType<s(1)(1)(0)>[&];                                                               
	int		pbRprSpanTableRecentTimesIndex<s(1)(1)(0)>[&];                                                                       
	char		pbRprSpanRecentPmTimeEnd<s(1)(1)(0)>[&][16];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbRprSpanRecentPmTimeSuspect<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInAllFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInAllFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInWrapFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInWrapFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInDataFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInDataFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInCtrlFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInCtrlFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInFaFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInFaFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutAllFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutAllFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutAddFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutAddFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutTransitFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutTransitFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutWrapFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutWrapFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutTpFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutTpFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutFaFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutFaFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutOamFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutOamFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentErrHecFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentErrHecFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentErrParityFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentErrParityFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentErrFcsFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentErrFcsFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentErrEdgeFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentErrEdgeFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentErrSelfSourceFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentErrSelfSourceFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInUcastClassAFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInUcastClassAFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInUcastClassAOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInUcastClassAOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInUcastClassBCirFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInUcastClassBCirFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInUcastClassBCirOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInUcastClassBCirOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInUcastClassBEirFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInUcastClassBEirFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInUcastClassBEirOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInUcastClassBEirOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInUcastClassCFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInUcastClassCFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInUcastClassCOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInUcastClassCOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInMcastClassAFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInMcastClassAFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInMcastClassAOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInMcastClassAOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInMcastClassBCirFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInMcastClassBCirFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInMcastClassBCirOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInMcastClassBCirOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInMcastClassBEirFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInMcastClassBEirFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInMcastClassBEirOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInMcastClassBEirOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInMcastClassCFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInMcastClassCFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInMcastClassCOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentInMcastClassCOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutUcastClassAFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutUcastClassAFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutUcastClassAOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutUcastClassAOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutUcastClassBCirFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutUcastClassBCirFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutUcastClassBCirOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutUcastClassBCirOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutUcastClassBEirFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutUcastClassBEirFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutUcastClassBEirOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutUcastClassBEirOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutUcastClassCFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutUcastClassCFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutUcastClassCOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutUcastClassCOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutMcastClassAFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutMcastClassAFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutMcastClassAOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutMcastClassAOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutMcastClassBCirFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutMcastClassBCirFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutMcastClassBCirOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutMcastClassBCirOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutMcastClassBEirFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutMcastClassBEirFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutMcastClassBEirOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutMcastClassBEirOctetsLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutMcastClassCFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutMcastClassCFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutMcastClassCOctetsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbRprSpanRecentOutMcastClassCOctetsLow<s(1)(1)(0)>[&];   
}MIBpbRprSpanRecentPMTable_t<s(0)(0)(0)>[&];(D1:MIBpbRprSpanRecentPMTable_t:1)[[TYPENAME:MIBpbRprSpanRecentPMTable_t]]
















































































































 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbPdhRecentSlipTable_Did<s(0)(0)(0)>[&];(D1:pbPdhRecentSlipTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                             
	PbPortType_Tval<s(1)(1)(0)>[T] pbPortType<s(1)(1)(0)>[&];                                     
	int		pbPortNo<s(1)(1)(0)>[&];                                                  
	PbPmTableType_Tval<s(1)(1)(0)>[T] pbRecentSlipTableType<s(1)(1)(0)>[&];                          
	int		pbRecentSlipTimesIndex<s(1)(1)(0)>[&];                                       
	unsigned int	pbRecentPSlipCounter<s(1)(1)(0)>[&];   
	unsigned int	pbRecentNSlipCounter<s(1)(1)(0)>[&];   
	char		pbSlipTimeEnd<s(1)(1)(0)>[&][16];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbRecentSlipSuspect<s(1)(1)(0)>[&];   
}MIBpbPdhRecentSlipTable_t<s(0)(0)(0)>[&];(D1:MIBpbPdhRecentSlipTable_t:1)[[TYPENAME:MIBpbPdhRecentSlipTable_t]]
















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbxSecEthRecentPMTable_Did<s(0)(0)(0)>[&];(D1:pbxSecEthRecentPMTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                                   
	int		pbPortNo<s(1)(1)(0)>[&];                                                                        
	EthPortClass_Tval<s(1)(1)(0)>[T] pbxSecEthRecentPmPortType<s(1)(1)(0)>[&];                                             
	int		pbxSecEthTimesIndex<s(1)(1)(0)>[&];                                                                
	TruthValue_Tval<s(1)(1)(0)>[T] pbxSecEthRecentPmStartFlag<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRecentInUnicastPkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRecentInMulcastPkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRecentInBrdcastPkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRecentInAllBadPkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRecentInAllBadBytes<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRecentInAllGoodPkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRecentInAllGoodBytes<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRecentInOverSizePkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRecentInUnderSizePkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRecentInCRCErrPkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRecentOutUnicastPkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRecentOutMulcastPkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRecentOutBrdcastPkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRecentOutAllGoodPkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRecentOutAllGoodBytes<s(1)(1)(0)>[&];   
	int		pbxSecEthFrmStartIndex<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRcntInAllBytes<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRcntInAllPkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRcntInAllGoodPkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRcntInAllBadPkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRcntInUnicastPkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRcntInMulcastPkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRcntInBrdcastPkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRcntInDropPkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRcntInUndersizeGoodPkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRcntInOversizeGoodPkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRcntIn64Pkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRcntIn65To127Pkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRcntIn128To255Pkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRcntIn256To511Pkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRcntIn512To1023Pkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRcntIn1024To1518Pkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRcntInPausePkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRcntInFragmentPkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRcntInJabberPkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRcntInAlignmentErrorPkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRcntOutAllBytes<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRcntOutAllPkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRcntOutUnicastPkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRcntOutMulcastPkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRcntOutBrdcastPkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRcntOutGoodPausePkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthRcntOutCollisionPkts<s(1)(1)(0)>[&];   
}MIBpbxSecEthRecentPMTable_t<s(0)(0)(0)>[&];(D1:MIBpbxSecEthRecentPMTable_t:1)[[TYPENAME:MIBpbxSecEthRecentPMTable_t]]























































 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbPdhRecentPMTable_Did<s(0)(0)(0)>[&];(D1:pbPdhRecentPMTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                 
	PbPortType_Tval<s(1)(1)(0)>[T] pbPortType<s(1)(1)(0)>[&];                                         
	int		pbPortNo<s(1)(1)(0)>[&];                                                      
	PbPmTableType_Tval<s(1)(1)(0)>[T] pbPdhRecentTableType<s(1)(1)(0)>[&];                               
	int		pbPdhRecentTimesIndex<s(1)(1)(0)>[&];                                            
	unsigned int	pbPdhRecentEsPmCounter<s(1)(1)(0)>[&];   
	unsigned int	pbPdhRecentBbePmCounter<s(1)(1)(0)>[&];   
	unsigned int	pbPdhRecentSesPmCounter<s(1)(1)(0)>[&];   
	unsigned int	pbPdhRecentUasPmCounter<s(1)(1)(0)>[&];   
	unsigned int	pbPdhRecentCsesPmCounter<s(1)(1)(0)>[&];   
	unsigned int	pbPdhRecentFcPmCounter<s(1)(1)(0)>[&];   
	char		pbPdhRecentPmTimeEnd<s(1)(1)(0)>[&][16];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbPdhSuspect<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbPdhComplete<s(1)(1)(0)>[&];   
}MIBpbPdhRecentPMTable_t<s(0)(0)(0)>[&];(D1:MIBpbPdhRecentPMTable_t:1)[[TYPENAME:MIBpbPdhRecentPMTable_t]]





















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbEthVlanRecentPMTable_Did<s(0)(0)(0)>[&];(D1:pbEthVlanRecentPMTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                                       
	int		pbPortNo<s(1)(1)(0)>[&];                                                                            
	PbPmTableType_Tval<s(1)(1)(0)>[T] pbEthVlanRecentTableType<s(1)(1)(0)>[&];                                                 
	EthPortClass_Tval<s(1)(1)(0)>[T] pbEthPmPortType<s(1)(1)(0)>[&];                                                        
	int		pbEthVlanNo<s(1)(1)(0)>[&];                                                                         
	int		pbEthVlanRecentTimesIndex<s(1)(1)(0)>[&];                                                              
	char		pbEthVlanRecentPmTimeEnd<s(1)(1)(0)>[&][16];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbEthVlanRecentPmTimeSuspect<s(1)(1)(0)>[&];   
	unsigned int	pbEthVlanRecentInPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthVlanRecentInPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthVlanRecentInBytesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthVlanRecentInBytesLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthVlanRecentDropPktsHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthVlanRecentDropPktsLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthVlanRecentRcvUnicastFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthVlanRecentRcvUnicastFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthVlanRecentRcvTotalFramesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthVlanRecentRcvTotalFramesLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthVlanRecentRcvUnicastBytesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthVlanRecentRcvUnicastBytesLow<s(1)(1)(0)>[&];   
	unsigned int	pbEthVlanRecentRcvTotalBytesHigh<s(1)(1)(0)>[&];   
	unsigned int	pbEthVlanRecentRcvTotalBytesLow<s(1)(1)(0)>[&];   
}MIBpbEthVlanRecentPMTable_t<s(0)(0)(0)>[&];(D1:MIBpbEthVlanRecentPMTable_t:1)[[TYPENAME:MIBpbEthVlanRecentPMTable_t]]





























 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbxSecEthVlanRecentPMTable_Did<s(0)(0)(0)>[&];(D1:pbxSecEthVlanRecentPMTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                                       
	int		pbPortNo<s(1)(1)(0)>[&];                                                                            
	EthPortClass_Tval<s(1)(1)(0)>[T] pbEthPmPortType<s(1)(1)(0)>[&];                                                        
	int		pbEthVlanNo<s(1)(1)(0)>[&];                                                                         
	int		pbxSecEthVlanTimesIndex<s(1)(1)(0)>[&];                                                                
	TruthValue_Tval<s(1)(1)(0)>[T] pbxSecEthVlanRecentPmStartFlag<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthVlanRecentInPkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthVlanRecentInBytes<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthVlanRecentDropPkts<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthVlanRecentRcvUnicastFrames<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthVlanRecentRcvTotalFrames<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthVlanRecentRcvUnicastBytes<s(1)(1)(0)>[&];   
	unsigned int	pbxSecEthVlanRecentRcvTotalBytes<s(1)(1)(0)>[&];   
	int		pbxSecEthVlanFrmStartIndex<s(1)(1)(0)>[&];   
}MIBpbxSecEthVlanRecentPMTable_t<s(0)(0)(0)>[&];(D1:MIBpbxSecEthVlanRecentPMTable_t:1)[[TYPENAME:MIBpbxSecEthVlanRecentPMTable_t]]





















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbFecRecentPMTable_Did<s(0)(0)(0)>[&];(D1:pbFecRecentPMTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                       
	PbPortType_Tval<s(1)(1)(0)>[T] pbPortType<s(1)(1)(0)>[&];                                               
	int		pbPortNo<s(1)(1)(0)>[&];                                                            
	PbPmTableType_Tval<s(1)(1)(0)>[T] pbFecRecentTableType<s(1)(1)(0)>[&];                                     
	int		pbFecRecentTimesIndex<s(1)(1)(0)>[&];                                                  
	unsigned int	pbFecRecentTecPmCounterHigh<s(1)(1)(0)>[&];   
	unsigned int	pbFecRecentTecPmCounterLow<s(1)(1)(0)>[&];   
	unsigned int	pbFecRecentZecPmCounterHigh<s(1)(1)(0)>[&];   
	unsigned int	pbFecRecentZecPmCounterLow<s(1)(1)(0)>[&];   
	unsigned int	pbFecRecentOecPmCounterHigh<s(1)(1)(0)>[&];   
	unsigned int	pbFecRecentOecPmCounterLow<s(1)(1)(0)>[&];   
	unsigned int	pbFecRecentFcPmCounter<s(1)(1)(0)>[&];   
	char		pbFecRecentPmTimeEnd<s(1)(1)(0)>[&][16];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbFecSuspect<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbFecComplete<s(1)(1)(0)>[&];   
	unsigned int	pbFecRecUncorrectedBlkHigh<s(1)(1)(0)>[&];
	unsigned int	pbFecRecUncorrectedBlkLow<s(1)(1)(0)>[&];
}MIBpbFecRecentPMTable_t<s(0)(0)(0)>[&];(D1:MIBpbFecRecentPMTable_t:1)[[TYPENAME:MIBpbFecRecentPMTable_t]]
























 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbOtuRecentPMTable_Did<s(0)(0)(0)>[&];(D1:pbOtuRecentPMTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                   
	PbPortType_Tval<s(1)(1)(0)>[T] pbPortType<s(1)(1)(0)>[&];                                           
	int		pbPortNo<s(1)(1)(0)>[&];                                                        
	unsigned int	pbOtuRecentChannelID<s(1)(1)(0)>[&];                                    
	unsigned int	pbOtuRecentSegmentNum<s(1)(1)(0)>[&];                                   
	PbPmTableType_Tval<s(1)(1)(0)>[T] pbOtuRecentTableType<s(1)(1)(0)>[&];                              
	int		pbOtuRecentTimesIndex<s(1)(1)(0)>[&];                                           
	unsigned int	pbOtuRecentEsPmCounter<s(1)(1)(0)>[&];
	unsigned int	pbOtuRecentBbePmCounter<s(1)(1)(0)>[&];
	unsigned int	pbOtuRecentSesPmCounter<s(1)(1)(0)>[&];
	unsigned int	pbOtuRecentUasPmCounter<s(1)(1)(0)>[&];
	unsigned int	pbOtuRecentCsesPmCounter<s(1)(1)(0)>[&];
	unsigned int	pbOtuRecentFcPmCounter<s(1)(1)(0)>[&];
	unsigned int	pbOtuRecentOfsPmCounter<s(1)(1)(0)>[&];
	unsigned int	pbOtuRecentIaesPmCounter<s(1)(1)(0)>[&];
	unsigned int	pbOtuRecentBiaesPmCounter<s(1)(1)(0)>[&];
	char		pbOtuRecentPmTimeEnd<s(1)(1)(0)>[&][16];
	TruthValue_Tval<s(1)(1)(0)>[T] pbOtuSuspect<s(1)(1)(0)>[&];
	TruthValue_Tval<s(1)(1)(0)>[T] pbOtuComplete<s(1)(1)(0)>[&];
}MIBpbOtuRecentPMTable_t<s(0)(0)(0)>[&];(D1:MIBpbOtuRecentPMTable_t:1)[[TYPENAME:MIBpbOtuRecentPMTable_t]]


























 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbSdhUapPMTable_Did<s(0)(0)(0)>[&];(D1:pbSdhUapPMTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];               
	PbPortType_Tval<s(1)(1)(0)>[T] pbPortType<s(1)(1)(0)>[&];                       
	int		pbPortNo<s(1)(1)(0)>[&];                                    
	PbTPType_Tval<s(1)(1)(0)>[T] pbTpType<s(1)(1)(0)>[&];                           
	int		pbTpIndex<s(1)(1)(0)>[&];                                   
	PbPmUapType_Tval<s(1)(1)(0)>[T] pbPmUapType<s(1)(1)(0)>[&];                        
	TruthValue_Tval<s(1)(1)(0)>[T] pbIsAtUap<s(1)(1)(0)>[&];   
	unsigned int	pbUAPCounter<s(1)(1)(0)>[&];   
	char		pbUapTimeStart<s(1)(1)(0)>[&][16];   
	unsigned int	pbUapTimeElapse<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbUAPReset<s(1)(1)(0)>[&];   
}MIBpbSdhUapPMTable_t<s(0)(0)(0)>[&];(D1:MIBpbSdhUapPMTable_t:1)[[TYPENAME:MIBpbSdhUapPMTable_t]]


















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbPdhUapPMTable_Did<s(0)(0)(0)>[&];(D1:pbPdhUapPMTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                     
	PbPortType_Tval<s(1)(1)(0)>[T] pbPortType<s(1)(1)(0)>[&];                             
	int		pbPortNo<s(1)(1)(0)>[&];                                          
	PbPmUapType_Tval<s(1)(1)(0)>[T] pbPdhUapType<s(1)(1)(0)>[&];                             
	TruthValue_Tval<s(1)(1)(0)>[T] pbPdhIsAtUap<s(1)(1)(0)>[&];   
	unsigned int	pbPdhUAPCounter<s(1)(1)(0)>[&];   
	char		pbPdhUapTimeStart<s(1)(1)(0)>[&][16];   
	unsigned int	pbPdhUapTimeElapse<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbPdhUAPReset<s(1)(1)(0)>[&];   
}MIBpbPdhUapPMTable_t<s(0)(0)(0)>[&];(D1:MIBpbPdhUapPMTable_t:1)[[TYPENAME:MIBpbPdhUapPMTable_t]]
















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbOtuUapPMTable_Did<s(0)(0)(0)>[&];(D1:pbOtuUapPMTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                     
	PbPortType_Tval<s(1)(1)(0)>[T] pbPortType<s(1)(1)(0)>[&];                             
	int		pbPortNo<s(1)(1)(0)>[&];                                          
	unsigned int	pbUapChannelID<s(1)(1)(0)>[&];                            
	unsigned int	pbUapSegmentNum<s(1)(1)(0)>[&];                           
	PbPmUapType_Tval<s(1)(1)(0)>[T] pbOtuUapType<s(1)(1)(0)>[&];                          
	TruthValue_Tval<s(1)(1)(0)>[T] pbOtuIsAtUap<s(1)(1)(0)>[&];
	unsigned int	pbOtuUAPCounter<s(1)(1)(0)>[&];
	char		pbOtuUapTimeStart<s(1)(1)(0)>[&][16];
	unsigned int	pbOtuUapTimeElapse<s(1)(1)(0)>[&];
	TruthValue_Tval<s(1)(1)(0)>[T] pbOtuUAPReset<s(1)(1)(0)>[&];
}MIBpbOtuUapPMTable_t<s(0)(0)(0)>[&];(D1:MIBpbOtuUapPMTable_t:1)[[TYPENAME:MIBpbOtuUapPMTable_t]]


















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbSdhRecentUapPMTable_Did<s(0)(0)(0)>[&];(D1:pbSdhRecentUapPMTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                         
	PbPortType_Tval<s(1)(1)(0)>[T] pbPortType<s(1)(1)(0)>[&];                                 
	int		pbPortNo<s(1)(1)(0)>[&];                                              
	PbTPType_Tval<s(1)(1)(0)>[T] pbTpType<s(1)(1)(0)>[&];                                     
	int		pbTpIndex<s(1)(1)(0)>[&];                                             
	PbPmUapType_Tval<s(1)(1)(0)>[T] pbPmRecUapType<s(1)(1)(0)>[&];                               
	int		pbUapTimesIndex<s(1)(1)(0)>[&];                                          
	char		pbRecentUapTimeStart<s(1)(1)(0)>[&][16];   
	char		pbRecentUapTimeEnd<s(1)(1)(0)>[&][16];   
}MIBpbSdhRecentUapPMTable_t<s(0)(0)(0)>[&];(D1:MIBpbSdhRecentUapPMTable_t:1)[[TYPENAME:MIBpbSdhRecentUapPMTable_t]]
















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbPdhRecentUapPMTable_Did<s(0)(0)(0)>[&];(D1:pbPdhRecentUapPMTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                               
	PbPortType_Tval<s(1)(1)(0)>[T] pbPortType<s(1)(1)(0)>[&];                                       
	int		pbPortNo<s(1)(1)(0)>[&];                                                    
	PbPmUapType_Tval<s(1)(1)(0)>[T] pbPdhRecUapType<s(1)(1)(0)>[&];                                    
	int		pbPdhUapTimesIndex<s(1)(1)(0)>[&];                                             
	char		pbPdhRecentUapTimeStart<s(1)(1)(0)>[&][16];   
	char		pbPdhRecentUapTimeEnd<s(1)(1)(0)>[&][16];   
}MIBpbPdhRecentUapPMTable_t<s(0)(0)(0)>[&];(D1:MIBpbPdhRecentUapPMTable_t:1)[[TYPENAME:MIBpbPdhRecentUapPMTable_t]]














 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbOtuRecentUapPMTable_Did<s(0)(0)(0)>[&];(D1:pbOtuRecentUapPMTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                               
	PbPortType_Tval<s(1)(1)(0)>[T] pbPortType<s(1)(1)(0)>[&];                                       
	int		pbPortNo<s(1)(1)(0)>[&];                                                    
	unsigned int	pbOtuRecUapChannelID<s(1)(1)(0)>[&];                                
	unsigned int	pbOtuRecUapSegmentNum<s(1)(1)(0)>[&];                               
	PbPmUapType_Tval<s(1)(1)(0)>[T] pbOtuRecUapType<s(1)(1)(0)>[&];                                 
	int		pbOtuUapTimesIndex<s(1)(1)(0)>[&];                                          
	char		pbOtuRecentUapTimeStart<s(1)(1)(0)>[&][16];
	char		pbOtuRecentUapTimeEnd<s(1)(1)(0)>[&][16];
}MIBpbOtuRecentUapPMTable_t<s(0)(0)(0)>[&];(D1:MIBpbOtuRecentUapPMTable_t:1)[[TYPENAME:MIBpbOtuRecentUapPMTable_t]]
















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbSdhMostRecentIndexTable_Did<s(0)(0)(0)>[&];(D1:pbSdhMostRecentIndexTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                     
	PbPortType_Tval<s(1)(1)(0)>[T] pbPortType<s(1)(1)(0)>[&];                                             
	int		pbPortNo<s(1)(1)(0)>[&];                                                          
	PbTPType_Tval<s(1)(1)(0)>[T] pbTpType<s(1)(1)(0)>[&];                                                 
	int		pbTpIndex<s(1)(1)(0)>[&];                                                         
	PbPmUapType_Tval<s(1)(1)(0)>[T] pbPmRecIntervalTblType<s(1)(1)(0)>[&];                                   
	int		pbRecentIntervalTblMRI<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbRecentIntervalUpMaxIndex<s(1)(1)(0)>[&];   
	int		pbRecentUapTblMRI<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbRecentUapUpMaxIndex<s(1)(1)(0)>[&];   
}MIBpbSdhMostRecentIndexTable_t<s(0)(0)(0)>[&];(D1:MIBpbSdhMostRecentIndexTable_t:1)[[TYPENAME:MIBpbSdhMostRecentIndexTable_t]]

















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbEthMostRecentIndexTable_Did<s(0)(0)(0)>[&];(D1:pbEthMostRecentIndexTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                           
	int		pbPortNo<s(1)(1)(0)>[&];                                                                
	PbPmTableType_Tval<s(1)(1)(0)>[T] pbEthIndexTableType<s(1)(1)(0)>[&];                                          
	EthPortClass_Tval<s(1)(1)(0)>[T] pbEthIndexPmPortType<s(1)(1)(0)>[&];                                          
	int		pbEthRecentIntervalTblMRI<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbEthRecentIntervalUpMaxIndex<s(1)(1)(0)>[&];   
}MIBpbEthMostRecentIndexTable_t<s(0)(0)(0)>[&];(D1:MIBpbEthMostRecentIndexTable_t:1)[[TYPENAME:MIBpbEthMostRecentIndexTable_t]]













 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbRprClientMostRecentIndexTable_Did<s(0)(0)(0)>[&];(D1:pbRprClientMostRecentIndexTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                                       
	int		rprIfIndex<s(1)(1)(0)>[&];                                                                             
	PbPmTableType_Tval<s(1)(1)(0)>[T] pbRprClientIndexTableType<s(1)(1)(0)>[&];                                                
	int		pbRprClientRecentIntervalTblMRI<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbRprClientRecentIntervalUpMaxIndex<s(1)(1)(0)>[&];   
}MIBpbRprClientMostRecentIndexTable_t<s(0)(0)(0)>[&];(D1:MIBpbRprClientMostRecentIndexTable_t:1)[[TYPENAME:MIBpbRprClientMostRecentIndexTable_t]]












 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbRprSpanMostRecentIndexTable_Did<s(0)(0)(0)>[&];(D1:pbRprSpanMostRecentIndexTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                                   
	int		rprIfIndex<s(1)(1)(0)>[&];                                                                      
	RprSpan_Tval<s(1)(1)(0)>[T] rprSpanId<s(1)(1)(0)>[&];                                                                  
	PbPmTableType_Tval<s(1)(1)(0)>[T] pbRprSpanIndexTableType<s(1)(1)(0)>[&];                                              
	int		pbRprSpanRecentIntervalTblMRI<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbRprSpanRecentIntervalUpMaxIndex<s(1)(1)(0)>[&];   
}MIBpbRprSpanMostRecentIndexTable_t<s(0)(0)(0)>[&];(D1:MIBpbRprSpanMostRecentIndexTable_t:1)[[TYPENAME:MIBpbRprSpanMostRecentIndexTable_t]]













 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbSlipMostRecentIndexTable_Did<s(0)(0)(0)>[&];(D1:pbSlipMostRecentIndexTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                     
	PbPortType_Tval<s(1)(1)(0)>[T] pbPortType<s(1)(1)(0)>[&];                             
	int		pbPortNo<s(1)(1)(0)>[&];                                          
	int		pbSlipRecentTblMRI<s(1)(1)(0)>[&];   
}MIBpbSlipMostRecentIndexTable_t<s(0)(0)(0)>[&];(D1:MIBpbSlipMostRecentIndexTable_t:1)[[TYPENAME:MIBpbSlipMostRecentIndexTable_t]]











 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbxSecEthIndexTable_Did<s(0)(0)(0)>[&];(D1:pbxSecEthIndexTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                                   
	int		pbPortNo<s(1)(1)(0)>[&];                                                                        
	EthPortClass_Tval<s(1)(1)(0)>[T] pbxSecEthIndexPortType<s(1)(1)(0)>[&];                                                
	int		pbxSecEthRecentIntervalTblMRI<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbxSecEthRecentIntervalUpMaxIndex<s(1)(1)(0)>[&];   
	int		pbxSecEthRecentIndex<s(1)(1)(0)>[&];   
}MIBpbxSecEthIndexTable_t<s(0)(0)(0)>[&];(D1:MIBpbxSecEthIndexTable_t:1)[[TYPENAME:MIBpbxSecEthIndexTable_t]]













 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbPdhMostRecentIndexTable_Did<s(0)(0)(0)>[&];(D1:pbPdhMostRecentIndexTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                           
	PbPortType_Tval<s(1)(1)(0)>[T] pbPortType<s(1)(1)(0)>[&];                                                   
	int		pbPortNo<s(1)(1)(0)>[&];                                                                
	PbPmUapType_Tval<s(1)(1)(0)>[T] pbPdhRecIntervalTblType<s(1)(1)(0)>[&];                                        
	int		pbPdhRecentIntervalTblMRI<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbPdhRecentIntervalUpMaxIndex<s(1)(1)(0)>[&];   
	int		pbPdhRecentUapTblMRI<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbPdhRecentUapUpMaxIndex<s(1)(1)(0)>[&];   
}MIBpbPdhMostRecentIndexTable_t<s(0)(0)(0)>[&];(D1:MIBpbPdhMostRecentIndexTable_t:1)[[TYPENAME:MIBpbPdhMostRecentIndexTable_t]]















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbEthVlanMostRecentIndexTable_Did<s(0)(0)(0)>[&];(D1:pbEthVlanMostRecentIndexTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                                   
	int		pbPortNo<s(1)(1)(0)>[&];                                                                        
	PbPmTableType_Tval<s(1)(1)(0)>[T] pbEthVlanIndexTableType<s(1)(1)(0)>[&];                                              
	EthPortClass_Tval<s(1)(1)(0)>[T] pbEthPmPortType<s(1)(1)(0)>[&];                                                       
	int		pbEthVlanNo<s(1)(1)(0)>[&];                                                                        
	int		pbEthVlanRecentIntervalTblMRI<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbEthVlanRecentIntervalUpMaxIndex<s(1)(1)(0)>[&];   
}MIBpbEthVlanMostRecentIndexTable_t<s(0)(0)(0)>[&];(D1:MIBpbEthVlanMostRecentIndexTable_t:1)[[TYPENAME:MIBpbEthVlanMostRecentIndexTable_t]]














 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbxSecEthVlanIndexTable_Did<s(0)(0)(0)>[&];(D1:pbxSecEthVlanIndexTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                                           
	int		pbPortNo<s(1)(1)(0)>[&];                                                                                
	EthPortClass_Tval<s(1)(1)(0)>[T] pbEthPmPortType<s(1)(1)(0)>[&];                                                            
	int		pbEthVlanNo<s(1)(1)(0)>[&];                                                                             
	int		pbxSecEthVlanRecentIntervalTblMRI<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbxSecEthVlanRecentIntervalUpMaxIndex<s(1)(1)(0)>[&];   
	int		pbxSecEthVlanRecentIndex<s(1)(1)(0)>[&];   
}MIBpbxSecEthVlanIndexTable_t<s(0)(0)(0)>[&];(D1:MIBpbxSecEthVlanIndexTable_t:1)[[TYPENAME:MIBpbxSecEthVlanIndexTable_t]]














 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbFecMostRecentIndexTable_Did<s(0)(0)(0)>[&];(D1:pbFecMostRecentIndexTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                           
	PbPortType_Tval<s(1)(1)(0)>[T] pbPortType<s(1)(1)(0)>[&];                                                   
	int		pbPortNo<s(1)(1)(0)>[&];                                                                
	PbPmUapType_Tval<s(1)(1)(0)>[T] pbFecRecIntervalTblType<s(1)(1)(0)>[&];                                        
	int		pbFecRecentIntervalTblMRI<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbFecRecentIntervalUpMaxIndex<s(1)(1)(0)>[&];   
}MIBpbFecMostRecentIndexTable_t<s(0)(0)(0)>[&];(D1:MIBpbFecMostRecentIndexTable_t:1)[[TYPENAME:MIBpbFecMostRecentIndexTable_t]]













 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbOtuMostRecentIndexTable_Did<s(0)(0)(0)>[&];(D1:pbOtuMostRecentIndexTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                           
	PbPortType_Tval<s(1)(1)(0)>[T] pbPortType<s(1)(1)(0)>[&];                                                   
	int		pbPortNo<s(1)(1)(0)>[&];                                                                
	unsigned int	pbOtuRecChannelID<s(1)(1)(0)>[&];                                               
	unsigned int	pbOtuRecSegmentNum<s(1)(1)(0)>[&];                                              
	PbPmUapType_Tval<s(1)(1)(0)>[T] pbOtuRecIntervalTblType<s(1)(1)(0)>[&];                                     
	int		pbOtuRecentIntervalTblMRI<s(1)(1)(0)>[&];
	TruthValue_Tval<s(1)(1)(0)>[T] pbOtuRecentIntervalUpMaxIndex<s(1)(1)(0)>[&];
	int		pbOtuRecentUapTblMRI<s(1)(1)(0)>[&];
	TruthValue_Tval<s(1)(1)(0)>[T] pbOtuRecentUapUpMaxIndex<s(1)(1)(0)>[&];
}MIBpbOtuMostRecentIndexTable_t<s(0)(0)(0)>[&];(D1:MIBpbOtuMostRecentIndexTable_t:1)[[TYPENAME:MIBpbOtuMostRecentIndexTable_t]]

















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbSdhPMUpLoadTable_Did<s(0)(0)(0)>[&];(D1:pbSdhPMUpLoadTable_Did:0)

   
typedef struct
{
	unsigned int	pbSdhFtpCmndHostIP<s(1)(1)(0)>[&];                                 
	char		pbSdhFtpCmndPath<s(1)(1)(0)>[&][64];   
	char		pbSdhFtpFileName<s(1)(1)(0)>[&][13];   
	char		pbSdhFtpCmndUsername<s(1)(1)(0)>[&][32];   
	char		pbSdhFtpCmndPassword<s(1)(1)(0)>[&][32];   
	SdhFtpCmndLastState_Tval<s(1)(1)(0)>[T] pbSdhFtpCmndLastState<s(1)(1)(0)>[&];   
	unsigned int	pbAdjustTimeDircetion<s(1)(1)(0)>[&];   
	unsigned int	pbAdjustTimeDays<s(1)(1)(0)>[&];   
	unsigned int	pbAdjustTimeHours<s(1)(1)(0)>[&];   
	unsigned int	pbAdjustTimeMins<s(1)(1)(0)>[&];   
	unsigned int	pbAdjustTimeSecs<s(1)(1)(0)>[&];   
	RowStatus_Tval<s(1)(1)(0)>[T] pbUpLoadStatus<s(1)(1)(0)>[&];   
}MIBpbSdhPMUpLoadTable_t<s(0)(0)(0)>[&];(D1:MIBpbSdhPMUpLoadTable_t:1)[[TYPENAME:MIBpbSdhPMUpLoadTable_t]]



















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbxSecEthUploadTable_Did<s(0)(0)(0)>[&];(D1:pbxSecEthUploadTable_Did:0)

   
typedef struct
{
	unsigned int	pbxSecEthFtpHostIP<s(1)(1)(0)>[&];                               
	char		pbxSecEthFtpFileName<s(1)(1)(0)>[&][20];   
	char		pbxSecEthFtpUsername<s(1)(1)(0)>[&][32];   
	char		pbxSecEthFtpPassword<s(1)(1)(0)>[&][32];   
}MIBpbxSecEthUploadTable_t<s(0)(0)(0)>[&];(D1:MIBpbxSecEthUploadTable_t:1)[[TYPENAME:MIBpbxSecEthUploadTable_t]]











 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbSonetSDHPMModule_Did<s(0)(0)(0)>[&];(D1:pbSonetSDHPMModule_Did:0)

   







 




 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbActiveAlarmTable_Did<s(0)(0)(0)>[&];(D1:pbActiveAlarmTable_Did:0)

   
typedef struct
{
	unsigned int	pbActiveAlarmIndex<s(1)(1)(0)>[&];                                             
	char		pbActiveAlarmCode<s(1)(1)(0)>[&][255];   
	AlarmSeverity_Tval<s(1)(1)(0)>[T] pbActiveAlarmSeverity<s(1)(1)(0)>[&];   
	char		pbActiveAlarmSource<s(1)(1)(0)>[&][255];   
	DateTime<s(1)(1)(0)>[T]	pbActiveAlarmDTS<s(1)(1)(0)>[&];   
	DateTime<s(1)(1)(0)>[T]	pbActiveAlarmClearDTS<s(1)(1)(0)>[&];   
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbActiveAlarmSlotNum<s(1)(1)(0)>[&];   
	int		pbActiveAlarmPortNum<s(1)(1)(0)>[&];   
	PbPortType_Tval<s(1)(1)(0)>[T] pbActiveAlarmPortType<s(1)(1)(0)>[&];   
	char		pbActiveAlarmDesc<s(1)(1)(0)>[&][255];   
	AlarmTypeID_Tval<s(1)(1)(0)>[T] pbActiveAlarmTypeID<s(1)(1)(0)>[&];   
	AlarmCategory_Tval<s(1)(1)(0)>[T] pbActiveAlarmCategory<s(1)(1)(0)>[&];   
	PbTPType_Tval<s(1)(1)(0)>[T] pbActiveAlarmPathType<s(1)(1)(0)>[&];   
	int		pbActiveAlarmSeqNum<s(1)(1)(0)>[&];   
	PbYesNo_Tval<s(1)(1)(0)>[T] pbActiveAlarmAcknowledge<s(1)(1)(0)>[&];   
	AlarmState_Tval<s(1)(1)(0)>[T] pbActiveAlarmState<s(1)(1)(0)>[&];   
	PbBoardStyle_Tval<s(1)(1)(0)>[T] pbActiveAlarmBoardStyle<s(1)(1)(0)>[&];   
	PbPortType_Tval<s(1)(1)(0)>[T] pbActiveAlarmActualPortType<s(1)(1)(0)>[&];   
}MIBpbActiveAlarmTable_t<s(0)(0)(0)>[&];(D1:MIBpbActiveAlarmTable_t:1)[[TYPENAME:MIBpbActiveAlarmTable_t]]

























 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbAlarmTypeCfgTable_Did<s(0)(0)(0)>[&];(D1:pbAlarmTypeCfgTable_Did:0)

   
typedef struct
{
	AlarmTypeID_Tval<s(1)(1)(0)>[T] pbAlarmTypeID<s(1)(1)(0)>[&];                              
	char		pbAlarmTypeCode<s(1)(1)(0)>[&][255];   
	char		pbAlarmTypeDesc<s(1)(1)(0)>[&][255];   
	AlarmCategory_Tval<s(1)(1)(0)>[T] pbAlarmTypeCategory<s(1)(1)(0)>[&];   
	AlarmSeverity_Tval<s(1)(1)(0)>[T] pbAlarmTypeSeverity<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbAlarmTypeInhibit<s(1)(1)(0)>[&];
	TruthValue_Tval<s(1)(1)(0)>[T] pbAlarmTypeMDO1<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbAlarmTypeMDO2<s(1)(1)(0)>[&];   
	int		pbAlarmTypeTrapID<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbAlarmTypeMDO3<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbAlarmTypeMDO4<s(1)(1)(0)>[&];   
	PbAlmClassType_Tval<s(1)(1)(0)>[T] pbAlmClassID<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbAlarmTypeMDO5<s(1)(1)(0)>[&];
	TruthValue_Tval<s(1)(1)(0)>[T] pbAlarmTypeMDO6<s(1)(1)(0)>[&];
	TruthValue_Tval<s(1)(1)(0)>[T] pbAlarmTypeMDO7<s(1)(1)(0)>[&];
	TruthValue_Tval<s(1)(1)(0)>[T] pbAlarmTypeMDO8<s(1)(1)(0)>[&];
}MIBpbAlarmTypeCfgTable_t<s(0)(0)(0)>[&];(D1:MIBpbAlarmTypeCfgTable_t:1)[[TYPENAME:MIBpbAlarmTypeCfgTable_t]]























 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbCurrentEventsTable_Did<s(0)(0)(0)>[&];(D1:pbCurrentEventsTable_Did:0)

   
typedef struct
{
	int		pbCurrentEventIndex<s(1)(1)(0)>[&];                                          
	EventTypeID_Tval<s(1)(1)(0)>[T] pbCurrentEventID<s(1)(1)(0)>[&];   
	DateTime<s(1)(1)(0)>[T]	pbCurrentEventDTS<s(1)(1)(0)>[&];   
	char		pbCurrentEventName<s(1)(1)(0)>[&][255];   
	EventCategory_Tval<s(1)(1)(0)>[T] pbCurrentEventCategory<s(1)(1)(0)>[&];   
	char		pbCurrentEventDetails<s(1)(1)(0)>[&][255];   
}MIBpbCurrentEventsTable_t<s(0)(0)(0)>[&];(D1:MIBpbCurrentEventsTable_t:1)[[TYPENAME:MIBpbCurrentEventsTable_t]]













 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbEventTypeCfgTable_Did<s(0)(0)(0)>[&];(D1:pbEventTypeCfgTable_Did:0)

   
typedef struct
{
	EventTypeID_Tval<s(1)(1)(0)>[T] pbEventTypeID<s(1)(1)(0)>[&];                              
	EventCategory_Tval<s(1)(1)(0)>[T] pbEventTypeCategory<s(1)(1)(0)>[&];   
	char		pbEventTypeName<s(1)(1)(0)>[&][255];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbEventTypeSendTrap<s(1)(1)(0)>[&];   
}MIBpbEventTypeCfgTable_t<s(0)(0)(0)>[&];(D1:MIBpbEventTypeCfgTable_t:1)[[TYPENAME:MIBpbEventTypeCfgTable_t]]











 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbLogSizeGroup_Did<s(0)(0)(0)>[&];(D1:pbLogSizeGroup_Did:0)

   
typedef struct
{
	int		pbAlarmLogSize<s(1)(1)(0)>[&];
	int		pbEventLogSize<s(1)(1)(0)>[&];
}MIBpbLogSizeGroup_t<s(0)(0)(0)>[&];(D1:MIBpbLogSizeGroup_t:1)[[TYPENAME:MIBpbLogSizeGroup_t]]







 



 
extern MIBDid_t<s(0)(0)(0)>[T] alarmPersistentTime_Did<s(0)(0)(0)>[&];(D1:alarmPersistentTime_Did:0)

   
typedef struct
{
	int		alarmDetectionPersistentTime<s(1)(1)(0)>[&];   
	int		alarmClearingPersistentTime<s(1)(1)(0)>[&];   
}MIBalarmPersistentTime_t<s(0)(0)(0)>[&];(D1:MIBalarmPersistentTime_t:1)[[TYPENAME:MIBalarmPersistentTime_t]]







 



 
extern MIBDid_t<s(0)(0)(0)>[T] logPolicyGroup_Did<s(0)(0)(0)>[&];(D1:logPolicyGroup_Did:0)

   
typedef enum {
	eventLogPolicy_fifo<s(0)(0)(0)>[&]=1,
	eventLogPolicy_rejectNewEvent<s(0)(0)(0)>[&]=2
} eventLogPolicy_Tval<s(0)(0)(0)>[&];(D1:eventLogPolicy_Tval:1)[[TYPENAME:eventLogPolicy_Tval]]

typedef struct
{
	eventLogPolicy_Tval<s(1)(1)(0)>[T] eventLogPolicy<s(1)(1)(0)>[&];   
}MIBlogPolicyGroup_t<s(0)(0)(0)>[&];(D1:MIBlogPolicyGroup_t:1)[[TYPENAME:MIBlogPolicyGroup_t]]






 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbAlarmStatGroup_Did<s(0)(0)(0)>[&];(D1:pbAlarmStatGroup_Did:0)

   
typedef struct
{
	int		pbNumberOfCriticalAlarms<s(1)(1)(0)>[&];   
	int		pbNumberOfMajorAlarms<s(1)(1)(0)>[&];   
	int		pbNumberOfMinorAlarms<s(1)(1)(0)>[&];   
	int		pbNumberOfWarningAlarms<s(1)(1)(0)>[&];   
	int		pbNumberOfIndeterminateAlarms<s(1)(1)(0)>[&];   
	int		pbNumberOfEvents<s(1)(1)(0)>[&];   
}MIBpbAlarmStatGroup_t<s(0)(0)(0)>[&];(D1:MIBpbAlarmStatGroup_t:1)[[TYPENAME:MIBpbAlarmStatGroup_t]]











 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbLogClearGroup_Did<s(0)(0)(0)>[&];(D1:pbLogClearGroup_Did:0)

   
typedef struct
{
	TruthValue_Tval<s(1)(1)(0)>[T] pbClearAlarmLog<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbClearEventsLog<s(1)(1)(0)>[&];   
}MIBpbLogClearGroup_t<s(0)(0)(0)>[&];(D1:MIBpbLogClearGroup_t:1)[[TYPENAME:MIBpbLogClearGroup_t]]







 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbEventsModule_Did<s(0)(0)(0)>[&];(D1:pbEventsModule_Did:0)

   







 




 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbSdhXcTable_Did<s(0)(0)(0)>[&];(D1:pbSdhXcTable_Did:0)

   
typedef struct
{
	PbXcCapacity_Tval<s(1)(1)(0)>[T] pbXConConnectCapacity<s(1)(1)(0)>[&];                                         
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbXConConnectSrcSlot<s(1)(1)(0)>[&];                                      
	int		pbXConConnectSrcPort<s(1)(1)(0)>[&];                                                       
	PbPortType_Tval<s(1)(1)(0)>[T] pbXConConnectSrcPortType<s(1)(1)(0)>[&];                                     
	int		pbXConConnectSource<s(1)(1)(0)>[&];                                                        
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbXConConnectDstSlot<s(1)(1)(0)>[&];                                      
	int		pbXConConnectDstPort<s(1)(1)(0)>[&];                                                       
	PbPortType_Tval<s(1)(1)(0)>[T] pbXConConnectDstPortType<s(1)(1)(0)>[&];                                     
	int		pbXConConnectDestination<s(1)(1)(0)>[&];                                                   
	int		pbXConConnectId<s(1)(1)(0)>[&];   
	char		pbXConConnectCircuitId<s(1)(1)(0)>[&][64];   
	PbXcStatus_Tval<s(1)(1)(0)>[T] pbXConConnectStatus<s(1)(1)(0)>[&];   
	PbXcFailReason_Tval<s(1)(1)(0)>[T] pbXConConnectReason<s(1)(1)(0)>[&];   
	PbXcType_Tval<s(1)(1)(0)>[T] pbXConConnectType<s(1)(1)(0)>[&];   
	PbCircuitDirection_Tval<s(1)(1)(0)>[T] pbXConConnectCircuitDirection<s(1)(1)(0)>[&];   
	PbXcAction_Tval<s(1)(1)(0)>[T] pbXConConnectAction<s(1)(1)(0)>[&];   
	PbXcFrom_Tval<s(1)(1)(0)>[T] pbXConFrom<s(1)(1)(0)>[&];   
	RowStatus_Tval<s(1)(1)(0)>[T] pbXConRowStatus<s(1)(1)(0)>[&];   
	char		pbXConConnectReqNo<s(1)(1)(0)>[&][40];   
	int		pbXCGmplsVcNumber<s(1)(1)(0)>[&];   
	char		pbXCGmplsCallName<s(1)(1)(0)>[&][255];   
	PbGmplsCcDirection_Tval<s(1)(1)(0)>[T] pbGmplsCcDirection<s(1)(1)(0)>[&];   
}MIBpbSdhXcTable_t<s(0)(0)(0)>[&];(D1:MIBpbSdhXcTable_t:1)[[TYPENAME:MIBpbSdhXcTable_t]]





























 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbXCModule_Did<s(0)(0)(0)>[&];(D1:pbXCModule_Did:0)

   







 




 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbXCExtendObjects_Did<s(0)(0)(0)>[&];(D1:pbXCExtendObjects_Did:0)

   


 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbSdhXcNewContextTable_Did<s(0)(0)(0)>[&];(D1:pbSdhXcNewContextTable_Did:0)

   
typedef enum {
	pbXConContextHOCCAu3Num_none<s(0)(0)(0)>[&]=0,
	pbXConContextHOCCAu3Num_init<s(0)(0)(0)>[&]=1,
	pbXConContextHOCCAu3Num_sys<s(0)(0)(0)>[&]=2,
	pbXConContextHOCCAu3Num_card<s(0)(0)(0)>[&]=4,
	pbXConContextHOCCAu3Num_map<s(0)(0)(0)>[&]=8,
	pbXConContextHOCCAu3Num_poh<s(0)(0)(0)>[&]=16,
	pbXConContextHOCCAu3Num_connect<s(0)(0)(0)>[&]=32,
	pbXConContextHOCCAu3Num_context<s(0)(0)(0)>[&]=64,
	pbXConContextHOCCAu3Num_device<s(0)(0)(0)>[&]=128,
	pbXConContextHOCCAu3Num_ccprot<s(0)(0)(0)>[&]=256,
	pbXConContextHOCCAu3Num_sncp<s(0)(0)(0)>[&]=512,
	pbXConContextHOCCAu3Num_msp<s(0)(0)(0)>[&]=1024,
	pbXConContextHOCCAu3Num_msspr<s(0)(0)(0)>[&]=2048,
	pbXConContextHOCCAu3Num_ep<s(0)(0)(0)>[&]=4096,
	pbXConContextHOCCAu3Num_loccprot<s(0)(0)(0)>[&]=8192,
	pbXConContextHOCCAu3Num_pco<s(0)(0)(0)>[&]=16384,
	pbXConContextHOCCAu3Num_ccs<s(0)(0)(0)>[&]=32768,
	pbXConContextHOCCAu3Num_cca<s(0)(0)(0)>[&]=65536,
	pbXConContextHOCCAu3Num_gmpls<s(0)(0)(0)>[&]=131072,
	pbXConContextHOCCAu3Num_all<s(0)(0)(0)>[&]=1048575
} pbXConContextHOCCAu3Num_Tval<s(0)(0)(0)>[&];(D1:pbXConContextHOCCAu3Num_Tval:1)[[TYPENAME:pbXConContextHOCCAu3Num_Tval]]

typedef enum {
	pbXConContextHOCCAu3Step_none<s(0)(0)(0)>[&]=0,
	pbXConContextHOCCAu3Step_message<s(0)(0)(0)>[&]=1,
	pbXConContextHOCCAu3Step_module<s(0)(0)(0)>[&]=2,
	pbXConContextHOCCAu3Step_manager<s(0)(0)(0)>[&]=3,
	pbXConContextHOCCAu3Step_ucsl<s(0)(0)(0)>[&]=4,
	pbXConContextHOCCAu3Step_ldsl<s(0)(0)(0)>[&]=5,
	pbXConContextHOCCAu3Step_pdsl<s(0)(0)(0)>[&]=6,
	pbXConContextHOCCAu3Step_driver<s(0)(0)(0)>[&]=7,
	pbXConContextHOCCAu3Step_system<s(0)(0)(0)>[&]=8,
	pbXConContextHOCCAu3Step_simulator<s(0)(0)(0)>[&]=9
} pbXConContextHOCCAu3Step_Tval<s(0)(0)(0)>[&];(D1:pbXConContextHOCCAu3Step_Tval:1)[[TYPENAME:pbXConContextHOCCAu3Step_Tval]]

typedef struct
{
	int		pbXConContextLOCCBusNum<s(1)(1)(0)>[&];                                         
	int		pbXConContextLOCCAuNum<s(1)(1)(0)>[&];                                          
	pbXConContextHOCCAu3Num_Tval<s(1)(1)(0)>[T] pbXConContextHOCCAu3Num<s(1)(1)(0)>[&];
	pbXConContextHOCCAu3Step_Tval<s(1)(1)(0)>[T] pbXConContextHOCCAu3Step<s(1)(1)(0)>[&];
	int		pbXConContextHOCCAu3Count<s(1)(1)(0)>[&];
}MIBpbSdhXcNewContextTable_t<s(0)(0)(0)>[&];(D1:MIBpbSdhXcNewContextTable_t:1)[[TYPENAME:MIBpbSdhXcNewContextTable_t]]












 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbSdhXcNewLoMapTable_Did<s(0)(0)(0)>[&];(D1:pbSdhXcNewLoMapTable_Did:0)

   
typedef enum {
	gmplsReservationStatus_unreserved<s(0)(0)(0)>[&]=0,
	gmplsReservationStatus_reserved<s(0)(0)(0)>[&]=1
} gmplsReservationStatus_Tval<s(0)(0)(0)>[&];(D1:gmplsReservationStatus_Tval:1)[[TYPENAME:gmplsReservationStatus_Tval]]

typedef enum {
	gmplsReservationOperate_unreserve<s(0)(0)(0)>[&]=0,
	gmplsReservationOperate_reserve<s(0)(0)(0)>[&]=1
} gmplsReservationOperate_Tval<s(0)(0)(0)>[&];(D1:gmplsReservationOperate_Tval:1)[[TYPENAME:gmplsReservationOperate_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbXConLoMapLOCCSlot<s(1)(1)(0)>[&];                        
	PbPortType_Tval<s(1)(1)(0)>[T] pbXConLoMapLOCCPortType<s(1)(1)(0)>[&];                          
	int		pbXConLoMapLOCCPort<s(1)(1)(0)>[&];                                         
	int		pbXConLoMapHOCCIndex<s(1)(1)(0)>[&];
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbXConLoMapLCSlot<s(1)(1)(0)>[&];
	PbPortType_Tval<s(1)(1)(0)>[T] pbXConLoMapLCPortType<s(1)(1)(0)>[&];
	int		pbXConLoMapLCPort<s(1)(1)(0)>[&];
	int		pbXConLoMapLCTP<s(1)(1)(0)>[&];
	gmplsReservationStatus_Tval<s(1)(1)(0)>[T] gmplsReservationStatus<s(1)(1)(0)>[&];
	gmplsReservationOperate_Tval<s(1)(1)(0)>[T] gmplsReservationOperate<s(1)(1)(0)>[&];
}MIBpbSdhXcNewLoMapTable_t<s(0)(0)(0)>[&];(D1:MIBpbSdhXcNewLoMapTable_t:1)[[TYPENAME:MIBpbSdhXcNewLoMapTable_t]]

















 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbXcMigrationGroup_Did<s(0)(0)(0)>[&];(D1:pbXcMigrationGroup_Did:0)

   
typedef enum {
	pbXcMigrationCommand_none<s(0)(0)(0)>[&]=0,
	pbXcMigrationCommand_movePathToGmpls<s(0)(0)(0)>[&]=1,
	pbXcMigrationCommand_confirmPathToGmpls<s(0)(0)(0)>[&]=2,
	pbXcMigrationCommand_abortPathToGmpls<s(0)(0)(0)>[&]=3
} pbXcMigrationCommand_Tval<s(0)(0)(0)>[&];(D1:pbXcMigrationCommand_Tval:1)[[TYPENAME:pbXcMigrationCommand_Tval]]

typedef enum {
	pbXcMigrationStatus_unknown<s(0)(0)(0)>[&]=0,
	pbXcMigrationStatus_successful<s(0)(0)(0)>[&]=1,
	pbXcMigrationStatus_failed<s(0)(0)(0)>[&]=2
} pbXcMigrationStatus_Tval<s(0)(0)(0)>[&];(D1:pbXcMigrationStatus_Tval:1)[[TYPENAME:pbXcMigrationStatus_Tval]]

typedef struct
{
	int		pbForwardXcId<s(1)(1)(0)>[&];
	int		pbReverseXcId<s(1)(1)(0)>[&];
	pbXcMigrationCommand_Tval<s(1)(1)(0)>[T] pbXcMigrationCommand<s(1)(1)(0)>[&];
	pbXcMigrationStatus_Tval<s(1)(1)(0)>[T] pbXcMigrationStatus<s(1)(1)(0)>[&];
}MIBpbXcMigrationGroup_t<s(0)(0)(0)>[&];(D1:MIBpbXcMigrationGroup_t:1)[[TYPENAME:MIBpbXcMigrationGroup_t]]









 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbXCContextModule_Did<s(0)(0)(0)>[&];(D1:pbXCContextModule_Did:0)

   







 




 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbTMSRefSourceTable_Did<s(0)(0)(0)>[&];(D1:pbTMSRefSourceTable_Did:0)

   
typedef struct
{
	int		pbTMSRefSourceIndex<s(1)(1)(0)>[&];                                            
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbTMSRefSourceSlot<s(1)(1)(0)>[&];   
	int		pbTMSRefSourcePort<s(1)(1)(0)>[&];   
	PbYesNo_Tval<s(1)(1)(0)>[T] pbTMSRefSourceMonitored<s(1)(1)(0)>[&];   
	PbTMSSignalStatus_Tval<s(1)(1)(0)>[T] pbTMSSignalStatus<s(1)(1)(0)>[&];   
	int		pbTMSRefSourcePriority<s(1)(1)(0)>[&];   
	PbYesNo_Tval<s(1)(1)(0)>[T] pbTMSRefSourceLockOut<s(1)(1)(0)>[&];   
	PbTMSQl_Tval<s(1)(1)(0)>[T] pbTMSRefSourceQlIn<s(1)(1)(0)>[&];   
	PbTMSQl_Tval<s(1)(1)(0)>[T] pbTMSRefSourceQl<s(1)(1)(0)>[&];   
	PbTMSQLMode_Tval<s(1)(1)(0)>[T] pbTMSQlProvionedMode<s(1)(1)(0)>[&];   
	PbTMSQl_Tval<s(1)(1)(0)>[T] pbTMSQlProvioned<s(1)(1)(0)>[&];   
	PbYesNo_Tval<s(1)(1)(0)>[T] pbTMSRefSourceValid<s(1)(1)(0)>[&];   
	int		pbTMSRefSourceWTR<s(1)(1)(0)>[&];   
	TMSIfSdhQlType_Tval<s(1)(1)(0)>[T] tMSIfSdhQLType<s(1)(1)(0)>[&];   
	PbTMSQl_Tval<s(1)(1)(0)>[T] tMSRefSourceQLOut<s(1)(1)(0)>[&];   
	PbYesNo_Tval<s(1)(1)(0)>[T] tMSForceDnu<s(1)(1)(0)>[&];   
	PbYesNo_Tval<s(1)(1)(0)>[T] tMSSupportQlOut<s(1)(1)(0)>[&];   
	PbPortType_Tval<s(1)(1)(0)>[T] tMSPortType<s(1)(1)(0)>[&];   
	int		tmsRefSourceFDUpband<s(1)(1)(0)>[&];   
	int		tmsRefSourceFDLowband<s(1)(1)(0)>[&];   
	int		tmsRefSourceFDValue<s(1)(1)(0)>[&];   
	int		tmsStoredDrvClkNum<s(1)(1)(0)>[&];   
}MIBpbTMSRefSourceTable_t<s(0)(0)(0)>[&];(D1:MIBpbTMSRefSourceTable_t:1)[[TYPENAME:MIBpbTMSRefSourceTable_t]]





























 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbTMSSysTimingGroup_Did<s(0)(0)(0)>[&];(D1:pbTMSSysTimingGroup_Did:0)

   
typedef enum {
	pbTMSTimingState_locked<s(0)(0)(0)>[&]=1,
	pbTMSTimingState_freerunning<s(0)(0)(0)>[&]=2,
	pbTMSTimingState_holdover<s(0)(0)(0)>[&]=3
} pbTMSTimingState_Tval<s(0)(0)(0)>[&];(D1:pbTMSTimingState_Tval:1)[[TYPENAME:pbTMSTimingState_Tval]]

typedef enum {
	pbTMSSysTimingMode_autoselection<s(0)(0)(0)>[&]=1,
	pbTMSSysTimingMode_freerunning<s(0)(0)(0)>[&]=2,
	pbTMSSysTimingMode_holdover<s(0)(0)(0)>[&]=3
} pbTMSSysTimingMode_Tval<s(0)(0)(0)>[&];(D1:pbTMSSysTimingMode_Tval:1)[[TYPENAME:pbTMSSysTimingMode_Tval]]

typedef enum {
	pbTMSSwitchRequestStatus_inactive<s(0)(0)(0)>[&]=0,
	pbTMSSwitchRequestStatus_ok<s(0)(0)(0)>[&]=1,
	pbTMSSwitchRequestStatus_other_fail<s(0)(0)(0)>[&]=2,
	pbTMSSwitchRequestStatus_dis_fail<s(0)(0)(0)>[&]=3,
	pbTMSSwitchRequestStatus_lock_fail<s(0)(0)(0)>[&]=4,
	pbTMSSwitchRequestStatus_fs_fail<s(0)(0)(0)>[&]=5,
	pbTMSSwitchRequestStatus_sf_fail<s(0)(0)(0)>[&]=6,
	pbTMSSwitchRequestStatus_ql_dnu<s(0)(0)(0)>[&]=7,
	pbTMSSwitchRequestStatus_ql_low<s(0)(0)(0)>[&]=8
} pbTMSSwitchRequestStatus_Tval<s(0)(0)(0)>[&];(D1:pbTMSSwitchRequestStatus_Tval:1)[[TYPENAME:pbTMSSwitchRequestStatus_Tval]]

typedef struct
{
	int		pbTMSSwitchRequest<s(1)(1)(0)>[&];   
	int		pbTMSActiveTimingSource<s(1)(1)(0)>[&];   
	pbTMSTimingState_Tval<s(1)(1)(0)>[T] pbTMSTimingState<s(1)(1)(0)>[&];   
	pbTMSSysTimingMode_Tval<s(1)(1)(0)>[T] pbTMSSysTimingMode<s(1)(1)(0)>[&];   
	pbTMSSwitchRequestStatus_Tval<s(1)(1)(0)>[T] pbTMSSwitchRequestStatus<s(1)(1)(0)>[&];   
	DateTime<s(1)(1)(0)>[T]	pbTMSHoldoverDTS<s(1)(1)(0)>[&];   
	int		pbTMSStaClkOutSource<s(1)(1)(0)>[&];   
	PbYesNo_Tval<s(1)(1)(0)>[T] pbTMSQlEnabled<s(1)(1)(0)>[&];   
	PbTMSQl_Tval<s(1)(1)(0)>[T] pbTMSExpectedSMMB<s(1)(1)(0)>[&];   
	PbYesNo_Tval<s(1)(1)(0)>[T] pbTMSStClkAutoLoopPrevention<s(1)(1)(0)>[&];   
	int		tmsSysSrcFDThreshold<s(1)(1)(0)>[&];   
	int		tmsSysFDValue<s(1)(1)(0)>[&];   
}MIBpbTMSSysTimingGroup_t<s(0)(0)(0)>[&];(D1:MIBpbTMSSysTimingGroup_t:1)[[TYPENAME:MIBpbTMSSysTimingGroup_t]]

















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbTMSStClkInTable_Did<s(0)(0)(0)>[&];(D1:pbTMSStClkInTable_Did:0)

   
typedef struct
{
	TmsRefSourceNum_Tval<s(1)(1)(0)>[T] pbTMSStClkInIndex<s(1)(1)(0)>[&];                          
	PbTMSStClkType_Tval<s(1)(1)(0)>[T] pbTMSStClkInType<s(1)(1)(0)>[&];   
	PbTMSMonitorMode_Tval<s(1)(1)(0)>[T] pbTMSStClkInMonitored<s(1)(1)(0)>[&];   
	PbTMSSetSa_Tval<s(1)(1)(0)>[T] pbTMSStClkInSaBit<s(1)(1)(0)>[&];   
	TMSStClkOhm_Tval<s(1)(1)(0)>[T] tMSStClkInOhm<s(1)(1)(0)>[&];   
}MIBpbTMSStClkInTable_t<s(0)(0)(0)>[&];(D1:MIBpbTMSStClkInTable_t:1)[[TYPENAME:MIBpbTMSStClkInTable_t]]












 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbTMSStClkOutTable_Did<s(0)(0)(0)>[&];(D1:pbTMSStClkOutTable_Did:0)

   
typedef struct
{
	TmsRefSourceNum_Tval<s(1)(1)(0)>[T] pbTMSStClkOutIndex<s(1)(1)(0)>[&];                               
	PbTMSStClkType_Tval<s(1)(1)(0)>[T] pbTMSStClkOutType<s(1)(1)(0)>[&];   
	PbYesNo_Tval<s(1)(1)(0)>[T] pbTMSStClkOutMonitored<s(1)(1)(0)>[&];   
	PbTMSSetSa_Tval<s(1)(1)(0)>[T] pbTMSStClkOutSaBit<s(1)(1)(0)>[&];   
	PbTMSQl_Tval<s(1)(1)(0)>[T] pbTMSStClkOutQlThreshold<s(1)(1)(0)>[&];   
	PbTMSSquelchMode_Tval<s(1)(1)(0)>[T] pbTMSStClkOutSquelchMode<s(1)(1)(0)>[&];   
	TMSStClkOhm_Tval<s(1)(1)(0)>[T] tMSStClkOutOhm<s(1)(1)(0)>[&];   
	PbTMSQl_Tval<s(1)(1)(0)>[T] pbTMSStClkOutQlIn<s(1)(1)(0)>[&];   
	PbTMSQl_Tval<s(1)(1)(0)>[T] pbTMSStClkOutQl<s(1)(1)(0)>[&];   
	PbTMSOutActType_Tval<s(1)(1)(0)>[T] tmsStClkOutputMode<s(1)(1)(0)>[&];   
	PbTMSOutState_Tval<s(1)(1)(0)>[T] pbTMSStClkOutState<s(1)(1)(0)>[&];   
}MIBpbTMSStClkOutTable_t<s(0)(0)(0)>[&];(D1:MIBpbTMSStClkOutTable_t:1)[[TYPENAME:MIBpbTMSStClkOutTable_t]]


















 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbTMSModule_Did<s(0)(0)(0)>[&];(D1:pbTMSModule_Did:0)

   







 




 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbEthGlobalPortTable_Did<s(0)(0)(0)>[&];(D1:pbEthGlobalPortTable_Did:0)

   
typedef enum {
	pbPortTagProtocol_iEEE802<s(0)(0)(0)>[&]=0,
	pbPortTagProtocol_doubleTag<s(0)(0)(0)>[&]=1,
	pbPortTagProtocol_tunneling<s(0)(0)(0)>[&]=2
} pbPortTagProtocol_Tval<s(0)(0)(0)>[&];(D1:pbPortTagProtocol_Tval:1)[[TYPENAME:pbPortTagProtocol_Tval]]

typedef enum {
	pbEthACLType_filter<s(0)(0)(0)>[&]=1,
	pbEthACLType_forward<s(0)(0)(0)>[&]=2
} pbEthACLType_Tval<s(0)(0)(0)>[&];(D1:pbEthACLType_Tval:1)[[TYPENAME:pbEthACLType_Tval]]

typedef enum {
	pbEthBroadcastEnableHol_disable<s(0)(0)(0)>[&]=0,
	pbEthBroadcastEnableHol_enable<s(0)(0)(0)>[&]=1
} pbEthBroadcastEnableHol_Tval<s(0)(0)(0)>[&];(D1:pbEthBroadcastEnableHol_Tval:1)[[TYPENAME:pbEthBroadcastEnableHol_Tval]]

typedef enum {
	pbEthQoSIEEE802Version_version2004<s(0)(0)(0)>[&]=0,
	pbEthQoSIEEE802Version_version2005<s(0)(0)(0)>[&]=1
} pbEthQoSIEEE802Version_Tval<s(0)(0)(0)>[&];(D1:pbEthQoSIEEE802Version_Tval:1)[[TYPENAME:pbEthQoSIEEE802Version_Tval]]

typedef enum {
	pbEthChangeCoSMode_onlyCos<s(0)(0)(0)>[&]=0,
	pbEthChangeCoSMode_cosAndPriority<s(0)(0)(0)>[&]=1
} pbEthChangeCoSMode_Tval<s(0)(0)(0)>[&];(D1:pbEthChangeCoSMode_Tval:1)[[TYPENAME:pbEthChangeCoSMode_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                 
	pbPortTagProtocol_Tval<s(1)(1)(0)>[T] pbPortTagProtocol<s(1)(1)(0)>[&];   
	int		pbAgingTime<s(1)(1)(0)>[&];   
	int		pbIPGConfig<s(1)(1)(0)>[&];   
	int		pbVlanTagProtocolType_len<s(1)(1)(0)>[&];
	char		pbVlanTagProtocolType<s(1)(1)(0)>[&][2];   
	int		pbMTUSize<s(1)(1)(0)>[&];   
	pbEthACLType_Tval<s(1)(1)(0)>[T] pbEthACLType<s(1)(1)(0)>[&];   
	pbEthBroadcastEnableHol_Tval<s(1)(1)(0)>[T] pbEthBroadcastEnableHol<s(1)(1)(0)>[&];   
	int		pbEthTunnelingRxTPID_len<s(1)(1)(0)>[&];
	char		pbEthTunnelingRxTPID<s(1)(1)(0)>[&][2];   
	pbEthQoSIEEE802Version_Tval<s(1)(1)(0)>[T] pbEthQoSIEEE802Version<s(1)(1)(0)>[&];   
	pbEthChangeCoSMode_Tval<s(1)(1)(0)>[T] pbEthChangeCoSMode<s(1)(1)(0)>[&];
	unsigned int	pbEthLabelBase<s(1)(1)(0)>[&];   
	int		pbEthWredDropProbability<s(1)(1)(0)>[&];   
}MIBpbEthGlobalPortTable_t<s(0)(0)(0)>[&];(D1:MIBpbEthGlobalPortTable_t:1)[[TYPENAME:MIBpbEthGlobalPortTable_t]]




















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbEthConfigTable_Did<s(0)(0)(0)>[&];(D1:pbEthConfigTable_Did:0)

   
typedef enum {
	pbEthPortType_ge<s(0)(0)(0)>[&]=8,
	pbEthPortType_fe<s(0)(0)(0)>[&]=7,
	pbEthPortType_tenge<s(0)(0)(0)>[&]=25,
	pbEthPortType_fiber_channel<s(0)(0)(0)>[&]=26
} pbEthPortType_Tval<s(0)(0)(0)>[&];(D1:pbEthPortType_Tval:1)[[TYPENAME:pbEthPortType_Tval]]

typedef enum {
	pbEthPortAdminStatus_up<s(0)(0)(0)>[&]=1,
	pbEthPortAdminStatus_down<s(0)(0)(0)>[&]=0
} pbEthPortAdminStatus_Tval<s(0)(0)(0)>[&];(D1:pbEthPortAdminStatus_Tval:1)[[TYPENAME:pbEthPortAdminStatus_Tval]]

typedef enum {
	pbPortLinkStatus_up<s(0)(0)(0)>[&]=1,
	pbPortLinkStatus_down<s(0)(0)(0)>[&]=0
} pbPortLinkStatus_Tval<s(0)(0)(0)>[&];(D1:pbPortLinkStatus_Tval:1)[[TYPENAME:pbPortLinkStatus_Tval]]

typedef enum {
	pbEthPortAutoNego_enable<s(0)(0)(0)>[&]=1,
	pbEthPortAutoNego_disable<s(0)(0)(0)>[&]=0
} pbEthPortAutoNego_Tval<s(0)(0)(0)>[&];(D1:pbEthPortAutoNego_Tval:1)[[TYPENAME:pbEthPortAutoNego_Tval]]

typedef enum {
	pbEthPortFlowControl_enable<s(0)(0)(0)>[&]=1,
	pbEthPortFlowControl_disable<s(0)(0)(0)>[&]=0
} pbEthPortFlowControl_Tval<s(0)(0)(0)>[&];(D1:pbEthPortFlowControl_Tval:1)[[TYPENAME:pbEthPortFlowControl_Tval]]

typedef enum {
	pbEthPortSpeed_s10M<s(0)(0)(0)>[&]=1,
	pbEthPortSpeed_s100M<s(0)(0)(0)>[&]=2,
	pbEthPortSpeed_s1G<s(0)(0)(0)>[&]=3,
	pbEthPortSpeed_s10G<s(0)(0)(0)>[&]=4,
	pbEthPortSpeed_fc1G<s(0)(0)(0)>[&]=5,
	pbEthPortSpeed_fc2G<s(0)(0)(0)>[&]=6,
	pbEthPortSpeed_fc4G<s(0)(0)(0)>[&]=7
} pbEthPortSpeed_Tval<s(0)(0)(0)>[&];(D1:pbEthPortSpeed_Tval:1)[[TYPENAME:pbEthPortSpeed_Tval]]

typedef enum {
	pbEthPortDuplex_full<s(0)(0)(0)>[&]=1,
	pbEthPortDuplex_half<s(0)(0)(0)>[&]=0
} pbEthPortDuplex_Tval<s(0)(0)(0)>[&];(D1:pbEthPortDuplex_Tval:1)[[TYPENAME:pbEthPortDuplex_Tval]]

typedef enum {
	pbUnTagMode_untag<s(0)(0)(0)>[&]=0,
	pbUnTagMode_tag<s(0)(0)(0)>[&]=1
} pbUnTagMode_Tval<s(0)(0)(0)>[&];(D1:pbUnTagMode_Tval:1)[[TYPENAME:pbUnTagMode_Tval]]

typedef enum {
	pbEthPortMode_auto<s(0)(0)(0)>[&]=1,
	pbEthPortMode_mon<s(0)(0)(0)>[&]=2,
	pbEthPortMode_nmon<s(0)(0)(0)>[&]=3
} pbEthPortMode_Tval<s(0)(0)(0)>[&];(D1:pbEthPortMode_Tval:1)[[TYPENAME:pbEthPortMode_Tval]]

typedef enum {
	pbPortDefaultVlanPriority_be<s(0)(0)(0)>[&]=0,
	pbPortDefaultVlanPriority_bk<s(0)(0)(0)>[&]=1,
	pbPortDefaultVlanPriority_sp<s(0)(0)(0)>[&]=2,
	pbPortDefaultVlanPriority_ee<s(0)(0)(0)>[&]=3,
	pbPortDefaultVlanPriority_cl<s(0)(0)(0)>[&]=4,
	pbPortDefaultVlanPriority_vi<s(0)(0)(0)>[&]=5,
	pbPortDefaultVlanPriority_vo<s(0)(0)(0)>[&]=6,
	pbPortDefaultVlanPriority_nc<s(0)(0)(0)>[&]=7
} pbPortDefaultVlanPriority_Tval<s(0)(0)(0)>[&];(D1:pbPortDefaultVlanPriority_Tval:1)[[TYPENAME:pbPortDefaultVlanPriority_Tval]]

typedef enum {
	pbLanTxPriAlg_wRR<s(0)(0)(0)>[&]=0,
	pbLanTxPriAlg_sP1_WRR3<s(0)(0)(0)>[&]=1,
	pbLanTxPriAlg_sP2_WRR2<s(0)(0)(0)>[&]=2,
	pbLanTxPriAlg_sP<s(0)(0)(0)>[&]=3,
	pbLanTxPriAlg_wFQ<s(0)(0)(0)>[&]=4
} pbLanTxPriAlg_Tval<s(0)(0)(0)>[&];(D1:pbLanTxPriAlg_Tval:1)[[TYPENAME:pbLanTxPriAlg_Tval]]

typedef enum {
	pbEthPortLoopback_none<s(0)(0)(0)>[&]=0,
	pbEthPortLoopback_incoming<s(0)(0)(0)>[&]=1,
	pbEthPortLoopback_outgoing<s(0)(0)(0)>[&]=2
} pbEthPortLoopback_Tval<s(0)(0)(0)>[&];(D1:pbEthPortLoopback_Tval:1)[[TYPENAME:pbEthPortLoopback_Tval]]

typedef enum {
	pbEthTxEnableHol_disable<s(0)(0)(0)>[&]=0,
	pbEthTxEnableHol_enable<s(0)(0)(0)>[&]=1
} pbEthTxEnableHol_Tval<s(0)(0)(0)>[&];(D1:pbEthTxEnableHol_Tval:1)[[TYPENAME:pbEthTxEnableHol_Tval]]

typedef enum {
	pbEthAlsMode_no_command<s(0)(0)(0)>[&]=0,
	pbEthAlsMode_manual_restart<s(0)(0)(0)>[&]=1,
	pbEthAlsMode_manual_test<s(0)(0)(0)>[&]=2
} pbEthAlsMode_Tval<s(0)(0)(0)>[&];(D1:pbEthAlsMode_Tval:1)[[TYPENAME:pbEthAlsMode_Tval]]

typedef enum {
	ethMDIorMDIX_autoCrossover<s(0)(0)(0)>[&]=0,
	ethMDIorMDIX_mdix<s(0)(0)(0)>[&]=1,
	ethMDIorMDIX_mdi<s(0)(0)(0)>[&]=2
} ethMDIorMDIX_Tval<s(0)(0)(0)>[&];(D1:ethMDIorMDIX_Tval:1)[[TYPENAME:ethMDIorMDIX_Tval]]

typedef enum {
	pbLanChangeCoS_be<s(0)(0)(0)>[&]=0,
	pbLanChangeCoS_bk<s(0)(0)(0)>[&]=1,
	pbLanChangeCoS_sp<s(0)(0)(0)>[&]=2,
	pbLanChangeCoS_ee<s(0)(0)(0)>[&]=3,
	pbLanChangeCoS_cl<s(0)(0)(0)>[&]=4,
	pbLanChangeCoS_vi<s(0)(0)(0)>[&]=5,
	pbLanChangeCoS_vo<s(0)(0)(0)>[&]=6,
	pbLanChangeCoS_nc<s(0)(0)(0)>[&]=7,
	pbLanChangeCoS_not_change<s(0)(0)(0)>[&]=8
} pbLanChangeCoS_Tval<s(0)(0)(0)>[&];(D1:pbLanChangeCoS_Tval:1)[[TYPENAME:pbLanChangeCoS_Tval]]

typedef enum {
	pbLanQinQStatus_disable<s(0)(0)(0)>[&]=0,
	pbLanQinQStatus_enable<s(0)(0)(0)>[&]=1
} pbLanQinQStatus_Tval<s(0)(0)(0)>[&];(D1:pbLanQinQStatus_Tval:1)[[TYPENAME:pbLanQinQStatus_Tval]]

typedef enum {
	pbLanQinQNewVlanPriority_be<s(0)(0)(0)>[&]=0,
	pbLanQinQNewVlanPriority_bk<s(0)(0)(0)>[&]=1,
	pbLanQinQNewVlanPriority_sp<s(0)(0)(0)>[&]=2,
	pbLanQinQNewVlanPriority_ee<s(0)(0)(0)>[&]=3,
	pbLanQinQNewVlanPriority_cl<s(0)(0)(0)>[&]=4,
	pbLanQinQNewVlanPriority_vi<s(0)(0)(0)>[&]=5,
	pbLanQinQNewVlanPriority_vo<s(0)(0)(0)>[&]=6,
	pbLanQinQNewVlanPriority_nc<s(0)(0)(0)>[&]=7
} pbLanQinQNewVlanPriority_Tval<s(0)(0)(0)>[&];(D1:pbLanQinQNewVlanPriority_Tval:1)[[TYPENAME:pbLanQinQNewVlanPriority_Tval]]

typedef enum {
	pbEthPortClassifier_non_gmpls<s(0)(0)(0)>[&]=0,
	pbEthPortClassifier_i_nni<s(0)(0)(0)>[&]=1,
	pbEthPortClassifier_e_nni<s(0)(0)(0)>[&]=2,
	pbEthPortClassifier_uni10<s(0)(0)(0)>[&]=3,
	pbEthPortClassifier_uni20<s(0)(0)(0)>[&]=4
} pbEthPortClassifier_Tval<s(0)(0)(0)>[&];(D1:pbEthPortClassifier_Tval:1)[[TYPENAME:pbEthPortClassifier_Tval]]

typedef enum {
	pbEthPortWorkMode_ethernetMode<s(0)(0)(0)>[&]=0,
	pbEthPortWorkMode_mplsMode<s(0)(0)(0)>[&]=1
} pbEthPortWorkMode_Tval<s(0)(0)(0)>[&];(D1:pbEthPortWorkMode_Tval:1)[[TYPENAME:pbEthPortWorkMode_Tval]]

typedef enum {
	pbSFPWorkMode_fx<s(0)(0)(0)>[&]=0,
	pbSFPWorkMode_t<s(0)(0)(0)>[&]=1,
	pbSFPWorkMode_fx100<s(0)(0)(0)>[&]=2,
	pbSFPWorkMode_xfp10G<s(0)(0)(0)>[&]=3
} pbSFPWorkMode_Tval<s(0)(0)(0)>[&];(D1:pbSFPWorkMode_Tval:1)[[TYPENAME:pbSFPWorkMode_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                       
	int		pbPortNo<s(1)(1)(0)>[&];                                                            
	pbEthPortType_Tval<s(1)(1)(0)>[T] pbEthPortType<s(1)(1)(0)>[&];   
	pbEthPortAdminStatus_Tval<s(1)(1)(0)>[T] pbEthPortAdminStatus<s(1)(1)(0)>[&];   
	pbPortLinkStatus_Tval<s(1)(1)(0)>[T] pbPortLinkStatus<s(1)(1)(0)>[&];   
	pbEthPortAutoNego_Tval<s(1)(1)(0)>[T] pbEthPortAutoNego<s(1)(1)(0)>[&];   
	pbEthPortFlowControl_Tval<s(1)(1)(0)>[T] pbEthPortFlowControl<s(1)(1)(0)>[&];   
	pbEthPortSpeed_Tval<s(1)(1)(0)>[T] pbEthPortSpeed<s(1)(1)(0)>[&];   
	pbEthPortDuplex_Tval<s(1)(1)(0)>[T] pbEthPortDuplex<s(1)(1)(0)>[&];   
	char		pbEthPortVlan<s(1)(1)(0)>[&][255];   
	int		pbEthPortPvid<s(1)(1)(0)>[&];   
	pbUnTagMode_Tval<s(1)(1)(0)>[T] pbUnTagMode<s(1)(1)(0)>[&];   
	int		pbPortInputRateLimit<s(1)(1)(0)>[&];   
	pbEthPortMode_Tval<s(1)(1)(0)>[T] pbEthPortMode<s(1)(1)(0)>[&];   
	int		pbEthPortBroadCastRateLimit<s(1)(1)(0)>[&];   
	pbPortDefaultVlanPriority_Tval<s(1)(1)(0)>[T] pbPortDefaultVlanPriority<s(1)(1)(0)>[&];   
	char		pbEthPortLabel<s(1)(1)(0)>[&][20];   
	pbLanTxPriAlg_Tval<s(1)(1)(0)>[T] pbLanTxPriAlg<s(1)(1)(0)>[&];   
	char		pbLanTaggedVlan<s(1)(1)(0)>[&][255];   
	pbEthPortLoopback_Tval<s(1)(1)(0)>[T] pbEthPortLoopback<s(1)(1)(0)>[&];   
	pbEthTxEnableHol_Tval<s(1)(1)(0)>[T] pbEthTxEnableHol<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbEthAutoLaserShutdown<s(1)(1)(0)>[&];   
	pbEthAlsMode_Tval<s(1)(1)(0)>[T] pbEthAlsMode<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbEthPortAlarmDisable<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] ethPortOnCSF<s(1)(1)(0)>[&];   
	ethMDIorMDIX_Tval<s(1)(1)(0)>[T] ethMDIorMDIX<s(1)(1)(0)>[&];   
	pbLanChangeCoS_Tval<s(1)(1)(0)>[T] pbLanChangeCoS<s(1)(1)(0)>[&];   
	pbLanQinQStatus_Tval<s(1)(1)(0)>[T] pbLanQinQStatus<s(1)(1)(0)>[&];   
	int		pbLanQinQNewVlan<s(1)(1)(0)>[&];   
	pbLanQinQNewVlanPriority_Tval<s(1)(1)(0)>[T] pbLanQinQNewVlanPriority<s(1)(1)(0)>[&];   
	int		pbLanTPID_len<s(1)(1)(0)>[&];
	char		pbLanTPID<s(1)(1)(0)>[&][2];   
	char		pbLanMirrorPort<s(1)(1)(0)>[&][8];   
	pbEthPortClassifier_Tval<s(1)(1)(0)>[T] pbEthPortClassifier<s(1)(1)(0)>[&];
	pbEthPortWorkMode_Tval<s(1)(1)(0)>[T] pbEthPortWorkMode<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbEthEnableWred<s(1)(1)(0)>[&];   
	pbSFPWorkMode_Tval<s(1)(1)(0)>[T] pbSFPWorkMode<s(1)(1)(0)>[&];   
}MIBpbEthConfigTable_t<s(0)(0)(0)>[&];(D1:MIBpbEthConfigTable_t:1)[[TYPENAME:MIBpbEthConfigTable_t]]











































 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbEthWanConfigTable_Did<s(0)(0)(0)>[&];(D1:pbEthWanConfigTable_Did:0)

   
typedef enum {
	pbWanDefaultVlanPriority_be<s(0)(0)(0)>[&]=0,
	pbWanDefaultVlanPriority_bk<s(0)(0)(0)>[&]=1,
	pbWanDefaultVlanPriority_sp<s(0)(0)(0)>[&]=2,
	pbWanDefaultVlanPriority_ee<s(0)(0)(0)>[&]=3,
	pbWanDefaultVlanPriority_cl<s(0)(0)(0)>[&]=4,
	pbWanDefaultVlanPriority_vi<s(0)(0)(0)>[&]=5,
	pbWanDefaultVlanPriority_vo<s(0)(0)(0)>[&]=6,
	pbWanDefaultVlanPriority_nc<s(0)(0)(0)>[&]=7
} pbWanDefaultVlanPriority_Tval<s(0)(0)(0)>[&];(D1:pbWanDefaultVlanPriority_Tval:1)[[TYPENAME:pbWanDefaultVlanPriority_Tval]]

typedef enum {
	pbWanChangeCoS_be<s(0)(0)(0)>[&]=0,
	pbWanChangeCoS_bk<s(0)(0)(0)>[&]=1,
	pbWanChangeCoS_sp<s(0)(0)(0)>[&]=2,
	pbWanChangeCoS_ee<s(0)(0)(0)>[&]=3,
	pbWanChangeCoS_cl<s(0)(0)(0)>[&]=4,
	pbWanChangeCoS_vi<s(0)(0)(0)>[&]=5,
	pbWanChangeCoS_vo<s(0)(0)(0)>[&]=6,
	pbWanChangeCoS_nc<s(0)(0)(0)>[&]=7,
	pbWanChangeCoS_not_change<s(0)(0)(0)>[&]=8
} pbWanChangeCoS_Tval<s(0)(0)(0)>[&];(D1:pbWanChangeCoS_Tval:1)[[TYPENAME:pbWanChangeCoS_Tval]]

typedef enum {
	pbWanTagMode_untag<s(0)(0)(0)>[&]=0,
	pbWanTagMode_tag<s(0)(0)(0)>[&]=1
} pbWanTagMode_Tval<s(0)(0)(0)>[&];(D1:pbWanTagMode_Tval:1)[[TYPENAME:pbWanTagMode_Tval]]

typedef enum {
	pbWanFlowControl_enable<s(0)(0)(0)>[&]=1,
	pbWanFlowControl_disable<s(0)(0)(0)>[&]=0
} pbWanFlowControl_Tval<s(0)(0)(0)>[&];(D1:pbWanFlowControl_Tval:1)[[TYPENAME:pbWanFlowControl_Tval]]

typedef enum {
	pbWanTxPriAlg_wRR<s(0)(0)(0)>[&]=0,
	pbWanTxPriAlg_sP1_WRR3<s(0)(0)(0)>[&]=1,
	pbWanTxPriAlg_sP2_WRR2<s(0)(0)(0)>[&]=2,
	pbWanTxPriAlg_sP<s(0)(0)(0)>[&]=3,
	pbWanTxPriAlg_wFQ<s(0)(0)(0)>[&]=4
} pbWanTxPriAlg_Tval<s(0)(0)(0)>[&];(D1:pbWanTxPriAlg_Tval:1)[[TYPENAME:pbWanTxPriAlg_Tval]]

typedef enum {
	pbWanTxEnableHol_disable<s(0)(0)(0)>[&]=0,
	pbWanTxEnableHol_enable<s(0)(0)(0)>[&]=1
} pbWanTxEnableHol_Tval<s(0)(0)(0)>[&];(D1:pbWanTxEnableHol_Tval:1)[[TYPENAME:pbWanTxEnableHol_Tval]]

typedef enum {
	pbWanQinQStatus_disable<s(0)(0)(0)>[&]=0,
	pbWanQinQStatus_enable<s(0)(0)(0)>[&]=1
} pbWanQinQStatus_Tval<s(0)(0)(0)>[&];(D1:pbWanQinQStatus_Tval:1)[[TYPENAME:pbWanQinQStatus_Tval]]

typedef enum {
	pbWanQinQNewVlanPriority_be<s(0)(0)(0)>[&]=0,
	pbWanQinQNewVlanPriority_bk<s(0)(0)(0)>[&]=1,
	pbWanQinQNewVlanPriority_sp<s(0)(0)(0)>[&]=2,
	pbWanQinQNewVlanPriority_ee<s(0)(0)(0)>[&]=3,
	pbWanQinQNewVlanPriority_cl<s(0)(0)(0)>[&]=4,
	pbWanQinQNewVlanPriority_vi<s(0)(0)(0)>[&]=5,
	pbWanQinQNewVlanPriority_vo<s(0)(0)(0)>[&]=6,
	pbWanQinQNewVlanPriority_nc<s(0)(0)(0)>[&]=7
} pbWanQinQNewVlanPriority_Tval<s(0)(0)(0)>[&];(D1:pbWanQinQNewVlanPriority_Tval:1)[[TYPENAME:pbWanQinQNewVlanPriority_Tval]]

typedef enum {
	pbWanLinkStatus_down<s(0)(0)(0)>[&]=0,
	pbWanLinkStatus_up<s(0)(0)(0)>[&]=1
} pbWanLinkStatus_Tval<s(0)(0)(0)>[&];(D1:pbWanLinkStatus_Tval:1)[[TYPENAME:pbWanLinkStatus_Tval]]

typedef enum {
	pbWanPortWorkMode_ethernetMode<s(0)(0)(0)>[&]=0,
	pbWanPortWorkMode_mplsMode<s(0)(0)(0)>[&]=1
} pbWanPortWorkMode_Tval<s(0)(0)(0)>[&];(D1:pbWanPortWorkMode_Tval:1)[[TYPENAME:pbWanPortWorkMode_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                 
	int		pbPortNo<s(1)(1)(0)>[&];                                                      
	char		pbWanLabel<s(1)(1)(0)>[&][20];   
	char		pbWanVlanList<s(1)(1)(0)>[&][255];   
	char		pbWanTaggedVlanList<s(1)(1)(0)>[&][255];   
	pbWanDefaultVlanPriority_Tval<s(1)(1)(0)>[T] pbWanDefaultVlanPriority<s(1)(1)(0)>[&];   
	pbWanChangeCoS_Tval<s(1)(1)(0)>[T] pbWanChangeCoS<s(1)(1)(0)>[&];   
	int		pbWanPvid<s(1)(1)(0)>[&];   
	pbWanTagMode_Tval<s(1)(1)(0)>[T] pbWanTagMode<s(1)(1)(0)>[&];   
	pbWanFlowControl_Tval<s(1)(1)(0)>[T] pbWanFlowControl<s(1)(1)(0)>[&];   
	pbWanTxPriAlg_Tval<s(1)(1)(0)>[T] pbWanTxPriAlg<s(1)(1)(0)>[&];   
	pbWanTxEnableHol_Tval<s(1)(1)(0)>[T] pbWanTxEnableHol<s(1)(1)(0)>[&];   
	pbWanQinQStatus_Tval<s(1)(1)(0)>[T] pbWanQinQStatus<s(1)(1)(0)>[&];   
	int		pbWanQinQNewVlan<s(1)(1)(0)>[&];   
	pbWanQinQNewVlanPriority_Tval<s(1)(1)(0)>[T] pbWanQinQNewVlanPriority<s(1)(1)(0)>[&];   
	int		pbWanTPID_len<s(1)(1)(0)>[&];
	char		pbWanTPID<s(1)(1)(0)>[&][2];   
	char		pbWanMirrorPort<s(1)(1)(0)>[&][8];   
	pbWanLinkStatus_Tval<s(1)(1)(0)>[T] pbWanLinkStatus<s(1)(1)(0)>[&];   
	pbWanPortWorkMode_Tval<s(1)(1)(0)>[T] pbWanPortWorkMode<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbWanEnableWred<s(1)(1)(0)>[&];   
}MIBpbEthWanConfigTable_t<s(0)(0)(0)>[&];(D1:MIBpbEthWanConfigTable_t:1)[[TYPENAME:MIBpbEthWanConfigTable_t]]



























 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbEthStaticMACTable_Did<s(0)(0)(0)>[&];(D1:pbEthStaticMACTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                       
	char		pbMACEntryMacAddr<s(1)(1)(0)>[&][20];                                 
	int		pbMACEntryVid<s(1)(1)(0)>[&];                                          
	char		pbMACEntryPort<s(1)(1)(0)>[&][8];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbMACEntryTagged<s(1)(1)(0)>[&];   
	int		pbMACEntryIndex<s(1)(1)(0)>[&];   
	RowStatus_Tval<s(1)(1)(0)>[T] pbMACEntryRowStatus<s(1)(1)(0)>[&];   
}MIBpbEthStaticMACTable_t<s(0)(0)(0)>[&];(D1:MIBpbEthStaticMACTable_t:1)[[TYPENAME:MIBpbEthStaticMACTable_t]]














 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbEthStaticMulticastTable_Did<s(0)(0)(0)>[&];(D1:pbEthStaticMulticastTable_Did:0)

   
typedef enum {
	pbStaticMulticastForGmrp_notForGmrp<s(0)(0)(0)>[&]=0,
	pbStaticMulticastForGmrp_forGmrp<s(0)(0)(0)>[&]=1
} pbStaticMulticastForGmrp_Tval<s(0)(0)(0)>[&];(D1:pbStaticMulticastForGmrp_Tval:1)[[TYPENAME:pbStaticMulticastForGmrp_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                     
	char		pbStaticMulticastMacAddr<s(1)(1)(0)>[&][20];                                        
	int		pbStaticMulticastVlan<s(1)(1)(0)>[&];                                                
	char		pbStaticMulticastPortList<s(1)(1)(0)>[&][64];   
	int		pbStaticMulticastIndex<s(1)(1)(0)>[&];   
	RowStatus_Tval<s(1)(1)(0)>[T] pbStaticMulticastRowStatus<s(1)(1)(0)>[&];   
	pbStaticMulticastForGmrp_Tval<s(1)(1)(0)>[T] pbStaticMulticastForGmrp<s(1)(1)(0)>[&];   
}MIBpbEthStaticMulticastTable_t<s(0)(0)(0)>[&];(D1:MIBpbEthStaticMulticastTable_t:1)[[TYPENAME:MIBpbEthStaticMulticastTable_t]]














 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbVlanPortCoSTable_Did<s(0)(0)(0)>[&];(D1:pbVlanPortCoSTable_Did:0)

   
typedef enum {
	pbEthVlanCoS_be<s(0)(0)(0)>[&]=0,
	pbEthVlanCoS_bk<s(0)(0)(0)>[&]=1,
	pbEthVlanCoS_sp<s(0)(0)(0)>[&]=2,
	pbEthVlanCoS_ee<s(0)(0)(0)>[&]=3,
	pbEthVlanCoS_cl<s(0)(0)(0)>[&]=4,
	pbEthVlanCoS_vi<s(0)(0)(0)>[&]=5,
	pbEthVlanCoS_vo<s(0)(0)(0)>[&]=6,
	pbEthVlanCoS_nc<s(0)(0)(0)>[&]=7,
	pbEthVlanCoS_none<s(0)(0)(0)>[&]=8
} pbEthVlanCoS_Tval<s(0)(0)(0)>[&];(D1:pbEthVlanCoS_Tval:1)[[TYPENAME:pbEthVlanCoS_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                   
	int		pbPortNo<s(1)(1)(0)>[&];                                                        
	PbEthPortClass_Tval<s(1)(1)(0)>[T] pbEthPortCls<s(1)(1)(0)>[&];                                        
	int		pbEthVlan<s(1)(1)(0)>[&];                                                          
	int		pbEthRateLimitValue<s(1)(1)(0)>[&];   
	pbEthVlanCoS_Tval<s(1)(1)(0)>[T] pbEthVlanCoS<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbEthVlanDisable<s(1)(1)(0)>[&];   
	char		pbEthRedirectionPort<s(1)(1)(0)>[&][8];   
	int		pbVlanPortCoSIndex<s(1)(1)(0)>[&];   
	RowStatus_Tval<s(1)(1)(0)>[T] pbEthVlanPortCoSRowStatus<s(1)(1)(0)>[&];   
	int		pbEthVlanPolicingID<s(1)(1)(0)>[&];   
	int		pbEthVlanColorID<s(1)(1)(0)>[&];   
}MIBpbVlanPortCoSTable_t<s(0)(0)(0)>[&];(D1:MIBpbVlanPortCoSTable_t:1)[[TYPENAME:MIBpbVlanPortCoSTable_t]]



















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbEthVlanNameTable_Did<s(0)(0)(0)>[&];(D1:pbEthVlanNameTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                     
	int		pbEthNamedVlan<s(1)(1)(0)>[&];                                                       
	char		pbEthVlanName<s(1)(1)(0)>[&][30];   
	RowStatus_Tval<s(1)(1)(0)>[T] pbEthVlanRowStatus<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbEthVlanEnableMacLearning<s(1)(1)(0)>[&];   
}MIBpbEthVlanNameTable_t<s(0)(0)(0)>[&];(D1:MIBpbEthVlanNameTable_t:1)[[TYPENAME:MIBpbEthVlanNameTable_t]]












 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbPortQueueTable_Did<s(0)(0)(0)>[&];(D1:pbPortQueueTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                         
	int		pbPortNo<s(1)(1)(0)>[&];                                              
	PbEthInterfaceType_Tval<s(1)(1)(0)>[T] pbEthPortStyle<s(1)(1)(0)>[&];                        
	int		pbEthTxQueNo<s(1)(1)(0)>[&];                                             
	int		pbEthPortQueueWeight<s(1)(1)(0)>[&];   
	int		pbEthQueueWredID<s(1)(1)(0)>[&];   
}MIBpbPortQueueTable_t<s(0)(0)(0)>[&];(D1:MIBpbPortQueueTable_t:1)[[TYPENAME:MIBpbPortQueueTable_t]]













 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbEthACLTable_Did<s(0)(0)(0)>[&];(D1:pbEthACLTable_Did:0)

   
typedef enum {
	pbEthACLItemType_filter<s(0)(0)(0)>[&]=1,
	pbEthACLItemType_forward<s(0)(0)(0)>[&]=2
} pbEthACLItemType_Tval<s(0)(0)(0)>[&];(D1:pbEthACLItemType_Tval:1)[[TYPENAME:pbEthACLItemType_Tval]]

typedef enum {
	pbEthACLCoS_be<s(0)(0)(0)>[&]=0,
	pbEthACLCoS_bk<s(0)(0)(0)>[&]=1,
	pbEthACLCoS_sp<s(0)(0)(0)>[&]=2,
	pbEthACLCoS_ee<s(0)(0)(0)>[&]=3,
	pbEthACLCoS_cl<s(0)(0)(0)>[&]=4,
	pbEthACLCoS_vi<s(0)(0)(0)>[&]=5,
	pbEthACLCoS_vo<s(0)(0)(0)>[&]=6,
	pbEthACLCoS_nc<s(0)(0)(0)>[&]=7,
	pbEthACLCoS_none<s(0)(0)(0)>[&]=8
} pbEthACLCoS_Tval<s(0)(0)(0)>[&];(D1:pbEthACLCoS_Tval:1)[[TYPENAME:pbEthACLCoS_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                             
	char		pbEthACLMacAddr<s(1)(1)(0)>[&][20];                                         
	int		pbEthACLVid<s(1)(1)(0)>[&];                                                  
	pbEthACLItemType_Tval<s(1)(1)(0)>[T] pbEthACLItemType<s(1)(1)(0)>[&];   
	int		pbEthACLRateLimit<s(1)(1)(0)>[&];   
	pbEthACLCoS_Tval<s(1)(1)(0)>[T] pbEthACLCoS<s(1)(1)(0)>[&];   
	int		pbEthACLIndex<s(1)(1)(0)>[&];   
	RowStatus_Tval<s(1)(1)(0)>[T] pbEthACLEntryRowStatus<s(1)(1)(0)>[&];   
}MIBpbEthACLTable_t<s(0)(0)(0)>[&];(D1:MIBpbEthACLTable_t:1)[[TYPENAME:MIBpbEthACLTable_t]]















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbEthStatusTable_Did<s(0)(0)(0)>[&];(D1:pbEthStatusTable_Did:0)

   
typedef enum {
	pbEthStatusPortStyle_lan<s(0)(0)(0)>[&]=1,
	pbEthStatusPortStyle_wan<s(0)(0)(0)>[&]=2
} pbEthStatusPortStyle_Tval<s(0)(0)(0)>[&];(D1:pbEthStatusPortStyle_Tval:1)[[TYPENAME:pbEthStatusPortStyle_Tval]]

typedef enum {
	pbEthStatusPortType_ge<s(0)(0)(0)>[&]=8,
	pbEthStatusPortType_fe<s(0)(0)(0)>[&]=7,
	pbEthStatusPortType_tenge<s(0)(0)(0)>[&]=25,
	pbEthStatusPortType_fiber_channel<s(0)(0)(0)>[&]=26
} pbEthStatusPortType_Tval<s(0)(0)(0)>[&];(D1:pbEthStatusPortType_Tval:1)[[TYPENAME:pbEthStatusPortType_Tval]]

typedef enum {
	pbEthStatusPortOperStatus_pbPortOperationStatus_up<s(0)(0)(0)>[&]=1,
	pbEthStatusPortOperStatus_pbPortOperationStatus_down<s(0)(0)(0)>[&]=2,
	pbEthStatusPortOperStatus_pbPortOperationStatus_absent<s(0)(0)(0)>[&]=3,
	pbEthStatusPortOperStatus_pbPortOperationStatus_na<s(0)(0)(0)>[&]=4
} pbEthStatusPortOperStatus_Tval<s(0)(0)(0)>[&];(D1:pbEthStatusPortOperStatus_Tval:1)[[TYPENAME:pbEthStatusPortOperStatus_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                       
	int		pbPortNo<s(1)(1)(0)>[&];                                                            
	pbEthStatusPortStyle_Tval<s(1)(1)(0)>[T] pbEthStatusPortStyle<s(1)(1)(0)>[&];   
	pbEthStatusPortType_Tval<s(1)(1)(0)>[T] pbEthStatusPortType<s(1)(1)(0)>[&];   
	pbEthStatusPortOperStatus_Tval<s(1)(1)(0)>[T] pbEthStatusPortOperStatus<s(1)(1)(0)>[&];   
	int		pbEthStatusLaserIBias<s(1)(1)(0)>[&];   
	int		pbEthStatusLaserRecvPwr<s(1)(1)(0)>[&];   
	int		pbEthStatusLaserTransPwr<s(1)(1)(0)>[&];   
	int		pbEthStatusLaserTemp<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbEthStatusCompliance8472<s(1)(1)(0)>[&];   
	int		pbEthStatusNominalMBps<s(1)(1)(0)>[&];   
	int		pbEthStatusWavelength<s(1)(1)(0)>[&];   
	int		pbEthStatusLinkLength9125<s(1)(1)(0)>[&];   
	int		pbEthStatusLinkLength50125<s(1)(1)(0)>[&];   
	int		pbEthStatusLinkLength62125<s(1)(1)(0)>[&];   
	int		pbEthStatusLinkLengthCopper<s(1)(1)(0)>[&];   
	char		pbEthStatusVendorName<s(1)(1)(0)>[&][20];   
	char		pbEthStatusVendorPN<s(1)(1)(0)>[&][20];   
	char		pbEthStatusVendorSN<s(1)(1)(0)>[&][20];   
	char		pbEthStatusManuDate<s(1)(1)(0)>[&][16];   
	int		pbEthStatusTransCode<s(1)(1)(0)>[&];   
	char		pbEthStatusVendorOUI<s(1)(1)(0)>[&][16];   
	PbConnectorType_Tval<s(1)(1)(0)>[T] pbEthStatusConnectorType<s(1)(1)(0)>[&];   
	char		pbEthsSAGPartNumber<s(1)(1)(0)>[&][20];   
	int		pbEthnClLaserTemp<s(1)(1)(0)>[&];   
	int		pbEthnTECCurrent<s(1)(1)(0)>[&];   
}MIBpbEthStatusTable_t<s(0)(0)(0)>[&];(D1:MIBpbEthStatusTable_t:1)[[TYPENAME:MIBpbEthStatusTable_t]]

































 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbVlanPortQinQTable_Did<s(0)(0)(0)>[&];(D1:pbVlanPortQinQTable_Did:0)

   
typedef enum {
	pbEthQinQNewVlanPriority_be<s(0)(0)(0)>[&]=0,
	pbEthQinQNewVlanPriority_bk<s(0)(0)(0)>[&]=1,
	pbEthQinQNewVlanPriority_sp<s(0)(0)(0)>[&]=2,
	pbEthQinQNewVlanPriority_ee<s(0)(0)(0)>[&]=3,
	pbEthQinQNewVlanPriority_cl<s(0)(0)(0)>[&]=4,
	pbEthQinQNewVlanPriority_vi<s(0)(0)(0)>[&]=5,
	pbEthQinQNewVlanPriority_vo<s(0)(0)(0)>[&]=6,
	pbEthQinQNewVlanPriority_nc<s(0)(0)(0)>[&]=7
} pbEthQinQNewVlanPriority_Tval<s(0)(0)(0)>[&];(D1:pbEthQinQNewVlanPriority_Tval:1)[[TYPENAME:pbEthQinQNewVlanPriority_Tval]]

typedef enum {
	pbEthQinQNewVlanPriMode_userDefined<s(0)(0)(0)>[&]=0,
	pbEthQinQNewVlanPriMode_innerTag<s(0)(0)(0)>[&]=1,
	pbEthQinQNewVlanPriMode_ipds<s(0)(0)(0)>[&]=2
} pbEthQinQNewVlanPriMode_Tval<s(0)(0)(0)>[&];(D1:pbEthQinQNewVlanPriMode_Tval:1)[[TYPENAME:pbEthQinQNewVlanPriMode_Tval]]

typedef enum {
	pbEthQinQVlanSwapMode_vlanId<s(0)(0)(0)>[&]=0,
	pbEthQinQVlanSwapMode_tpid<s(0)(0)(0)>[&]=1,
	pbEthQinQVlanSwapMode_both<s(0)(0)(0)>[&]=2
} pbEthQinQVlanSwapMode_Tval<s(0)(0)(0)>[&];(D1:pbEthQinQVlanSwapMode_Tval:1)[[TYPENAME:pbEthQinQVlanSwapMode_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                     
	int		pbPortNo<s(1)(1)(0)>[&];                                                          
	PbEthPortClass_Tval<s(1)(1)(0)>[T] pbEthPortCls<s(1)(1)(0)>[&];                                       
	int		pbEthVlan<s(1)(1)(0)>[&];                                                         
	int		pbEthQinQNewVlanId<s(1)(1)(0)>[&];   
	pbEthQinQNewVlanPriority_Tval<s(1)(1)(0)>[T] pbEthQinQNewVlanPriority<s(1)(1)(0)>[&];   
	int		pbVlanPortQinQIndex<s(1)(1)(0)>[&];   
	RowStatus_Tval<s(1)(1)(0)>[T] pbEthVlanPortQinQRowStatus<s(1)(1)(0)>[&];   
	pbEthQinQNewVlanPriMode_Tval<s(1)(1)(0)>[T] pbEthQinQNewVlanPriMode<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbEthQinQVlanSwapEnable<s(1)(1)(0)>[&];   
	int		pbEthQinQVlanSwapVid<s(1)(1)(0)>[&];   
	pbEthQinQVlanSwapMode_Tval<s(1)(1)(0)>[T] pbEthQinQVlanSwapMode<s(1)(1)(0)>[&];   
}MIBpbVlanPortQinQTable_t<s(0)(0)(0)>[&];(D1:MIBpbVlanPortQinQTable_t:1)[[TYPENAME:MIBpbVlanPortQinQTable_t]]



















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbEthProtPktACLTable_Did<s(0)(0)(0)>[&];(D1:pbEthProtPktACLTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                 
	char		pbEthACLMacAddr<s(1)(1)(0)>[&][20];                                          
	char		pbEthProtPktACLPort<s(1)(1)(0)>[&][64];
	int		pbEthProtPktACLIndex<s(1)(1)(0)>[&];
	RowStatus_Tval<s(1)(1)(0)>[T] pbEthProtPktACLRowStatus<s(1)(1)(0)>[&];
}MIBpbEthProtPktACLTable_t<s(0)(0)(0)>[&];(D1:MIBpbEthProtPktACLTable_t:1)[[TYPENAME:MIBpbEthProtPktACLTable_t]]












 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbEthReservedTable_Did<s(0)(0)(0)>[&];(D1:pbEthReservedTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                             
	int		pbEthReserveIndex<s(1)(1)(0)>[&];                                         
	char		pbEthReservedCfg<s(1)(1)(0)>[&][255];
	RowStatus_Tval<s(1)(1)(0)>[T] pbEthReservedRowStatus<s(1)(1)(0)>[&];
}MIBpbEthReservedTable_t<s(0)(0)(0)>[&];(D1:MIBpbEthReservedTable_t:1)[[TYPENAME:MIBpbEthReservedTable_t]]











 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbIGMPSnooping_Did<s(0)(0)(0)>[&];(D1:pbIGMPSnooping_Did:0)

   


 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbLagConfigTable_Did<s(0)(0)(0)>[&];(D1:pbLagConfigTable_Did:0)

   
typedef enum {
	pbLagType_lan<s(0)(0)(0)>[&]=0,
	pbLagType_wan<s(0)(0)(0)>[&]=1
} pbLagType_Tval<s(0)(0)(0)>[&];(D1:pbLagType_Tval:1)[[TYPENAME:pbLagType_Tval]]

typedef enum {
	pbLagFlowControl_disable<s(0)(0)(0)>[&]=0,
	pbLagFlowControl_enable<s(0)(0)(0)>[&]=1
} pbLagFlowControl_Tval<s(0)(0)(0)>[&];(D1:pbLagFlowControl_Tval:1)[[TYPENAME:pbLagFlowControl_Tval]]

typedef enum {
	pbLagTagMode_untag<s(0)(0)(0)>[&]=0,
	pbLagTagMode_tag<s(0)(0)(0)>[&]=1
} pbLagTagMode_Tval<s(0)(0)(0)>[&];(D1:pbLagTagMode_Tval:1)[[TYPENAME:pbLagTagMode_Tval]]

typedef enum {
	pbLagDefaultVlanPriority_be<s(0)(0)(0)>[&]=0,
	pbLagDefaultVlanPriority_bk<s(0)(0)(0)>[&]=1,
	pbLagDefaultVlanPriority_sp<s(0)(0)(0)>[&]=2,
	pbLagDefaultVlanPriority_ee<s(0)(0)(0)>[&]=3,
	pbLagDefaultVlanPriority_cl<s(0)(0)(0)>[&]=4,
	pbLagDefaultVlanPriority_vi<s(0)(0)(0)>[&]=5,
	pbLagDefaultVlanPriority_vo<s(0)(0)(0)>[&]=6,
	pbLagDefaultVlanPriority_nc<s(0)(0)(0)>[&]=7
} pbLagDefaultVlanPriority_Tval<s(0)(0)(0)>[&];(D1:pbLagDefaultVlanPriority_Tval:1)[[TYPENAME:pbLagDefaultVlanPriority_Tval]]

typedef enum {
	pbLagTxPriAlg_wRR<s(0)(0)(0)>[&]=0,
	pbLagTxPriAlg_sP1_WRR3<s(0)(0)(0)>[&]=1,
	pbLagTxPriAlg_sP2_WRR2<s(0)(0)(0)>[&]=2,
	pbLagTxPriAlg_sP<s(0)(0)(0)>[&]=3,
	pbLagTxPriAlg_wFQ<s(0)(0)(0)>[&]=4
} pbLagTxPriAlg_Tval<s(0)(0)(0)>[&];(D1:pbLagTxPriAlg_Tval:1)[[TYPENAME:pbLagTxPriAlg_Tval]]

typedef enum {
	pbLagTxEnableHol_disable<s(0)(0)(0)>[&]=0,
	pbLagTxEnableHol_enable<s(0)(0)(0)>[&]=1
} pbLagTxEnableHol_Tval<s(0)(0)(0)>[&];(D1:pbLagTxEnableHol_Tval:1)[[TYPENAME:pbLagTxEnableHol_Tval]]

typedef enum {
	pbLagChangeCoS_be<s(0)(0)(0)>[&]=0,
	pbLagChangeCoS_bk<s(0)(0)(0)>[&]=1,
	pbLagChangeCoS_sp<s(0)(0)(0)>[&]=2,
	pbLagChangeCoS_ee<s(0)(0)(0)>[&]=3,
	pbLagChangeCoS_cl<s(0)(0)(0)>[&]=4,
	pbLagChangeCoS_vi<s(0)(0)(0)>[&]=5,
	pbLagChangeCoS_vo<s(0)(0)(0)>[&]=6,
	pbLagChangeCoS_nc<s(0)(0)(0)>[&]=7,
	pbLagChangeCoS_not_change<s(0)(0)(0)>[&]=8
} pbLagChangeCoS_Tval<s(0)(0)(0)>[&];(D1:pbLagChangeCoS_Tval:1)[[TYPENAME:pbLagChangeCoS_Tval]]

typedef enum {
	pbLagQinQStatus_disable<s(0)(0)(0)>[&]=0,
	pbLagQinQStatus_enable<s(0)(0)(0)>[&]=1
} pbLagQinQStatus_Tval<s(0)(0)(0)>[&];(D1:pbLagQinQStatus_Tval:1)[[TYPENAME:pbLagQinQStatus_Tval]]

typedef enum {
	pbLagQinQNewVlanPriority_be<s(0)(0)(0)>[&]=0,
	pbLagQinQNewVlanPriority_bk<s(0)(0)(0)>[&]=1,
	pbLagQinQNewVlanPriority_sp<s(0)(0)(0)>[&]=2,
	pbLagQinQNewVlanPriority_ee<s(0)(0)(0)>[&]=3,
	pbLagQinQNewVlanPriority_cl<s(0)(0)(0)>[&]=4,
	pbLagQinQNewVlanPriority_vi<s(0)(0)(0)>[&]=5,
	pbLagQinQNewVlanPriority_vo<s(0)(0)(0)>[&]=6,
	pbLagQinQNewVlanPriority_nc<s(0)(0)(0)>[&]=7
} pbLagQinQNewVlanPriority_Tval<s(0)(0)(0)>[&];(D1:pbLagQinQNewVlanPriority_Tval:1)[[TYPENAME:pbLagQinQNewVlanPriority_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                 
	int		pbLagId<s(1)(1)(0)>[&];                                                          
	pbLagType_Tval<s(1)(1)(0)>[T] pbLagType<s(1)(1)(0)>[&];   
	pbLagFlowControl_Tval<s(1)(1)(0)>[T] pbLagFlowControl<s(1)(1)(0)>[&];   
	int		pbLagPvid<s(1)(1)(0)>[&];   
	char		pbLagVlan<s(1)(1)(0)>[&][255];   
	pbLagTagMode_Tval<s(1)(1)(0)>[T] pbLagTagMode<s(1)(1)(0)>[&];   
	int		pbLagInputRateLimit<s(1)(1)(0)>[&];   
	int		pbLagBroadCastRateLimit<s(1)(1)(0)>[&];   
	pbLagDefaultVlanPriority_Tval<s(1)(1)(0)>[T] pbLagDefaultVlanPriority<s(1)(1)(0)>[&];   
	pbLagTxPriAlg_Tval<s(1)(1)(0)>[T] pbLagTxPriAlg<s(1)(1)(0)>[&];   
	pbLagTxEnableHol_Tval<s(1)(1)(0)>[T] pbLagTxEnableHol<s(1)(1)(0)>[&];   
	pbLagChangeCoS_Tval<s(1)(1)(0)>[T] pbLagChangeCoS<s(1)(1)(0)>[&];   
	pbLagQinQStatus_Tval<s(1)(1)(0)>[T] pbLagQinQStatus<s(1)(1)(0)>[&];   
	int		pbLagQinQNewVlan<s(1)(1)(0)>[&];   
	pbLagQinQNewVlanPriority_Tval<s(1)(1)(0)>[T] pbLagQinQNewVlanPriority<s(1)(1)(0)>[&];   
	char		pbLagPortList<s(1)(1)(0)>[&][255];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbLagEnableWred<s(1)(1)(0)>[&];   
}MIBpbLagConfigTable_t<s(0)(0)(0)>[&];(D1:MIBpbLagConfigTable_t:1)[[TYPENAME:MIBpbLagConfigTable_t]]

























 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbLacpConfig_Did<s(0)(0)(0)>[&];(D1:pbLacpConfig_Did:0)

   


 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbEthStaticMplsTable_Did<s(0)(0)(0)>[&];(D1:pbEthStaticMplsTable_Did:0)

   
typedef enum {
	pbEthInPortType_lan<s(0)(0)(0)>[&]=0,
	pbEthInPortType_wan<s(0)(0)(0)>[&]=1
} pbEthInPortType_Tval<s(0)(0)(0)>[&];(D1:pbEthInPortType_Tval:1)[[TYPENAME:pbEthInPortType_Tval]]

typedef enum {
	pbEthOutPortType_lan<s(0)(0)(0)>[&]=0,
	pbEthOutPortType_wan<s(0)(0)(0)>[&]=1
} pbEthOutPortType_Tval<s(0)(0)(0)>[&];(D1:pbEthOutPortType_Tval:1)[[TYPENAME:pbEthOutPortType_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                   
	unsigned int	pbEthLspLabel<s(1)(1)(0)>[&];                                              
	char		pbEthInPort<s(1)(1)(0)>[&][8];   
	pbEthInPortType_Tval<s(1)(1)(0)>[T] pbEthInPortType<s(1)(1)(0)>[&];   
	char		pbEthPort<s(1)(1)(0)>[&][8];   
	pbEthOutPortType_Tval<s(1)(1)(0)>[T] pbEthOutPortType<s(1)(1)(0)>[&];   
	int		pbEthStaticMplsPolicingID<s(1)(1)(0)>[&];   
	int		pbEthStaticMplsColorID<s(1)(1)(0)>[&];   
	RowStatus_Tval<s(1)(1)(0)>[T] pbEthStaticMplsStatus<s(1)(1)(0)>[&];   
	char		pbEthLspName<s(1)(1)(0)>[&][64];   
}MIBpbEthStaticMplsTable_t<s(0)(0)(0)>[&];(D1:MIBpbEthStaticMplsTable_t:1)[[TYPENAME:MIBpbEthStaticMplsTable_t]]

















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbEthPolicingTable_Did<s(0)(0)(0)>[&];(D1:pbEthPolicingTable_Did:0)

   
typedef enum {
	pbEthPolicingMode_rfc2698<s(0)(0)(0)>[&]=0,
	pbEthPolicingMode_mef10_cf0<s(0)(0)(0)>[&]=1,
	pbEthPolicingMode_mef10_cf1<s(0)(0)(0)>[&]=2
} pbEthPolicingMode_Tval<s(0)(0)(0)>[&];(D1:pbEthPolicingMode_Tval:1)[[TYPENAME:pbEthPolicingMode_Tval]]

typedef enum {
	pbEthPolicingColorAware_unaware<s(0)(0)(0)>[&]=0,
	pbEthPolicingColorAware_aware<s(0)(0)(0)>[&]=1
} pbEthPolicingColorAware_Tval<s(0)(0)(0)>[&];(D1:pbEthPolicingColorAware_Tval:1)[[TYPENAME:pbEthPolicingColorAware_Tval]]

typedef enum {
	pbEthPolicingDiscardColor_noColor<s(0)(0)(0)>[&]=0,
	pbEthPolicingDiscardColor_red<s(0)(0)(0)>[&]=1,
	pbEthPolicingDiscardColor_yellow<s(0)(0)(0)>[&]=2,
	pbEthPolicingDiscardColor_all<s(0)(0)(0)>[&]=3
} pbEthPolicingDiscardColor_Tval<s(0)(0)(0)>[&];(D1:pbEthPolicingDiscardColor_Tval:1)[[TYPENAME:pbEthPolicingDiscardColor_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                   
	int		pbEthPolicingIndex<s(1)(1)(0)>[&];                                                 
	char		pbEthPolicingName<s(1)(1)(0)>[&][32];   
	pbEthPolicingMode_Tval<s(1)(1)(0)>[T] pbEthPolicingMode<s(1)(1)(0)>[&];   
	unsigned int	pbEthPolicingEIRPIR<s(1)(1)(0)>[&];   
	unsigned int	pbEthPolicingCIR<s(1)(1)(0)>[&];   
	unsigned int	pbEthPolicingEBSPBS<s(1)(1)(0)>[&];   
	unsigned int	pbEthPolicingCBS<s(1)(1)(0)>[&];   
	pbEthPolicingColorAware_Tval<s(1)(1)(0)>[T] pbEthPolicingColorAware<s(1)(1)(0)>[&];   
	pbEthPolicingDiscardColor_Tval<s(1)(1)(0)>[T] pbEthPolicingDiscardColor<s(1)(1)(0)>[&];   
	RowStatus_Tval<s(1)(1)(0)>[T] pbEthPolicingRowStatus<s(1)(1)(0)>[&];   
	int		pbEthPolicingCount<s(1)(1)(0)>[&];   
}MIBpbEthPolicingTable_t<s(0)(0)(0)>[&];(D1:MIBpbEthPolicingTable_t:1)[[TYPENAME:MIBpbEthPolicingTable_t]]



















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbEthColorTable_Did<s(0)(0)(0)>[&];(D1:pbEthColorTable_Did:0)

   
typedef enum {
	pbEthPrio0Color_green<s(0)(0)(0)>[&]=0,
	pbEthPrio0Color_yellow<s(0)(0)(0)>[&]=1,
	pbEthPrio0Color_red<s(0)(0)(0)>[&]=2
} pbEthPrio0Color_Tval<s(0)(0)(0)>[&];(D1:pbEthPrio0Color_Tval:1)[[TYPENAME:pbEthPrio0Color_Tval]]

typedef enum {
	pbEthPrio1Color_green<s(0)(0)(0)>[&]=0,
	pbEthPrio1Color_yellow<s(0)(0)(0)>[&]=1,
	pbEthPrio1Color_red<s(0)(0)(0)>[&]=2
} pbEthPrio1Color_Tval<s(0)(0)(0)>[&];(D1:pbEthPrio1Color_Tval:1)[[TYPENAME:pbEthPrio1Color_Tval]]

typedef enum {
	pbEthPrio2Color_green<s(0)(0)(0)>[&]=0,
	pbEthPrio2Color_yellow<s(0)(0)(0)>[&]=1,
	pbEthPrio2Color_red<s(0)(0)(0)>[&]=2
} pbEthPrio2Color_Tval<s(0)(0)(0)>[&];(D1:pbEthPrio2Color_Tval:1)[[TYPENAME:pbEthPrio2Color_Tval]]

typedef enum {
	pbEthPrio3Color_green<s(0)(0)(0)>[&]=0,
	pbEthPrio3Color_yellow<s(0)(0)(0)>[&]=1,
	pbEthPrio3Color_red<s(0)(0)(0)>[&]=2
} pbEthPrio3Color_Tval<s(0)(0)(0)>[&];(D1:pbEthPrio3Color_Tval:1)[[TYPENAME:pbEthPrio3Color_Tval]]

typedef enum {
	pbEthPrio4Color_green<s(0)(0)(0)>[&]=0,
	pbEthPrio4Color_yellow<s(0)(0)(0)>[&]=1,
	pbEthPrio4Color_red<s(0)(0)(0)>[&]=2
} pbEthPrio4Color_Tval<s(0)(0)(0)>[&];(D1:pbEthPrio4Color_Tval:1)[[TYPENAME:pbEthPrio4Color_Tval]]

typedef enum {
	pbEthPrio5Color_green<s(0)(0)(0)>[&]=0,
	pbEthPrio5Color_yellow<s(0)(0)(0)>[&]=1,
	pbEthPrio5Color_red<s(0)(0)(0)>[&]=2
} pbEthPrio5Color_Tval<s(0)(0)(0)>[&];(D1:pbEthPrio5Color_Tval:1)[[TYPENAME:pbEthPrio5Color_Tval]]

typedef enum {
	pbEthPrio6Color_green<s(0)(0)(0)>[&]=0,
	pbEthPrio6Color_yellow<s(0)(0)(0)>[&]=1,
	pbEthPrio6Color_red<s(0)(0)(0)>[&]=2
} pbEthPrio6Color_Tval<s(0)(0)(0)>[&];(D1:pbEthPrio6Color_Tval:1)[[TYPENAME:pbEthPrio6Color_Tval]]

typedef enum {
	pbEthPrio7Color_green<s(0)(0)(0)>[&]=0,
	pbEthPrio7Color_yellow<s(0)(0)(0)>[&]=1,
	pbEthPrio7Color_red<s(0)(0)(0)>[&]=2
} pbEthPrio7Color_Tval<s(0)(0)(0)>[&];(D1:pbEthPrio7Color_Tval:1)[[TYPENAME:pbEthPrio7Color_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                       
	int		pbEthColorIndex<s(1)(1)(0)>[&];                                        
	pbEthPrio0Color_Tval<s(1)(1)(0)>[T] pbEthPrio0Color<s(1)(1)(0)>[&];   
	pbEthPrio1Color_Tval<s(1)(1)(0)>[T] pbEthPrio1Color<s(1)(1)(0)>[&];   
	pbEthPrio2Color_Tval<s(1)(1)(0)>[T] pbEthPrio2Color<s(1)(1)(0)>[&];   
	pbEthPrio3Color_Tval<s(1)(1)(0)>[T] pbEthPrio3Color<s(1)(1)(0)>[&];   
	pbEthPrio4Color_Tval<s(1)(1)(0)>[T] pbEthPrio4Color<s(1)(1)(0)>[&];   
	pbEthPrio5Color_Tval<s(1)(1)(0)>[T] pbEthPrio5Color<s(1)(1)(0)>[&];   
	pbEthPrio6Color_Tval<s(1)(1)(0)>[T] pbEthPrio6Color<s(1)(1)(0)>[&];   
	pbEthPrio7Color_Tval<s(1)(1)(0)>[T] pbEthPrio7Color<s(1)(1)(0)>[&];   
	RowStatus_Tval<s(1)(1)(0)>[T] pbEthColorRowStatus<s(1)(1)(0)>[&];   
	int		pbEthColorCount<s(1)(1)(0)>[&];   
}MIBpbEthColorTable_t<s(0)(0)(0)>[&];(D1:MIBpbEthColorTable_t:1)[[TYPENAME:MIBpbEthColorTable_t]]



















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbEthWredTable_Did<s(0)(0)(0)>[&];(D1:pbEthWredTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                     
	int		pbEthWredIndex<s(1)(1)(0)>[&];                                       
	int		pbEthWredLowThr0<s(1)(1)(0)>[&];   
	int		pbEthWredUpThr0<s(1)(1)(0)>[&];   
	int		pbEthWredLowThr1<s(1)(1)(0)>[&];   
	int		pbEthWredUpThr1<s(1)(1)(0)>[&];   
	int		pbEthWredLowThr2<s(1)(1)(0)>[&];   
	int		pbEthWredUpThr2<s(1)(1)(0)>[&];   
	RowStatus_Tval<s(1)(1)(0)>[T] pbEthWredRowStatus<s(1)(1)(0)>[&];   
	int		pbEthWredCount<s(1)(1)(0)>[&];   
}MIBpbEthWredTable_t<s(0)(0)(0)>[&];(D1:MIBpbEthWredTable_t:1)[[TYPENAME:MIBpbEthWredTable_t]]

















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbEthPortBasedACLTable_Did<s(0)(0)(0)>[&];(D1:pbEthPortBasedACLTable_Did:0)

   
typedef enum {
	pbEthPortBasedACLItemType_filter<s(0)(0)(0)>[&]=1,
	pbEthPortBasedACLItemType_forward<s(0)(0)(0)>[&]=2
} pbEthPortBasedACLItemType_Tval<s(0)(0)(0)>[&];(D1:pbEthPortBasedACLItemType_Tval:1)[[TYPENAME:pbEthPortBasedACLItemType_Tval]]

typedef enum {
	pbEthPortBasedACLCoS_be<s(0)(0)(0)>[&]=0,
	pbEthPortBasedACLCoS_bk<s(0)(0)(0)>[&]=1,
	pbEthPortBasedACLCoS_sp<s(0)(0)(0)>[&]=2,
	pbEthPortBasedACLCoS_ee<s(0)(0)(0)>[&]=3,
	pbEthPortBasedACLCoS_cl<s(0)(0)(0)>[&]=4,
	pbEthPortBasedACLCoS_vi<s(0)(0)(0)>[&]=5,
	pbEthPortBasedACLCoS_vo<s(0)(0)(0)>[&]=6,
	pbEthPortBasedACLCoS_nc<s(0)(0)(0)>[&]=7,
	pbEthPortBasedACLCoS_none<s(0)(0)(0)>[&]=8
} pbEthPortBasedACLCoS_Tval<s(0)(0)(0)>[&];(D1:pbEthPortBasedACLCoS_Tval:1)[[TYPENAME:pbEthPortBasedACLCoS_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                               
	int		pbPortNo<s(1)(1)(0)>[&];                                                                    
	PbEthPortClass_Tval<s(1)(1)(0)>[T] pbEthPortCls<s(1)(1)(0)>[&];                                                 
	char		pbEthPortBasedACLMacAddr<s(1)(1)(0)>[&][20];                                                  
	int		pbEthPortBasedACLVid<s(1)(1)(0)>[&];                                                           
	pbEthPortBasedACLItemType_Tval<s(1)(1)(0)>[T] pbEthPortBasedACLItemType<s(1)(1)(0)>[&];   
	int		pbEthPortBasedACLRateLimit<s(1)(1)(0)>[&];   
	pbEthPortBasedACLCoS_Tval<s(1)(1)(0)>[T] pbEthPortBasedACLCoS<s(1)(1)(0)>[&];   
	int		pbEthPortBasedACLIndex<s(1)(1)(0)>[&];   
	RowStatus_Tval<s(1)(1)(0)>[T] pbEthPortBasedACLEntryRowStatus<s(1)(1)(0)>[&];   
}MIBpbEthPortBasedACLTable_t<s(0)(0)(0)>[&];(D1:MIBpbEthPortBasedACLTable_t:1)[[TYPENAME:MIBpbEthPortBasedACLTable_t]]

















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbLacpGlobalCfgTable_Did<s(0)(0)(0)>[&];(D1:pbLacpGlobalCfgTable_Did:0)

   
typedef enum {
	pbLacpEnable_enable<s(0)(0)(0)>[&]=1,
	pbLacpEnable_disable<s(0)(0)(0)>[&]=2
} pbLacpEnable_Tval<s(0)(0)(0)>[&];(D1:pbLacpEnable_Tval:1)[[TYPENAME:pbLacpEnable_Tval]]

typedef enum {
	pbLacpHashMode_macipport<s(0)(0)(0)>[&]=1,
	pbLacpHashMode_mac<s(0)(0)(0)>[&]=2,
	pbLacpHashMode_ipport<s(0)(0)(0)>[&]=3
} pbLacpHashMode_Tval<s(0)(0)(0)>[&];(D1:pbLacpHashMode_Tval:1)[[TYPENAME:pbLacpHashMode_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];               
	pbLacpEnable_Tval<s(1)(1)(0)>[T] pbLacpEnable<s(1)(1)(0)>[&];   
	char		pbLacpSystemID<s(1)(1)(0)>[&][255];   
	int		pbLacpSystemPri<s(1)(1)(0)>[&];   
	pbLacpHashMode_Tval<s(1)(1)(0)>[T] pbLacpHashMode<s(1)(1)(0)>[&];   
}MIBpbLacpGlobalCfgTable_t<s(0)(0)(0)>[&];(D1:MIBpbLacpGlobalCfgTable_t:1)[[TYPENAME:MIBpbLacpGlobalCfgTable_t]]












 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbLacpAgConfigTable_Did<s(0)(0)(0)>[&];(D1:pbLacpAgConfigTable_Did:0)

   
typedef enum {
	pbLacpAgMode_dynamic<s(0)(0)(0)>[&]=1,
	pbLacpAgMode_static<s(0)(0)(0)>[&]=0
} pbLacpAgMode_Tval<s(0)(0)(0)>[&];(D1:pbLacpAgMode_Tval:1)[[TYPENAME:pbLacpAgMode_Tval]]

typedef enum {
	pbLacpAgRowState_active<s(0)(0)(0)>[&]=1,
	pbLacpAgRowState_inactive<s(0)(0)(0)>[&]=0
} pbLacpAgRowState_Tval<s(0)(0)(0)>[&];(D1:pbLacpAgRowState_Tval:1)[[TYPENAME:pbLacpAgRowState_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                 
	int		pbLacpAgNo<s(1)(1)(0)>[&];                                       
	char		pbLacpAgName<s(1)(1)(0)>[&][32];   
	char		pbLacpAgMac<s(1)(1)(0)>[&][32];   
	pbLacpAgMode_Tval<s(1)(1)(0)>[T] pbLacpAgMode<s(1)(1)(0)>[&];   
	pbLacpAgRowState_Tval<s(1)(1)(0)>[T] pbLacpAgRowState<s(1)(1)(0)>[&];   
}MIBpbLacpAgConfigTable_t<s(0)(0)(0)>[&];(D1:MIBpbLacpAgConfigTable_t:1)[[TYPENAME:MIBpbLacpAgConfigTable_t]]













 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbLacpAgInformTable_Did<s(0)(0)(0)>[&];(D1:pbLacpAgInformTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                             
	int		pbLacpAgNo<s(1)(1)(0)>[&];                                                
	int		pbLacpAgOperKey<s(1)(1)(0)>[&];   
	char		pbLacpPortList<s(1)(1)(0)>[&][128];   
	char		pbLacpPartnerMac<s(1)(1)(0)>[&][128];   
	int		pbLacpPartnerSysPri<s(1)(1)(0)>[&];   
	int		pbLacpPartnerAgOperKey<s(1)(1)(0)>[&];   
	int		pbLacpPortTypeInAg<s(1)(1)(0)>[&];   
	int		pbLacpPortSpeedInAg<s(1)(1)(0)>[&];   
}MIBpbLacpAgInformTable_t<s(0)(0)(0)>[&];(D1:MIBpbLacpAgInformTable_t:1)[[TYPENAME:MIBpbLacpAgInformTable_t]]
















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbLacpApConfigTable_Did<s(0)(0)(0)>[&];(D1:pbLacpApConfigTable_Did:0)

   
typedef enum {
	pbLacpTimeoutMode_fast<s(0)(0)(0)>[&]=1,
	pbLacpTimeoutMode_slow<s(0)(0)(0)>[&]=0
} pbLacpTimeoutMode_Tval<s(0)(0)(0)>[&];(D1:pbLacpTimeoutMode_Tval:1)[[TYPENAME:pbLacpTimeoutMode_Tval]]

typedef enum {
	pbLacpPortIndiv_individual<s(0)(0)(0)>[&]=1,
	pbLacpPortIndiv_aggregable<s(0)(0)(0)>[&]=2
} pbLacpPortIndiv_Tval<s(0)(0)(0)>[&];(D1:pbLacpPortIndiv_Tval:1)[[TYPENAME:pbLacpPortIndiv_Tval]]

typedef enum {
	pbLacpActiveMode_active<s(0)(0)(0)>[&]=1,
	pbLacpActiveMode_passive<s(0)(0)(0)>[&]=0
} pbLacpActiveMode_Tval<s(0)(0)(0)>[&];(D1:pbLacpActiveMode_Tval:1)[[TYPENAME:pbLacpActiveMode_Tval]]

typedef enum {
	pbLacpPortBpduMode_standardMode<s(0)(0)(0)>[&]=0,
	pbLacpPortBpduMode_tagMode<s(0)(0)(0)>[&]=1
} pbLacpPortBpduMode_Tval<s(0)(0)(0)>[&];(D1:pbLacpPortBpduMode_Tval:1)[[TYPENAME:pbLacpPortBpduMode_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                     
	PbLacpPortClass_Tval<s(1)(1)(0)>[T] pbLacpPortType<s(1)(1)(0)>[&];                       
	int		pbPortNo<s(1)(1)(0)>[&];                                          
	pbLacpTimeoutMode_Tval<s(1)(1)(0)>[T] pbLacpTimeoutMode<s(1)(1)(0)>[&];   
	pbLacpPortIndiv_Tval<s(1)(1)(0)>[T] pbLacpPortIndiv<s(1)(1)(0)>[&];   
	pbLacpActiveMode_Tval<s(1)(1)(0)>[T] pbLacpActiveMode<s(1)(1)(0)>[&];   
	int		pbLacpDesigAggor<s(1)(1)(0)>[&];   
	int		pbLacpPortPri<s(1)(1)(0)>[&];   
	pbLacpPortBpduMode_Tval<s(1)(1)(0)>[T] pbLacpPortBpduMode<s(1)(1)(0)>[&];   
}MIBpbLacpApConfigTable_t<s(0)(0)(0)>[&];(D1:MIBpbLacpApConfigTable_t:1)[[TYPENAME:MIBpbLacpApConfigTable_t]]
















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbLacpApInformTable_Did<s(0)(0)(0)>[&];(D1:pbLacpApInformTable_Did:0)

   
typedef enum {
	pbLacpPortLinkState_up<s(0)(0)(0)>[&]=1,
	pbLacpPortLinkState_down<s(0)(0)(0)>[&]=2
} pbLacpPortLinkState_Tval<s(0)(0)(0)>[&];(D1:pbLacpPortLinkState_Tval:1)[[TYPENAME:pbLacpPortLinkState_Tval]]

typedef enum {
	pbLacpPartnerPortMode_active<s(0)(0)(0)>[&]=1,
	pbLacpPartnerPortMode_passive<s(0)(0)(0)>[&]=0
} pbLacpPartnerPortMode_Tval<s(0)(0)(0)>[&];(D1:pbLacpPartnerPortMode_Tval:1)[[TYPENAME:pbLacpPartnerPortMode_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                             
	PbLacpPortClass_Tval<s(1)(1)(0)>[T] pbLacpPortType<s(1)(1)(0)>[&];                            
	int		pbPortNo<s(1)(1)(0)>[&];                                                  
	pbLacpPortLinkState_Tval<s(1)(1)(0)>[T] pbLacpPortLinkState<s(1)(1)(0)>[&];   
	int		pbLacpPortBelongAg<s(1)(1)(0)>[&];   
	char		pbLacpPortSync<s(1)(1)(0)>[&][32];   
	int		pbLacpPortOperKey<s(1)(1)(0)>[&];   
	int		pbLacpPartnerPortNo<s(1)(1)(0)>[&];   
	pbLacpPartnerPortMode_Tval<s(1)(1)(0)>[T] pbLacpPartnerPortMode<s(1)(1)(0)>[&];   
	int		pbLacpPartnerPortPri<s(1)(1)(0)>[&];   
	int		pbLacpPartnerOperKey<s(1)(1)(0)>[&];   
	char		pbLacpPartnerPortState<s(1)(1)(0)>[&][32];   
}MIBpbLacpApInformTable_t<s(0)(0)(0)>[&];(D1:MIBpbLacpApInformTable_t:1)[[TYPENAME:MIBpbLacpApInformTable_t]]



















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbIgmpSnoopingGlobalTable_Did<s(0)(0)(0)>[&];(D1:pbIgmpSnoopingGlobalTable_Did:0)

   
typedef enum {
	pbIgmpSnoopingEnable_enable<s(0)(0)(0)>[&]=1,
	pbIgmpSnoopingEnable_disable<s(0)(0)(0)>[&]=2
} pbIgmpSnoopingEnable_Tval<s(0)(0)(0)>[&];(D1:pbIgmpSnoopingEnable_Tval:1)[[TYPENAME:pbIgmpSnoopingEnable_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                               
	pbIgmpSnoopingEnable_Tval<s(1)(1)(0)>[T] pbIgmpSnoopingEnable<s(1)(1)(0)>[&];   
	int		pbIgmpSnoopingAgingTime<s(1)(1)(0)>[&];   
}MIBpbIgmpSnoopingGlobalTable_t<s(0)(0)(0)>[&];(D1:MIBpbIgmpSnoopingGlobalTable_t:1)[[TYPENAME:MIBpbIgmpSnoopingGlobalTable_t]]










 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbVlanIgmpSnoopingTable_Did<s(0)(0)(0)>[&];(D1:pbVlanIgmpSnoopingTable_Did:0)

   
typedef enum {
	pbVlanIgmpSnoopingEnable_enable<s(0)(0)(0)>[&]=1,
	pbVlanIgmpSnoopingEnable_disable<s(0)(0)(0)>[&]=2
} pbVlanIgmpSnoopingEnable_Tval<s(0)(0)(0)>[&];(D1:pbVlanIgmpSnoopingEnable_Tval:1)[[TYPENAME:pbVlanIgmpSnoopingEnable_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                       
	int		pbIgmpVlanNumber<s(1)(1)(0)>[&];                                                       
	pbVlanIgmpSnoopingEnable_Tval<s(1)(1)(0)>[T] pbVlanIgmpSnoopingEnable<s(1)(1)(0)>[&];   
	RowStatus_Tval<s(1)(1)(0)>[T] pbVlanIgmpSnoopingRowStatus<s(1)(1)(0)>[&];   
}MIBpbVlanIgmpSnoopingTable_t<s(0)(0)(0)>[&];(D1:MIBpbVlanIgmpSnoopingTable_t:1)[[TYPENAME:MIBpbVlanIgmpSnoopingTable_t]]











 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbIgmpSnoopingIpGroupTable_Did<s(0)(0)(0)>[&];(D1:pbIgmpSnoopingIpGroupTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                     
	int		pbIgmpVlanNumber<s(1)(1)(0)>[&];                                  
	unsigned int	pbGroupIp<s(1)(1)(0)>[&];                                    
	char		pbIgmpMacAddr<s(1)(1)(0)>[&][20];   
	char		pbIgmpIpMemberPort<s(1)(1)(0)>[&][128];   
}MIBpbIgmpSnoopingIpGroupTable_t<s(0)(0)(0)>[&];(D1:MIBpbIgmpSnoopingIpGroupTable_t:1)[[TYPENAME:MIBpbIgmpSnoopingIpGroupTable_t]]












 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbIgmpSnoopingMacGroupTable_Did<s(0)(0)(0)>[&];(D1:pbIgmpSnoopingMacGroupTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                       
	int		pbIgmpVlanNumber<s(1)(1)(0)>[&];                                    
	char		pbIgmpMacAddr<s(1)(1)(0)>[&][20];                                  
	char		pbIgmpMacMemberPort<s(1)(1)(0)>[&][128];   
}MIBpbIgmpSnoopingMacGroupTable_t<s(0)(0)(0)>[&];(D1:MIBpbIgmpSnoopingMacGroupTable_t:1)[[TYPENAME:MIBpbIgmpSnoopingMacGroupTable_t]]











 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbIgmpSnoopingMulRouterTable_Did<s(0)(0)(0)>[&];(D1:pbIgmpSnoopingMulRouterTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                       
	int		pbIgmpVlanNumber<s(1)(1)(0)>[&];                                    
	char		pbIgmpMulRouterPort<s(1)(1)(0)>[&][128];   
}MIBpbIgmpSnoopingMulRouterTable_t<s(0)(0)(0)>[&];(D1:MIBpbIgmpSnoopingMulRouterTable_t:1)[[TYPENAME:MIBpbIgmpSnoopingMulRouterTable_t]]










 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbEthernetModule_Did<s(0)(0)(0)>[&];(D1:pbEthernetModule_Did:0)

   







 




 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbGvrpBase_Did<s(0)(0)(0)>[&];(D1:pbGvrpBase_Did:0)

   


 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbGvrpBridgeTable_Did<s(0)(0)(0)>[&];(D1:pbGvrpBridgeTable_Did:0)

   
typedef enum {
	pbGvrpEnable_disabled<s(0)(0)(0)>[&]=0,
	pbGvrpEnable_enabled<s(0)(0)(0)>[&]=1
} pbGvrpEnable_Tval<s(0)(0)(0)>[&];(D1:pbGvrpEnable_Tval:1)[[TYPENAME:pbGvrpEnable_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                       
	char		pbGvrpBridgeAddress<s(1)(1)(0)>[&][32];   
	pbGvrpEnable_Tval<s(1)(1)(0)>[T] pbGvrpEnable<s(1)(1)(0)>[&];   
	int		pbGvrpJoinTimer<s(1)(1)(0)>[&];   
	int		pbGvrpLeaveTimer<s(1)(1)(0)>[&];   
	int		pbGvrpLeaveallTimer<s(1)(1)(0)>[&];   
	char		pbGvrpVlanList<s(1)(1)(0)>[&][255];
	int		pbGvrpMaxDVlanNum<s(1)(1)(0)>[&];
}MIBpbGvrpBridgeTable_t<s(0)(0)(0)>[&];(D1:MIBpbGvrpBridgeTable_t:1)[[TYPENAME:MIBpbGvrpBridgeTable_t]]















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbGvrpPortTable_Did<s(0)(0)(0)>[&];(D1:pbGvrpPortTable_Did:0)

   
typedef enum {
	pbGvrpPortType_lan<s(0)(0)(0)>[&]=1,
	pbGvrpPortType_wan<s(0)(0)(0)>[&]=2,
	pbGvrpPortType_trunk<s(0)(0)(0)>[&]=3
} pbGvrpPortType_Tval<s(0)(0)(0)>[&];(D1:pbGvrpPortType_Tval:1)[[TYPENAME:pbGvrpPortType_Tval]]

typedef enum {
	pbGvrpPortEnable_disabled<s(0)(0)(0)>[&]=0,
	pbGvrpPortEnable_enabled<s(0)(0)(0)>[&]=1
} pbGvrpPortEnable_Tval<s(0)(0)(0)>[&];(D1:pbGvrpPortEnable_Tval:1)[[TYPENAME:pbGvrpPortEnable_Tval]]

typedef enum {
	pbGvrpPortRegAdminCtrl_normal<s(0)(0)(0)>[&]=0,
	pbGvrpPortRegAdminCtrl_fixed<s(0)(0)(0)>[&]=1,
	pbGvrpPortRegAdminCtrl_forbidden<s(0)(0)(0)>[&]=2
} pbGvrpPortRegAdminCtrl_Tval<s(0)(0)(0)>[&];(D1:pbGvrpPortRegAdminCtrl_Tval:1)[[TYPENAME:pbGvrpPortRegAdminCtrl_Tval]]

typedef enum {
	pbGvrpPortApplAdminCtrl_normal<s(0)(0)(0)>[&]=0,
	pbGvrpPortApplAdminCtrl_nonparticipant<s(0)(0)(0)>[&]=1
} pbGvrpPortApplAdminCtrl_Tval<s(0)(0)(0)>[&];(D1:pbGvrpPortApplAdminCtrl_Tval:1)[[TYPENAME:pbGvrpPortApplAdminCtrl_Tval]]

typedef enum {
	pbGvrpBlockPortEnable_disabled<s(0)(0)(0)>[&]=0,
	pbGvrpBlockPortEnable_enabled<s(0)(0)(0)>[&]=1
} pbGvrpBlockPortEnable_Tval<s(0)(0)(0)>[&];(D1:pbGvrpBlockPortEnable_Tval:1)[[TYPENAME:pbGvrpBlockPortEnable_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                               
	pbGvrpPortType_Tval<s(1)(1)(0)>[T] pbGvrpPortType<s(1)(1)(0)>[&];                                  
	int		pbGvrpPortNo<s(1)(1)(0)>[&];                                                   
	pbGvrpPortEnable_Tval<s(1)(1)(0)>[T] pbGvrpPortEnable<s(1)(1)(0)>[&];   
	pbGvrpPortRegAdminCtrl_Tval<s(1)(1)(0)>[T] pbGvrpPortRegAdminCtrl<s(1)(1)(0)>[&];   
	pbGvrpPortApplAdminCtrl_Tval<s(1)(1)(0)>[T] pbGvrpPortApplAdminCtrl<s(1)(1)(0)>[&];   
	pbGvrpBlockPortEnable_Tval<s(1)(1)(0)>[T] pbGvrpBlockPortEnable<s(1)(1)(0)>[&];   
}MIBpbGvrpPortTable_t<s(0)(0)(0)>[&];(D1:MIBpbGvrpPortTable_t:1)[[TYPENAME:MIBpbGvrpPortTable_t]]














 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbGvrpDVlanTable_Did<s(0)(0)(0)>[&];(D1:pbGvrpDVlanTable_Did:0)

   
typedef enum {
	pbGvrpDPortType_lan<s(0)(0)(0)>[&]=1,
	pbGvrpDPortType_wan<s(0)(0)(0)>[&]=2,
	pbGvrpDPortType_trunk<s(0)(0)(0)>[&]=3
} pbGvrpDPortType_Tval<s(0)(0)(0)>[&];(D1:pbGvrpDPortType_Tval:1)[[TYPENAME:pbGvrpDPortType_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];               
	pbGvrpDPortType_Tval<s(1)(1)(0)>[T] pbGvrpDPortType<s(1)(1)(0)>[&];                
	int		pbGvrpDPortNo<s(1)(1)(0)>[&];                                  
	char		pbGvrpDVlanList<s(1)(1)(0)>[&][255];   
}MIBpbGvrpDVlanTable_t<s(0)(0)(0)>[&];(D1:MIBpbGvrpDVlanTable_t:1)[[TYPENAME:MIBpbGvrpDVlanTable_t]]











 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbGvrpModule_Did<s(0)(0)(0)>[&];(D1:pbGvrpModule_Did:0)

   







 




 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbGmrpBase_Did<s(0)(0)(0)>[&];(D1:pbGmrpBase_Did:0)

   


 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbGmrpBridgeTable_Did<s(0)(0)(0)>[&];(D1:pbGmrpBridgeTable_Did:0)

   
typedef enum {
	pbGmrpEnable_disabled<s(0)(0)(0)>[&]=0,
	pbGmrpEnable_enabled<s(0)(0)(0)>[&]=1
} pbGmrpEnable_Tval<s(0)(0)(0)>[&];(D1:pbGmrpEnable_Tval:1)[[TYPENAME:pbGmrpEnable_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                       
	char		pbGmrpBridgeAddress<s(1)(1)(0)>[&][32];   
	pbGmrpEnable_Tval<s(1)(1)(0)>[T] pbGmrpEnable<s(1)(1)(0)>[&];   
	int		pbGmrpJoinTimer<s(1)(1)(0)>[&];   
	int		pbGmrpLeaveTimer<s(1)(1)(0)>[&];   
	int		pbGmrpLeaveallTimer<s(1)(1)(0)>[&];   
	int		pbGmrpMaxDMacNum<s(1)(1)(0)>[&];   
}MIBpbGmrpBridgeTable_t<s(0)(0)(0)>[&];(D1:MIBpbGmrpBridgeTable_t:1)[[TYPENAME:MIBpbGmrpBridgeTable_t]]














 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbGmrpPortTable_Did<s(0)(0)(0)>[&];(D1:pbGmrpPortTable_Did:0)

   
typedef enum {
	pbGmrpPortType_lan<s(0)(0)(0)>[&]=1,
	pbGmrpPortType_wan<s(0)(0)(0)>[&]=2,
	pbGmrpPortType_trunk<s(0)(0)(0)>[&]=3
} pbGmrpPortType_Tval<s(0)(0)(0)>[&];(D1:pbGmrpPortType_Tval:1)[[TYPENAME:pbGmrpPortType_Tval]]

typedef enum {
	pbGmrpPortEnable_disabled<s(0)(0)(0)>[&]=0,
	pbGmrpPortEnable_enabled<s(0)(0)(0)>[&]=1
} pbGmrpPortEnable_Tval<s(0)(0)(0)>[&];(D1:pbGmrpPortEnable_Tval:1)[[TYPENAME:pbGmrpPortEnable_Tval]]

typedef enum {
	pbGmrpPortRegAdminCtrl_normal<s(0)(0)(0)>[&]=0,
	pbGmrpPortRegAdminCtrl_fixed<s(0)(0)(0)>[&]=1,
	pbGmrpPortRegAdminCtrl_forbidden<s(0)(0)(0)>[&]=2
} pbGmrpPortRegAdminCtrl_Tval<s(0)(0)(0)>[&];(D1:pbGmrpPortRegAdminCtrl_Tval:1)[[TYPENAME:pbGmrpPortRegAdminCtrl_Tval]]

typedef enum {
	pbGmrpPortApplAdminCtrl_normal<s(0)(0)(0)>[&]=0,
	pbGmrpPortApplAdminCtrl_nonparticipant<s(0)(0)(0)>[&]=1
} pbGmrpPortApplAdminCtrl_Tval<s(0)(0)(0)>[&];(D1:pbGmrpPortApplAdminCtrl_Tval:1)[[TYPENAME:pbGmrpPortApplAdminCtrl_Tval]]

typedef enum {
	pbGmrpForwardAllEnable_disabled<s(0)(0)(0)>[&]=0,
	pbGmrpForwardAllEnable_enabled<s(0)(0)(0)>[&]=1
} pbGmrpForwardAllEnable_Tval<s(0)(0)(0)>[&];(D1:pbGmrpForwardAllEnable_Tval:1)[[TYPENAME:pbGmrpForwardAllEnable_Tval]]

typedef enum {
	pbGmrpBlockPortEnable_disabled<s(0)(0)(0)>[&]=0,
	pbGmrpBlockPortEnable_enabled<s(0)(0)(0)>[&]=1
} pbGmrpBlockPortEnable_Tval<s(0)(0)(0)>[&];(D1:pbGmrpBlockPortEnable_Tval:1)[[TYPENAME:pbGmrpBlockPortEnable_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                               
	pbGmrpPortType_Tval<s(1)(1)(0)>[T] pbGmrpPortType<s(1)(1)(0)>[&];                                  
	int		pbGmrpPortNo<s(1)(1)(0)>[&];                                                   
	pbGmrpPortEnable_Tval<s(1)(1)(0)>[T] pbGmrpPortEnable<s(1)(1)(0)>[&];   
	pbGmrpPortRegAdminCtrl_Tval<s(1)(1)(0)>[T] pbGmrpPortRegAdminCtrl<s(1)(1)(0)>[&];   
	pbGmrpPortApplAdminCtrl_Tval<s(1)(1)(0)>[T] pbGmrpPortApplAdminCtrl<s(1)(1)(0)>[&];   
	pbGmrpForwardAllEnable_Tval<s(1)(1)(0)>[T] pbGmrpForwardAllEnable<s(1)(1)(0)>[&];   
	pbGmrpBlockPortEnable_Tval<s(1)(1)(0)>[T] pbGmrpBlockPortEnable<s(1)(1)(0)>[&];   
}MIBpbGmrpPortTable_t<s(0)(0)(0)>[&];(D1:MIBpbGmrpPortTable_t:1)[[TYPENAME:MIBpbGmrpPortTable_t]]















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbVlanGmrpTable_Did<s(0)(0)(0)>[&];(D1:pbVlanGmrpTable_Did:0)

   
typedef enum {
	pbVlanGmrpEnable_disable<s(0)(0)(0)>[&]=0,
	pbVlanGmrpEnable_enable<s(0)(0)(0)>[&]=1
} pbVlanGmrpEnable_Tval<s(0)(0)(0)>[&];(D1:pbVlanGmrpEnable_Tval:1)[[TYPENAME:pbVlanGmrpEnable_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                       
	int		pbGmrpVlanNumber<s(1)(1)(0)>[&];                                       
	pbVlanGmrpEnable_Tval<s(1)(1)(0)>[T] pbVlanGmrpEnable<s(1)(1)(0)>[&];   
	RowStatus_Tval<s(1)(1)(0)>[T] pbVlanGmrpRowStatus<s(1)(1)(0)>[&];   
}MIBpbVlanGmrpTable_t<s(0)(0)(0)>[&];(D1:MIBpbVlanGmrpTable_t:1)[[TYPENAME:MIBpbVlanGmrpTable_t]]











 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbGmrpDMacTable_Did<s(0)(0)(0)>[&];(D1:pbGmrpDMacTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                         
	int		pbGmrpVlanId<s(1)(1)(0)>[&];                                             
	char		pbGmrpMacAddr<s(1)(1)(0)>[&][20];                                       
	char		pbGmrpMacMemberPort1<s(1)(1)(0)>[&][255];   
	char		pbGmrpMacMemberPort2<s(1)(1)(0)>[&][255];   
}MIBpbGmrpDMacTable_t<s(0)(0)(0)>[&];(D1:MIBpbGmrpDMacTable_t:1)[[TYPENAME:MIBpbGmrpDMacTable_t]]












 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbGmrpModule_Did<s(0)(0)(0)>[&];(D1:pbGmrpModule_Did:0)

   







 




 



 
extern MIBDid_t<s(0)(0)(0)>[T] eosMapper_Did<s(0)(0)(0)>[&];(D1:eosMapper_Did:0)

   


 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] vcgConfigTable_Did<s(0)(0)(0)>[&];(D1:vcgConfigTable_Did:0)

   
typedef enum {
	vcgXVType_vc4<s(0)(0)(0)>[&]=0,
	vcgXVType_vc3<s(0)(0)(0)>[&]=1,
	vcgXVType_vc12<s(0)(0)(0)>[&]=2
} vcgXVType_Tval<s(0)(0)(0)>[&];(D1:vcgXVType_Tval:1)[[TYPENAME:vcgXVType_Tval]]

typedef enum {
	vcgPauseTransparent_disable<s(0)(0)(0)>[&]=0,
	vcgPauseTransparent_enable<s(0)(0)(0)>[&]=1
} vcgPauseTransparent_Tval<s(0)(0)(0)>[&];(D1:vcgPauseTransparent_Tval:1)[[TYPENAME:vcgPauseTransparent_Tval]]

typedef enum {
	vcgGfpMode_gfp_f<s(0)(0)(0)>[&]=0,
	vcgGfpMode_gfp_t<s(0)(0)(0)>[&]=1
} vcgGfpMode_Tval<s(0)(0)(0)>[&];(D1:vcgGfpMode_Tval:1)[[TYPENAME:vcgGfpMode_Tval]]

typedef enum {
	vcgGfpType_gfp_NullExternsion<s(0)(0)(0)>[&]=0,
	vcgGfpType_gfp_LinearFrames<s(0)(0)(0)>[&]=1
} vcgGfpType_Tval<s(0)(0)(0)>[&];(D1:vcgGfpType_Tval:1)[[TYPENAME:vcgGfpType_Tval]]

typedef enum {
	vcgGfpFCS_disable<s(0)(0)(0)>[&]=0,
	vcgGfpFCS_enable<s(0)(0)(0)>[&]=1
} vcgGfpFCS_Tval<s(0)(0)(0)>[&];(D1:vcgGfpFCS_Tval:1)[[TYPENAME:vcgGfpFCS_Tval]]

typedef enum {
	vcgGfpFcsAutoDetect_disable<s(0)(0)(0)>[&]=0,
	vcgGfpFcsAutoDetect_enable<s(0)(0)(0)>[&]=1
} vcgGfpFcsAutoDetect_Tval<s(0)(0)(0)>[&];(D1:vcgGfpFcsAutoDetect_Tval:1)[[TYPENAME:vcgGfpFcsAutoDetect_Tval]]

typedef enum {
	vcgPortMonMode_auto<s(0)(0)(0)>[&]=1,
	vcgPortMonMode_mon<s(0)(0)(0)>[&]=2,
	vcgPortMonMode_nmon<s(0)(0)(0)>[&]=3
} vcgPortMonMode_Tval<s(0)(0)(0)>[&];(D1:vcgPortMonMode_Tval:1)[[TYPENAME:vcgPortMonMode_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                       
	int		vcgNo<s(1)(1)(0)>[&];                                                  
	char		vcgLabel<s(1)(1)(0)>[&][100];   
	vcgXVType_Tval<s(1)(1)(0)>[T] vcgXVType<s(1)(1)(0)>[&];   
	char		vcgChannelId<s(1)(1)(0)>[&][50];   
	TruthValue_Tval<s(1)(1)(0)>[T] vcgLCASSupport<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] vcgCapacityTrigger<s(1)(1)(0)>[&];   
	vcgPauseTransparent_Tval<s(1)(1)(0)>[T] vcgPauseTransparent<s(1)(1)(0)>[&];   
	int		vcgLcasHoldOffTime<s(1)(1)(0)>[&];   
	vcgGfpMode_Tval<s(1)(1)(0)>[T] vcgGfpMode<s(1)(1)(0)>[&];   
	vcgGfpType_Tval<s(1)(1)(0)>[T] vcgGfpType<s(1)(1)(0)>[&];   
	vcgGfpFCS_Tval<s(1)(1)(0)>[T] vcgGfpFCS<s(1)(1)(0)>[&];   
	vcgGfpFcsAutoDetect_Tval<s(1)(1)(0)>[T] vcgGfpFcsAutoDetect<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] vcgGfpCsfAutoMode<s(1)(1)(0)>[&];   
	vcgPortMonMode_Tval<s(1)(1)(0)>[T] vcgPortMonMode<s(1)(1)(0)>[&];
	TruthValue_Tval<s(1)(1)(0)>[T] vcgPortAlarmDisable<s(1)(1)(0)>[&];
	int		vcgPLCTThreshold<s(1)(1)(0)>[&];   
	int		vcgPLCRThreshold<s(1)(1)(0)>[&];   
}MIBvcgConfigTable_t<s(0)(0)(0)>[&];(D1:MIBvcgConfigTable_t:1)[[TYPENAME:MIBvcgConfigTable_t]]

























 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] eosGlobalConfigTable_Did<s(0)(0)(0)>[&];(D1:eosGlobalConfigTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];         
	int		eosIPGConfig<s(1)(1)(0)>[&];   
	int		eosMTUSize<s(1)(1)(0)>[&];   
	int		eosEslConfig<s(1)(1)(0)>[&];   
}MIBeosGlobalConfigTable_t<s(0)(0)(0)>[&];(D1:MIBeosGlobalConfigTable_t:1)[[TYPENAME:MIBeosGlobalConfigTable_t]]











 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbSOLCASConfigTable_Did<s(0)(0)(0)>[&];(D1:pbSOLCASConfigTable_Did:0)

   
typedef enum {
	pbSOLCASActive_none<s(0)(0)(0)>[&]=0,
	pbSOLCASActive_active<s(0)(0)(0)>[&]=1,
	pbSOLCASActive_deactive<s(0)(0)(0)>[&]=2
} pbSOLCASActive_Tval<s(0)(0)(0)>[&];(D1:pbSOLCASActive_Tval:1)[[TYPENAME:pbSOLCASActive_Tval]]

typedef enum {
	pbSOLCASState_fixed<s(0)(0)(0)>[&]=0,
	pbSOLCASState_add<s(0)(0)(0)>[&]=1,
	pbSOLCASState_normal<s(0)(0)(0)>[&]=2,
	pbSOLCASState_eos<s(0)(0)(0)>[&]=3,
	pbSOLCASState_idle<s(0)(0)(0)>[&]=5,
	pbSOLCASState_dnu<s(0)(0)(0)>[&]=15
} pbSOLCASState_Tval<s(0)(0)(0)>[&];(D1:pbSOLCASState_Tval:1)[[TYPENAME:pbSOLCASState_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];               
	int		pbPortNo<s(1)(1)(0)>[&];                                    
	PbTPType_Tval<s(1)(1)(0)>[T] pbTpType<s(1)(1)(0)>[&];                           
	int		pbTpIndex<s(1)(1)(0)>[&];                                   
	pbSOLCASActive_Tval<s(1)(1)(0)>[T] pbSOLCASActive<s(1)(1)(0)>[&];   
	int		pbSOLCASVCGPort<s(1)(1)(0)>[&];   
	pbSOLCASState_Tval<s(1)(1)(0)>[T] pbSOLCASState<s(1)(1)(0)>[&];   
}MIBpbSOLCASConfigTable_t<s(0)(0)(0)>[&];(D1:MIBpbSOLCASConfigTable_t:1)[[TYPENAME:MIBpbSOLCASConfigTable_t]]














 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbSKLCASConfigTable_Did<s(0)(0)(0)>[&];(D1:pbSKLCASConfigTable_Did:0)

   
typedef enum {
	pbSKLCASState_ok<s(0)(0)(0)>[&]=0,
	pbSKLCASState_fail<s(0)(0)(0)>[&]=1
} pbSKLCASState_Tval<s(0)(0)(0)>[&];(D1:pbSKLCASState_Tval:1)[[TYPENAME:pbSKLCASState_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];               
	int		pbPortNo<s(1)(1)(0)>[&];                                    
	PbTPType_Tval<s(1)(1)(0)>[T] pbTpType<s(1)(1)(0)>[&];                           
	int		pbTpIndex<s(1)(1)(0)>[&];                                   
	int		pbSKLCASVCGPort<s(1)(1)(0)>[&];   
	pbSKLCASState_Tval<s(1)(1)(0)>[T] pbSKLCASState<s(1)(1)(0)>[&];   
}MIBpbSKLCASConfigTable_t<s(0)(0)(0)>[&];(D1:MIBpbSKLCASConfigTable_t:1)[[TYPENAME:MIBpbSKLCASConfigTable_t]]













 



 
extern MIBDid_t<s(0)(0)(0)>[T] enterpriseEOSModule_Did<s(0)(0)(0)>[&];(D1:enterpriseEOSModule_Did:0)

   







 




 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbRstpBase_Did<s(0)(0)(0)>[&];(D1:pbRstpBase_Did:0)

   


 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbRstpBridgeTable_Did<s(0)(0)(0)>[&];(D1:pbRstpBridgeTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                 
	int		pbRstpBridgeAddress_len<s(1)(1)(0)>[&];
	char		pbRstpBridgeAddress<s(1)(1)(0)>[&][6];   
	int		pbRstpBridgePriority<s(1)(1)(0)>[&];   
	int		pbRstpBridgeMaxAge<s(1)(1)(0)>[&];   
	int		pbRstpBridgeHelloTime<s(1)(1)(0)>[&];   
	int		pbRstpBridgeForwardDelay<s(1)(1)(0)>[&];   
	int		pbRstpTxHoldCount<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbRstpBEGIN<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbRstpEventSwitch<s(1)(1)(0)>[&];   
}MIBpbRstpBridgeTable_t<s(0)(0)(0)>[&];(D1:MIBpbRstpBridgeTable_t:1)[[TYPENAME:MIBpbRstpBridgeTable_t]]
















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbRstpPortTable_Did<s(0)(0)(0)>[&];(D1:pbRstpPortTable_Did:0)

   
typedef enum {
	pbRstpPortType_lan<s(0)(0)(0)>[&]=1,
	pbRstpPortType_wan<s(0)(0)(0)>[&]=2,
	pbRstpPortType_trunk<s(0)(0)(0)>[&]=3
} pbRstpPortType_Tval<s(0)(0)(0)>[&];(D1:pbRstpPortType_Tval:1)[[TYPENAME:pbRstpPortType_Tval]]

typedef enum {
	pbRstpPortEnable_enabled<s(0)(0)(0)>[&]=1,
	pbRstpPortEnable_disabled<s(0)(0)(0)>[&]=2
} pbRstpPortEnable_Tval<s(0)(0)(0)>[&];(D1:pbRstpPortEnable_Tval:1)[[TYPENAME:pbRstpPortEnable_Tval]]

typedef enum {
	pbRstpPortAdminPointToPoint_forceTrue<s(0)(0)(0)>[&]=0,
	pbRstpPortAdminPointToPoint_forceFalse<s(0)(0)(0)>[&]=1,
	pbRstpPortAdminPointToPoint_auto<s(0)(0)(0)>[&]=2
} pbRstpPortAdminPointToPoint_Tval<s(0)(0)(0)>[&];(D1:pbRstpPortAdminPointToPoint_Tval:1)[[TYPENAME:pbRstpPortAdminPointToPoint_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                       
	pbRstpPortType_Tval<s(1)(1)(0)>[T] pbRstpPortType<s(1)(1)(0)>[&];                                          
	int		pbRstpPortNo<s(1)(1)(0)>[&];                                                           
	int		pbRstpPortPriority<s(1)(1)(0)>[&];   
	pbRstpPortEnable_Tval<s(1)(1)(0)>[T] pbRstpPortEnable<s(1)(1)(0)>[&];   
	int		pbRstpPortPathCost<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbRstpPortAdminEdgePort<s(1)(1)(0)>[&];   
	pbRstpPortAdminPointToPoint_Tval<s(1)(1)(0)>[T] pbRstpPortAdminPointToPoint<s(1)(1)(0)>[&];   
}MIBpbRstpPortTable_t<s(0)(0)(0)>[&];(D1:MIBpbRstpPortTable_t:1)[[TYPENAME:MIBpbRstpPortTable_t]]















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbRstpBridgeStateTable_Did<s(0)(0)(0)>[&];(D1:pbRstpBridgeStateTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                             
	char		pbRstpRPVector1<s(1)(1)(0)>[&][75];   
	char		pbRstpRPVector2<s(1)(1)(0)>[&][75];   
	int		pbRstpRootMaxAge<s(1)(1)(0)>[&];   
	int		pbRstpRootHelloTime<s(1)(1)(0)>[&];   
	int		pbRstpRootForwardDelay<s(1)(1)(0)>[&];   
	int		pbRstpRootPortId<s(1)(1)(0)>[&];   
}MIBpbRstpBridgeStateTable_t<s(0)(0)(0)>[&];(D1:MIBpbRstpBridgeStateTable_t:1)[[TYPENAME:MIBpbRstpBridgeStateTable_t]]














 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbRstpPortStateTable_Did<s(0)(0)(0)>[&];(D1:pbRstpPortStateTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                       
	int		pbRstpPortType<s(1)(1)(0)>[&];                                      
	int		pbRstpPortNo<s(1)(1)(0)>[&];                                        
	int		pbRstpPEnable<s(1)(1)(0)>[&];   
	char		pbRstpPPVector1<s(1)(1)(0)>[&][75];   
	char		pbRstpPPVector2<s(1)(1)(0)>[&][75];   
	char		pbRstpDsgPVector1<s(1)(1)(0)>[&][75];   
	char		pbRstpDsgPVector2<s(1)(1)(0)>[&][75];   
	char		pbRstpMsgPVector1<s(1)(1)(0)>[&][75];   
	char		pbRstpMsgPVector2<s(1)(1)(0)>[&][75];   
	char		pbRstpPTimes<s(1)(1)(0)>[&][30];   
	char		pbRstpDsgTimes<s(1)(1)(0)>[&][30];   
	char		pbRstpMsgTimes<s(1)(1)(0)>[&][30];   
	int		pbRstpPForward<s(1)(1)(0)>[&];   
	int		pbRstpPLearn<s(1)(1)(0)>[&];   
	int		pbRstpPInfoIs<s(1)(1)(0)>[&];   
	int		pbRstpPRole<s(1)(1)(0)>[&];   
	int		pbRstpPSelectedRole<s(1)(1)(0)>[&];   
}MIBpbRstpPortStateTable_t<s(0)(0)(0)>[&];(D1:MIBpbRstpPortStateTable_t:1)[[TYPENAME:MIBpbRstpPortStateTable_t]]

























 



 
extern MIBDid_t<s(0)(0)(0)>[T] enterpriseRstpMIB_Did<s(0)(0)(0)>[&];(D1:enterpriseRstpMIB_Did:0)

   







 




 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbMstpBase_Did<s(0)(0)(0)>[&];(D1:pbMstpBase_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbMstpBridgeBase_Did<s(0)(0)(0)>[&];(D1:pbMstpBridgeBase_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbMstpPortBase_Did<s(0)(0)(0)>[&];(D1:pbMstpPortBase_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbMstpBridgeStateBase_Did<s(0)(0)(0)>[&];(D1:pbMstpBridgeStateBase_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbMstpPortStateBase_Did<s(0)(0)(0)>[&];(D1:pbMstpPortStateBase_Did:0)

   


 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbCistPortStateTable_Did<s(0)(0)(0)>[&];(D1:pbCistPortStateTable_Did:0)

   
typedef enum {
	pbCistPState_psDisable<s(0)(0)(0)>[&]=0,
	pbCistPState_psBlocking<s(0)(0)(0)>[&]=1,
	pbCistPState_psLearning<s(0)(0)(0)>[&]=2,
	pbCistPState_psForwarding<s(0)(0)(0)>[&]=3
} pbCistPState_Tval<s(0)(0)(0)>[&];(D1:pbCistPState_Tval:1)[[TYPENAME:pbCistPState_Tval]]

typedef enum {
	pbCistPRole_prDisable<s(0)(0)(0)>[&]=0,
	pbCistPRole_prRoot<s(0)(0)(0)>[&]=1,
	pbCistPRole_prDesignated<s(0)(0)(0)>[&]=2,
	pbCistPRole_prAlternate<s(0)(0)(0)>[&]=3,
	pbCistPRole_prBackup<s(0)(0)(0)>[&]=4,
	pbCistPRole_prMaster<s(0)(0)(0)>[&]=5
} pbCistPRole_Tval<s(0)(0)(0)>[&];(D1:pbCistPRole_Tval:1)[[TYPENAME:pbCistPRole_Tval]]

typedef enum {
	pbCistPPState_forceTrue<s(0)(0)(0)>[&]=0,
	pbCistPPState_forceFalse<s(0)(0)(0)>[&]=1
} pbCistPPState_Tval<s(0)(0)(0)>[&];(D1:pbCistPPState_Tval:1)[[TYPENAME:pbCistPPState_Tval]]

typedef enum {
	pbPortBpduRule_stp<s(0)(0)(0)>[&]=0,
	pbPortBpduRule_rstp_mstp<s(0)(0)(0)>[&]=1
} pbPortBpduRule_Tval<s(0)(0)(0)>[&];(D1:pbPortBpduRule_Tval:1)[[TYPENAME:pbPortBpduRule_Tval]]

typedef enum {
	pbPortOperEdge_normalPort<s(0)(0)(0)>[&]=0,
	pbPortOperEdge_edgePort<s(0)(0)(0)>[&]=1
} pbPortOperEdge_Tval<s(0)(0)(0)>[&];(D1:pbPortOperEdge_Tval:1)[[TYPENAME:pbPortOperEdge_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                   
	PbEthInterfaceType_Tval<s(1)(1)(0)>[T] pbMstPortType<s(1)(1)(0)>[&];                
	int		pbPortNo<s(1)(1)(0)>[&];                                        
	PbEnableDisable_Tval<s(1)(1)(0)>[T] pbCistPortEnable<s(1)(1)(0)>[&];   
	char		pbCistPPVector1<s(1)(1)(0)>[&][75];   
	char		pbCistPPVector2<s(1)(1)(0)>[&][75];   
	char		pbCistPPVector3<s(1)(1)(0)>[&][75];   
	char		pbCistDPVector1<s(1)(1)(0)>[&][75];   
	char		pbCistDPVector2<s(1)(1)(0)>[&][75];   
	char		pbCistDPVector3<s(1)(1)(0)>[&][75];   
	char		pbCistMPVector1<s(1)(1)(0)>[&][75];   
	char		pbCistMPVector2<s(1)(1)(0)>[&][75];   
	char		pbCistMPVector3<s(1)(1)(0)>[&][75];   
	char		pbCistPTimes<s(1)(1)(0)>[&][30];   
	char		pbCistDTimes<s(1)(1)(0)>[&][30];   
	char		pbCistMTimes<s(1)(1)(0)>[&][30];   
	pbCistPState_Tval<s(1)(1)(0)>[T] pbCistPState<s(1)(1)(0)>[&];   
	int		pbCistPInfoIs<s(1)(1)(0)>[&];   
	pbCistPRole_Tval<s(1)(1)(0)>[T] pbCistPRole<s(1)(1)(0)>[&];   
	pbCistPPState_Tval<s(1)(1)(0)>[T] pbCistPPState<s(1)(1)(0)>[&];
	int		pbMstRcvdInternal<s(1)(1)(0)>[&];   
	pbPortBpduRule_Tval<s(1)(1)(0)>[T] pbPortBpduRule<s(1)(1)(0)>[&];
	pbPortOperEdge_Tval<s(1)(1)(0)>[T] pbPortOperEdge<s(1)(1)(0)>[&];
}MIBpbCistPortStateTable_t<s(0)(0)(0)>[&];(D1:MIBpbCistPortStateTable_t:1)[[TYPENAME:MIBpbCistPortStateTable_t]]






























 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbMstiPortStateTable_Did<s(0)(0)(0)>[&];(D1:pbMstiPortStateTable_Did:0)

   
typedef enum {
	pbMstiPState_psDisable<s(0)(0)(0)>[&]=0,
	pbMstiPState_psBlocking<s(0)(0)(0)>[&]=1,
	pbMstiPState_psLearning<s(0)(0)(0)>[&]=2,
	pbMstiPState_psForwarding<s(0)(0)(0)>[&]=3
} pbMstiPState_Tval<s(0)(0)(0)>[&];(D1:pbMstiPState_Tval:1)[[TYPENAME:pbMstiPState_Tval]]

typedef enum {
	pbMstiPRole_prDisable<s(0)(0)(0)>[&]=0,
	pbMstiPRole_prRoot<s(0)(0)(0)>[&]=1,
	pbMstiPRole_prDesignated<s(0)(0)(0)>[&]=2,
	pbMstiPRole_prAlternate<s(0)(0)(0)>[&]=3,
	pbMstiPRole_prBackup<s(0)(0)(0)>[&]=4,
	pbMstiPRole_prMaster<s(0)(0)(0)>[&]=5
} pbMstiPRole_Tval<s(0)(0)(0)>[&];(D1:pbMstiPRole_Tval:1)[[TYPENAME:pbMstiPRole_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                       
	PbEthInterfaceType_Tval<s(1)(1)(0)>[T] pbMstPortType<s(1)(1)(0)>[&];                    
	int		pbPortNo<s(1)(1)(0)>[&];                                            
	int		pbMstiNumber<s(1)(1)(0)>[&];                                        
	char		pbMstiPPVector1<s(1)(1)(0)>[&][75];   
	char		pbMstiPPVector2<s(1)(1)(0)>[&][75];   
	char		pbMstiDPVector1<s(1)(1)(0)>[&][75];   
	char		pbMstiDPVector2<s(1)(1)(0)>[&][75];   
	char		pbMstiMPVector1<s(1)(1)(0)>[&][75];   
	char		pbMstiMPVector2<s(1)(1)(0)>[&][75];   
	char		pbMstiPTimes<s(1)(1)(0)>[&][30];   
	char		pbMstiDTimes<s(1)(1)(0)>[&][30];   
	char		pbMstiMTimes<s(1)(1)(0)>[&][30];   
	pbMstiPState_Tval<s(1)(1)(0)>[T] pbMstiPState<s(1)(1)(0)>[&];   
	int		pbMstiPInfoIs<s(1)(1)(0)>[&];   
	pbMstiPRole_Tval<s(1)(1)(0)>[T] pbMstiPRole<s(1)(1)(0)>[&];   
	int		pbMstiPSelectedRole<s(1)(1)(0)>[&];   
}MIBpbMstiPortStateTable_t<s(0)(0)(0)>[&];(D1:MIBpbMstiPortStateTable_t:1)[[TYPENAME:MIBpbMstiPortStateTable_t]]
























 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbCistBridgeStateTable_Did<s(0)(0)(0)>[&];(D1:pbCistBridgeStateTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                               
	int		pbMstBaseNumPorts<s(1)(1)(0)>[&];   
	char		pbCistRPVector1<s(1)(1)(0)>[&][75];   
	char		pbCistRPVector2<s(1)(1)(0)>[&][75];   
	char		pbCistRPVector3<s(1)(1)(0)>[&][75];   
	int		pbMstRootMaxAge<s(1)(1)(0)>[&];
	int		pbMstRootMsgAge<s(1)(1)(0)>[&];   
	int		pbMstRootHelloTime<s(1)(1)(0)>[&];   
	int		pbMstRootForwardDelay<s(1)(1)(0)>[&];   
	int		pbCistRootRemainingHops<s(1)(1)(0)>[&];   
	int		pbCistRootPortId<s(1)(1)(0)>[&];   
	int		pbMstCfgDigest_len<s(1)(1)(0)>[&];
	char		pbMstCfgDigest<s(1)(1)(0)>[&][16];   
}MIBpbCistBridgeStateTable_t<s(0)(0)(0)>[&];(D1:MIBpbCistBridgeStateTable_t:1)[[TYPENAME:MIBpbCistBridgeStateTable_t]]



















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbMstiBridgeStateTable_Did<s(0)(0)(0)>[&];(D1:pbMstiBridgeStateTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                               
	int		pbMstiNumber<s(1)(1)(0)>[&];                                                
	char		pbMstiRPVector1<s(1)(1)(0)>[&][75];   
	char		pbMstiRPVector2<s(1)(1)(0)>[&][75];   
	int		pbMstiRootRemainingHops<s(1)(1)(0)>[&];   
	int		pbMstiRootPortId<s(1)(1)(0)>[&];   
}MIBpbMstiBridgeStateTable_t<s(0)(0)(0)>[&];(D1:MIBpbMstiBridgeStateTable_t:1)[[TYPENAME:MIBpbMstiBridgeStateTable_t]]













 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbCistPortTable_Did<s(0)(0)(0)>[&];(D1:pbCistPortTable_Did:0)

   
typedef enum {
	pbMstPortAdminPointToPoint_forceTrue<s(0)(0)(0)>[&]=0,
	pbMstPortAdminPointToPoint_forceFalse<s(0)(0)(0)>[&]=1,
	pbMstPortAdminPointToPoint_auto<s(0)(0)(0)>[&]=2
} pbMstPortAdminPointToPoint_Tval<s(0)(0)(0)>[&];(D1:pbMstPortAdminPointToPoint_Tval:1)[[TYPENAME:pbMstPortAdminPointToPoint_Tval]]

typedef enum {
	pbMstPortBpduMode_standardMode<s(0)(0)(0)>[&]=0,
	pbMstPortBpduMode_tagMode<s(0)(0)(0)>[&]=1
} pbMstPortBpduMode_Tval<s(0)(0)(0)>[&];(D1:pbMstPortBpduMode_Tval:1)[[TYPENAME:pbMstPortBpduMode_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                                     
	PbEthInterfaceType_Tval<s(1)(1)(0)>[T] pbMstPortType<s(1)(1)(0)>[&];                                  
	int		pbPortNo<s(1)(1)(0)>[&];                                                          
	int		pbMstPort<s(1)(1)(0)>[&];   
	int		pbCistPortPriority<s(1)(1)(0)>[&];   
	int		pbCistExPortPathCost<s(1)(1)(0)>[&];   
	int		pbCistInPortPathCost<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbMstPortAdminEdgePort<s(1)(1)(0)>[&];   
	pbMstPortAdminPointToPoint_Tval<s(1)(1)(0)>[T] pbMstPortAdminPointToPoint<s(1)(1)(0)>[&];   
	PbEnableDisable_Tval<s(1)(1)(0)>[T] pbMstPortEnable<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbMstPortCheck<s(1)(1)(0)>[&];
	pbMstPortBpduMode_Tval<s(1)(1)(0)>[T] pbMstPortBpduMode<s(1)(1)(0)>[&];
}MIBpbCistPortTable_t<s(0)(0)(0)>[&];(D1:MIBpbCistPortTable_t:1)[[TYPENAME:MIBpbCistPortTable_t]]



















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbMstiPortTable_Did<s(0)(0)(0)>[&];(D1:pbMstiPortTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                     
	PbEthInterfaceType_Tval<s(1)(1)(0)>[T] pbMstPortType<s(1)(1)(0)>[&];                  
	int		pbPortNo<s(1)(1)(0)>[&];                                          
	int		pbMstiNumber<s(1)(1)(0)>[&];                                      
	int		pbMstiPortPriority<s(1)(1)(0)>[&];   
	int		pbMstiPortPathCost<s(1)(1)(0)>[&];   
}MIBpbMstiPortTable_t<s(0)(0)(0)>[&];(D1:MIBpbMstiPortTable_t:1)[[TYPENAME:MIBpbMstiPortTable_t]]













 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbCistBridgeTable_Did<s(0)(0)(0)>[&];(D1:pbCistBridgeTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                               
	int		pbMstBaseBridgeAddress_len<s(1)(1)(0)>[&];
	char		pbMstBaseBridgeAddress<s(1)(1)(0)>[&][6];   
	int		pbCistPriority<s(1)(1)(0)>[&];   
	int		pbMstForceVersion<s(1)(1)(0)>[&];   
	int		pbMstBridgeMaxAge<s(1)(1)(0)>[&];   
	int		pbMstBridgeHelloTime<s(1)(1)(0)>[&];   
	int		pbMstBridgeForwardDelay<s(1)(1)(0)>[&];   
	int		pbMstTxHoldCount<s(1)(1)(0)>[&];   
	int		pbMstMaxHops<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbMstMstpBEGIN<s(1)(1)(0)>[&];   
	char		pbMstMstpConfigName<s(1)(1)(0)>[&][33];   
	int		pbMstMstpRevisonLevel<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbMstEventSwitch<s(1)(1)(0)>[&];
}MIBpbCistBridgeTable_t<s(0)(0)(0)>[&];(D1:MIBpbCistBridgeTable_t:1)[[TYPENAME:MIBpbCistBridgeTable_t]]




















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbMstiBridgeTable_Did<s(0)(0)(0)>[&];(D1:pbMstiBridgeTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                 
	int		pbMstiNumber<s(1)(1)(0)>[&];                                     
	char		pbMstiVlanNumber<s(1)(1)(0)>[&][255];   
	int		pbMstiPriority<s(1)(1)(0)>[&];   
}MIBpbMstiBridgeTable_t<s(0)(0)(0)>[&];(D1:MIBpbMstiBridgeTable_t:1)[[TYPENAME:MIBpbMstiBridgeTable_t]]











 



 
extern MIBDid_t<s(0)(0)(0)>[T] enterpriseMstpMIB_Did<s(0)(0)(0)>[&];(D1:enterpriseMstpMIB_Did:0)

   







 




 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbIpRouteTable_Did<s(0)(0)(0)>[&];(D1:pbIpRouteTable_Did:0)

   
typedef enum {
	pbIpRouteProto_other<s(0)(0)(0)>[&]=1,
	pbIpRouteProto_local<s(0)(0)(0)>[&]=2,
	pbIpRouteProto_netmgmt<s(0)(0)(0)>[&]=3,
	pbIpRouteProto_icmp<s(0)(0)(0)>[&]=4,
	pbIpRouteProto_egp<s(0)(0)(0)>[&]=5,
	pbIpRouteProto_ggp<s(0)(0)(0)>[&]=6,
	pbIpRouteProto_hello<s(0)(0)(0)>[&]=7,
	pbIpRouteProto_rip<s(0)(0)(0)>[&]=8,
	pbIpRouteProto_is_is<s(0)(0)(0)>[&]=9,
	pbIpRouteProto_es_is<s(0)(0)(0)>[&]=10,
	pbIpRouteProto_ciscoIgrp<s(0)(0)(0)>[&]=11,
	pbIpRouteProto_bbnSpfIgp<s(0)(0)(0)>[&]=12,
	pbIpRouteProto_ospf<s(0)(0)(0)>[&]=13,
	pbIpRouteProto_bgp<s(0)(0)(0)>[&]=14
} pbIpRouteProto_Tval<s(0)(0)(0)>[&];(D1:pbIpRouteProto_Tval:1)[[TYPENAME:pbIpRouteProto_Tval]]

typedef enum {
	pbIpRouteType_other<s(0)(0)(0)>[&]=1,
	pbIpRouteType_invalid<s(0)(0)(0)>[&]=2,
	pbIpRouteType_direct<s(0)(0)(0)>[&]=3,
	pbIpRouteType_indirect<s(0)(0)(0)>[&]=4
} pbIpRouteType_Tval<s(0)(0)(0)>[&];(D1:pbIpRouteType_Tval:1)[[TYPENAME:pbIpRouteType_Tval]]

typedef struct
{
	unsigned int	pbIpRouteDest<s(1)(1)(0)>[&];                            
	unsigned int	pbIpRouteMask<s(1)(1)(0)>[&];                            
	pbIpRouteProto_Tval<s(1)(1)(0)>[T] pbIpRouteProto<s(1)(1)(0)>[&];                    
	int		pbIpRouteIfIndex<s(1)(1)(0)>[&];   
	unsigned int	pbIpRouteNextHop<s(1)(1)(0)>[&];   
	pbIpRouteType_Tval<s(1)(1)(0)>[T] pbIpRouteType<s(1)(1)(0)>[&];   
	int		pbIpRouteAge<s(1)(1)(0)>[&];   
	int		pbIpRouteMetric1<s(1)(1)(0)>[&];   
	int		pbIpRouteMetric2<s(1)(1)(0)>[&];   
	int		pbIpRouteMetric3<s(1)(1)(0)>[&];   
	int		pbIpRouteMetric4<s(1)(1)(0)>[&];   
	int		pbIpRouteMetric5<s(1)(1)(0)>[&];   
}MIBpbIpRouteTable_t<s(0)(0)(0)>[&];(D1:MIBpbIpRouteTable_t:1)[[TYPENAME:MIBpbIpRouteTable_t]]



















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] dccCfgTable_Did<s(0)(0)(0)>[&];(D1:dccCfgTable_Did:0)

   
typedef enum {
	mode_ms<s(0)(0)(0)>[&]=0,
	mode_rs<s(0)(0)(0)>[&]=1,
	mode_hcoc9<s(0)(0)(0)>[&]=2,
	mode_hcoc27<s(0)(0)(0)>[&]=3,
	mode_ecc<s(0)(0)(0)>[&]=4
} mode_Tval<s(0)(0)(0)>[&];(D1:mode_Tval:1)[[TYPENAME:mode_Tval]]

typedef enum {
	state_disable<s(0)(0)(0)>[&]=1,
	state_enable<s(0)(0)(0)>[&]=2,
	state_transparent<s(0)(0)(0)>[&]=3
} state_Tval<s(0)(0)(0)>[&];(D1:state_Tval:1)[[TYPENAME:state_Tval]]

typedef enum {
	protocol_ppp<s(0)(0)(0)>[&]=1,
	protocol_osi<s(0)(0)(0)>[&]=2,
	protocol_iptunnel<s(0)(0)(0)>[&]=3
} protocol_Tval<s(0)(0)(0)>[&];(D1:protocol_Tval:1)[[TYPENAME:protocol_Tval]]

typedef enum {
	linkStatus_down<s(0)(0)(0)>[&]=1,
	linkStatus_up<s(0)(0)(0)>[&]=2
} linkStatus_Tval<s(0)(0)(0)>[&];(D1:linkStatus_Tval:1)[[TYPENAME:linkStatus_Tval]]

typedef enum {
	mspStatus_nonprotected<s(0)(0)(0)>[&]=1,
	mspStatus_protected<s(0)(0)(0)>[&]=2
} mspStatus_Tval<s(0)(0)(0)>[&];(D1:mspStatus_Tval:1)[[TYPENAME:mspStatus_Tval]]

typedef enum {
	crcMode_crc16<s(0)(0)(0)>[&]=1,
	crcMode_crc32<s(0)(0)(0)>[&]=2
} crcMode_Tval<s(0)(0)(0)>[&];(D1:crcMode_Tval:1)[[TYPENAME:crcMode_Tval]]

typedef enum {
	multilink_open<s(0)(0)(0)>[&]=1,
	multilink_close<s(0)(0)(0)>[&]=2
} multilink_Tval<s(0)(0)(0)>[&];(D1:multilink_Tval:1)[[TYPENAME:multilink_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];               
	int		pbPortNo<s(1)(1)(0)>[&];                                    
	mode_Tval<s(1)(1)(0)>[T] mode<s(1)(1)(0)>[&];                                      
	state_Tval<s(1)(1)(0)>[T] state<s(1)(1)(0)>[&];   
	protocol_Tval<s(1)(1)(0)>[T] protocol<s(1)(1)(0)>[&];   
	unsigned int	dccBundleNumber<s(1)(1)(0)>[&];   
	linkStatus_Tval<s(1)(1)(0)>[T] linkStatus<s(1)(1)(0)>[&];   
	mspStatus_Tval<s(1)(1)(0)>[T] mspStatus<s(1)(1)(0)>[&];   
	int		destSlot<s(1)(1)(0)>[&];   
	int		destPort<s(1)(1)(0)>[&];   
	int		mtu<s(1)(1)(0)>[&];
	crcMode_Tval<s(1)(1)(0)>[T] crcMode<s(1)(1)(0)>[&];   
	int		hcocIndex<s(1)(1)(0)>[&];   
	multilink_Tval<s(1)(1)(0)>[T] multilink<s(1)(1)(0)>[&];   
}MIBdccCfgTable_t<s(0)(0)(0)>[&];(D1:MIBdccCfgTable_t:1)[[TYPENAME:MIBdccCfgTable_t]]





















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] ipInIpCfgTable_Did<s(0)(0)(0)>[&];(D1:ipInIpCfgTable_Did:0)

   
typedef struct
{
	unsigned int	ipInIpIfIpAddr<s(1)(1)(0)>[&];                               
	unsigned int	ipInIpIfMask<s(1)(1)(0)>[&];                                 
	unsigned int	ipInIpDestIpAddr<s(1)(1)(0)>[&];                             
	unsigned int	ipInIpSourcIpAddr<s(1)(1)(0)>[&];   
	unsigned int	ipInIpIfIndex<s(1)(1)(0)>[&];   
	unsigned int	ipInIpIfMtu<s(1)(1)(0)>[&];   
	RowStatus_Tval<s(1)(1)(0)>[T] ipInIpRowStatus<s(1)(1)(0)>[&];
	unsigned int	ipInIpPeerIfIpAddr<s(1)(1)(0)>[&];   
}MIBipInIpCfgTable_t<s(0)(0)(0)>[&];(D1:MIBipInIpCfgTable_t:1)[[TYPENAME:MIBipInIpCfgTable_t]]















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] mpBundleCfgTable_Did<s(0)(0)(0)>[&];(D1:mpBundleCfgTable_Did:0)

   
typedef enum {
	bundleTOS_enable<s(0)(0)(0)>[&]=1,
	bundleTOS_disable<s(0)(0)(0)>[&]=2
} bundleTOS_Tval<s(0)(0)(0)>[&];(D1:bundleTOS_Tval:1)[[TYPENAME:bundleTOS_Tval]]

typedef struct
{
	unsigned int	bundlePeerIpAddr<s(1)(1)(0)>[&];                         
	unsigned int	bundleIndex<s(1)(1)(0)>[&];   
	int		bundleStatus<s(1)(1)(0)>[&];   
	int		bundleNumber<s(1)(1)(0)>[&];   
	RowStatus_Tval<s(1)(1)(0)>[T] bundleRowStatus<s(1)(1)(0)>[&];   
	bundleTOS_Tval<s(1)(1)(0)>[T] bundleTOS<s(1)(1)(0)>[&];
}MIBmpBundleCfgTable_t<s(0)(0)(0)>[&];(D1:MIBmpBundleCfgTable_t:1)[[TYPENAME:MIBmpBundleCfgTable_t]]













 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbStaticIpRouteTable_Did<s(0)(0)(0)>[&];(D1:pbStaticIpRouteTable_Did:0)

   
typedef enum {
	pbStaticIpRouteProto_local<s(0)(0)(0)>[&]=1
} pbStaticIpRouteProto_Tval<s(0)(0)(0)>[&];(D1:pbStaticIpRouteProto_Tval:1)[[TYPENAME:pbStaticIpRouteProto_Tval]]

typedef enum {
	pbStaticIpRouteMetricType_none<s(0)(0)(0)>[&]=0,
	pbStaticIpRouteMetricType_aseType1Metric<s(0)(0)(0)>[&]=1,
	pbStaticIpRouteMetricType_aseType2Metric<s(0)(0)(0)>[&]=2
} pbStaticIpRouteMetricType_Tval<s(0)(0)(0)>[&];(D1:pbStaticIpRouteMetricType_Tval:1)[[TYPENAME:pbStaticIpRouteMetricType_Tval]]

typedef struct
{
	unsigned int	pbStaticIpRouteDest<s(1)(1)(0)>[&];                                          
	unsigned int	pbStaticIpRouteMask<s(1)(1)(0)>[&];                                          
	pbStaticIpRouteProto_Tval<s(1)(1)(0)>[T] pbStaticIpRouteProto<s(1)(1)(0)>[&];                            
	int		pbStaticIpRouteIfIndex<s(1)(1)(0)>[&];   
	unsigned int	pbStaticIpRouteNextHop<s(1)(1)(0)>[&];   
	RouteStatus_Tval<s(1)(1)(0)>[T] pbStaticIpRouteAdminStatus<s(1)(1)(0)>[&];   
	RouteStatus_Tval<s(1)(1)(0)>[T] pbStaticIpRouteOperStatus<s(1)(1)(0)>[&];   
	pbStaticIpRouteMetricType_Tval<s(1)(1)(0)>[T] pbStaticIpRouteMetricType<s(1)(1)(0)>[&];   
	int		pbStaticIpRouteCost<s(1)(1)(0)>[&];   
}MIBpbStaticIpRouteTable_t<s(0)(0)(0)>[&];(D1:MIBpbStaticIpRouteTable_t:1)[[TYPENAME:MIBpbStaticIpRouteTable_t]]
















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] tracertCfgTable_Did<s(0)(0)(0)>[&];(D1:tracertCfgTable_Did:0)

   
typedef enum {
	tracertStart_start<s(0)(0)(0)>[&]=1,
	tracertStart_stop<s(0)(0)(0)>[&]=2
} tracertStart_Tval<s(0)(0)(0)>[&];(D1:tracertStart_Tval:1)[[TYPENAME:tracertStart_Tval]]

typedef struct
{
	unsigned int	tracertPeerIpAddr<s(1)(1)(0)>[&];                       
	unsigned int	tracertTimeout<s(1)(1)(0)>[&];
	RowStatus_Tval<s(1)(1)(0)>[T] tracertRowStatus<s(1)(1)(0)>[&];
	tracertStart_Tval<s(1)(1)(0)>[T] tracertStart<s(1)(1)(0)>[&];
}MIBtracertCfgTable_t<s(0)(0)(0)>[&];(D1:MIBtracertCfgTable_t:1)[[TYPENAME:MIBtracertCfgTable_t]]











 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] tracertResultTable_Did<s(0)(0)(0)>[&];(D1:tracertResultTable_Did:0)

   
typedef struct
{
	int		tracertTtlNumber<s(1)(1)(0)>[&];                                      
	int		tracertTripTime1<s(1)(1)(0)>[&];
	int		tracertTripTime2<s(1)(1)(0)>[&];
	int		tracertTripTime3<s(1)(1)(0)>[&];
	unsigned int	tracertPeerIpAddrDis<s(1)(1)(0)>[&];
	RowStatus_Tval<s(1)(1)(0)>[T] tracertRstRowStatus<s(1)(1)(0)>[&];
}MIBtracertResultTable_t<s(0)(0)(0)>[&];(D1:MIBtracertResultTable_t:1)[[TYPENAME:MIBtracertResultTable_t]]













 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pingCfgTable_Did<s(0)(0)(0)>[&];(D1:pingCfgTable_Did:0)

   
typedef enum {
	pingStart_start<s(0)(0)(0)>[&]=1,
	pingStart_stop<s(0)(0)(0)>[&]=2
} pingStart_Tval<s(0)(0)(0)>[&];(D1:pingStart_Tval:1)[[TYPENAME:pingStart_Tval]]

typedef struct
{
	unsigned int	pingTargetIpAddr<s(1)(1)(0)>[&];                      
	int		pingDataSize<s(1)(1)(0)>[&];
	int		pingCounts<s(1)(1)(0)>[&];
	int		pingTimeout<s(1)(1)(0)>[&];
	RowStatus_Tval<s(1)(1)(0)>[T] pingRowStatus<s(1)(1)(0)>[&];
	pingStart_Tval<s(1)(1)(0)>[T] pingStart<s(1)(1)(0)>[&];
}MIBpingCfgTable_t<s(0)(0)(0)>[&];(D1:MIBpingCfgTable_t:1)[[TYPENAME:MIBpingCfgTable_t]]













 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pingResultTable_Did<s(0)(0)(0)>[&];(D1:pingResultTable_Did:0)

   
typedef struct
{
	int		pingIndex<s(1)(1)(0)>[&];                                           
	unsigned int	pingTargetIpAddrDis<s(1)(1)(0)>[&];
	int		pingDataSizeDis<s(1)(1)(0)>[&];
	int		pingTripTime<s(1)(1)(0)>[&];
	int		pingTtlnumber<s(1)(1)(0)>[&];
	int		pingResult<s(1)(1)(0)>[&];
	RowStatus_Tval<s(1)(1)(0)>[T] pingRstRowStatus<s(1)(1)(0)>[&];
}MIBpingResultTable_t<s(0)(0)(0)>[&];(D1:MIBpingResultTable_t:1)[[TYPENAME:MIBpingResultTable_t]]














 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] dccReservePortTable_Did<s(0)(0)(0)>[&];(D1:dccReservePortTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];         
	int		phyPortNum<s(1)(1)(0)>[&];                            
	int		logPortNum<s(1)(1)(0)>[&];
}MIBdccReservePortTable_t<s(0)(0)(0)>[&];(D1:MIBdccReservePortTable_t:1)[[TYPENAME:MIBdccReservePortTable_t]]










 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbDccModule_Did<s(0)(0)(0)>[&];(D1:pbDccModule_Did:0)

   







 




 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbIpTunnelCfgTable_Did<s(0)(0)(0)>[&];(D1:pbIpTunnelCfgTable_Did:0)

   
typedef enum {
	pbSdhServerType_ms<s(0)(0)(0)>[&]=0,
	pbSdhServerType_rs<s(0)(0)(0)>[&]=1,
	pbSdhServerType_hcoc9<s(0)(0)(0)>[&]=2,
	pbSdhServerType_hcoc27<s(0)(0)(0)>[&]=3
} pbSdhServerType_Tval<s(0)(0)(0)>[&];(D1:pbSdhServerType_Tval:1)[[TYPENAME:pbSdhServerType_Tval]]

typedef enum {
	pbLapdNetworkSide_user<s(0)(0)(0)>[&]=0,
	pbLapdNetworkSide_network<s(0)(0)(0)>[&]=1
} pbLapdNetworkSide_Tval<s(0)(0)(0)>[&];(D1:pbLapdNetworkSide_Tval:1)[[TYPENAME:pbLapdNetworkSide_Tval]]

typedef enum {
	pbLapdAITS_unconfirmed<s(0)(0)(0)>[&]=0,
	pbLapdAITS_acknowledged<s(0)(0)(0)>[&]=1
} pbLapdAITS_Tval<s(0)(0)(0)>[&];(D1:pbLapdAITS_Tval:1)[[TYPENAME:pbLapdAITS_Tval]]

typedef enum {
	pbIpTunnelByPass_nobypass<s(0)(0)(0)>[&]=0,
	pbIpTunnelByPass_bypass<s(0)(0)(0)>[&]=1
} pbIpTunnelByPass_Tval<s(0)(0)(0)>[&];(D1:pbIpTunnelByPass_Tval:1)[[TYPENAME:pbIpTunnelByPass_Tval]]

typedef enum {
	pbIpTunnelDstMode_ms<s(0)(0)(0)>[&]=0,
	pbIpTunnelDstMode_rs<s(0)(0)(0)>[&]=1
} pbIpTunnelDstMode_Tval<s(0)(0)(0)>[&];(D1:pbIpTunnelDstMode_Tval:1)[[TYPENAME:pbIpTunnelDstMode_Tval]]

typedef enum {
	pbIpTunnelStatus_deactive<s(0)(0)(0)>[&]=0,
	pbIpTunnelStatus_active<s(0)(0)(0)>[&]=1
} pbIpTunnelStatus_Tval<s(0)(0)(0)>[&];(D1:pbIpTunnelStatus_Tval:1)[[TYPENAME:pbIpTunnelStatus_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                             
	int		pbPortNo<s(1)(1)(0)>[&];                                                  
	pbSdhServerType_Tval<s(1)(1)(0)>[T] pbSdhServerType<s(1)(1)(0)>[&];                           
	pbLapdNetworkSide_Tval<s(1)(1)(0)>[T] pbLapdNetworkSide<s(1)(1)(0)>[&];   
	int		pbLapdT200<s(1)(1)(0)>[&];   
	int		pbLapdT203<s(1)(1)(0)>[&];   
	int		pbLapdN200<s(1)(1)(0)>[&];   
	pbLapdAITS_Tval<s(1)(1)(0)>[T] pbLapdAITS<s(1)(1)(0)>[&];   
	int		pbLapdWindow<s(1)(1)(0)>[&];   
	unsigned int	pbIpTunnelSrcIpAddress<s(1)(1)(0)>[&];   
	unsigned int	pbIpTunnelDesIpAddress<s(1)(1)(0)>[&];   
	pbIpTunnelByPass_Tval<s(1)(1)(0)>[T] pbIpTunnelByPass<s(1)(1)(0)>[&];   
	int		pbIpTunnelDstSlot<s(1)(1)(0)>[&];   
	int		pbIpTunnelDstPort<s(1)(1)(0)>[&];   
	pbIpTunnelDstMode_Tval<s(1)(1)(0)>[T] pbIpTunnelDstMode<s(1)(1)(0)>[&];   
	pbIpTunnelStatus_Tval<s(1)(1)(0)>[T] pbIpTunnelStatus<s(1)(1)(0)>[&];   
}MIBpbIpTunnelCfgTable_t<s(0)(0)(0)>[&];(D1:MIBpbIpTunnelCfgTable_t:1)[[TYPENAME:MIBpbIpTunnelCfgTable_t]]























 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbIpTunnelModule_Did<s(0)(0)(0)>[&];(D1:pbIpTunnelModule_Did:0)

   







 




 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbOsiConfigTable_Did<s(0)(0)(0)>[&];(D1:pbOsiConfigTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                   
	int		pbPortNo<s(1)(1)(0)>[&];                                        
	int		pbOsiNetworkSide<s(1)(1)(0)>[&];   
	int		pbOsiT200<s(1)(1)(0)>[&];   
	int		pbOsiT203<s(1)(1)(0)>[&];   
	int		pbOsiN200<s(1)(1)(0)>[&];   
	int		pbOsiAITS<s(1)(1)(0)>[&];   
	int		pbOsiWindow<s(1)(1)(0)>[&];   
	int		pbOsiConfigTimer<s(1)(1)(0)>[&];   
	int		pbOsiTTL<s(1)(1)(0)>[&];   
	char		pbOsiLocalNasp<s(1)(1)(0)>[&][41];   
	char		pbOsiRemoteNasp<s(1)(1)(0)>[&][41];   
	unsigned int	pbOsiSrcIpAddress<s(1)(1)(0)>[&];   
	unsigned int	pbOsiDesIpAddress<s(1)(1)(0)>[&];   
	int		pbOsiIpIfMtu<s(1)(1)(0)>[&];   
}MIBpbOsiConfigTable_t<s(0)(0)(0)>[&];(D1:MIBpbOsiConfigTable_t:1)[[TYPENAME:MIBpbOsiConfigTable_t]]






















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] osiTunnelConfigTable_Did<s(0)(0)(0)>[&];(D1:osiTunnelConfigTable_Did:0)

   
typedef enum {
	osiTunnelStatus_deactive<s(0)(0)(0)>[&]=0,
	osiTunnelStatus_active<s(0)(0)(0)>[&]=1
} osiTunnelStatus_Tval<s(0)(0)(0)>[&];(D1:osiTunnelStatus_Tval:1)[[TYPENAME:osiTunnelStatus_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];                           
	int		pbPortNo<s(1)(1)(0)>[&];                                                
	int		pbSdhServerType<s(1)(1)(0)>[&];                                            
	int		osiTunnelNetworkSide<s(1)(1)(0)>[&];   
	int		osiTunnelT200<s(1)(1)(0)>[&];   
	int		osiTunnelT203<s(1)(1)(0)>[&];   
	int		osiTunnelN200<s(1)(1)(0)>[&];   
	int		osiTunnelAITS<s(1)(1)(0)>[&];   
	int		osiTunnelWindow<s(1)(1)(0)>[&];   
	int		osiTunnelConfigTimer<s(1)(1)(0)>[&];   
	int		osiTunnelTTL<s(1)(1)(0)>[&];   
	char		osiTunnelLocalNasp<s(1)(1)(0)>[&][41];   
	char		osiTunnelRemoteNasp<s(1)(1)(0)>[&][41];   
	unsigned int	osiTunnelSrcIpAddress<s(1)(1)(0)>[&];   
	unsigned int	osiTunnelDesIpAddress<s(1)(1)(0)>[&];   
	int		osiTunnelIpIfMtu<s(1)(1)(0)>[&];   
	osiTunnelStatus_Tval<s(1)(1)(0)>[T] osiTunnelStatus<s(1)(1)(0)>[&];
	unsigned int	osiTunnelIndex<s(1)(1)(0)>[&];   
}MIBosiTunnelConfigTable_t<s(0)(0)(0)>[&];(D1:MIBosiTunnelConfigTable_t:1)[[TYPENAME:MIBosiTunnelConfigTable_t]]

























 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbOsiModule_Did<s(0)(0)(0)>[&];(D1:pbOsiModule_Did:0)

   







 




 



 
extern MIBDid_t<s(0)(0)(0)>[T] epgGroup_Did<s(0)(0)(0)>[&];(D1:epgGroup_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] msspringGroup_Did<s(0)(0)(0)>[&];(D1:msspringGroup_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] mspGroup_Did<s(0)(0)(0)>[&];(D1:mspGroup_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] sncpGroup_Did<s(0)(0)(0)>[&];(D1:sncpGroup_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] mssp4fGroup_Did<s(0)(0)(0)>[&];(D1:mssp4fGroup_Did:0)

   


 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] mssp4fConfigTable_Did<s(0)(0)(0)>[&];(D1:mssp4fConfigTable_Did:0)

   
typedef enum {
	mssp4fProtectMode_normal<s(0)(0)(0)>[&]=1,
	mssp4fProtectMode_transoceanic<s(0)(0)(0)>[&]=2
} mssp4fProtectMode_Tval<s(0)(0)(0)>[&];(D1:mssp4fProtectMode_Tval:1)[[TYPENAME:mssp4fProtectMode_Tval]]

typedef enum {
	mssp4fRingType_none<s(0)(0)(0)>[&]=0,
	mssp4fRingType_stm_1<s(0)(0)(0)>[&]=1,
	mssp4fRingType_stm_4<s(0)(0)(0)>[&]=4,
	mssp4fRingType_stm_16<s(0)(0)(0)>[&]=16,
	mssp4fRingType_stm_64<s(0)(0)(0)>[&]=64
} mssp4fRingType_Tval<s(0)(0)(0)>[&];(D1:mssp4fRingType_Tval:1)[[TYPENAME:mssp4fRingType_Tval]]

typedef struct
{
	unsigned int	mssp4fRingId<s(1)(1)(0)>[&];                                                     
	mssp4fProtectMode_Tval<s(1)(1)(0)>[T] mssp4fProtectMode<s(1)(1)(0)>[&];   
	char		mssp4fRingName<s(1)(1)(0)>[&][64];   
	unsigned int	mssp4fGroupId<s(1)(1)(0)>[&];   
	unsigned int	mssp4fWaitToRestore<s(1)(1)(0)>[&];   
	mssp4fRingType_Tval<s(1)(1)(0)>[T] mssp4fRingType<s(1)(1)(0)>[&];   
	char		mssp4fWestWorkChannelNutInfo<s(1)(1)(0)>[&][64];   
	char		mssp4fEastWorkChannelNutInfo<s(1)(1)(0)>[&][64];   
	TruthValue_Tval<s(1)(1)(0)>[T] mssp4fConfigEnabled<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] mssp4fConfigDeleted<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] mssp4fRingSuspended<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] mssp4fAutoSquelchEnabled<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] mssp4fAutoMappingEnabled<s(1)(1)(0)>[&];   
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] mssp4fWestWorkSlotNum<s(1)(1)(0)>[&];   
	PbPortType_Tval<s(1)(1)(0)>[T] mssp4fWestWorkPortType<s(1)(1)(0)>[&];   
	unsigned int	mssp4fWestWorkPortNum<s(1)(1)(0)>[&];   
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] mssp4fWestProtSlotNum<s(1)(1)(0)>[&];   
	PbPortType_Tval<s(1)(1)(0)>[T] mssp4fWestProtPortType<s(1)(1)(0)>[&];   
	unsigned int	mssp4fWestProtPortNum<s(1)(1)(0)>[&];   
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] mssp4fEastWorkSlotNum<s(1)(1)(0)>[&];   
	PbPortType_Tval<s(1)(1)(0)>[T] mssp4fEastWorkPortType<s(1)(1)(0)>[&];   
	unsigned int	mssp4fEastWorkPortNum<s(1)(1)(0)>[&];   
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] mssp4fEastProtSlotNum<s(1)(1)(0)>[&];   
	PbPortType_Tval<s(1)(1)(0)>[T] mssp4fEastProtPortType<s(1)(1)(0)>[&];   
	unsigned int	mssp4fEastProtPortNum<s(1)(1)(0)>[&];   
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] mssp4fPeerWestWorkSlotNum<s(1)(1)(0)>[&];
	PbPortType_Tval<s(1)(1)(0)>[T] mssp4fPeerWestWorkPortType<s(1)(1)(0)>[&];
	unsigned int	mssp4fPeerWestWorkPortNum<s(1)(1)(0)>[&];
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] mssp4fPeerWestProtSlotNum<s(1)(1)(0)>[&];
	PbPortType_Tval<s(1)(1)(0)>[T] mssp4fPeerWestProtPortType<s(1)(1)(0)>[&];
	unsigned int	mssp4fPeerWestProtPortNum<s(1)(1)(0)>[&];
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] mssp4fPeerEastWorkSlotNum<s(1)(1)(0)>[&];
	PbPortType_Tval<s(1)(1)(0)>[T] mssp4fPeerEastWorkPortType<s(1)(1)(0)>[&];
	unsigned int	mssp4fPeerEastWorkPortNum<s(1)(1)(0)>[&];
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] mssp4fPeerEastProtSlotNum<s(1)(1)(0)>[&];
	PbPortType_Tval<s(1)(1)(0)>[T] mssp4fPeerEastProtPortType<s(1)(1)(0)>[&];
	unsigned int	mssp4fPeerEastProtPortNum<s(1)(1)(0)>[&];
}MIBmssp4fConfigTable_t<s(0)(0)(0)>[&];(D1:MIBmssp4fConfigTable_t:1)[[TYPENAME:MIBmssp4fConfigTable_t]]












































 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] mssp4fTopologyTable_Did<s(0)(0)(0)>[&];(D1:mssp4fTopologyTable_Did:0)

   
typedef struct
{
	unsigned int	mssp4fRingId<s(1)(1)(0)>[&];                          
	unsigned int	mssp4fSumOfNodes<s(1)(1)(0)>[&];
	unsigned int	mssp4fNodeId0<s(1)(1)(0)>[&];
	unsigned int	mssp4fNodeId1<s(1)(1)(0)>[&];
	unsigned int	mssp4fNodeId2<s(1)(1)(0)>[&];
	unsigned int	mssp4fNodeId3<s(1)(1)(0)>[&];
	unsigned int	mssp4fNodeId4<s(1)(1)(0)>[&];
	unsigned int	mssp4fNodeId5<s(1)(1)(0)>[&];
	unsigned int	mssp4fNodeId6<s(1)(1)(0)>[&];
	unsigned int	mssp4fNodeId7<s(1)(1)(0)>[&];
	unsigned int	mssp4fNodeId8<s(1)(1)(0)>[&];
	unsigned int	mssp4fNodeId9<s(1)(1)(0)>[&];
	unsigned int	mssp4fNodeId10<s(1)(1)(0)>[&];
	unsigned int	mssp4fNodeId11<s(1)(1)(0)>[&];
	unsigned int	mssp4fNodeId12<s(1)(1)(0)>[&];
	unsigned int	mssp4fNodeId13<s(1)(1)(0)>[&];
	unsigned int	mssp4fNodeId14<s(1)(1)(0)>[&];
	unsigned int	mssp4fNodeId15<s(1)(1)(0)>[&];
	unsigned int	mssp4fNodeIp0<s(1)(1)(0)>[&];
	unsigned int	mssp4fNodeIp1<s(1)(1)(0)>[&];
	unsigned int	mssp4fNodeIp2<s(1)(1)(0)>[&];
	unsigned int	mssp4fNodeIp3<s(1)(1)(0)>[&];
	unsigned int	mssp4fNodeIp4<s(1)(1)(0)>[&];
	unsigned int	mssp4fNodeIp5<s(1)(1)(0)>[&];
	unsigned int	mssp4fNodeIp6<s(1)(1)(0)>[&];
	unsigned int	mssp4fNodeIp7<s(1)(1)(0)>[&];
	unsigned int	mssp4fNodeIp8<s(1)(1)(0)>[&];
	unsigned int	mssp4fNodeIp9<s(1)(1)(0)>[&];
	unsigned int	mssp4fNodeIp10<s(1)(1)(0)>[&];
	unsigned int	mssp4fNodeIp11<s(1)(1)(0)>[&];
	unsigned int	mssp4fNodeIp12<s(1)(1)(0)>[&];
	unsigned int	mssp4fNodeIp13<s(1)(1)(0)>[&];
	unsigned int	mssp4fNodeIp14<s(1)(1)(0)>[&];
	unsigned int	mssp4fNodeIp15<s(1)(1)(0)>[&];
}MIBmssp4fTopologyTable_t<s(0)(0)(0)>[&];(D1:MIBmssp4fTopologyTable_t:1)[[TYPENAME:MIBmssp4fTopologyTable_t]]









































 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] mssp4fCommandTable_Did<s(0)(0)(0)>[&];(D1:mssp4fCommandTable_Did:0)

   
typedef enum {
	mssp4fCommandCurrentSide_west<s(0)(0)(0)>[&]=0,
	mssp4fCommandCurrentSide_east<s(0)(0)(0)>[&]=1
} mssp4fCommandCurrentSide_Tval<s(0)(0)(0)>[&];(D1:mssp4fCommandCurrentSide_Tval:1)[[TYPENAME:mssp4fCommandCurrentSide_Tval]]

typedef enum {
	mssp4fCommand_exerciseRing<s(0)(0)(0)>[&]=3,
	mssp4fCommand_exerciseSpan<s(0)(0)(0)>[&]=4,
	mssp4fCommand_manualSwitchRing<s(0)(0)(0)>[&]=6,
	mssp4fCommand_manualSwitchSpan<s(0)(0)(0)>[&]=7,
	mssp4fCommand_forcedSwitchRing<s(0)(0)(0)>[&]=13,
	mssp4fCommand_forcedSwitchSpan<s(0)(0)(0)>[&]=14,
	mssp4fCommand_lockoutProtection<s(0)(0)(0)>[&]=15,
	mssp4fCommand_clear<s(0)(0)(0)>[&]=21,
	mssp4fCommand_noCommand<s(0)(0)(0)>[&]=23
} mssp4fCommand_Tval<s(0)(0)(0)>[&];(D1:mssp4fCommand_Tval:1)[[TYPENAME:mssp4fCommand_Tval]]

typedef struct
{
	unsigned int	mssp4fRingId<s(1)(1)(0)>[&];                                          
	mssp4fCommandCurrentSide_Tval<s(1)(1)(0)>[T] mssp4fCommandCurrentSide<s(1)(1)(0)>[&];             
	mssp4fCommand_Tval<s(1)(1)(0)>[T] mssp4fCommand<s(1)(1)(0)>[&];
	char		mssp4fLastCommandStatus<s(1)(1)(0)>[&][64];   
}MIBmssp4fCommandTable_t<s(0)(0)(0)>[&];(D1:MIBmssp4fCommandTable_t:1)[[TYPENAME:MIBmssp4fCommandTable_t]]











 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] mssp4fNodeStatusTable_Did<s(0)(0)(0)>[&];(D1:mssp4fNodeStatusTable_Did:0)

   
typedef enum {
	mssp4fNodeAgentState_init<s(0)(0)(0)>[&]=0,
	mssp4fNodeAgentState_ready<s(0)(0)(0)>[&]=1,
	mssp4fNodeAgentState_suspend<s(0)(0)(0)>[&]=2
} mssp4fNodeAgentState_Tval<s(0)(0)(0)>[&];(D1:mssp4fNodeAgentState_Tval:1)[[TYPENAME:mssp4fNodeAgentState_Tval]]

typedef enum {
	mssp4fNodeState_idle<s(0)(0)(0)>[&]=0,
	mssp4fNodeState_passthough<s(0)(0)(0)>[&]=1,
	mssp4fNodeState_switching<s(0)(0)(0)>[&]=2,
	mssp4fNodeState_isolated<s(0)(0)(0)>[&]=3
} mssp4fNodeState_Tval<s(0)(0)(0)>[&];(D1:mssp4fNodeState_Tval:1)[[TYPENAME:mssp4fNodeState_Tval]]

typedef enum {
	mssp4fNodeCurrentSide_west<s(0)(0)(0)>[&]=0,
	mssp4fNodeCurrentSide_east<s(0)(0)(0)>[&]=1
} mssp4fNodeCurrentSide_Tval<s(0)(0)(0)>[&];(D1:mssp4fNodeCurrentSide_Tval:1)[[TYPENAME:mssp4fNodeCurrentSide_Tval]]

typedef enum {
	mssp4fNodeCurrentReq_idle<s(0)(0)(0)>[&]=0,
	mssp4fNodeCurrentReq_bridge<s(0)(0)(0)>[&]=1,
	mssp4fNodeCurrentReq_bridgeAndSwitch<s(0)(0)(0)>[&]=2,
	mssp4fNodeCurrentReq_passthrough<s(0)(0)(0)>[&]=3
} mssp4fNodeCurrentReq_Tval<s(0)(0)(0)>[&];(D1:mssp4fNodeCurrentReq_Tval:1)[[TYPENAME:mssp4fNodeCurrentReq_Tval]]

typedef enum {
	mssp4fNodeCurrentSrc_kByte<s(0)(0)(0)>[&]=0,
	mssp4fNodeCurrentSrc_line<s(0)(0)(0)>[&]=1,
	mssp4fNodeCurrentSrc_external<s(0)(0)(0)>[&]=2
} mssp4fNodeCurrentSrc_Tval<s(0)(0)(0)>[&];(D1:mssp4fNodeCurrentSrc_Tval:1)[[TYPENAME:mssp4fNodeCurrentSrc_Tval]]

typedef enum {
	mssp4fNodeKExpressMode_autoLocal<s(0)(0)(0)>[&]=0,
	mssp4fNodeKExpressMode_autoExpress<s(0)(0)(0)>[&]=1,
	mssp4fNodeKExpressMode_forceExpress<s(0)(0)(0)>[&]=2,
	mssp4fNodeKExpressMode_forceLocal<s(0)(0)(0)>[&]=3
} mssp4fNodeKExpressMode_Tval<s(0)(0)(0)>[&];(D1:mssp4fNodeKExpressMode_Tval:1)[[TYPENAME:mssp4fNodeKExpressMode_Tval]]

typedef struct
{
	unsigned int	mssp4fRingId<s(1)(1)(0)>[&];                                        
	mssp4fNodeAgentState_Tval<s(1)(1)(0)>[T] mssp4fNodeAgentState<s(1)(1)(0)>[&];
	mssp4fNodeState_Tval<s(1)(1)(0)>[T] mssp4fNodeState<s(1)(1)(0)>[&];   
	mssp4fNodeCurrentSide_Tval<s(1)(1)(0)>[T] mssp4fNodeCurrentSide<s(1)(1)(0)>[&];
	mssp4fNodeCurrentReq_Tval<s(1)(1)(0)>[T] mssp4fNodeCurrentReq<s(1)(1)(0)>[&];
	mssp4fNodeCurrentSrc_Tval<s(1)(1)(0)>[T] mssp4fNodeCurrentSrc<s(1)(1)(0)>[&];
	mssp4fNodeKExpressMode_Tval<s(1)(1)(0)>[T] mssp4fNodeKExpressMode<s(1)(1)(0)>[&];
	Mssp4fSwitchCommand_Tval<s(1)(1)(0)>[T] mssp4fWestSwitchCommand<s(1)(1)(0)>[&];
	Mssp4fLineRequest_Tval<s(1)(1)(0)>[T] mssp4fWestLineReq<s(1)(1)(0)>[&];
	Mssp4fSwitchCommand_Tval<s(1)(1)(0)>[T] mssp4fWestLastSwitchCmd<s(1)(1)(0)>[&];
	int		mssp4fWestSwitchStatus_len<s(1)(1)(0)>[&];
	char		mssp4fWestSwitchStatus<s(1)(1)(0)>[&][64];   
	unsigned int	mssp4fWestK1byteInput<s(1)(1)(0)>[&];
	unsigned int	mssp4fWestK2byteInput<s(1)(1)(0)>[&];
	unsigned int	mssp4fWestK1byteOutput<s(1)(1)(0)>[&];
	unsigned int	mssp4fWestK2byteOutput<s(1)(1)(0)>[&];
	Mssp4fSwitchCommand_Tval<s(1)(1)(0)>[T] mssp4fEastSwitchCommand<s(1)(1)(0)>[&];
	Mssp4fLineRequest_Tval<s(1)(1)(0)>[T] mssp4fEastLineReq<s(1)(1)(0)>[&];
	Mssp4fSwitchCommand_Tval<s(1)(1)(0)>[T] mssp4fEastLastSwitchCmd<s(1)(1)(0)>[&];
	int		mssp4fEastSwitchStatus_len<s(1)(1)(0)>[&];
	char		mssp4fEastSwitchStatus<s(1)(1)(0)>[&][64];   
	unsigned int	mssp4fEastK1byteInput<s(1)(1)(0)>[&];
	unsigned int	mssp4fEastK2byteInput<s(1)(1)(0)>[&];
	unsigned int	mssp4fEastK1byteOutput<s(1)(1)(0)>[&];
	unsigned int	mssp4fEastK2byteOutput<s(1)(1)(0)>[&];
	unsigned int	mssp4fPassNodeId<s(1)(1)(0)>[&];
}MIBmssp4fNodeStatusTable_t<s(0)(0)(0)>[&];(D1:MIBmssp4fNodeStatusTable_t:1)[[TYPENAME:MIBmssp4fNodeStatusTable_t]]































 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] mssp4fAutoMappingTable_Did<s(0)(0)(0)>[&];(D1:mssp4fAutoMappingTable_Did:0)

   
typedef struct
{
	unsigned int	mssp4fRingId<s(1)(1)(0)>[&];                                                
	unsigned int	mssp4fNodeId<s(1)(1)(0)>[&];                                                
	int		mssp4fWestWorkMappingString_len<s(1)(1)(0)>[&];
	char		mssp4fWestWorkMappingString<s(1)(1)(0)>[&][192];
	int		mssp4fEastWorkMappingString_len<s(1)(1)(0)>[&];
	char		mssp4fEastWorkMappingString<s(1)(1)(0)>[&][192];
	RowStatus_Tval<s(1)(1)(0)>[T] mssp4fAutomappingRowStatus<s(1)(1)(0)>[&];
}MIBmssp4fAutoMappingTable_t<s(0)(0)(0)>[&];(D1:MIBmssp4fAutoMappingTable_t:1)[[TYPENAME:MIBmssp4fAutoMappingTable_t]]












 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] mssp4fXcTable_Did<s(0)(0)(0)>[&];(D1:mssp4fXcTable_Did:0)

   
typedef enum {
	mssp4fXcSide_west<s(0)(0)(0)>[&]=0,
	mssp4fXcSide_east<s(0)(0)(0)>[&]=1,
	mssp4fXcSide_both<s(0)(0)(0)>[&]=2
} mssp4fXcSide_Tval<s(0)(0)(0)>[&];(D1:mssp4fXcSide_Tval:1)[[TYPENAME:mssp4fXcSide_Tval]]

typedef enum {
	mssp4fXcOrder_au4clear<s(0)(0)(0)>[&]=0,
	mssp4fXcOrder_au44c<s(0)(0)(0)>[&]=1,
	mssp4fXcOrder_au416c<s(0)(0)(0)>[&]=2,
	mssp4fXcOrder_au464c<s(0)(0)(0)>[&]=3
} mssp4fXcOrder_Tval<s(0)(0)(0)>[&];(D1:mssp4fXcOrder_Tval:1)[[TYPENAME:mssp4fXcOrder_Tval]]

typedef enum {
	mssp4fXcType_adddrop<s(0)(0)(0)>[&]=0,
	mssp4fXcType_passthrough<s(0)(0)(0)>[&]=1,
	mssp4fXcType_nonrelated<s(0)(0)(0)>[&]=2,
	mssp4fXcType_invalid<s(0)(0)(0)>[&]=3
} mssp4fXcType_Tval<s(0)(0)(0)>[&];(D1:mssp4fXcType_Tval:1)[[TYPENAME:mssp4fXcType_Tval]]

typedef struct
{
	unsigned int	mssp4fRingId<s(1)(1)(0)>[&];                          
	unsigned int	mssp4fNodeId<s(1)(1)(0)>[&];                          
	mssp4fXcSide_Tval<s(1)(1)(0)>[T] mssp4fXcSide<s(1)(1)(0)>[&];                     
	unsigned int	mssp4fXcTimeSlot<s(1)(1)(0)>[&];                      
	mssp4fXcOrder_Tval<s(1)(1)(0)>[T] mssp4fXcOrder<s(1)(1)(0)>[&];
	mssp4fXcType_Tval<s(1)(1)(0)>[T] mssp4fXcType<s(1)(1)(0)>[&];
}MIBmssp4fXcTable_t<s(0)(0)(0)>[&];(D1:MIBmssp4fXcTable_t:1)[[TYPENAME:MIBmssp4fXcTable_t]]













 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbSncpConfigTable_Did<s(0)(0)(0)>[&];(D1:pbSncpConfigTable_Did:0)

   
typedef struct
{
	PbXcCapacity_Tval<s(1)(1)(0)>[T] pbSncpTPType<s(1)(1)(0)>[&];                                            
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSncpWorkChSlotNum<s(1)(1)(0)>[&];                                 
	PbPortType_Tval<s(1)(1)(0)>[T] pbSncpWorkChPortType<s(1)(1)(0)>[&];                                   
	int		pbSncpWorkChPortNum<s(1)(1)(0)>[&];                                                  
	int		pbSncpWorkSource<s(1)(1)(0)>[&];                                                     
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSncpProtectChSlotNum<s(1)(1)(0)>[&];                              
	PbPortType_Tval<s(1)(1)(0)>[T] pbSncpProtectChPortType<s(1)(1)(0)>[&];                                
	int		pbSncpProtectChPortNum<s(1)(1)(0)>[&];                                               
	int		pbSncpProtectSource<s(1)(1)(0)>[&];                                                  
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbSncpSrcOrDstSlotNum<s(1)(1)(0)>[&];                               
	PbPortType_Tval<s(1)(1)(0)>[T] pbSncpSrcOrDstPortType<s(1)(1)(0)>[&];                                    
	int		pbSncpSrcOrDstPortNum<s(1)(1)(0)>[&];                                                
	int		pbSncpSrcOrDstSource<s(1)(1)(0)>[&];                                                 
	PbSNCPSignalDirection_Tval<s(1)(1)(0)>[T] pbSncpSignalDircetion<s(1)(1)(0)>[&];                          
	int		pbSncpGroupId<s(1)(1)(0)>[&];   
	PbSNCPChannelState_Tval<s(1)(1)(0)>[T] pbSncpWorkChState<s(1)(1)(0)>[&];   
	PbSNCPExternalCmd_Tval<s(1)(1)(0)>[T] pbSncpExternalCmd<s(1)(1)(0)>[&];   
	PbSNCPExCmdRslt_Tval<s(1)(1)(0)>[T] pbSncpExCmdRslt<s(1)(1)(0)>[&];   
	PbSNCPCurrentReq_Tval<s(1)(1)(0)>[T] pbSncpCurSwitchReq<s(1)(1)(0)>[&];   
	PbSNCPSwitchReason_Tval<s(1)(1)(0)>[T] pbSncpSwitchReason<s(1)(1)(0)>[&];   
	unsigned int	pbSncpHoldOffTime<s(1)(1)(0)>[&];   
	PbSNCPRestoreMode_Tval<s(1)(1)(0)>[T] pbSncpRestoreMode<s(1)(1)(0)>[&];   
	unsigned int	pbSncpWTR<s(1)(1)(0)>[&];   
	PBSNCPSignalState_Tval<s(1)(1)(0)>[T] pbSncpWorkSignalState<s(1)(1)(0)>[&];   
	PBSNCPSignalState_Tval<s(1)(1)(0)>[T] pbSncpProtectSignalState<s(1)(1)(0)>[&];   
	RowStatus_Tval<s(1)(1)(0)>[T] pbSncpRowStatus<s(1)(1)(0)>[&];   
	char		pbSncpLable<s(1)(1)(0)>[&][64];   
	PBSNCPAddRslt_Tval<s(1)(1)(0)>[T] pbSncpAddRslt<s(1)(1)(0)>[&];   
	unsigned int	pbDNIId<s(1)(1)(0)>[&];   
	PBSNCPIntrusive_Tval<s(1)(1)(0)>[T] pbSncpIntrusive<s(1)(1)(0)>[&];   
	int		pbSncpWorkGmplsVcNumber<s(1)(1)(0)>[&];   
	char		pbSncpWorkGmplsCallName<s(1)(1)(0)>[&][255];   
	int		pbSncpProtectGmplsVcNumber<s(1)(1)(0)>[&];   
	char		pbSncpProtectGmplsCallName<s(1)(1)(0)>[&][255];   
	PBSNCPWorkorProtToCC_Tval<s(1)(1)(0)>[T] pbSncpWorkorProtToCC<s(1)(1)(0)>[&];   
	PbSncpCircuitDirection_Tval<s(1)(1)(0)>[T] pbSncpDirection<s(1)(1)(0)>[&];   
	PbSncpFrom_Tval<s(1)(1)(0)>[T] pbSncpFrom<s(1)(1)(0)>[&];   
	PbGmplsSncpDirection_Tval<s(1)(1)(0)>[T] pbGmplsSncpDirection<s(1)(1)(0)>[&];   
	PBSNCPAction_Tval<s(1)(1)(0)>[T] pbSncpAction<s(1)(1)(0)>[&];   
}MIBpbSncpConfigTable_t<s(0)(0)(0)>[&];(D1:MIBpbSncpConfigTable_t:1)[[TYPENAME:MIBpbSncpConfigTable_t]]














































 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbSncpStateTable_Did<s(0)(0)(0)>[&];(D1:pbSncpStateTable_Did:0)

   
typedef struct
{
	int		pbSncpStateLineId<s(1)(1)(0)>[&];                                                    
	char		pbSncpDetailedStateString1<s(1)(1)(0)>[&][255];   
	char		pbSncpDetailedStateString2<s(1)(1)(0)>[&][255];   
	char		pbSncpDetailedStateString3<s(1)(1)(0)>[&][255];   
	char		pbSncpDetailedStateString4<s(1)(1)(0)>[&][255];   
}MIBpbSncpStateTable_t<s(0)(0)(0)>[&];(D1:MIBpbSncpStateTable_t:1)[[TYPENAME:MIBpbSncpStateTable_t]]












 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbDpnpConfigTable_Did<s(0)(0)(0)>[&];(D1:pbDpnpConfigTable_Did:0)

   
typedef struct
{
	PbXcCapacity_Tval<s(1)(1)(0)>[T] pbDpnpTPType<s(1)(1)(0)>[&];                                         
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbDpnpDstSlotNum<s(1)(1)(0)>[&];                                 
	PbPortType_Tval<s(1)(1)(0)>[T] pbDpnpDstPortType<s(1)(1)(0)>[&];                                      
	int		pbDpnpDstPortNum<s(1)(1)(0)>[&];                                                  
	int		pbDpnpDstSource<s(1)(1)(0)>[&];                                                   
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbVSncpWorkChSlotNum<s(1)(1)(0)>[&];                             
	PbPortType_Tval<s(1)(1)(0)>[T] pbVSncpWorkChPortType<s(1)(1)(0)>[&];                                  
	int		pbVSncpWorkChPortNum<s(1)(1)(0)>[&];                                              
	int		pbVSncpWorkSource<s(1)(1)(0)>[&];                                                 
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbVSncpProtectChSlotNum<s(1)(1)(0)>[&];                          
	PbPortType_Tval<s(1)(1)(0)>[T] pbVSncpProtectChPortType<s(1)(1)(0)>[&];                               
	int		pbVSncpProtectChPortNum<s(1)(1)(0)>[&];                                           
	int		pbVSncpProtectSource<s(1)(1)(0)>[&];                                              
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbVMsspringWorkChSlotNum<s(1)(1)(0)>[&];                         
	PbPortType_Tval<s(1)(1)(0)>[T] pbVMsspringWorkChPortType<s(1)(1)(0)>[&];                              
	int		pbVMsspringWorkChPortNum<s(1)(1)(0)>[&];                                          
	int		pbVMsspringWorkSource<s(1)(1)(0)>[&];                                             
	PbSNCPSignalDirection_Tval<s(1)(1)(0)>[T] pbDpnpSignalDircetion<s(1)(1)(0)>[&];                       
	int		pbDpnpGroupId<s(1)(1)(0)>[&];
	PbSNCPChannelState_Tval<s(1)(1)(0)>[T] pbDpnpWorkChState<s(1)(1)(0)>[&];
	PbSNCPExternalCmd_Tval<s(1)(1)(0)>[T] pbDpnpExternalCmd<s(1)(1)(0)>[&];
	PbSNCPExCmdRslt_Tval<s(1)(1)(0)>[T] pbDpnpExCmdRslt<s(1)(1)(0)>[&];
	PbSNCPCurrentReq_Tval<s(1)(1)(0)>[T] pbDpnpCurSwitchReq<s(1)(1)(0)>[&];
	PbSNCPSwitchReason_Tval<s(1)(1)(0)>[T] pbDpnpSwitchReason<s(1)(1)(0)>[&];
	unsigned int	pbDpnpHoldOffTime<s(1)(1)(0)>[&];
	PbSNCPRestoreMode_Tval<s(1)(1)(0)>[T] pbDpnpRestoreMode<s(1)(1)(0)>[&];
	unsigned int	pbDpnpWTR<s(1)(1)(0)>[&];
	PBSNCPSignalState_Tval<s(1)(1)(0)>[T] pbDpnpWorkSignalState<s(1)(1)(0)>[&];
	PBSNCPSignalState_Tval<s(1)(1)(0)>[T] pbDpnpProtectSignalState<s(1)(1)(0)>[&];
	PBSNCPSignalState_Tval<s(1)(1)(0)>[T] pbDpnpVMsspringSignalState<s(1)(1)(0)>[&];
	RowStatus_Tval<s(1)(1)(0)>[T] pbDpnpRowStatus<s(1)(1)(0)>[&];
	char		pbDpnpLable<s(1)(1)(0)>[&][64];
	PBSNCPAddRslt_Tval<s(1)(1)(0)>[T] pbDpnpAddRslt<s(1)(1)(0)>[&];
	unsigned int	pbDpnpDNIId<s(1)(1)(0)>[&];
	PBSNCPIntrusive_Tval<s(1)(1)(0)>[T] pbDpnpIntrusive<s(1)(1)(0)>[&];
	PbSncpCircuitDirection_Tval<s(1)(1)(0)>[T] pbDpnpDirection<s(1)(1)(0)>[&];
	PbSncpFrom_Tval<s(1)(1)(0)>[T] pbDpnpFrom<s(1)(1)(0)>[&];
	PbDpnpSwitchEvent_Tval<s(1)(1)(0)>[T] pbDpnpSwitchEvent<s(1)(1)(0)>[&];
	PbGmplsSncpDirection_Tval<s(1)(1)(0)>[T] pbGmplsDpnpDirection<s(1)(1)(0)>[&];
}MIBpbDpnpConfigTable_t<s(0)(0)(0)>[&];(D1:MIBpbDpnpConfigTable_t:1)[[TYPENAME:MIBpbDpnpConfigTable_t]]














































 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbDpnpStateTable_Did<s(0)(0)(0)>[&];(D1:pbDpnpStateTable_Did:0)

   
typedef struct
{
	int		pbDpnpStateLineId<s(1)(1)(0)>[&];                                                 
	char		pbDpnpDetailedStateString1<s(1)(1)(0)>[&][255];
	char		pbDpnpDetailedStateString2<s(1)(1)(0)>[&][255];
	char		pbDpnpDetailedStateString3<s(1)(1)(0)>[&][255];
	char		pbDpnpDetailedStateString4<s(1)(1)(0)>[&][255];
}MIBpbDpnpStateTable_t<s(0)(0)(0)>[&];(D1:MIBpbDpnpStateTable_t:1)[[TYPENAME:MIBpbDpnpStateTable_t]]












 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbSncpExtendParaGroup_Did<s(0)(0)(0)>[&];(D1:pbSncpExtendParaGroup_Did:0)

   
typedef struct
{
	unsigned int	pbLoSncpWTR<s(1)(1)(0)>[&];
	unsigned int	pbLoSncpHoldOffTime<s(1)(1)(0)>[&];
}MIBpbSncpExtendParaGroup_t<s(0)(0)(0)>[&];(D1:MIBpbSncpExtendParaGroup_t:1)[[TYPENAME:MIBpbSncpExtendParaGroup_t]]







 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbMspConfigTable_Did<s(0)(0)(0)>[&];(D1:pbMspConfigTable_Did:0)

   
typedef struct
{
	PbPortType_Tval<s(1)(1)(0)>[T] pbMspGroupActPortType<s(1)(1)(0)>[&];                                
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbMspProtectChSlotNum<s(1)(1)(0)>[&];                             
	int		pbMspProtectChPortNum<s(1)(1)(0)>[&];                                              
	PbPortType_Tval<s(1)(1)(0)>[T] pbMspProtectChPortType<s(1)(1)(0)>[&];
	PBMSPSignalState_Tval<s(1)(1)(0)>[T] pbMspProtectChSignalState<s(1)(1)(0)>[&];
	int		pbMspGroupId<s(1)(1)(0)>[&];   
	PBMSPType_Tval<s(1)(1)(0)>[T] pbMspType<s(1)(1)(0)>[&];   
	PbMSPSignalDirection_Tval<s(1)(1)(0)>[T] pbMspSignalDircetion<s(1)(1)(0)>[&];   
	PbMSPRestoreMode_Tval<s(1)(1)(0)>[T] pbMspRestoreMode<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbMspExTrafficEnable<s(1)(1)(0)>[&];
	TruthValue_Tval<s(1)(1)(0)>[T] pbMspEnable<s(1)(1)(0)>[&];
	PbMSPExternalCmd_Tval<s(1)(1)(0)>[T] pbMspExternalCmd<s(1)(1)(0)>[&];   
	PbMspChNumberType_Tval<s(1)(1)(0)>[T] pbMspExtCmdParam<s(1)(1)(0)>[&];
	PbMSPExCmdRslt_Tval<s(1)(1)(0)>[T] pbMspExCmdRslt<s(1)(1)(0)>[&];   
	PbMspChNumberType_Tval<s(1)(1)(0)>[T] pbMspSwitchState<s(1)(1)(0)>[&];
	PbMSPCurrentReq_Tval<s(1)(1)(0)>[T] pbMspCurSwitchReq<s(1)(1)(0)>[&];   
	PbMSPSwitchReason_Tval<s(1)(1)(0)>[T] pbMspSwitchReason<s(1)(1)(0)>[&];   
	unsigned int	pbMspWTR<s(1)(1)(0)>[&];   
	int		pbMspWorkChNum<s(1)(1)(0)>[&];
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbMspWorkCh1SlotNum<s(1)(1)(0)>[&];
	int		pbMspWorkCh1PortNum<s(1)(1)(0)>[&];
	PbPortType_Tval<s(1)(1)(0)>[T] pbMspWorkCh1PortType<s(1)(1)(0)>[&];
	PBMSPSignalState_Tval<s(1)(1)(0)>[T] pbMspWorkCh1SignalState<s(1)(1)(0)>[&];
	PBMSPChPriState_Tval<s(1)(1)(0)>[T] pbMspWorkCh1PriState<s(1)(1)(0)>[&];
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbMspWorkCh2SlotNum<s(1)(1)(0)>[&];
	int		pbMspWorkCh2PortNum<s(1)(1)(0)>[&];
	PbPortType_Tval<s(1)(1)(0)>[T] pbMspWorkCh2PortType<s(1)(1)(0)>[&];
	PBMSPSignalState_Tval<s(1)(1)(0)>[T] pbMspWorkCh2SignalState<s(1)(1)(0)>[&];
	PBMSPChPriState_Tval<s(1)(1)(0)>[T] pbMspWorkCh2PriState<s(1)(1)(0)>[&];
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbMspWorkCh3SlotNum<s(1)(1)(0)>[&];
	int		pbMspWorkCh3PortNum<s(1)(1)(0)>[&];
	PbPortType_Tval<s(1)(1)(0)>[T] pbMspWorkCh3PortType<s(1)(1)(0)>[&];
	PBMSPSignalState_Tval<s(1)(1)(0)>[T] pbMspWorkCh3SignalState<s(1)(1)(0)>[&];
	PBMSPChPriState_Tval<s(1)(1)(0)>[T] pbMspWorkCh3PriState<s(1)(1)(0)>[&];
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbMspWorkCh4SlotNum<s(1)(1)(0)>[&];
	int		pbMspWorkCh4PortNum<s(1)(1)(0)>[&];
	PbPortType_Tval<s(1)(1)(0)>[T] pbMspWorkCh4PortType<s(1)(1)(0)>[&];
	PBMSPSignalState_Tval<s(1)(1)(0)>[T] pbMspWorkCh4SignalState<s(1)(1)(0)>[&];
	PBMSPChPriState_Tval<s(1)(1)(0)>[T] pbMspWorkCh4PriState<s(1)(1)(0)>[&];
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbMspWorkCh5SlotNum<s(1)(1)(0)>[&];
	int		pbMspWorkCh5PortNum<s(1)(1)(0)>[&];
	PbPortType_Tval<s(1)(1)(0)>[T] pbMspWorkCh5PortType<s(1)(1)(0)>[&];
	PBMSPSignalState_Tval<s(1)(1)(0)>[T] pbMspWorkCh5SignalState<s(1)(1)(0)>[&];
	PBMSPChPriState_Tval<s(1)(1)(0)>[T] pbMspWorkCh5PriState<s(1)(1)(0)>[&];
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbMspWorkCh6SlotNum<s(1)(1)(0)>[&];
	int		pbMspWorkCh6PortNum<s(1)(1)(0)>[&];
	PbPortType_Tval<s(1)(1)(0)>[T] pbMspWorkCh6PortType<s(1)(1)(0)>[&];
	PBMSPSignalState_Tval<s(1)(1)(0)>[T] pbMspWorkCh6SignalState<s(1)(1)(0)>[&];
	PBMSPChPriState_Tval<s(1)(1)(0)>[T] pbMspWorkCh6PriState<s(1)(1)(0)>[&];
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbMspWorkCh7SlotNum<s(1)(1)(0)>[&];
	int		pbMspWorkCh7PortNum<s(1)(1)(0)>[&];
	PbPortType_Tval<s(1)(1)(0)>[T] pbMspWorkCh7PortType<s(1)(1)(0)>[&];
	PBMSPSignalState_Tval<s(1)(1)(0)>[T] pbMspWorkCh7SignalState<s(1)(1)(0)>[&];
	PBMSPChPriState_Tval<s(1)(1)(0)>[T] pbMspWorkCh7PriState<s(1)(1)(0)>[&];
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbMspWorkCh8SlotNum<s(1)(1)(0)>[&];
	int		pbMspWorkCh8PortNum<s(1)(1)(0)>[&];
	PbPortType_Tval<s(1)(1)(0)>[T] pbMspWorkCh8PortType<s(1)(1)(0)>[&];
	PBMSPSignalState_Tval<s(1)(1)(0)>[T] pbMspWorkCh8SignalState<s(1)(1)(0)>[&];
	PBMSPChPriState_Tval<s(1)(1)(0)>[T] pbMspWorkCh8PriState<s(1)(1)(0)>[&];
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbMspWorkCh9SlotNum<s(1)(1)(0)>[&];
	int		pbMspWorkCh9PortNum<s(1)(1)(0)>[&];
	PbPortType_Tval<s(1)(1)(0)>[T] pbMspWorkCh9PortType<s(1)(1)(0)>[&];
	PBMSPSignalState_Tval<s(1)(1)(0)>[T] pbMspWorkCh9SignalState<s(1)(1)(0)>[&];
	PBMSPChPriState_Tval<s(1)(1)(0)>[T] pbMspWorkCh9PriState<s(1)(1)(0)>[&];
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbMspWorkCh10SlotNum<s(1)(1)(0)>[&];
	int		pbMspWorkCh10PortNum<s(1)(1)(0)>[&];
	PbPortType_Tval<s(1)(1)(0)>[T] pbMspWorkCh10PortType<s(1)(1)(0)>[&];
	PBMSPSignalState_Tval<s(1)(1)(0)>[T] pbMspWorkCh10SignalState<s(1)(1)(0)>[&];
	PBMSPChPriState_Tval<s(1)(1)(0)>[T] pbMspWorkCh10PriState<s(1)(1)(0)>[&];
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbMspWorkCh11SlotNum<s(1)(1)(0)>[&];
	int		pbMspWorkCh11PortNum<s(1)(1)(0)>[&];
	PbPortType_Tval<s(1)(1)(0)>[T] pbMspWorkCh11PortType<s(1)(1)(0)>[&];
	PBMSPSignalState_Tval<s(1)(1)(0)>[T] pbMspWorkCh11SignalState<s(1)(1)(0)>[&];
	PBMSPChPriState_Tval<s(1)(1)(0)>[T] pbMspWorkCh11PriState<s(1)(1)(0)>[&];
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbMspWorkCh12SlotNum<s(1)(1)(0)>[&];
	int		pbMspWorkCh12PortNum<s(1)(1)(0)>[&];
	PbPortType_Tval<s(1)(1)(0)>[T] pbMspWorkCh12PortType<s(1)(1)(0)>[&];
	PBMSPSignalState_Tval<s(1)(1)(0)>[T] pbMspWorkCh12SignalState<s(1)(1)(0)>[&];
	PBMSPChPriState_Tval<s(1)(1)(0)>[T] pbMspWorkCh12PriState<s(1)(1)(0)>[&];
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbMspWorkCh13SlotNum<s(1)(1)(0)>[&];
	int		pbMspWorkCh13PortNum<s(1)(1)(0)>[&];
	PbPortType_Tval<s(1)(1)(0)>[T] pbMspWorkCh13PortType<s(1)(1)(0)>[&];
	PBMSPSignalState_Tval<s(1)(1)(0)>[T] pbMspWorkCh13SignalState<s(1)(1)(0)>[&];
	PBMSPChPriState_Tval<s(1)(1)(0)>[T] pbMspWorkCh13PriState<s(1)(1)(0)>[&];
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbMspWorkCh14SlotNum<s(1)(1)(0)>[&];
	int		pbMspWorkCh14PortNum<s(1)(1)(0)>[&];
	PbPortType_Tval<s(1)(1)(0)>[T] pbMspWorkCh14PortType<s(1)(1)(0)>[&];
	PBMSPSignalState_Tval<s(1)(1)(0)>[T] pbMspWorkCh14SignalState<s(1)(1)(0)>[&];
	PBMSPChPriState_Tval<s(1)(1)(0)>[T] pbMspWorkCh14PriState<s(1)(1)(0)>[&];
	TruthValue_Tval<s(1)(1)(0)>[T] pbMspK2Bit5Mismatch<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbMspK1Bit1to4Mismatch<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbMspK1Bit5to8Mismatch<s(1)(1)(0)>[&];   
	int		pbMspReceiveK1<s(1)(1)(0)>[&];   
	int		pbMspReceiveK2<s(1)(1)(0)>[&];   
	int		pbMspSendoutK1<s(1)(1)(0)>[&];   
	int		pbMspSendoutK2<s(1)(1)(0)>[&];   
	RowStatus_Tval<s(1)(1)(0)>[T] pbMspRowStatus<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbMspFreeze<s(1)(1)(0)>[&];
	char		pbMspLable<s(1)(1)(0)>[&][255];   
}MIBpbMspConfigTable_t<s(0)(0)(0)>[&];(D1:MIBpbMspConfigTable_t:1)[[TYPENAME:MIBpbMspConfigTable_t]]










































































































 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbMSMConfigTable_Did<s(0)(0)(0)>[&];(D1:pbMSMConfigTable_Did:0)

   
typedef enum {
	pbMSMProtectMode_none<s(0)(0)(0)>[&]=1,
	pbMSMProtectMode_msspring<s(0)(0)(0)>[&]=2,
	pbMSMProtectMode_ulsr<s(0)(0)(0)>[&]=3
} pbMSMProtectMode_Tval<s(0)(0)(0)>[&];(D1:pbMSMProtectMode_Tval:1)[[TYPENAME:pbMSMProtectMode_Tval]]

typedef enum {
	pbMSMConfigSdBerThreshold_ber10_5<s(0)(0)(0)>[&]=1,
	pbMSMConfigSdBerThreshold_ber10_6<s(0)(0)(0)>[&]=2,
	pbMSMConfigSdBerThreshold_ber10_7<s(0)(0)(0)>[&]=3,
	pbMSMConfigSdBerThreshold_ber10_8<s(0)(0)(0)>[&]=4,
	pbMSMConfigSdBerThreshold_ber10_9<s(0)(0)(0)>[&]=5,
	pbMSMConfigSdBerThreshold_global_sd<s(0)(0)(0)>[&]=6
} pbMSMConfigSdBerThreshold_Tval<s(0)(0)(0)>[&];(D1:pbMSMConfigSdBerThreshold_Tval:1)[[TYPENAME:pbMSMConfigSdBerThreshold_Tval]]

typedef enum {
	pbMSMConfigSfBerThreshold_ber10_3<s(0)(0)(0)>[&]=1,
	pbMSMConfigSfBerThreshold_ber10_4<s(0)(0)(0)>[&]=2,
	pbMSMConfigSfBerThreshold_ber10_5<s(0)(0)(0)>[&]=3,
	pbMSMConfigSfBerThreshold_global_sf<s(0)(0)(0)>[&]=4
} pbMSMConfigSfBerThreshold_Tval<s(0)(0)(0)>[&];(D1:pbMSMConfigSfBerThreshold_Tval:1)[[TYPENAME:pbMSMConfigSfBerThreshold_Tval]]

typedef enum {
	pbMSMCardFunction_none<s(0)(0)(0)>[&]=0,
	pbMSMCardFunction_stm_4<s(0)(0)(0)>[&]=4,
	pbMSMCardFunction_stm_16<s(0)(0)(0)>[&]=16,
	pbMSMCardFunction_stm_64<s(0)(0)(0)>[&]=64
} pbMSMCardFunction_Tval<s(0)(0)(0)>[&];(D1:pbMSMCardFunction_Tval:1)[[TYPENAME:pbMSMCardFunction_Tval]]

typedef struct
{
	int		pbMSMSNMRingId<s(1)(1)(0)>[&];                                                     
	pbMSMProtectMode_Tval<s(1)(1)(0)>[T] pbMSMProtectMode<s(1)(1)(0)>[&];   
	char		pbMSMSNMRingName<s(1)(1)(0)>[&][64];   
	int		pbMSMRingIdx<s(1)(1)(0)>[&];   
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbMSMWestSideSlotNum<s(1)(1)(0)>[&];   
	PbPortType_Tval<s(1)(1)(0)>[T] pbMSMWestSidePortType<s(1)(1)(0)>[&];   
	int		pbMSMWestSidePortNum<s(1)(1)(0)>[&];   
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbMSMWestProtSlotNum<s(1)(1)(0)>[&];
	PbPortType_Tval<s(1)(1)(0)>[T] pbMSMWestProtPortType<s(1)(1)(0)>[&];
	int		pbMSMWestProtPortNum<s(1)(1)(0)>[&];
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbMSMEastSideSlotNum<s(1)(1)(0)>[&];   
	PbPortType_Tval<s(1)(1)(0)>[T] pbMSMEastSidePortType<s(1)(1)(0)>[&];   
	int		pbMSMEastSidePortNum<s(1)(1)(0)>[&];   
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbMSMEastProtSlotNum<s(1)(1)(0)>[&];
	PbPortType_Tval<s(1)(1)(0)>[T] pbMSMEastProtPortType<s(1)(1)(0)>[&];
	int		pbMSMEastProtPortNum<s(1)(1)(0)>[&];
	PbOnOff_Tval<s(1)(1)(0)>[T] pbMSMAutoSquelchDiscovery<s(1)(1)(0)>[&];
	PbOnOff_Tval<s(1)(1)(0)>[T] pbMSMAutoRingDiscovery<s(1)(1)(0)>[&];
	unsigned int	pbMSMPeerWestAddress<s(1)(1)(0)>[&];   
	int		pbMSMPeerWestSlotNum<s(1)(1)(0)>[&];   
	int		pbMSMPeerWestPortType<s(1)(1)(0)>[&];   
	int		pbMSMPeerWestPortNum<s(1)(1)(0)>[&];   
	unsigned int	pbMSMPeerEastAddress<s(1)(1)(0)>[&];   
	int		pbMSMPeerEastSlotNum<s(1)(1)(0)>[&];   
	int		pbMSMPeerEastPortType<s(1)(1)(0)>[&];   
	int		pbMSMPeerEastPortNum<s(1)(1)(0)>[&];   
	pbMSMConfigSdBerThreshold_Tval<s(1)(1)(0)>[T] pbMSMConfigSdBerThreshold<s(1)(1)(0)>[&];
	pbMSMConfigSfBerThreshold_Tval<s(1)(1)(0)>[T] pbMSMConfigSfBerThreshold<s(1)(1)(0)>[&];
	int		pbMSMConfigWaitToRestore<s(1)(1)(0)>[&];   
	PbOnOff_Tval<s(1)(1)(0)>[T] pbMSMConfigExtraTraffic<s(1)(1)(0)>[&];
	TruthValue_Tval<s(1)(1)(0)>[T] pbMSMConfigEnable<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbMSMConfigDelete<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbMSMSquelchFin<s(1)(1)(0)>[&];
	pbMSMCardFunction_Tval<s(1)(1)(0)>[T] pbMSMCardFunction<s(1)(1)(0)>[&];   
	char		pbMSMChannelInfo<s(1)(1)(0)>[&][255];   
	unsigned int	pbMSMSelfAddress<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbMSMStartAutoSquelch<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbMSMAutoMappingEnable<s(1)(1)(0)>[&];   
	PbEnableDisable_Tval<s(1)(1)(0)>[T] pbMSMPortMapRefresh<s(1)(1)(0)>[&];   
}MIBpbMSMConfigTable_t<s(0)(0)(0)>[&];(D1:MIBpbMSMConfigTable_t:1)[[TYPENAME:MIBpbMSMConfigTable_t]]














































 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbMSMStatusTable_Did<s(0)(0)(0)>[&];(D1:pbMSMStatusTable_Did:0)

   
typedef enum {
	pbMSMSide_west<s(0)(0)(0)>[&]=0,
	pbMSMSide_east<s(0)(0)(0)>[&]=1
} pbMSMSide_Tval<s(0)(0)(0)>[&];(D1:pbMSMSide_Tval:1)[[TYPENAME:pbMSMSide_Tval]]

typedef enum {
	pbMSMTransBridgeReq_noRequest<s(0)(0)(0)>[&]=0,
	pbMSMTransBridgeReq_reverseRequestRing<s(0)(0)(0)>[&]=1,
	pbMSMTransBridgeReq_reverseRequestSpan<s(0)(0)(0)>[&]=2,
	pbMSMTransBridgeReq_exerciserRing<s(0)(0)(0)>[&]=3,
	pbMSMTransBridgeReq_exerciserSpan<s(0)(0)(0)>[&]=4,
	pbMSMTransBridgeReq_waitToRestore<s(0)(0)(0)>[&]=5,
	pbMSMTransBridgeReq_manualSwitchRing<s(0)(0)(0)>[&]=6,
	pbMSMTransBridgeReq_manualSwitchSpan<s(0)(0)(0)>[&]=7,
	pbMSMTransBridgeReq_signalDegradeRing<s(0)(0)(0)>[&]=8,
	pbMSMTransBridgeReq_signalDegradeSpan<s(0)(0)(0)>[&]=9,
	pbMSMTransBridgeReq_signalDegradeProtection<s(0)(0)(0)>[&]=10,
	pbMSMTransBridgeReq_signalFailRing<s(0)(0)(0)>[&]=11,
	pbMSMTransBridgeReq_signalFailSpan<s(0)(0)(0)>[&]=12,
	pbMSMTransBridgeReq_forcedSwitchRing<s(0)(0)(0)>[&]=13,
	pbMSMTransBridgeReq_forcedSwitchSpan<s(0)(0)(0)>[&]=14,
	pbMSMTransBridgeReq_lockoutProtection<s(0)(0)(0)>[&]=15
} pbMSMTransBridgeReq_Tval<s(0)(0)(0)>[&];(D1:pbMSMTransBridgeReq_Tval:1)[[TYPENAME:pbMSMTransBridgeReq_Tval]]

typedef enum {
	pbMSMTransLongShort_shortPath<s(0)(0)(0)>[&]=0,
	pbMSMTransLongShort_longPath<s(0)(0)(0)>[&]=1
} pbMSMTransLongShort_Tval<s(0)(0)(0)>[&];(D1:pbMSMTransLongShort_Tval:1)[[TYPENAME:pbMSMTransLongShort_Tval]]

typedef enum {
	pbMSMTransStatus_idle<s(0)(0)(0)>[&]=0,
	pbMSMTransStatus_bridged<s(0)(0)(0)>[&]=1,
	pbMSMTransStatus_bridgedAndSwitched<s(0)(0)(0)>[&]=2,
	pbMSMTransStatus_extraTraffic<s(0)(0)(0)>[&]=3,
	pbMSMTransStatus_msRDI<s(0)(0)(0)>[&]=6,
	pbMSMTransStatus_msAIS<s(0)(0)(0)>[&]=7
} pbMSMTransStatus_Tval<s(0)(0)(0)>[&];(D1:pbMSMTransStatus_Tval:1)[[TYPENAME:pbMSMTransStatus_Tval]]

typedef enum {
	pbMSMReceiveBridgeReq_noRequest<s(0)(0)(0)>[&]=0,
	pbMSMReceiveBridgeReq_reverseRequestRing<s(0)(0)(0)>[&]=1,
	pbMSMReceiveBridgeReq_reverseRequestSpan<s(0)(0)(0)>[&]=2,
	pbMSMReceiveBridgeReq_exerciserRing<s(0)(0)(0)>[&]=3,
	pbMSMReceiveBridgeReq_exerciserSpan<s(0)(0)(0)>[&]=4,
	pbMSMReceiveBridgeReq_waitToRestore<s(0)(0)(0)>[&]=5,
	pbMSMReceiveBridgeReq_manualSwitchRing<s(0)(0)(0)>[&]=6,
	pbMSMReceiveBridgeReq_manualSwitchSpan<s(0)(0)(0)>[&]=7,
	pbMSMReceiveBridgeReq_signalDegradeRing<s(0)(0)(0)>[&]=8,
	pbMSMReceiveBridgeReq_signalDegradeSpan<s(0)(0)(0)>[&]=9,
	pbMSMReceiveBridgeReq_signalDegradeProtection<s(0)(0)(0)>[&]=10,
	pbMSMReceiveBridgeReq_signalFailRing<s(0)(0)(0)>[&]=11,
	pbMSMReceiveBridgeReq_signalFailSpan<s(0)(0)(0)>[&]=12,
	pbMSMReceiveBridgeReq_forcedSwitchRing<s(0)(0)(0)>[&]=13,
	pbMSMReceiveBridgeReq_forcedSwitchSpan<s(0)(0)(0)>[&]=14,
	pbMSMReceiveBridgeReq_lockoutProtection<s(0)(0)(0)>[&]=15
} pbMSMReceiveBridgeReq_Tval<s(0)(0)(0)>[&];(D1:pbMSMReceiveBridgeReq_Tval:1)[[TYPENAME:pbMSMReceiveBridgeReq_Tval]]

typedef enum {
	pbMSMReceiveLongShort_shortPath<s(0)(0)(0)>[&]=0,
	pbMSMReceiveLongShort_longPath<s(0)(0)(0)>[&]=1
} pbMSMReceiveLongShort_Tval<s(0)(0)(0)>[&];(D1:pbMSMReceiveLongShort_Tval:1)[[TYPENAME:pbMSMReceiveLongShort_Tval]]

typedef enum {
	pbMSMReceiveStatus_idle<s(0)(0)(0)>[&]=0,
	pbMSMReceiveStatus_bridged<s(0)(0)(0)>[&]=1,
	pbMSMReceiveStatus_bridgedAndSwitched<s(0)(0)(0)>[&]=2,
	pbMSMReceiveStatus_extraTraffic<s(0)(0)(0)>[&]=3,
	pbMSMReceiveStatus_msRDI<s(0)(0)(0)>[&]=6,
	pbMSMReceiveStatus_msAIS<s(0)(0)(0)>[&]=7
} pbMSMReceiveStatus_Tval<s(0)(0)(0)>[&];(D1:pbMSMReceiveStatus_Tval:1)[[TYPENAME:pbMSMReceiveStatus_Tval]]

typedef enum {
	pbMSMSideReq_noRequest<s(0)(0)(0)>[&]=0,
	pbMSMSideReq_reverseRequestRing<s(0)(0)(0)>[&]=1,
	pbMSMSideReq_reverseRequestSpan<s(0)(0)(0)>[&]=2,
	pbMSMSideReq_exerciserRing<s(0)(0)(0)>[&]=3,
	pbMSMSideReq_exerciserSpan<s(0)(0)(0)>[&]=4,
	pbMSMSideReq_waitToRestore<s(0)(0)(0)>[&]=5,
	pbMSMSideReq_manualSwitchRing<s(0)(0)(0)>[&]=6,
	pbMSMSideReq_manualSwitchSpan<s(0)(0)(0)>[&]=7,
	pbMSMSideReq_signalDegradeRing<s(0)(0)(0)>[&]=8,
	pbMSMSideReq_signalDegradeSpan<s(0)(0)(0)>[&]=9,
	pbMSMSideReq_signalDegradeProtection<s(0)(0)(0)>[&]=10,
	pbMSMSideReq_signalFailRing<s(0)(0)(0)>[&]=11,
	pbMSMSideReq_signalFailSpan<s(0)(0)(0)>[&]=12,
	pbMSMSideReq_forcedSwitchRing<s(0)(0)(0)>[&]=13,
	pbMSMSideReq_forcedSwitchSpan<s(0)(0)(0)>[&]=14,
	pbMSMSideReq_lockoutProtection<s(0)(0)(0)>[&]=15,
	pbMSMSideReq_reset<s(0)(0)(0)>[&]=20,
	pbMSMSideReq_clear<s(0)(0)(0)>[&]=21,
	pbMSMSideReq_lockoutService<s(0)(0)(0)>[&]=22
} pbMSMSideReq_Tval<s(0)(0)(0)>[&];(D1:pbMSMSideReq_Tval:1)[[TYPENAME:pbMSMSideReq_Tval]]

typedef enum {
	pbMSMSideSrc_kByte<s(0)(0)(0)>[&]=0,
	pbMSMSideSrc_line<s(0)(0)(0)>[&]=1,
	pbMSMSideSrc_external<s(0)(0)(0)>[&]=2
} pbMSMSideSrc_Tval<s(0)(0)(0)>[&];(D1:pbMSMSideSrc_Tval:1)[[TYPENAME:pbMSMSideSrc_Tval]]

typedef enum {
	pbMSMSwitchCommand_idle<s(0)(0)(0)>[&]=0,
	pbMSMSwitchCommand_bridge<s(0)(0)(0)>[&]=1,
	pbMSMSwitchCommand_bridgeAndSwitch<s(0)(0)(0)>[&]=2,
	pbMSMSwitchCommand_passthough<s(0)(0)(0)>[&]=3
} pbMSMSwitchCommand_Tval<s(0)(0)(0)>[&];(D1:pbMSMSwitchCommand_Tval:1)[[TYPENAME:pbMSMSwitchCommand_Tval]]

typedef enum {
	pbMSMLineReq_signalDegradeRing<s(0)(0)(0)>[&]=8,
	pbMSMLineReq_signalFailRing<s(0)(0)(0)>[&]=11,
	pbMSMLineReq_clear<s(0)(0)(0)>[&]=21
} pbMSMLineReq_Tval<s(0)(0)(0)>[&];(D1:pbMSMLineReq_Tval:1)[[TYPENAME:pbMSMLineReq_Tval]]

typedef enum {
	pbMSMCmndReq_manualSwitchRing<s(0)(0)(0)>[&]=6,
	pbMSMCmndReq_forcedSwitchRing<s(0)(0)(0)>[&]=13,
	pbMSMCmndReq_lockoutProtection<s(0)(0)(0)>[&]=15,
	pbMSMCmndReq_reset<s(0)(0)(0)>[&]=21
} pbMSMCmndReq_Tval<s(0)(0)(0)>[&];(D1:pbMSMCmndReq_Tval:1)[[TYPENAME:pbMSMCmndReq_Tval]]

typedef struct
{
	int		pbMSMSNMRingId<s(1)(1)(0)>[&];                                            
	pbMSMSide_Tval<s(1)(1)(0)>[T] pbMSMSide<s(1)(1)(0)>[&];                                          
	pbMSMTransBridgeReq_Tval<s(1)(1)(0)>[T] pbMSMTransBridgeReq<s(1)(1)(0)>[&];   
	int		pbMSMTransDestNodeId<s(1)(1)(0)>[&];   
	int		pbMSMTransSrcNodeId<s(1)(1)(0)>[&];   
	pbMSMTransLongShort_Tval<s(1)(1)(0)>[T] pbMSMTransLongShort<s(1)(1)(0)>[&];   
	pbMSMTransStatus_Tval<s(1)(1)(0)>[T] pbMSMTransStatus<s(1)(1)(0)>[&];   
	pbMSMReceiveBridgeReq_Tval<s(1)(1)(0)>[T] pbMSMReceiveBridgeReq<s(1)(1)(0)>[&];   
	int		pbMSMReceiveDestNodeId<s(1)(1)(0)>[&];   
	int		pbMSMReceiveSrcNodeId<s(1)(1)(0)>[&];   
	pbMSMReceiveLongShort_Tval<s(1)(1)(0)>[T] pbMSMReceiveLongShort<s(1)(1)(0)>[&];   
	pbMSMReceiveStatus_Tval<s(1)(1)(0)>[T] pbMSMReceiveStatus<s(1)(1)(0)>[&];   
	pbMSMSideReq_Tval<s(1)(1)(0)>[T] pbMSMSideReq<s(1)(1)(0)>[&];   
	pbMSMSideSrc_Tval<s(1)(1)(0)>[T] pbMSMSideSrc<s(1)(1)(0)>[&];   
	pbMSMSwitchCommand_Tval<s(1)(1)(0)>[T] pbMSMSwitchCommand<s(1)(1)(0)>[&];   
	pbMSMLineReq_Tval<s(1)(1)(0)>[T] pbMSMLineReq<s(1)(1)(0)>[&];   
	pbMSMCmndReq_Tval<s(1)(1)(0)>[T] pbMSMCmndReq<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbMSMIsSquelched<s(1)(1)(0)>[&];   
}MIBpbMSMStatusTable_t<s(0)(0)(0)>[&];(D1:MIBpbMSMStatusTable_t:1)[[TYPENAME:MIBpbMSMStatusTable_t]]

























 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbMSMNodeStatusTable_Did<s(0)(0)(0)>[&];(D1:pbMSMNodeStatusTable_Did:0)

   
typedef enum {
	pbMSMNodeKExpressMode_autoLocal<s(0)(0)(0)>[&]=0,
	pbMSMNodeKExpressMode_autoExpress<s(0)(0)(0)>[&]=1,
	pbMSMNodeKExpressMode_forceExpress<s(0)(0)(0)>[&]=2,
	pbMSMNodeKExpressMode_forceLocal<s(0)(0)(0)>[&]=3
} pbMSMNodeKExpressMode_Tval<s(0)(0)(0)>[&];(D1:pbMSMNodeKExpressMode_Tval:1)[[TYPENAME:pbMSMNodeKExpressMode_Tval]]

typedef struct
{
	int		pbMSMSNMRingId<s(1)(1)(0)>[&];                                            
	PbMsspAgentState_Tval<s(1)(1)(0)>[T] pbMSMNodeAgentState<s(1)(1)(0)>[&];   
	PbMsspNodeState_Tval<s(1)(1)(0)>[T] pbMSMNodeState<s(1)(1)(0)>[&];   
	PbMsspNodeSide_Tval<s(1)(1)(0)>[T] pbMSMNodeCurrentSide<s(1)(1)(0)>[&];   
	PbMsspRequest_Tval<s(1)(1)(0)>[T] pbMSMNodeCurrentReq<s(1)(1)(0)>[&];   
	PbMsspRequestSource_Tval<s(1)(1)(0)>[T] pbMSMNodeCurrentSrc<s(1)(1)(0)>[&];   
	pbMSMNodeKExpressMode_Tval<s(1)(1)(0)>[T] pbMSMNodeKExpressMode<s(1)(1)(0)>[&];   
	PbMsspRequest_Tval<s(1)(1)(0)>[T] pbMSMEastSwitchCommand<s(1)(1)(0)>[&];   
	PbMsspLineRequest_Tval<s(1)(1)(0)>[T] pbMSMEastLineReq<s(1)(1)(0)>[&];   
	PbMsspRequest_Tval<s(1)(1)(0)>[T] pbMSMEastLastSwitchCmd<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbMSMEastIsSquelched<s(1)(1)(0)>[&];   
	PbMsspRequest_Tval<s(1)(1)(0)>[T] pbMSMWestSwitchCommand<s(1)(1)(0)>[&];   
	PbMsspLineRequest_Tval<s(1)(1)(0)>[T] pbMSMWestLineReq<s(1)(1)(0)>[&];   
	PbMsspRequest_Tval<s(1)(1)(0)>[T] pbMSMWestLastSwitchCmd<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbMSMWestIsSquelched<s(1)(1)(0)>[&];   
	PbMsspSwitchStatus_Tval<s(1)(1)(0)>[T] pbMSMEastSwitchStatus<s(1)(1)(0)>[&];   
	PbMsspSwitchStatus_Tval<s(1)(1)(0)>[T] pbMSMWestSwitchStatus<s(1)(1)(0)>[&];   
	int		pbMSMPassNodeId<s(1)(1)(0)>[&];   
}MIBpbMSMNodeStatusTable_t<s(0)(0)(0)>[&];(D1:MIBpbMSMNodeStatusTable_t:1)[[TYPENAME:MIBpbMSMNodeStatusTable_t]]

























 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbMSMTopoConfigTable_Did<s(0)(0)(0)>[&];(D1:pbMSMTopoConfigTable_Did:0)

   
typedef enum {
	pbMSMTopoStatus_unconfigured<s(0)(0)(0)>[&]=0,
	pbMSMTopoStatus_closed<s(0)(0)(0)>[&]=1,
	pbMSMTopoStatus_open<s(0)(0)(0)>[&]=2,
	pbMSMTopoStatus_locallyMisconfigured<s(0)(0)(0)>[&]=3,
	pbMSMTopoStatus_remotelyMisconfigured<s(0)(0)(0)>[&]=4
} pbMSMTopoStatus_Tval<s(0)(0)(0)>[&];(D1:pbMSMTopoStatus_Tval:1)[[TYPENAME:pbMSMTopoStatus_Tval]]

typedef enum {
	pbMSMTopoConfig_unsuspend<s(0)(0)(0)>[&]=1,
	pbMSMTopoConfig_suspend<s(0)(0)(0)>[&]=2
} pbMSMTopoConfig_Tval<s(0)(0)(0)>[&];(D1:pbMSMTopoConfig_Tval:1)[[TYPENAME:pbMSMTopoConfig_Tval]]

typedef struct
{
	int		pbMSMSNMRingId<s(1)(1)(0)>[&];                                                    
	int		pbMSMTopoNumOfNodes<s(1)(1)(0)>[&];   
	int		pbMSMTopoNodeId0<s(1)(1)(0)>[&];   
	int		pbMSMTopoNodeId1<s(1)(1)(0)>[&];   
	int		pbMSMTopoNodeId2<s(1)(1)(0)>[&];   
	int		pbMSMTopoNodeId3<s(1)(1)(0)>[&];   
	int		pbMSMTopoNodeId4<s(1)(1)(0)>[&];   
	int		pbMSMTopoNodeId5<s(1)(1)(0)>[&];   
	int		pbMSMTopoNodeId6<s(1)(1)(0)>[&];   
	int		pbMSMTopoNodeId7<s(1)(1)(0)>[&];   
	int		pbMSMTopoNodeId8<s(1)(1)(0)>[&];   
	int		pbMSMTopoNodeId9<s(1)(1)(0)>[&];   
	int		pbMSMTopoNodeId10<s(1)(1)(0)>[&];   
	int		pbMSMTopoNodeId11<s(1)(1)(0)>[&];   
	int		pbMSMTopoNodeId12<s(1)(1)(0)>[&];   
	int		pbMSMTopoNodeId13<s(1)(1)(0)>[&];   
	int		pbMSMTopoNodeId14<s(1)(1)(0)>[&];   
	int		pbMSMTopoNodeId15<s(1)(1)(0)>[&];   
	pbMSMTopoStatus_Tval<s(1)(1)(0)>[T] pbMSMTopoStatus<s(1)(1)(0)>[&];   
	pbMSMTopoConfig_Tval<s(1)(1)(0)>[T] pbMSMTopoConfig<s(1)(1)(0)>[&];   
	unsigned int	pbMSMTopoNodeId0IpAddress<s(1)(1)(0)>[&];   
	unsigned int	pbMSMTopoNodeId1IpAddress<s(1)(1)(0)>[&];   
	unsigned int	pbMSMTopoNodeId2IpAddress<s(1)(1)(0)>[&];   
	unsigned int	pbMSMTopoNodeId3IpAddress<s(1)(1)(0)>[&];   
	unsigned int	pbMSMTopoNodeId4IpAddress<s(1)(1)(0)>[&];   
	unsigned int	pbMSMTopoNodeId5IpAddress<s(1)(1)(0)>[&];   
	unsigned int	pbMSMTopoNodeId6IpAddress<s(1)(1)(0)>[&];   
	unsigned int	pbMSMTopoNodeId7IpAddress<s(1)(1)(0)>[&];   
	unsigned int	pbMSMTopoNodeId8IpAddress<s(1)(1)(0)>[&];   
	unsigned int	pbMSMTopoNodeId9IpAddress<s(1)(1)(0)>[&];   
	unsigned int	pbMSMTopoNodeId10IpAddress<s(1)(1)(0)>[&];   
	unsigned int	pbMSMTopoNodeId11IpAddress<s(1)(1)(0)>[&];   
	unsigned int	pbMSMTopoNodeId12IpAddress<s(1)(1)(0)>[&];   
	unsigned int	pbMSMTopoNodeId13IpAddress<s(1)(1)(0)>[&];   
	unsigned int	pbMSMTopoNodeId14IpAddress<s(1)(1)(0)>[&];   
	unsigned int	pbMSMTopoNodeId15IpAddress<s(1)(1)(0)>[&];   
}MIBpbMSMTopoConfigTable_t<s(0)(0)(0)>[&];(D1:MIBpbMSMTopoConfigTable_t:1)[[TYPENAME:MIBpbMSMTopoConfigTable_t]]











































 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbMSMSquelchTable_Did<s(0)(0)(0)>[&];(D1:pbMSMSquelchTable_Did:0)

   
typedef enum {
	pbMSMSquelchType_none<s(0)(0)(0)>[&]=0,
	pbMSMSquelchType_add<s(0)(0)(0)>[&]=1,
	pbMSMSquelchType_drop<s(0)(0)(0)>[&]=2,
	pbMSMSquelchType_passthrough<s(0)(0)(0)>[&]=3
} pbMSMSquelchType_Tval<s(0)(0)(0)>[&];(D1:pbMSMSquelchType_Tval:1)[[TYPENAME:pbMSMSquelchType_Tval]]

typedef struct
{
	int		pbMSMSNMRingId<s(1)(1)(0)>[&];                                            
	PbMsspNodeSide_Tval<s(1)(1)(0)>[T] pbMSMSquelchSide<s(1)(1)(0)>[&];                              
	PbMsspTrafficDirection_Tval<s(1)(1)(0)>[T] pbMSMSquelchGress<s(1)(1)(0)>[&];                     
	int		pbMSMSquelchTimeSlot<s(1)(1)(0)>[&];                                         
	PbMsspTrafficOrder_Tval<s(1)(1)(0)>[T] pbMSMSquelchOrder<s(1)(1)(0)>[&];   
	pbMSMSquelchType_Tval<s(1)(1)(0)>[T] pbMSMSquelchType<s(1)(1)(0)>[&];   
	int		pbMSMSquelchSrcNodeId<s(1)(1)(0)>[&];   
	int		pbMSMSquelchDstNodeId<s(1)(1)(0)>[&];   
	int		pbMSMSquelchReference<s(1)(1)(0)>[&];   
	int		pbMSMSquelchOpTimeSlot<s(1)(1)(0)>[&];   
	RowStatus_Tval<s(1)(1)(0)>[T] pbMSMSquelchRowStatus<s(1)(1)(0)>[&];   
}MIBpbMSMSquelchTable_t<s(0)(0)(0)>[&];(D1:MIBpbMSMSquelchTable_t:1)[[TYPENAME:MIBpbMSMSquelchTable_t]]


















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbMSMCommandTable_Did<s(0)(0)(0)>[&];(D1:pbMSMCommandTable_Did:0)

   
typedef enum {
	pbMSMCommandResult_unknown<s(0)(0)(0)>[&]=0,
	pbMSMCommandResult_success<s(0)(0)(0)>[&]=1,
	pbMSMCommandResult_fail<s(0)(0)(0)>[&]=2
} pbMSMCommandResult_Tval<s(0)(0)(0)>[&];(D1:pbMSMCommandResult_Tval:1)[[TYPENAME:pbMSMCommandResult_Tval]]

typedef struct
{
	int		pbMSMSNMRingId<s(1)(1)(0)>[&];                                              
	PbMsspNodeSide_Tval<s(1)(1)(0)>[T] pbMSMCommandCurrentSide<s(1)(1)(0)>[&];                         
	PbMsspExternalCommand_Tval<s(1)(1)(0)>[T] pbMSMCommandSwitch<s(1)(1)(0)>[&];   
	char		pbMSMLastCommandStatus<s(1)(1)(0)>[&][64];   
	pbMSMCommandResult_Tval<s(1)(1)(0)>[T] pbMSMCommandResult<s(1)(1)(0)>[&];   
}MIBpbMSMCommandTable_t<s(0)(0)(0)>[&];(D1:MIBpbMSMCommandTable_t:1)[[TYPENAME:MIBpbMSMCommandTable_t]]












 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbAutoMappingTable_Did<s(0)(0)(0)>[&];(D1:pbAutoMappingTable_Did:0)

   
typedef struct
{
	int		pbMSMSNMRingId<s(1)(1)(0)>[&];                                            
	int		pbAutoNodeId<s(1)(1)(0)>[&];                                                 
	int		pbPortMappingString_len<s(1)(1)(0)>[&];
	char		pbPortMappingString<s(1)(1)(0)>[&][768];   
	RowStatus_Tval<s(1)(1)(0)>[T] pbAutoMappingRowStatus<s(1)(1)(0)>[&];   
}MIBpbAutoMappingTable_t<s(0)(0)(0)>[&];(D1:MIBpbAutoMappingTable_t:1)[[TYPENAME:MIBpbAutoMappingTable_t]]











 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbEpgTable_Did<s(0)(0)(0)>[&];(D1:pbEpgTable_Did:0)

   
typedef enum {
	pbEpgType_onevsn<s(0)(0)(0)>[&]=1,
	pbEpgType_oneplusone<s(0)(0)(0)>[&]=2
} pbEpgType_Tval<s(0)(0)(0)>[&];(D1:pbEpgType_Tval:1)[[TYPENAME:pbEpgType_Tval]]

typedef enum {
	pbEpgProtMode_none<s(0)(0)(0)>[&]=0,
	pbEpgProtMode_revertive<s(0)(0)(0)>[&]=1,
	pbEpgProtMode_nonrevertive<s(0)(0)(0)>[&]=2
} pbEpgProtMode_Tval<s(0)(0)(0)>[&];(D1:pbEpgProtMode_Tval:1)[[TYPENAME:pbEpgProtMode_Tval]]

typedef struct
{
	int		pbEpgId<s(1)(1)(0)>[&];                                                  
	PbBoardStyle_Tval<s(1)(1)(0)>[T] pbEpgBoardType<s(1)(1)(0)>[&];   
	pbEpgType_Tval<s(1)(1)(0)>[T] pbEpgType<s(1)(1)(0)>[&];   
	pbEpgProtMode_Tval<s(1)(1)(0)>[T] pbEpgProtMode<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbEpgEnable<s(1)(1)(0)>[&];   
	PbEpgSwitchRequest_Tval<s(1)(1)(0)>[T] pbEpgExtCmd<s(1)(1)(0)>[&];   
	int		pbEpgExtCmdParam<s(1)(1)(0)>[&];   
	PbEpgCmdResult_Tval<s(1)(1)(0)>[T] pbEpgExtCmdResult<s(1)(1)(0)>[&];   
	int		pbEpgWtr<s(1)(1)(0)>[&];   
	PbEpgSwitchRequest_Tval<s(1)(1)(0)>[T] pbEpgPreSwitchReason<s(1)(1)(0)>[&];   
	PbEpgSwitchRequest_Tval<s(1)(1)(0)>[T] pbEpgCurRequest<s(1)(1)(0)>[&];   
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbEpgProtState<s(1)(1)(0)>[&];   
	int		pbEpgHoldOffTime<s(1)(1)(0)>[&];   
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbEpgProtSlotNum<s(1)(1)(0)>[&];   
	PbEpgFunctionCardStatus_Tval<s(1)(1)(0)>[T] pbEpgProtSlotState<s(1)(1)(0)>[&];   
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbEpgWorkSlotNum1<s(1)(1)(0)>[&];   
	PbEpgFunctionCardStatus_Tval<s(1)(1)(0)>[T] pbEpgWorkSlot1State<s(1)(1)(0)>[&];   
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbEpgWorkSlotNum2<s(1)(1)(0)>[&];   
	PbEpgFunctionCardStatus_Tval<s(1)(1)(0)>[T] pbEpgWorkSlot2State<s(1)(1)(0)>[&];   
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbEpgWorkSlotNum3<s(1)(1)(0)>[&];   
	PbEpgFunctionCardStatus_Tval<s(1)(1)(0)>[T] pbEpgWorkSlot3State<s(1)(1)(0)>[&];   
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbEpgWorkSlotNum4<s(1)(1)(0)>[&];   
	PbEpgFunctionCardStatus_Tval<s(1)(1)(0)>[T] pbEpgWorkSlot4State<s(1)(1)(0)>[&];   
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbEpgWorkSlotNum5<s(1)(1)(0)>[&];   
	PbEpgFunctionCardStatus_Tval<s(1)(1)(0)>[T] pbEpgWorkSlot5State<s(1)(1)(0)>[&];   
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbEpgWorkSlotNum6<s(1)(1)(0)>[&];   
	PbEpgFunctionCardStatus_Tval<s(1)(1)(0)>[T] pbEpgWorkSlot6State<s(1)(1)(0)>[&];   
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbEpgWorkSlotNum7<s(1)(1)(0)>[&];   
	PbEpgFunctionCardStatus_Tval<s(1)(1)(0)>[T] pbEpgWorkSlot7State<s(1)(1)(0)>[&];   
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbEpgWorkSlotNum8<s(1)(1)(0)>[&];   
	PbEpgFunctionCardStatus_Tval<s(1)(1)(0)>[T] pbEpgWorkSlot8State<s(1)(1)(0)>[&];   
	RowStatus_Tval<s(1)(1)(0)>[T] pbEpgRowStatus<s(1)(1)(0)>[&];   
}MIBpbEpgTable_t<s(0)(0)(0)>[&];(D1:MIBpbEpgTable_t:1)[[TYPENAME:MIBpbEpgTable_t]]







































 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbCpgTable_Did<s(0)(0)(0)>[&];(D1:pbCpgTable_Did:0)

   
typedef enum {
	pbCpgProtectStatus_worker<s(0)(0)(0)>[&]=0,
	pbCpgProtectStatus_protector<s(0)(0)(0)>[&]=1,
	pbCpgProtectStatus_na<s(0)(0)(0)>[&]=2
} pbCpgProtectStatus_Tval<s(0)(0)(0)>[&];(D1:pbCpgProtectStatus_Tval:1)[[TYPENAME:pbCpgProtectStatus_Tval]]

typedef enum {
	pbCpgAct_none<s(0)(0)(0)>[&]=0,
	pbCpgAct_force_Worker<s(0)(0)(0)>[&]=1,
	pbCpgAct_force_Protector<s(0)(0)(0)>[&]=2,
	pbCpgAct_manual_Worker<s(0)(0)(0)>[&]=3,
	pbCpgAct_manual_Protector<s(0)(0)(0)>[&]=4,
	pbCpgAct_clear<s(0)(0)(0)>[&]=5,
	pbCpgAct_lockout_protection<s(0)(0)(0)>[&]=6
} pbCpgAct_Tval<s(0)(0)(0)>[&];(D1:pbCpgAct_Tval:1)[[TYPENAME:pbCpgAct_Tval]]

typedef enum {
	pbCpgActStatus_no_Request<s(0)(0)(0)>[&]=0,
	pbCpgActStatus_force_Worker<s(0)(0)(0)>[&]=1,
	pbCpgActStatus_force_Protector<s(0)(0)(0)>[&]=2,
	pbCpgActStatus_manual_Worker<s(0)(0)(0)>[&]=3,
	pbCpgActStatus_manual_Protector<s(0)(0)(0)>[&]=4,
	pbCpgActStatus_ufur_Worker<s(0)(0)(0)>[&]=5,
	pbCpgActStatus_ufur_Protector<s(0)(0)(0)>[&]=6,
	pbCpgActStatus_latchon_Worker<s(0)(0)(0)>[&]=7,
	pbCpgActStatus_latchon_Protector<s(0)(0)(0)>[&]=8,
	pbCpgActStatus_lockout_protection<s(0)(0)(0)>[&]=9
} pbCpgActStatus_Tval<s(0)(0)(0)>[&];(D1:pbCpgActStatus_Tval:1)[[TYPENAME:pbCpgActStatus_Tval]]

typedef enum {
	pbCpgCurActStatus_no_Request<s(0)(0)(0)>[&]=0,
	pbCpgCurActStatus_force_Worker<s(0)(0)(0)>[&]=1,
	pbCpgCurActStatus_force_Protector<s(0)(0)(0)>[&]=2,
	pbCpgCurActStatus_manual_Worker<s(0)(0)(0)>[&]=3,
	pbCpgCurActStatus_manual_Protector<s(0)(0)(0)>[&]=4,
	pbCpgCurActStatus_ufur_Worker<s(0)(0)(0)>[&]=5,
	pbCpgCurActStatus_ufur_Protector<s(0)(0)(0)>[&]=6,
	pbCpgCurActStatus_latchon_Worker<s(0)(0)(0)>[&]=7,
	pbCpgCurActStatus_latchon_Protector<s(0)(0)(0)>[&]=8,
	pbCpgCurActStatus_lockout_protection<s(0)(0)(0)>[&]=9
} pbCpgCurActStatus_Tval<s(0)(0)(0)>[&];(D1:pbCpgCurActStatus_Tval:1)[[TYPENAME:pbCpgCurActStatus_Tval]]

typedef struct
{
	int		pbCpgIndexNo<s(1)(1)(0)>[&];                                         
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbCpgWorkerSlot<s(1)(1)(0)>[&];   
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbCpgProtectorSlot<s(1)(1)(0)>[&];   
	pbCpgProtectStatus_Tval<s(1)(1)(0)>[T] pbCpgProtectStatus<s(1)(1)(0)>[&];   
	PbCpgCardStatus_Tval<s(1)(1)(0)>[T] pbWorkerStatus<s(1)(1)(0)>[&];   
	PbCpgCardStatus_Tval<s(1)(1)(0)>[T] pbProtectorStatus<s(1)(1)(0)>[&];   
	pbCpgAct_Tval<s(1)(1)(0)>[T] pbCpgAct<s(1)(1)(0)>[&];   
	pbCpgActStatus_Tval<s(1)(1)(0)>[T] pbCpgActStatus<s(1)(1)(0)>[&];   
	pbCpgCurActStatus_Tval<s(1)(1)(0)>[T] pbCpgCurActStatus<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbCpgReadyToSwitch<s(1)(1)(0)>[&];   
}MIBpbCpgTable_t<s(0)(0)(0)>[&];(D1:MIBpbCpgTable_t:1)[[TYPENAME:MIBpbCpgTable_t]]

















 



 
extern MIBDid_t<s(0)(0)(0)>[T] scEpgGroup_Did<s(0)(0)(0)>[&];(D1:scEpgGroup_Did:0)

   
typedef enum {
	scEpgRequest_clear<s(0)(0)(0)>[&]=0,
	scEpgRequest_lockout<s(0)(0)(0)>[&]=1,
	scEpgRequest_manual_switch_to_sc1<s(0)(0)(0)>[&]=2,
	scEpgRequest_manual_switch_to_sc2<s(0)(0)(0)>[&]=3,
	scEpgRequest_no_Request<s(0)(0)(0)>[&]=4
} scEpgRequest_Tval<s(0)(0)(0)>[&];(D1:scEpgRequest_Tval:1)[[TYPENAME:scEpgRequest_Tval]]

typedef enum {
	scEpgLastSwichReason_no_Request<s(0)(0)(0)>[&]=0,
	scEpgLastSwichReason_manual_switch_to_sc1<s(0)(0)(0)>[&]=1,
	scEpgLastSwichReason_manual_switch_to_sc2<s(0)(0)(0)>[&]=2,
	scEpgLastSwichReason_latchon_Switch<s(0)(0)(0)>[&]=3,
	scEpgLastSwichReason_uf2_Switch<s(0)(0)(0)>[&]=4,
	scEpgLastSwichReason_uf1_Switch<s(0)(0)(0)>[&]=5,
	scEpgLastSwichReason_cr_Switch<s(0)(0)(0)>[&]=6,
	scEpgLastSwichReason_lockout_protection<s(0)(0)(0)>[&]=7
} scEpgLastSwichReason_Tval<s(0)(0)(0)>[&];(D1:scEpgLastSwichReason_Tval:1)[[TYPENAME:scEpgLastSwichReason_Tval]]

typedef enum {
	scEpgStandbySc_failed<s(0)(0)(0)>[&]=0,
	scEpgStandbySc_ok<s(0)(0)(0)>[&]=1
} scEpgStandbySc_Tval<s(0)(0)(0)>[&];(D1:scEpgStandbySc_Tval:1)[[TYPENAME:scEpgStandbySc_Tval]]

typedef enum {
	scEpgASCSwithchState_no_switch<s(0)(0)(0)>[&]=0,
	scEpgASCSwithchState_begin_switch<s(0)(0)(0)>[&]=1,
	scEpgASCSwithchState_end_switch<s(0)(0)(0)>[&]=2
} scEpgASCSwithchState_Tval<s(0)(0)(0)>[&];(D1:scEpgASCSwithchState_Tval:1)[[TYPENAME:scEpgASCSwithchState_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] scEpgScWorkerSlot<s(1)(1)(0)>[&];   
	int		scEpgSc1Status<s(1)(1)(0)>[&];   
	int		scEpgSc2Status<s(1)(1)(0)>[&];   
	scEpgRequest_Tval<s(1)(1)(0)>[T] scEpgRequest<s(1)(1)(0)>[&];   
	scEpgLastSwichReason_Tval<s(1)(1)(0)>[T] scEpgLastSwichReason<s(1)(1)(0)>[&];   
	scEpgStandbySc_Tval<s(1)(1)(0)>[T] scEpgStandbySc<s(1)(1)(0)>[&];   
	scEpgASCSwithchState_Tval<s(1)(1)(0)>[T] scEpgASCSwithchState<s(1)(1)(0)>[&];
}MIBscEpgGroup_t<s(0)(0)(0)>[&];(D1:MIBscEpgGroup_t:1)[[TYPENAME:MIBscEpgGroup_t]]












 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbSDHProtectionModule_Did<s(0)(0)(0)>[&];(D1:pbSDHProtectionModule_Did:0)

   







 




 



 
extern MIBDid_t<s(0)(0)(0)>[T] securityGlobalSettingGroup_Did<s(0)(0)(0)>[&];(D1:securityGlobalSettingGroup_Did:0)

   
typedef enum {
	securityTCBehavior_none<s(0)(0)(0)>[&]=1,
	securityTCBehavior_alarm<s(0)(0)(0)>[&]=2,
	securityTCBehavior_disable_account<s(0)(0)(0)>[&]=3
} securityTCBehavior_Tval<s(0)(0)(0)>[&];(D1:securityTCBehavior_Tval:1)[[TYPENAME:securityTCBehavior_Tval]]

typedef struct
{
	int		securityPasswordMinLen<s(1)(1)(0)>[&];   
	int		securityMaxInvalidLogin<s(1)(1)(0)>[&];   
	int		securityUnauthorizedAccessThreshold<s(1)(1)(0)>[&];   
	securityTCBehavior_Tval<s(1)(1)(0)>[T] securityTCBehavior<s(1)(1)(0)>[&];   
}MIBsecurityGlobalSettingGroup_t<s(0)(0)(0)>[&];(D1:MIBsecurityGlobalSettingGroup_t:1)[[TYPENAME:MIBsecurityGlobalSettingGroup_t]]









 



 
extern MIBDid_t<s(0)(0)(0)>[T] securityAlarmInhibitGroup_Did<s(0)(0)(0)>[&];(D1:securityAlarmInhibitGroup_Did:0)

   
typedef struct
{
	PbEnableDisable_Tval<s(1)(1)(0)>[T] securityULEInhibit<s(1)(1)(0)>[&];   
	PbEnableDisable_Tval<s(1)(1)(0)>[T] securityUAInhibit<s(1)(1)(0)>[&];   
	PbEnableDisable_Tval<s(1)(1)(0)>[T] securityAEDInhibit<s(1)(1)(0)>[&];   
	PbEnableDisable_Tval<s(1)(1)(0)>[T] securityLTWInhibit<s(1)(1)(0)>[&];   
	PbEnableDisable_Tval<s(1)(1)(0)>[T] securityLFAInhibit<s(1)(1)(0)>[&];   
}MIBsecurityAlarmInhibitGroup_t<s(0)(0)(0)>[&];(D1:MIBsecurityAlarmInhibitGroup_t:1)[[TYPENAME:MIBsecurityAlarmInhibitGroup_t]]










 



 
extern MIBDid_t<s(0)(0)(0)>[T] snmpSecurityGroup_Did<s(0)(0)(0)>[&];(D1:snmpSecurityGroup_Did:0)

   


 



 
extern MIBDid_t<s(0)(0)(0)>[T] securityLogGroup_Did<s(0)(0)(0)>[&];(D1:securityLogGroup_Did:0)

   
typedef enum {
	securityLogGetStatus_inactive<s(0)(0)(0)>[&]=0,
	securityLogGetStatus_getStarted<s(0)(0)(0)>[&]=1,
	securityLogGetStatus_getPrepared<s(0)(0)(0)>[&]=2,
	securityLogGetStatus_getCompleted<s(0)(0)(0)>[&]=3,
	securityLogGetStatus_getCompletedNotClear<s(0)(0)(0)>[&]=4
} securityLogGetStatus_Tval<s(0)(0)(0)>[&];(D1:securityLogGetStatus_Tval:1)[[TYPENAME:securityLogGetStatus_Tval]]

typedef enum {
	securityLogFullBehavior_wrap_around<s(0)(0)(0)>[&]=1,
	securityLogFullBehavior_stop<s(0)(0)(0)>[&]=2
} securityLogFullBehavior_Tval<s(0)(0)(0)>[&];(D1:securityLogFullBehavior_Tval:1)[[TYPENAME:securityLogFullBehavior_Tval]]

typedef enum {
	securityLogControl_active<s(0)(0)(0)>[&]=1,
	securityLogControl_hold<s(0)(0)(0)>[&]=2,
	securityLogControl_purge<s(0)(0)(0)>[&]=3,
	securityLogControl_trap<s(0)(0)(0)>[&]=4
} securityLogControl_Tval<s(0)(0)(0)>[&];(D1:securityLogControl_Tval:1)[[TYPENAME:securityLogControl_Tval]]

typedef struct
{
	int		securityLogMaxSize<s(1)(1)(0)>[&];
	securityLogGetStatus_Tval<s(1)(1)(0)>[T] securityLogGetStatus<s(1)(1)(0)>[&];
	int		securityLogFullWarningThreshold<s(1)(1)(0)>[&];
	securityLogFullBehavior_Tval<s(1)(1)(0)>[T] securityLogFullBehavior<s(1)(1)(0)>[&];
	securityLogControl_Tval<s(1)(1)(0)>[T] securityLogControl<s(1)(1)(0)>[&];
}MIBsecurityLogGroup_t<s(0)(0)(0)>[&];(D1:MIBsecurityLogGroup_t:1)[[TYPENAME:MIBsecurityLogGroup_t]]










 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbTrapDestinationTable_Did<s(0)(0)(0)>[&];(D1:pbTrapDestinationTable_Did:0)

   
typedef enum {
	trapDestAccessMode_read<s(0)(0)(0)>[&]=1,
	trapDestAccessMode_write<s(0)(0)(0)>[&]=2
} trapDestAccessMode_Tval<s(0)(0)(0)>[&];(D1:trapDestAccessMode_Tval:1)[[TYPENAME:trapDestAccessMode_Tval]]

typedef struct
{
	unsigned int	pbTrapDestIPAddress<s(1)(1)(0)>[&];                                    
	int		pbTrapDestAlarmPort<s(1)(1)(0)>[&];                                            
	int		pbTrapDestOperationPort<s(1)(1)(0)>[&];                                        
	PbUpDown_Tval<s(1)(1)(0)>[T] pbTrapDestAdminStatus<s(1)(1)(0)>[&];   
	RowStatus_Tval<s(1)(1)(0)>[T] pbTrapDestRowStatus<s(1)(1)(0)>[&];   
	trapDestAccessMode_Tval<s(1)(1)(0)>[T] trapDestAccessMode<s(1)(1)(0)>[&];   
	DateTime<s(1)(1)(0)>[T]	trapDestLastWrite<s(1)(1)(0)>[&];   
	char		trapDestUserName<s(1)(1)(0)>[&][66];   
	unsigned int	trapDestClientIP<s(1)(1)(0)>[&];
	unsigned int	trapDestSysUpTime<s(1)(1)(0)>[&];
}MIBpbTrapDestinationTable_t<s(0)(0)(0)>[&];(D1:MIBpbTrapDestinationTable_t:1)[[TYPENAME:MIBpbTrapDestinationTable_t]]

















 



 
extern MIBDid_t<s(0)(0)(0)>[T] writeAccessGroup_Did<s(0)(0)(0)>[&];(D1:writeAccessGroup_Did:0)

   
typedef struct
{
	int		writeAccessTimeout<s(1)(1)(0)>[&];   
	int		writeAccessAutoCleanup<s(1)(1)(0)>[&];
}MIBwriteAccessGroup_t<s(0)(0)(0)>[&];(D1:MIBwriteAccessGroup_t:1)[[TYPENAME:MIBwriteAccessGroup_t]]







 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] portProtectforTCPorUDPTable_Did<s(0)(0)(0)>[&];(D1:portProtectforTCPorUDPTable_Did:0)

   
typedef enum {
	portProtecttype_tcp<s(0)(0)(0)>[&]=1,
	portProtecttype_udp<s(0)(0)(0)>[&]=2
} portProtecttype_Tval<s(0)(0)(0)>[&];(D1:portProtecttype_Tval:1)[[TYPENAME:portProtecttype_Tval]]

typedef struct
{
	int		portProtectIndex<s(1)(1)(0)>[&];                                        
	portProtecttype_Tval<s(1)(1)(0)>[T] portProtecttype<s(1)(1)(0)>[&];                         
	char		portProtectDescrption<s(1)(1)(0)>[&][64];
	RowStatus_Tval<s(1)(1)(0)>[T] portProtectStatus<s(1)(1)(0)>[&];
}MIBportProtectforTCPorUDPTable_t<s(0)(0)(0)>[&];(D1:MIBportProtectforTCPorUDPTable_t:1)[[TYPENAME:MIBportProtectforTCPorUDPTable_t]]











 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] usmUserExtendedTable_Did<s(0)(0)(0)>[&];(D1:usmUserExtendedTable_Did:0)

   
typedef struct
{
	int		usmUserEngineID_len<s(1)(1)(0)>[&];
	char		usmUserEngineID<s(1)(1)(0)>[&][32];                                                  
	char		usmUserName<s(1)(1)(0)>[&][32];                                                      
	RowStatus_Tval<s(1)(1)(0)>[T] usmUserExtRowStatus<s(1)(1)(0)>[&];
	DateTime<s(1)(1)(0)>[T]	usmUserLastSucLogin<s(1)(1)(0)>[&];
	int		usmUserInvalidLoginAttempts<s(1)(1)(0)>[&];
	int		usmUserUnauthAccessAttempts<s(1)(1)(0)>[&];
	int		usmUserPwExpirationDate<s(1)(1)(0)>[&];
	int		usmUserPwExpirationPeriod<s(1)(1)(0)>[&];
	int		usmUserAccountExpirationDate<s(1)(1)(0)>[&];
	int		usmUserID<s(1)(1)(0)>[&];
}MIBusmUserExtendedTable_t<s(0)(0)(0)>[&];(D1:MIBusmUserExtendedTable_t:1)[[TYPENAME:MIBusmUserExtendedTable_t]]

















 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbSecurityModule_Did<s(0)(0)(0)>[&];(D1:pbSecurityModule_Did:0)

   







 




 



 
extern MIBDid_t<s(0)(0)(0)>[T] tasksGroup_Did<s(0)(0)(0)>[&];(D1:tasksGroup_Did:0)

   
typedef struct
{
	char		applTableVer<s(1)(1)(0)>[&][30];
}MIBtasksGroup_t<s(0)(0)(0)>[&];(D1:MIBtasksGroup_t:1)[[TYPENAME:MIBtasksGroup_t]]






 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] applTable_Did<s(0)(0)(0)>[&];(D1:applTable_Did:0)

   
typedef enum {
	applStart_none<s(0)(0)(0)>[&]=0,
	applStart_full<s(0)(0)(0)>[&]=1,
	applStart_diag<s(0)(0)(0)>[&]=2,
	applStart_always<s(0)(0)(0)>[&]=3
} applStart_Tval<s(0)(0)(0)>[&];(D1:applStart_Tval:1)[[TYPENAME:applStart_Tval]]

typedef struct
{
	int		applIndex<s(1)(1)(0)>[&];                                       
	PbBoardFunction_Tval<s(1)(1)(0)>[T] applBoardFunction<s(1)(1)(0)>[&];
	PbBoardProperty_Tval<s(1)(1)(0)>[T] applBoardProperty<s(1)(1)(0)>[&];
	PbBoardStyle_Tval<s(1)(1)(0)>[T] applBoardStyle<s(1)(1)(0)>[&];
	PbChassisType_Tval<s(1)(1)(0)>[T] applChassisType<s(1)(1)(0)>[&];
	char		applName<s(1)(1)(0)>[&][30];
	int		applNumber<s(1)(1)(0)>[&];
	char		applFname<s(1)(1)(0)>[&][15];
	char		applEntryfn<s(1)(1)(0)>[&][30];
	char		applTaskName<s(1)(1)(0)>[&][30];
	int		applTaskPri<s(1)(1)(0)>[&];
	int		applTaskStack<s(1)(1)(0)>[&];
	int		applLogLevels<s(1)(1)(0)>[&];
	int		applOptions<s(1)(1)(0)>[&];
	applStart_Tval<s(1)(1)(0)>[T] applStart<s(1)(1)(0)>[&];
}MIBapplTable_t<s(0)(0)(0)>[&];(D1:MIBapplTable_t:1)[[TYPENAME:MIBapplTable_t]]






















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] aapplTable_Did<s(0)(0)(0)>[&];(D1:aapplTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] aapplSlotNo<s(1)(1)(0)>[&];              
	int		aapplNumber<s(1)(1)(0)>[&];                               
	char		aapplName<s(1)(1)(0)>[&][30];
	int		aapplCpuUsage<s(1)(1)(0)>[&];
	int		aapplLogLevels<s(1)(1)(0)>[&];
	int		aapplOptions<s(1)(1)(0)>[&];
	PbApplState_Tval<s(1)(1)(0)>[T] aapplStatus<s(1)(1)(0)>[&];
	int		aapplLoadOrder<s(1)(1)(0)>[&];
}MIBaapplTable_t<s(0)(0)(0)>[&];(D1:MIBaapplTable_t:1)[[TYPENAME:MIBaapplTable_t]]















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] bootpTable_Did<s(0)(0)(0)>[&];(D1:bootpTable_Did:0)

   
typedef struct
{
	PbBoardStyle_Tval<s(1)(1)(0)>[T] bootpBoardType<s(1)(1)(0)>[&];                  
	char		bootpFname<s(1)(1)(0)>[&][20];   
}MIBbootpTable_t<s(0)(0)(0)>[&];(D1:MIBbootpTable_t:1)[[TYPENAME:MIBbootpTable_t]]









 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbIntVcTable_Did<s(0)(0)(0)>[&];(D1:pbIntVcTable_Did:0)

   
typedef struct
{
	int		pbIntVcLocalIntf<s(1)(1)(0)>[&];                                   
	int		pbIntVcLocalVpi<s(1)(1)(0)>[&];                                    
	int		pbIntVcLocalVci<s(1)(1)(0)>[&];                                    
	int		pbIntVcRemoteIntf<s(1)(1)(0)>[&];                                  
	int		pbIntVcRemoteVpi<s(1)(1)(0)>[&];                                   
	int		pbIntVcRemoteVci<s(1)(1)(0)>[&];                                   
}MIBpbIntVcTable_t<s(0)(0)(0)>[&];(D1:MIBpbIntVcTable_t:1)[[TYPENAME:MIBpbIntVcTable_t]]













 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbFileSystemTable_Did<s(0)(0)(0)>[&];(D1:pbFileSystemTable_Did:0)

   
typedef struct
{
	char		pbFileDir<s(1)(1)(0)>[&][50];                       
	char		pbFileName<s(1)(1)(0)>[&][50];                      
	int		pbFileSize<s(1)(1)(0)>[&];   
	int		pbFileSlot<s(1)(1)(0)>[&];   
}MIBpbFileSystemTable_t<s(0)(0)(0)>[&];(D1:MIBpbFileSystemTable_t:1)[[TYPENAME:MIBpbFileSystemTable_t]]











 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbDivaMTable_Did<s(0)(0)(0)>[&];(D1:pbDivaMTable_Did:0)

   
typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbDivaMslotno<s(1)(1)(0)>[&];             
	int		pbDivaMportno<s(1)(1)(0)>[&];                              
	int		pbDivaMmetric<s(1)(1)(0)>[&];   
}MIBpbDivaMTable_t<s(0)(0)(0)>[&];(D1:MIBpbDivaMTable_t:1)[[TYPENAME:MIBpbDivaMTable_t]]










 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] moduleTable_Did<s(0)(0)(0)>[&];(D1:moduleTable_Did:0)

   
typedef enum {
	moduleStart_none<s(0)(0)(0)>[&]=0,
	moduleStart_full<s(0)(0)(0)>[&]=1,
	moduleStart_diag<s(0)(0)(0)>[&]=2,
	moduleStart_always<s(0)(0)(0)>[&]=3
} moduleStart_Tval<s(0)(0)(0)>[&];(D1:moduleStart_Tval:1)[[TYPENAME:moduleStart_Tval]]

typedef struct
{
	int		moduleIndex<s(1)(1)(0)>[&];                                         
	PbBoardFunction_Tval<s(1)(1)(0)>[T] moduleBoardFunction<s(1)(1)(0)>[&];
	PbBoardProperty_Tval<s(1)(1)(0)>[T] moduleBoardProperty<s(1)(1)(0)>[&];
	PbBoardStyle_Tval<s(1)(1)(0)>[T] moduleBoardStyle<s(1)(1)(0)>[&];
	PbChassisType_Tval<s(1)(1)(0)>[T] moduleChassisType<s(1)(1)(0)>[&];
	char		moduleName<s(1)(1)(0)>[&][30];
	char		moduleFname<s(1)(1)(0)>[&][15];
	moduleStart_Tval<s(1)(1)(0)>[T] moduleStart<s(1)(1)(0)>[&];
	char		moduleInit<s(1)(1)(0)>[&][30];
}MIBmoduleTable_t<s(0)(0)(0)>[&];(D1:MIBmoduleTable_t:1)[[TYPENAME:MIBmoduleTable_t]]
















 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbPortLedsTable_Did<s(0)(0)(0)>[&];(D1:pbPortLedsTable_Did:0)

   
typedef enum {
	pbPortLedColor_off<s(0)(0)(0)>[&]=0,
	pbPortLedColor_green<s(0)(0)(0)>[&]=1,
	pbPortLedColor_yellow<s(0)(0)(0)>[&]=2,
	pbPortLedColor_red<s(0)(0)(0)>[&]=3,
	pbPortLedColor_blinkingGreen<s(0)(0)(0)>[&]=4,
	pbPortLedColor_blinkingYellow<s(0)(0)(0)>[&]=5,
	pbPortLedColor_blinkingRed<s(0)(0)(0)>[&]=6
} pbPortLedColor_Tval<s(0)(0)(0)>[&];(D1:pbPortLedColor_Tval:1)[[TYPENAME:pbPortLedColor_Tval]]

typedef struct
{
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbPortLedProxySlot<s(1)(1)(0)>[&];                  
	PbSlotNumberType_Tval<s(1)(1)(0)>[T] pbPortLedSlot<s(1)(1)(0)>[&];                       
	int		pbPortLedIndexNo<s(1)(1)(0)>[&];                                     
	pbPortLedColor_Tval<s(1)(1)(0)>[T] pbPortLedColor<s(1)(1)(0)>[&];   
}MIBpbPortLedsTable_t<s(0)(0)(0)>[&];(D1:MIBpbPortLedsTable_t:1)[[TYPENAME:MIBpbPortLedsTable_t]]
















 




 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbMgnt_Did<s(0)(0)(0)>[&];(D1:pbMgnt_Did:0)

   
typedef struct
{
	PbEnableDisable_Tval<s(1)(1)(0)>[T] pbTelnetLogin<s(1)(1)(0)>[&];   
	char		pbPhotonCommunityString<s(1)(1)(0)>[&][8];   
	char		pbPhotonTrapCommunity<s(1)(1)(0)>[&][8];   
}MIBpbMgnt_t<s(0)(0)(0)>[&];(D1:MIBpbMgnt_t:1)[[TYPENAME:MIBpbMgnt_t]]








 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbUserTable_Did<s(0)(0)(0)>[&];(D1:pbUserTable_Did:0)

   
typedef struct
{
	char		pbUserName<s(1)(1)(0)>[&][64];                                                  
	char		pbUserPassword<s(1)(1)(0)>[&][64];   
	int		pbUserInactivityTimeout<s(1)(1)(0)>[&];   
	PbUserAccessLevel_Tval<s(1)(1)(0)>[T] pbUserAccessLevel<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbUserLoggedIn<s(1)(1)(0)>[&];   
	int		pbUserTimeLoggedIn<s(1)(1)(0)>[&];   
	int		pbUserLastAccessed<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbUserAccessBrowser<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbUserAccessCraft<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbUserAccessTL1<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbUserAccessFTP<s(1)(1)(0)>[&];   
	TruthValue_Tval<s(1)(1)(0)>[T] pbUserAccessCLI<s(1)(1)(0)>[&];   
	PbEnableDisable_Tval<s(1)(1)(0)>[T] pbCriticalAudible<s(1)(1)(0)>[&];   
	PbEnableDisable_Tval<s(1)(1)(0)>[T] pbMajorAudible<s(1)(1)(0)>[&];   
	PbEnableDisable_Tval<s(1)(1)(0)>[T] pbMinorAudible<s(1)(1)(0)>[&];   
	PbEnableDisable_Tval<s(1)(1)(0)>[T] pbWarningAudible<s(1)(1)(0)>[&];   
	PbEnableDisable_Tval<s(1)(1)(0)>[T] pbInfoAudible<s(1)(1)(0)>[&];   
	PbEnableDisable_Tval<s(1)(1)(0)>[T] pbCriticalVisual<s(1)(1)(0)>[&];   
	PbEnableDisable_Tval<s(1)(1)(0)>[T] pbMajorVisual<s(1)(1)(0)>[&];   
	PbEnableDisable_Tval<s(1)(1)(0)>[T] pbMinorVisual<s(1)(1)(0)>[&];   
	PbEnableDisable_Tval<s(1)(1)(0)>[T] pbWarningVisual<s(1)(1)(0)>[&];   
	PbEnableDisable_Tval<s(1)(1)(0)>[T] pbInfoVisual<s(1)(1)(0)>[&];   
	PbUserAccessLevel_Tval<s(1)(1)(0)>[T] pbUserCurrentAccessLevel<s(1)(1)(0)>[&];   
	RowStatus_Tval<s(1)(1)(0)>[T] pbUserRowStatus<s(1)(1)(0)>[&];   
	int		pbUserLoginCount<s(1)(1)(0)>[&];   
}MIBpbUserTable_t<s(0)(0)(0)>[&];(D1:MIBpbUserTable_t:1)[[TYPENAME:MIBpbUserTable_t]]
































 



 
 
extern MIBDid_t<s(0)(0)(0)>[T] pbCommunityStrTable_Did<s(0)(0)(0)>[&];(D1:pbCommunityStrTable_Did:0)

   
typedef struct
{
	char		pbCommunityStringName<s(1)(1)(0)>[&][32];                                               
	PbCommunityStringAccessLevel_Tval<s(1)(1)(0)>[T] pbCommunityStringAccessLevel<s(1)(1)(0)>[&];   
	RowStatus_Tval<s(1)(1)(0)>[T] pbCommunityStringRowStatus<s(1)(1)(0)>[&];   
	char		pbCommunityStringComment<s(1)(1)(0)>[&][64];   
}MIBpbCommunityStrTable_t<s(0)(0)(0)>[&];(D1:MIBpbCommunityStrTable_t:1)[[TYPENAME:MIBpbCommunityStrTable_t]]











 



 
extern MIBDid_t<s(0)(0)(0)>[T] pbPrivateManagement_Did<s(0)(0)(0)>[&];(D1:pbPrivateManagement_Did:0)

   




typedef struct {
	MIBDID<s(1)(1)(0)>[T] did<s(1)(1)(0)>[&];
	int    last_oid<s(1)(1)(0)>[&];
} LeafInfo<s(0)(0)(0)>[&];(D1:LeafInfo:1)[[TYPENAME:LeafInfo]]

extern LeafInfo<s(0)(0)(0)>[T] pbUserTable_cookie<s(0)(0)(0)>[&];(D1:pbUserTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTelnetLogin_cookie<s(0)(0)(0)>[&];(D1:pbTelnetLogin_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCommunityStrTable_cookie<s(0)(0)(0)>[&];(D1:pbCommunityStrTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPhotonCommunityString_cookie<s(0)(0)(0)>[&];(D1:pbPhotonCommunityString_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPhotonTrapCommunity_cookie<s(0)(0)(0)>[&];(D1:pbPhotonTrapCommunity_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCommunityStringName_cookie<s(0)(0)(0)>[&];(D1:pbCommunityStringName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCommunityStringAccessLevel_cookie<s(0)(0)(0)>[&];(D1:pbCommunityStringAccessLevel_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCommunityStringRowStatus_cookie<s(0)(0)(0)>[&];(D1:pbCommunityStringRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCommunityStringComment_cookie<s(0)(0)(0)>[&];(D1:pbCommunityStringComment_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUserName_cookie<s(0)(0)(0)>[&];(D1:pbUserName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUserPassword_cookie<s(0)(0)(0)>[&];(D1:pbUserPassword_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUserInactivityTimeout_cookie<s(0)(0)(0)>[&];(D1:pbUserInactivityTimeout_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUserAccessLevel_cookie<s(0)(0)(0)>[&];(D1:pbUserAccessLevel_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUserLoggedIn_cookie<s(0)(0)(0)>[&];(D1:pbUserLoggedIn_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUserTimeLoggedIn_cookie<s(0)(0)(0)>[&];(D1:pbUserTimeLoggedIn_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUserLastAccessed_cookie<s(0)(0)(0)>[&];(D1:pbUserLastAccessed_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUserAccessBrowser_cookie<s(0)(0)(0)>[&];(D1:pbUserAccessBrowser_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUserAccessCraft_cookie<s(0)(0)(0)>[&];(D1:pbUserAccessCraft_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUserAccessTL1_cookie<s(0)(0)(0)>[&];(D1:pbUserAccessTL1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUserAccessFTP_cookie<s(0)(0)(0)>[&];(D1:pbUserAccessFTP_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUserAccessCLI_cookie<s(0)(0)(0)>[&];(D1:pbUserAccessCLI_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCriticalAudible_cookie<s(0)(0)(0)>[&];(D1:pbCriticalAudible_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMajorAudible_cookie<s(0)(0)(0)>[&];(D1:pbMajorAudible_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMinorAudible_cookie<s(0)(0)(0)>[&];(D1:pbMinorAudible_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbWarningAudible_cookie<s(0)(0)(0)>[&];(D1:pbWarningAudible_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbInfoAudible_cookie<s(0)(0)(0)>[&];(D1:pbInfoAudible_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCriticalVisual_cookie<s(0)(0)(0)>[&];(D1:pbCriticalVisual_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMajorVisual_cookie<s(0)(0)(0)>[&];(D1:pbMajorVisual_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMinorVisual_cookie<s(0)(0)(0)>[&];(D1:pbMinorVisual_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbWarningVisual_cookie<s(0)(0)(0)>[&];(D1:pbWarningVisual_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbInfoVisual_cookie<s(0)(0)(0)>[&];(D1:pbInfoVisual_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUserCurrentAccessLevel_cookie<s(0)(0)(0)>[&];(D1:pbUserCurrentAccessLevel_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUserRowStatus_cookie<s(0)(0)(0)>[&];(D1:pbUserRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUserLoginCount_cookie<s(0)(0)(0)>[&];(D1:pbUserLoginCount_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] dod_cookie<s(0)(0)(0)>[&];(D1:dod_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] internet_cookie<s(0)(0)(0)>[&];(D1:internet_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mgmt_cookie<s(0)(0)(0)>[&];(D1:mgmt_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] private_cookie<s(0)(0)(0)>[&];(D1:private_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpV2_cookie<s(0)(0)(0)>[&];(D1:snmpV2_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpModules_cookie<s(0)(0)(0)>[&];(D1:snmpModules_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpMIB_cookie<s(0)(0)(0)>[&];(D1:snmpMIB_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpFrameworkMIB_cookie<s(0)(0)(0)>[&];(D1:snmpFrameworkMIB_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpMPDMIB_cookie<s(0)(0)(0)>[&];(D1:snmpMPDMIB_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpTargetMIB_cookie<s(0)(0)(0)>[&];(D1:snmpTargetMIB_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpNotificationMIB_cookie<s(0)(0)(0)>[&];(D1:snmpNotificationMIB_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpUsmMIB_cookie<s(0)(0)(0)>[&];(D1:snmpUsmMIB_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpVacmMIB_cookie<s(0)(0)(0)>[&];(D1:snmpVacmMIB_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpCommunityMIB_cookie<s(0)(0)(0)>[&];(D1:snmpCommunityMIB_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpCommunityMIBObjects_cookie<s(0)(0)(0)>[&];(D1:snmpCommunityMIBObjects_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpCommunityMIBConformance_cookie<s(0)(0)(0)>[&];(D1:snmpCommunityMIBConformance_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpCommunityMIBCompliances_cookie<s(0)(0)(0)>[&];(D1:snmpCommunityMIBCompliances_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpCommunityMIBGroups_cookie<s(0)(0)(0)>[&];(D1:snmpCommunityMIBGroups_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpCommunityTable_cookie<s(0)(0)(0)>[&];(D1:snmpCommunityTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpTargetAddrExtTable_cookie<s(0)(0)(0)>[&];(D1:snmpTargetAddrExtTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpTrapAddress_cookie<s(0)(0)(0)>[&];(D1:snmpTrapAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpTrapCommunity_cookie<s(0)(0)(0)>[&];(D1:snmpTrapCommunity_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpTargetAddrName_cookie<s(0)(0)(0)>[&];(D1:snmpTargetAddrName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpTargetAddrTMask_cookie<s(0)(0)(0)>[&];(D1:snmpTargetAddrTMask_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpTargetAddrMMS_cookie<s(0)(0)(0)>[&];(D1:snmpTargetAddrMMS_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpCommunityIndex_cookie<s(0)(0)(0)>[&];(D1:snmpCommunityIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpCommunityName_cookie<s(0)(0)(0)>[&];(D1:snmpCommunityName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpCommunitySecurityName_cookie<s(0)(0)(0)>[&];(D1:snmpCommunitySecurityName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpCommunityContextEngineID_cookie<s(0)(0)(0)>[&];(D1:snmpCommunityContextEngineID_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpCommunityContextName_cookie<s(0)(0)(0)>[&];(D1:snmpCommunityContextName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpCommunityTransportTag_cookie<s(0)(0)(0)>[&];(D1:snmpCommunityTransportTag_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpCommunityStorageType_cookie<s(0)(0)(0)>[&];(D1:snmpCommunityStorageType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpCommunityStatus_cookie<s(0)(0)(0)>[&];(D1:snmpCommunityStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vacmMIBObjects_cookie<s(0)(0)(0)>[&];(D1:vacmMIBObjects_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vacmMIBConformance_cookie<s(0)(0)(0)>[&];(D1:vacmMIBConformance_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vacmMIBCompliances_cookie<s(0)(0)(0)>[&];(D1:vacmMIBCompliances_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vacmMIBGroups_cookie<s(0)(0)(0)>[&];(D1:vacmMIBGroups_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vacmContextTable_cookie<s(0)(0)(0)>[&];(D1:vacmContextTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vacmSecurityToGroupTable_cookie<s(0)(0)(0)>[&];(D1:vacmSecurityToGroupTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vacmAccessTable_cookie<s(0)(0)(0)>[&];(D1:vacmAccessTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vacmMIBViews_cookie<s(0)(0)(0)>[&];(D1:vacmMIBViews_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vacmViewSpinLock_cookie<s(0)(0)(0)>[&];(D1:vacmViewSpinLock_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vacmViewTreeFamilyTable_cookie<s(0)(0)(0)>[&];(D1:vacmViewTreeFamilyTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vacmViewTreeFamilyViewName_cookie<s(0)(0)(0)>[&];(D1:vacmViewTreeFamilyViewName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vacmViewTreeFamilySubtree_cookie<s(0)(0)(0)>[&];(D1:vacmViewTreeFamilySubtree_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vacmViewTreeFamilyMask_cookie<s(0)(0)(0)>[&];(D1:vacmViewTreeFamilyMask_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vacmViewTreeFamilyType_cookie<s(0)(0)(0)>[&];(D1:vacmViewTreeFamilyType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vacmViewTreeFamilyStorageType_cookie<s(0)(0)(0)>[&];(D1:vacmViewTreeFamilyStorageType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vacmViewTreeFamilyStatus_cookie<s(0)(0)(0)>[&];(D1:vacmViewTreeFamilyStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vacmGroupName_cookie<s(0)(0)(0)>[&];(D1:vacmGroupName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vacmAccessContextPrefix_cookie<s(0)(0)(0)>[&];(D1:vacmAccessContextPrefix_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vacmAccessSecurityModel_cookie<s(0)(0)(0)>[&];(D1:vacmAccessSecurityModel_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vacmAccessSecurityLevel_cookie<s(0)(0)(0)>[&];(D1:vacmAccessSecurityLevel_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vacmAccessContextMatch_cookie<s(0)(0)(0)>[&];(D1:vacmAccessContextMatch_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vacmAccessReadViewName_cookie<s(0)(0)(0)>[&];(D1:vacmAccessReadViewName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vacmAccessWriteViewName_cookie<s(0)(0)(0)>[&];(D1:vacmAccessWriteViewName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vacmAccessNotifyViewName_cookie<s(0)(0)(0)>[&];(D1:vacmAccessNotifyViewName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vacmAccessStorageType_cookie<s(0)(0)(0)>[&];(D1:vacmAccessStorageType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vacmAccessStatus_cookie<s(0)(0)(0)>[&];(D1:vacmAccessStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vacmSecurityModel_cookie<s(0)(0)(0)>[&];(D1:vacmSecurityModel_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vacmSecurityName_cookie<s(0)(0)(0)>[&];(D1:vacmSecurityName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vacmGroupName_cookie<s(0)(0)(0)>[&];(D1:vacmGroupName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vacmSecurityToGroupStorageType_cookie<s(0)(0)(0)>[&];(D1:vacmSecurityToGroupStorageType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vacmSecurityToGroupStatus_cookie<s(0)(0)(0)>[&];(D1:vacmSecurityToGroupStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vacmContextName_cookie<s(0)(0)(0)>[&];(D1:vacmContextName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmMIBObjects_cookie<s(0)(0)(0)>[&];(D1:usmMIBObjects_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmMIBConformance_cookie<s(0)(0)(0)>[&];(D1:usmMIBConformance_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmMIBCompliances_cookie<s(0)(0)(0)>[&];(D1:usmMIBCompliances_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmMIBGroups_cookie<s(0)(0)(0)>[&];(D1:usmMIBGroups_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmStats_cookie<s(0)(0)(0)>[&];(D1:usmStats_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmUser_cookie<s(0)(0)(0)>[&];(D1:usmUser_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmUserSpinLock_cookie<s(0)(0)(0)>[&];(D1:usmUserSpinLock_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmUserTable_cookie<s(0)(0)(0)>[&];(D1:usmUserTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmUserEngineID_cookie<s(0)(0)(0)>[&];(D1:usmUserEngineID_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmUserName_cookie<s(0)(0)(0)>[&];(D1:usmUserName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmUserSecurityName_cookie<s(0)(0)(0)>[&];(D1:usmUserSecurityName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmUserCloneFrom_cookie<s(0)(0)(0)>[&];(D1:usmUserCloneFrom_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmUserAuthProtocol_cookie<s(0)(0)(0)>[&];(D1:usmUserAuthProtocol_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmUserAuthKeyChange_cookie<s(0)(0)(0)>[&];(D1:usmUserAuthKeyChange_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmUserOwnAuthKeyChange_cookie<s(0)(0)(0)>[&];(D1:usmUserOwnAuthKeyChange_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmUserPrivProtocol_cookie<s(0)(0)(0)>[&];(D1:usmUserPrivProtocol_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmUserPrivKeyChange_cookie<s(0)(0)(0)>[&];(D1:usmUserPrivKeyChange_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmUserOwnPrivKeyChange_cookie<s(0)(0)(0)>[&];(D1:usmUserOwnPrivKeyChange_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmUserPublic_cookie<s(0)(0)(0)>[&];(D1:usmUserPublic_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmUserStorageType_cookie<s(0)(0)(0)>[&];(D1:usmUserStorageType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmUserStatus_cookie<s(0)(0)(0)>[&];(D1:usmUserStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmStatsUnsupportedSecLevels_cookie<s(0)(0)(0)>[&];(D1:usmStatsUnsupportedSecLevels_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmStatsNotInTimeWindows_cookie<s(0)(0)(0)>[&];(D1:usmStatsNotInTimeWindows_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmStatsUnknownUserNames_cookie<s(0)(0)(0)>[&];(D1:usmStatsUnknownUserNames_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmStatsUnknownEngineIDs_cookie<s(0)(0)(0)>[&];(D1:usmStatsUnknownEngineIDs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmStatsWrongDigests_cookie<s(0)(0)(0)>[&];(D1:usmStatsWrongDigests_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmStatsDecryptionErrors_cookie<s(0)(0)(0)>[&];(D1:usmStatsDecryptionErrors_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpNotifyObjects_cookie<s(0)(0)(0)>[&];(D1:snmpNotifyObjects_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpNotifyConformance_cookie<s(0)(0)(0)>[&];(D1:snmpNotifyConformance_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpNotifyCompliances_cookie<s(0)(0)(0)>[&];(D1:snmpNotifyCompliances_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpNotifyGroups_cookie<s(0)(0)(0)>[&];(D1:snmpNotifyGroups_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpNotifyTable_cookie<s(0)(0)(0)>[&];(D1:snmpNotifyTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpNotifyFilterProfileTable_cookie<s(0)(0)(0)>[&];(D1:snmpNotifyFilterProfileTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpNotifyFilterTable_cookie<s(0)(0)(0)>[&];(D1:snmpNotifyFilterTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpNotifyFilterProfileName_cookie<s(0)(0)(0)>[&];(D1:snmpNotifyFilterProfileName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpNotifyFilterSubtree_cookie<s(0)(0)(0)>[&];(D1:snmpNotifyFilterSubtree_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpNotifyFilterMask_cookie<s(0)(0)(0)>[&];(D1:snmpNotifyFilterMask_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpNotifyFilterType_cookie<s(0)(0)(0)>[&];(D1:snmpNotifyFilterType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpNotifyFilterStorageType_cookie<s(0)(0)(0)>[&];(D1:snmpNotifyFilterStorageType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpNotifyFilterRowStatus_cookie<s(0)(0)(0)>[&];(D1:snmpNotifyFilterRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpTargetParamsName_cookie<s(0)(0)(0)>[&];(D1:snmpTargetParamsName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpNotifyFilterProfileName_cookie<s(0)(0)(0)>[&];(D1:snmpNotifyFilterProfileName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpNotifyFilterProfileStorType_cookie<s(0)(0)(0)>[&];(D1:snmpNotifyFilterProfileStorType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpNotifyFilterProfileRowStatus_cookie<s(0)(0)(0)>[&];(D1:snmpNotifyFilterProfileRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpNotifyName_cookie<s(0)(0)(0)>[&];(D1:snmpNotifyName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpNotifyTag_cookie<s(0)(0)(0)>[&];(D1:snmpNotifyTag_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpNotifyType_cookie<s(0)(0)(0)>[&];(D1:snmpNotifyType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpNotifyStorageType_cookie<s(0)(0)(0)>[&];(D1:snmpNotifyStorageType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpNotifyRowStatus_cookie<s(0)(0)(0)>[&];(D1:snmpNotifyRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpTargetObjects_cookie<s(0)(0)(0)>[&];(D1:snmpTargetObjects_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpTargetConformance_cookie<s(0)(0)(0)>[&];(D1:snmpTargetConformance_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpTargetCompliances_cookie<s(0)(0)(0)>[&];(D1:snmpTargetCompliances_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpTargetGroups_cookie<s(0)(0)(0)>[&];(D1:snmpTargetGroups_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpTargetSpinLock_cookie<s(0)(0)(0)>[&];(D1:snmpTargetSpinLock_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpTargetAddrTable_cookie<s(0)(0)(0)>[&];(D1:snmpTargetAddrTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpTargetParamsTable_cookie<s(0)(0)(0)>[&];(D1:snmpTargetParamsTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpUnavailableContexts_cookie<s(0)(0)(0)>[&];(D1:snmpUnavailableContexts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpUnknownContexts_cookie<s(0)(0)(0)>[&];(D1:snmpUnknownContexts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpTargetParamsName_cookie<s(0)(0)(0)>[&];(D1:snmpTargetParamsName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpTargetParamsMPModel_cookie<s(0)(0)(0)>[&];(D1:snmpTargetParamsMPModel_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpTargetParamsSecurityModel_cookie<s(0)(0)(0)>[&];(D1:snmpTargetParamsSecurityModel_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpTargetParamsSecurityName_cookie<s(0)(0)(0)>[&];(D1:snmpTargetParamsSecurityName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpTargetParamsSecurityLevel_cookie<s(0)(0)(0)>[&];(D1:snmpTargetParamsSecurityLevel_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpTargetParamsStorageType_cookie<s(0)(0)(0)>[&];(D1:snmpTargetParamsStorageType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpTargetParamsRowStatus_cookie<s(0)(0)(0)>[&];(D1:snmpTargetParamsRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpTargetAddrName_cookie<s(0)(0)(0)>[&];(D1:snmpTargetAddrName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpTargetAddrTDomain_cookie<s(0)(0)(0)>[&];(D1:snmpTargetAddrTDomain_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpTargetAddrTAddress_cookie<s(0)(0)(0)>[&];(D1:snmpTargetAddrTAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpTargetAddrTimeout_cookie<s(0)(0)(0)>[&];(D1:snmpTargetAddrTimeout_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpTargetAddrRetryCount_cookie<s(0)(0)(0)>[&];(D1:snmpTargetAddrRetryCount_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpTargetAddrTagList_cookie<s(0)(0)(0)>[&];(D1:snmpTargetAddrTagList_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpTargetAddrParams_cookie<s(0)(0)(0)>[&];(D1:snmpTargetAddrParams_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpTargetAddrStorageType_cookie<s(0)(0)(0)>[&];(D1:snmpTargetAddrStorageType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpTargetAddrRowStatus_cookie<s(0)(0)(0)>[&];(D1:snmpTargetAddrRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpMPDAdmin_cookie<s(0)(0)(0)>[&];(D1:snmpMPDAdmin_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpMPDMIBObjects_cookie<s(0)(0)(0)>[&];(D1:snmpMPDMIBObjects_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpMPDMIBConformance_cookie<s(0)(0)(0)>[&];(D1:snmpMPDMIBConformance_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpMPDMIBCompliances_cookie<s(0)(0)(0)>[&];(D1:snmpMPDMIBCompliances_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpMPDMIBGroups_cookie<s(0)(0)(0)>[&];(D1:snmpMPDMIBGroups_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpMPDStats_cookie<s(0)(0)(0)>[&];(D1:snmpMPDStats_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpUnknownSecurityModels_cookie<s(0)(0)(0)>[&];(D1:snmpUnknownSecurityModels_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpInvalidMsgs_cookie<s(0)(0)(0)>[&];(D1:snmpInvalidMsgs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpUnknownPDUHandlers_cookie<s(0)(0)(0)>[&];(D1:snmpUnknownPDUHandlers_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpFrameworkAdmin_cookie<s(0)(0)(0)>[&];(D1:snmpFrameworkAdmin_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpFrameworkMIBObjects_cookie<s(0)(0)(0)>[&];(D1:snmpFrameworkMIBObjects_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpFrameworkMIBConformance_cookie<s(0)(0)(0)>[&];(D1:snmpFrameworkMIBConformance_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpFrameworkMIBCompliances_cookie<s(0)(0)(0)>[&];(D1:snmpFrameworkMIBCompliances_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpFrameworkMIBGroups_cookie<s(0)(0)(0)>[&];(D1:snmpFrameworkMIBGroups_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpEngine_cookie<s(0)(0)(0)>[&];(D1:snmpEngine_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpEngineID_cookie<s(0)(0)(0)>[&];(D1:snmpEngineID_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpEngineBoots_cookie<s(0)(0)(0)>[&];(D1:snmpEngineBoots_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpEngineTime_cookie<s(0)(0)(0)>[&];(D1:snmpEngineTime_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpEngineMaxMessageSize_cookie<s(0)(0)(0)>[&];(D1:snmpEngineMaxMessageSize_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpAuthProtocols_cookie<s(0)(0)(0)>[&];(D1:snmpAuthProtocols_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpPrivProtocols_cookie<s(0)(0)(0)>[&];(D1:snmpPrivProtocols_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmNoPrivProtocol_cookie<s(0)(0)(0)>[&];(D1:usmNoPrivProtocol_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmDESPrivProtocol_cookie<s(0)(0)(0)>[&];(D1:usmDESPrivProtocol_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmNoAuthProtocol_cookie<s(0)(0)(0)>[&];(D1:usmNoAuthProtocol_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmHMACMD5AuthProtocol_cookie<s(0)(0)(0)>[&];(D1:usmHMACMD5AuthProtocol_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmHMACSHAAuthProtocol_cookie<s(0)(0)(0)>[&];(D1:usmHMACSHAAuthProtocol_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpMIBObjects_cookie<s(0)(0)(0)>[&];(D1:snmpMIBObjects_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpMIBConformance_cookie<s(0)(0)(0)>[&];(D1:snmpMIBConformance_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpMIBCompliances_cookie<s(0)(0)(0)>[&];(D1:snmpMIBCompliances_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpMIBGroups_cookie<s(0)(0)(0)>[&];(D1:snmpMIBGroups_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpTrap_cookie<s(0)(0)(0)>[&];(D1:snmpTrap_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpTraps_cookie<s(0)(0)(0)>[&];(D1:snmpTraps_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpSet_cookie<s(0)(0)(0)>[&];(D1:snmpSet_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpSetSerialNo_cookie<s(0)(0)(0)>[&];(D1:snmpSetSerialNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpTrapOID_cookie<s(0)(0)(0)>[&];(D1:snmpTrapOID_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpTrapEnterprise_cookie<s(0)(0)(0)>[&];(D1:snmpTrapEnterprise_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] enterprises_cookie<s(0)(0)(0)>[&];(D1:enterprises_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] enterpriseRoot_cookie<s(0)(0)(0)>[&];(D1:enterpriseRoot_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] enterpriseCommonRoot_cookie<s(0)(0)(0)>[&];(D1:enterpriseCommonRoot_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] enterpriseReg_cookie<s(0)(0)(0)>[&];(D1:enterpriseReg_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] enterpriseGeneric_cookie<s(0)(0)(0)>[&];(D1:enterpriseGeneric_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] enterpriseProducts_cookie<s(0)(0)(0)>[&];(D1:enterpriseProducts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] enterpriseCaps_cookie<s(0)(0)(0)>[&];(D1:enterpriseCaps_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] enterpriseReqs_cookie<s(0)(0)(0)>[&];(D1:enterpriseReqs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] enterpriseExpr_cookie<s(0)(0)(0)>[&];(D1:enterpriseExpr_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] productSeries1Products_cookie<s(0)(0)(0)>[&];(D1:productSeries1Products_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] productSeries1Common_cookie<s(0)(0)(0)>[&];(D1:productSeries1Common_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] productSeries1CmnConf_cookie<s(0)(0)(0)>[&];(D1:productSeries1CmnConf_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] productSeries1CmnObjs_cookie<s(0)(0)(0)>[&];(D1:productSeries1CmnObjs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] productSeries1CmnEvents_cookie<s(0)(0)(0)>[&];(D1:productSeries1CmnEvents_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] productSeries1CmnTCs_cookie<s(0)(0)(0)>[&];(D1:productSeries1CmnTCs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] productSeries1TrapGroup_cookie<s(0)(0)(0)>[&];(D1:productSeries1TrapGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTrapTimeStamp_cookie<s(0)(0)(0)>[&];(D1:pbTrapTimeStamp_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbNode_cookie<s(0)(0)(0)>[&];(D1:pbNode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEvents_cookie<s(0)(0)(0)>[&];(D1:pbEvents_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCircuitBasedTransport_cookie<s(0)(0)(0)>[&];(D1:pbCircuitBasedTransport_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMS_cookie<s(0)(0)(0)>[&];(D1:pbTMS_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOspf_cookie<s(0)(0)(0)>[&];(D1:pbOspf_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMoln_cookie<s(0)(0)(0)>[&];(D1:pbMoln_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDcc_cookie<s(0)(0)(0)>[&];(D1:pbDcc_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthernet_cookie<s(0)(0)(0)>[&];(D1:pbEthernet_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDiagnostics_cookie<s(0)(0)(0)>[&];(D1:pbDiagnostics_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOpticsMonitor_cookie<s(0)(0)(0)>[&];(D1:pbOpticsMonitor_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPowerCircuitMonitor_cookie<s(0)(0)(0)>[&];(D1:pbPowerCircuitMonitor_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOr_cookie<s(0)(0)(0)>[&];(D1:pbOr_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTrunk_cookie<s(0)(0)(0)>[&];(D1:pbTrunk_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXcExtend_cookie<s(0)(0)(0)>[&];(D1:pbXcExtend_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSdhXcTable_cookie<s(0)(0)(0)>[&];(D1:pbSdhXcTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRpr_cookie<s(0)(0)(0)>[&];(D1:pbRpr_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOAObjects_cookie<s(0)(0)(0)>[&];(D1:pbOAObjects_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOsi_cookie<s(0)(0)(0)>[&];(D1:pbOsi_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIpTunnel_cookie<s(0)(0)(0)>[&];(D1:pbIpTunnel_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbProtection_cookie<s(0)(0)(0)>[&];(D1:pbProtection_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSecurity_cookie<s(0)(0)(0)>[&];(D1:pbSecurity_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] securityGlobalSettingGroup_cookie<s(0)(0)(0)>[&];(D1:securityGlobalSettingGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] securityAlarmInhibitGroup_cookie<s(0)(0)(0)>[&];(D1:securityAlarmInhibitGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpSecurityGroup_cookie<s(0)(0)(0)>[&];(D1:snmpSecurityGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] securityLogGroup_cookie<s(0)(0)(0)>[&];(D1:securityLogGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTrapDestinationTable_cookie<s(0)(0)(0)>[&];(D1:pbTrapDestinationTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] writeAccessGroup_cookie<s(0)(0)(0)>[&];(D1:writeAccessGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] portProtectforTCPorUDPTable_cookie<s(0)(0)(0)>[&];(D1:portProtectforTCPorUDPTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] portProtectIndex_cookie<s(0)(0)(0)>[&];(D1:portProtectIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] portProtecttype_cookie<s(0)(0)(0)>[&];(D1:portProtecttype_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] portProtectDescrption_cookie<s(0)(0)(0)>[&];(D1:portProtectDescrption_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] portProtectStatus_cookie<s(0)(0)(0)>[&];(D1:portProtectStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] writeAccessTimeout_cookie<s(0)(0)(0)>[&];(D1:writeAccessTimeout_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] writeAccessAutoCleanup_cookie<s(0)(0)(0)>[&];(D1:writeAccessAutoCleanup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTrapDestIPAddress_cookie<s(0)(0)(0)>[&];(D1:pbTrapDestIPAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTrapDestAlarmPort_cookie<s(0)(0)(0)>[&];(D1:pbTrapDestAlarmPort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTrapDestOperationPort_cookie<s(0)(0)(0)>[&];(D1:pbTrapDestOperationPort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTrapDestAdminStatus_cookie<s(0)(0)(0)>[&];(D1:pbTrapDestAdminStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTrapDestRowStatus_cookie<s(0)(0)(0)>[&];(D1:pbTrapDestRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] trapDestAccessMode_cookie<s(0)(0)(0)>[&];(D1:trapDestAccessMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] trapDestLastWrite_cookie<s(0)(0)(0)>[&];(D1:trapDestLastWrite_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] trapDestUserName_cookie<s(0)(0)(0)>[&];(D1:trapDestUserName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] trapDestClientIP_cookie<s(0)(0)(0)>[&];(D1:trapDestClientIP_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] trapDestSysUpTime_cookie<s(0)(0)(0)>[&];(D1:trapDestSysUpTime_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] securityLogMaxSize_cookie<s(0)(0)(0)>[&];(D1:securityLogMaxSize_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] securityLogGetStatus_cookie<s(0)(0)(0)>[&];(D1:securityLogGetStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] securityLogFullWarningThreshold_cookie<s(0)(0)(0)>[&];(D1:securityLogFullWarningThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] securityLogFullBehavior_cookie<s(0)(0)(0)>[&];(D1:securityLogFullBehavior_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] securityLogControl_cookie<s(0)(0)(0)>[&];(D1:securityLogControl_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmUserExtendedTable_cookie<s(0)(0)(0)>[&];(D1:usmUserExtendedTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmUserEngineID_cookie<s(0)(0)(0)>[&];(D1:usmUserEngineID_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmUserName_cookie<s(0)(0)(0)>[&];(D1:usmUserName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmUserExtRowStatus_cookie<s(0)(0)(0)>[&];(D1:usmUserExtRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmUserLastSucLogin_cookie<s(0)(0)(0)>[&];(D1:usmUserLastSucLogin_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmUserInvalidLoginAttempts_cookie<s(0)(0)(0)>[&];(D1:usmUserInvalidLoginAttempts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmUserUnauthAccessAttempts_cookie<s(0)(0)(0)>[&];(D1:usmUserUnauthAccessAttempts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmUserPwExpirationDate_cookie<s(0)(0)(0)>[&];(D1:usmUserPwExpirationDate_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmUserPwExpirationPeriod_cookie<s(0)(0)(0)>[&];(D1:usmUserPwExpirationPeriod_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmUserAccountExpirationDate_cookie<s(0)(0)(0)>[&];(D1:usmUserAccountExpirationDate_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] usmUserID_cookie<s(0)(0)(0)>[&];(D1:usmUserID_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] securityULEInhibit_cookie<s(0)(0)(0)>[&];(D1:securityULEInhibit_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] securityUAInhibit_cookie<s(0)(0)(0)>[&];(D1:securityUAInhibit_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] securityAEDInhibit_cookie<s(0)(0)(0)>[&];(D1:securityAEDInhibit_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] securityLTWInhibit_cookie<s(0)(0)(0)>[&];(D1:securityLTWInhibit_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] securityLFAInhibit_cookie<s(0)(0)(0)>[&];(D1:securityLFAInhibit_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] securityPasswordMinLen_cookie<s(0)(0)(0)>[&];(D1:securityPasswordMinLen_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] securityMaxInvalidLogin_cookie<s(0)(0)(0)>[&];(D1:securityMaxInvalidLogin_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] securityUnauthorizedAccessThreshold_cookie<s(0)(0)(0)>[&];(D1:securityUnauthorizedAccessThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] securityTCBehavior_cookie<s(0)(0)(0)>[&];(D1:securityTCBehavior_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] epgGroup_cookie<s(0)(0)(0)>[&];(D1:epgGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] msspringGroup_cookie<s(0)(0)(0)>[&];(D1:msspringGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mspGroup_cookie<s(0)(0)(0)>[&];(D1:mspGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] sncpGroup_cookie<s(0)(0)(0)>[&];(D1:sncpGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fGroup_cookie<s(0)(0)(0)>[&];(D1:mssp4fGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fConfigTable_cookie<s(0)(0)(0)>[&];(D1:mssp4fConfigTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fTopologyTable_cookie<s(0)(0)(0)>[&];(D1:mssp4fTopologyTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fCommandTable_cookie<s(0)(0)(0)>[&];(D1:mssp4fCommandTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeStatusTable_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeStatusTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fAutoMappingTable_cookie<s(0)(0)(0)>[&];(D1:mssp4fAutoMappingTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fXcTable_cookie<s(0)(0)(0)>[&];(D1:mssp4fXcTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fRingId_cookie<s(0)(0)(0)>[&];(D1:mssp4fRingId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeId_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fXcSide_cookie<s(0)(0)(0)>[&];(D1:mssp4fXcSide_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fXcTimeSlot_cookie<s(0)(0)(0)>[&];(D1:mssp4fXcTimeSlot_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fXcOrder_cookie<s(0)(0)(0)>[&];(D1:mssp4fXcOrder_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fXcType_cookie<s(0)(0)(0)>[&];(D1:mssp4fXcType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fRingId_cookie<s(0)(0)(0)>[&];(D1:mssp4fRingId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeId_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fWestWorkMappingString_cookie<s(0)(0)(0)>[&];(D1:mssp4fWestWorkMappingString_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fEastWorkMappingString_cookie<s(0)(0)(0)>[&];(D1:mssp4fEastWorkMappingString_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fAutomappingRowStatus_cookie<s(0)(0)(0)>[&];(D1:mssp4fAutomappingRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fRingId_cookie<s(0)(0)(0)>[&];(D1:mssp4fRingId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeAgentState_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeAgentState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeState_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeCurrentSide_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeCurrentSide_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeCurrentReq_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeCurrentReq_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeCurrentSrc_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeCurrentSrc_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeKExpressMode_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeKExpressMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fWestSwitchCommand_cookie<s(0)(0)(0)>[&];(D1:mssp4fWestSwitchCommand_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fWestLineReq_cookie<s(0)(0)(0)>[&];(D1:mssp4fWestLineReq_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fWestLastSwitchCmd_cookie<s(0)(0)(0)>[&];(D1:mssp4fWestLastSwitchCmd_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fWestSwitchStatus_cookie<s(0)(0)(0)>[&];(D1:mssp4fWestSwitchStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fWestK1byteInput_cookie<s(0)(0)(0)>[&];(D1:mssp4fWestK1byteInput_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fWestK2byteInput_cookie<s(0)(0)(0)>[&];(D1:mssp4fWestK2byteInput_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fWestK1byteOutput_cookie<s(0)(0)(0)>[&];(D1:mssp4fWestK1byteOutput_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fWestK2byteOutput_cookie<s(0)(0)(0)>[&];(D1:mssp4fWestK2byteOutput_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fEastSwitchCommand_cookie<s(0)(0)(0)>[&];(D1:mssp4fEastSwitchCommand_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fEastLineReq_cookie<s(0)(0)(0)>[&];(D1:mssp4fEastLineReq_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fEastLastSwitchCmd_cookie<s(0)(0)(0)>[&];(D1:mssp4fEastLastSwitchCmd_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fEastSwitchStatus_cookie<s(0)(0)(0)>[&];(D1:mssp4fEastSwitchStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fEastK1byteInput_cookie<s(0)(0)(0)>[&];(D1:mssp4fEastK1byteInput_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fEastK2byteInput_cookie<s(0)(0)(0)>[&];(D1:mssp4fEastK2byteInput_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fEastK1byteOutput_cookie<s(0)(0)(0)>[&];(D1:mssp4fEastK1byteOutput_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fEastK2byteOutput_cookie<s(0)(0)(0)>[&];(D1:mssp4fEastK2byteOutput_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fPassNodeId_cookie<s(0)(0)(0)>[&];(D1:mssp4fPassNodeId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fRingId_cookie<s(0)(0)(0)>[&];(D1:mssp4fRingId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fCommandCurrentSide_cookie<s(0)(0)(0)>[&];(D1:mssp4fCommandCurrentSide_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fCommand_cookie<s(0)(0)(0)>[&];(D1:mssp4fCommand_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fLastCommandStatus_cookie<s(0)(0)(0)>[&];(D1:mssp4fLastCommandStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fRingId_cookie<s(0)(0)(0)>[&];(D1:mssp4fRingId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fSumOfNodes_cookie<s(0)(0)(0)>[&];(D1:mssp4fSumOfNodes_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeId0_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeId0_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeId1_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeId1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeId2_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeId2_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeId3_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeId3_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeId4_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeId4_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeId5_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeId5_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeId6_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeId6_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeId7_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeId7_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeId8_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeId8_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeId9_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeId9_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeId10_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeId10_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeId11_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeId11_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeId12_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeId12_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeId13_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeId13_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeId14_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeId14_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeId15_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeId15_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeIp0_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeIp0_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeIp1_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeIp1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeIp2_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeIp2_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeIp3_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeIp3_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeIp4_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeIp4_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeIp5_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeIp5_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeIp6_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeIp6_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeIp7_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeIp7_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeIp8_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeIp8_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeIp9_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeIp9_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeIp10_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeIp10_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeIp11_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeIp11_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeIp12_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeIp12_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeIp13_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeIp13_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeIp14_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeIp14_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fNodeIp15_cookie<s(0)(0)(0)>[&];(D1:mssp4fNodeIp15_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fRingId_cookie<s(0)(0)(0)>[&];(D1:mssp4fRingId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fProtectMode_cookie<s(0)(0)(0)>[&];(D1:mssp4fProtectMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fRingName_cookie<s(0)(0)(0)>[&];(D1:mssp4fRingName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fGroupId_cookie<s(0)(0)(0)>[&];(D1:mssp4fGroupId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fWaitToRestore_cookie<s(0)(0)(0)>[&];(D1:mssp4fWaitToRestore_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fRingType_cookie<s(0)(0)(0)>[&];(D1:mssp4fRingType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fWestWorkChannelNutInfo_cookie<s(0)(0)(0)>[&];(D1:mssp4fWestWorkChannelNutInfo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fEastWorkChannelNutInfo_cookie<s(0)(0)(0)>[&];(D1:mssp4fEastWorkChannelNutInfo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fConfigEnabled_cookie<s(0)(0)(0)>[&];(D1:mssp4fConfigEnabled_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fConfigDeleted_cookie<s(0)(0)(0)>[&];(D1:mssp4fConfigDeleted_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fRingSuspended_cookie<s(0)(0)(0)>[&];(D1:mssp4fRingSuspended_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fAutoSquelchEnabled_cookie<s(0)(0)(0)>[&];(D1:mssp4fAutoSquelchEnabled_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fAutoMappingEnabled_cookie<s(0)(0)(0)>[&];(D1:mssp4fAutoMappingEnabled_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fWestWorkSlotNum_cookie<s(0)(0)(0)>[&];(D1:mssp4fWestWorkSlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fWestWorkPortType_cookie<s(0)(0)(0)>[&];(D1:mssp4fWestWorkPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fWestWorkPortNum_cookie<s(0)(0)(0)>[&];(D1:mssp4fWestWorkPortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fWestProtSlotNum_cookie<s(0)(0)(0)>[&];(D1:mssp4fWestProtSlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fWestProtPortType_cookie<s(0)(0)(0)>[&];(D1:mssp4fWestProtPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fWestProtPortNum_cookie<s(0)(0)(0)>[&];(D1:mssp4fWestProtPortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fEastWorkSlotNum_cookie<s(0)(0)(0)>[&];(D1:mssp4fEastWorkSlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fEastWorkPortType_cookie<s(0)(0)(0)>[&];(D1:mssp4fEastWorkPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fEastWorkPortNum_cookie<s(0)(0)(0)>[&];(D1:mssp4fEastWorkPortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fEastProtSlotNum_cookie<s(0)(0)(0)>[&];(D1:mssp4fEastProtSlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fEastProtPortType_cookie<s(0)(0)(0)>[&];(D1:mssp4fEastProtPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fEastProtPortNum_cookie<s(0)(0)(0)>[&];(D1:mssp4fEastProtPortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fPeerWestWorkSlotNum_cookie<s(0)(0)(0)>[&];(D1:mssp4fPeerWestWorkSlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fPeerWestWorkPortType_cookie<s(0)(0)(0)>[&];(D1:mssp4fPeerWestWorkPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fPeerWestWorkPortNum_cookie<s(0)(0)(0)>[&];(D1:mssp4fPeerWestWorkPortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fPeerWestProtSlotNum_cookie<s(0)(0)(0)>[&];(D1:mssp4fPeerWestProtSlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fPeerWestProtPortType_cookie<s(0)(0)(0)>[&];(D1:mssp4fPeerWestProtPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fPeerWestProtPortNum_cookie<s(0)(0)(0)>[&];(D1:mssp4fPeerWestProtPortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fPeerEastWorkSlotNum_cookie<s(0)(0)(0)>[&];(D1:mssp4fPeerEastWorkSlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fPeerEastWorkPortType_cookie<s(0)(0)(0)>[&];(D1:mssp4fPeerEastWorkPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fPeerEastWorkPortNum_cookie<s(0)(0)(0)>[&];(D1:mssp4fPeerEastWorkPortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fPeerEastProtSlotNum_cookie<s(0)(0)(0)>[&];(D1:mssp4fPeerEastProtSlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fPeerEastProtPortType_cookie<s(0)(0)(0)>[&];(D1:mssp4fPeerEastProtPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mssp4fPeerEastProtPortNum_cookie<s(0)(0)(0)>[&];(D1:mssp4fPeerEastProtPortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpConfigTable_cookie<s(0)(0)(0)>[&];(D1:pbSncpConfigTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpStateTable_cookie<s(0)(0)(0)>[&];(D1:pbSncpStateTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDpnpConfigTable_cookie<s(0)(0)(0)>[&];(D1:pbDpnpConfigTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDpnpStateTable_cookie<s(0)(0)(0)>[&];(D1:pbDpnpStateTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpExtendParaGroup_cookie<s(0)(0)(0)>[&];(D1:pbSncpExtendParaGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLoSncpWTR_cookie<s(0)(0)(0)>[&];(D1:pbLoSncpWTR_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLoSncpHoldOffTime_cookie<s(0)(0)(0)>[&];(D1:pbLoSncpHoldOffTime_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDpnpStateLineId_cookie<s(0)(0)(0)>[&];(D1:pbDpnpStateLineId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDpnpDetailedStateString1_cookie<s(0)(0)(0)>[&];(D1:pbDpnpDetailedStateString1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDpnpDetailedStateString2_cookie<s(0)(0)(0)>[&];(D1:pbDpnpDetailedStateString2_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDpnpDetailedStateString3_cookie<s(0)(0)(0)>[&];(D1:pbDpnpDetailedStateString3_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDpnpDetailedStateString4_cookie<s(0)(0)(0)>[&];(D1:pbDpnpDetailedStateString4_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDpnpTPType_cookie<s(0)(0)(0)>[&];(D1:pbDpnpTPType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDpnpDstSlotNum_cookie<s(0)(0)(0)>[&];(D1:pbDpnpDstSlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDpnpDstPortType_cookie<s(0)(0)(0)>[&];(D1:pbDpnpDstPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDpnpDstPortNum_cookie<s(0)(0)(0)>[&];(D1:pbDpnpDstPortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDpnpDstSource_cookie<s(0)(0)(0)>[&];(D1:pbDpnpDstSource_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbVSncpWorkChSlotNum_cookie<s(0)(0)(0)>[&];(D1:pbVSncpWorkChSlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbVSncpWorkChPortType_cookie<s(0)(0)(0)>[&];(D1:pbVSncpWorkChPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbVSncpWorkChPortNum_cookie<s(0)(0)(0)>[&];(D1:pbVSncpWorkChPortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbVSncpWorkSource_cookie<s(0)(0)(0)>[&];(D1:pbVSncpWorkSource_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbVSncpProtectChSlotNum_cookie<s(0)(0)(0)>[&];(D1:pbVSncpProtectChSlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbVSncpProtectChPortType_cookie<s(0)(0)(0)>[&];(D1:pbVSncpProtectChPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbVSncpProtectChPortNum_cookie<s(0)(0)(0)>[&];(D1:pbVSncpProtectChPortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbVSncpProtectSource_cookie<s(0)(0)(0)>[&];(D1:pbVSncpProtectSource_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbVMsspringWorkChSlotNum_cookie<s(0)(0)(0)>[&];(D1:pbVMsspringWorkChSlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbVMsspringWorkChPortType_cookie<s(0)(0)(0)>[&];(D1:pbVMsspringWorkChPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbVMsspringWorkChPortNum_cookie<s(0)(0)(0)>[&];(D1:pbVMsspringWorkChPortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbVMsspringWorkSource_cookie<s(0)(0)(0)>[&];(D1:pbVMsspringWorkSource_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDpnpSignalDircetion_cookie<s(0)(0)(0)>[&];(D1:pbDpnpSignalDircetion_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDpnpGroupId_cookie<s(0)(0)(0)>[&];(D1:pbDpnpGroupId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDpnpWorkChState_cookie<s(0)(0)(0)>[&];(D1:pbDpnpWorkChState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDpnpExternalCmd_cookie<s(0)(0)(0)>[&];(D1:pbDpnpExternalCmd_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDpnpExCmdRslt_cookie<s(0)(0)(0)>[&];(D1:pbDpnpExCmdRslt_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDpnpCurSwitchReq_cookie<s(0)(0)(0)>[&];(D1:pbDpnpCurSwitchReq_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDpnpSwitchReason_cookie<s(0)(0)(0)>[&];(D1:pbDpnpSwitchReason_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDpnpHoldOffTime_cookie<s(0)(0)(0)>[&];(D1:pbDpnpHoldOffTime_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDpnpRestoreMode_cookie<s(0)(0)(0)>[&];(D1:pbDpnpRestoreMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDpnpWTR_cookie<s(0)(0)(0)>[&];(D1:pbDpnpWTR_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDpnpWorkSignalState_cookie<s(0)(0)(0)>[&];(D1:pbDpnpWorkSignalState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDpnpProtectSignalState_cookie<s(0)(0)(0)>[&];(D1:pbDpnpProtectSignalState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDpnpVMsspringSignalState_cookie<s(0)(0)(0)>[&];(D1:pbDpnpVMsspringSignalState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDpnpRowStatus_cookie<s(0)(0)(0)>[&];(D1:pbDpnpRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDpnpLable_cookie<s(0)(0)(0)>[&];(D1:pbDpnpLable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDpnpAddRslt_cookie<s(0)(0)(0)>[&];(D1:pbDpnpAddRslt_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDpnpDNIId_cookie<s(0)(0)(0)>[&];(D1:pbDpnpDNIId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDpnpIntrusive_cookie<s(0)(0)(0)>[&];(D1:pbDpnpIntrusive_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDpnpDirection_cookie<s(0)(0)(0)>[&];(D1:pbDpnpDirection_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDpnpFrom_cookie<s(0)(0)(0)>[&];(D1:pbDpnpFrom_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDpnpSwitchEvent_cookie<s(0)(0)(0)>[&];(D1:pbDpnpSwitchEvent_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGmplsDpnpDirection_cookie<s(0)(0)(0)>[&];(D1:pbGmplsDpnpDirection_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpStateLineId_cookie<s(0)(0)(0)>[&];(D1:pbSncpStateLineId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpDetailedStateString1_cookie<s(0)(0)(0)>[&];(D1:pbSncpDetailedStateString1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpDetailedStateString2_cookie<s(0)(0)(0)>[&];(D1:pbSncpDetailedStateString2_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpDetailedStateString3_cookie<s(0)(0)(0)>[&];(D1:pbSncpDetailedStateString3_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpDetailedStateString4_cookie<s(0)(0)(0)>[&];(D1:pbSncpDetailedStateString4_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpTPType_cookie<s(0)(0)(0)>[&];(D1:pbSncpTPType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpWorkChSlotNum_cookie<s(0)(0)(0)>[&];(D1:pbSncpWorkChSlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpWorkChPortType_cookie<s(0)(0)(0)>[&];(D1:pbSncpWorkChPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpWorkChPortNum_cookie<s(0)(0)(0)>[&];(D1:pbSncpWorkChPortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpWorkSource_cookie<s(0)(0)(0)>[&];(D1:pbSncpWorkSource_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpProtectChSlotNum_cookie<s(0)(0)(0)>[&];(D1:pbSncpProtectChSlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpProtectChPortType_cookie<s(0)(0)(0)>[&];(D1:pbSncpProtectChPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpProtectChPortNum_cookie<s(0)(0)(0)>[&];(D1:pbSncpProtectChPortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpProtectSource_cookie<s(0)(0)(0)>[&];(D1:pbSncpProtectSource_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpSrcOrDstSlotNum_cookie<s(0)(0)(0)>[&];(D1:pbSncpSrcOrDstSlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpSrcOrDstPortType_cookie<s(0)(0)(0)>[&];(D1:pbSncpSrcOrDstPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpSrcOrDstPortNum_cookie<s(0)(0)(0)>[&];(D1:pbSncpSrcOrDstPortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpSrcOrDstSource_cookie<s(0)(0)(0)>[&];(D1:pbSncpSrcOrDstSource_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpSignalDircetion_cookie<s(0)(0)(0)>[&];(D1:pbSncpSignalDircetion_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpGroupId_cookie<s(0)(0)(0)>[&];(D1:pbSncpGroupId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpWorkChState_cookie<s(0)(0)(0)>[&];(D1:pbSncpWorkChState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpExternalCmd_cookie<s(0)(0)(0)>[&];(D1:pbSncpExternalCmd_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpExCmdRslt_cookie<s(0)(0)(0)>[&];(D1:pbSncpExCmdRslt_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpCurSwitchReq_cookie<s(0)(0)(0)>[&];(D1:pbSncpCurSwitchReq_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpSwitchReason_cookie<s(0)(0)(0)>[&];(D1:pbSncpSwitchReason_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpHoldOffTime_cookie<s(0)(0)(0)>[&];(D1:pbSncpHoldOffTime_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpRestoreMode_cookie<s(0)(0)(0)>[&];(D1:pbSncpRestoreMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpWTR_cookie<s(0)(0)(0)>[&];(D1:pbSncpWTR_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpWorkSignalState_cookie<s(0)(0)(0)>[&];(D1:pbSncpWorkSignalState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpProtectSignalState_cookie<s(0)(0)(0)>[&];(D1:pbSncpProtectSignalState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpRowStatus_cookie<s(0)(0)(0)>[&];(D1:pbSncpRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpLable_cookie<s(0)(0)(0)>[&];(D1:pbSncpLable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpAddRslt_cookie<s(0)(0)(0)>[&];(D1:pbSncpAddRslt_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDNIId_cookie<s(0)(0)(0)>[&];(D1:pbDNIId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpIntrusive_cookie<s(0)(0)(0)>[&];(D1:pbSncpIntrusive_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpWorkGmplsVcNumber_cookie<s(0)(0)(0)>[&];(D1:pbSncpWorkGmplsVcNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpWorkGmplsCallName_cookie<s(0)(0)(0)>[&];(D1:pbSncpWorkGmplsCallName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpProtectGmplsVcNumber_cookie<s(0)(0)(0)>[&];(D1:pbSncpProtectGmplsVcNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpProtectGmplsCallName_cookie<s(0)(0)(0)>[&];(D1:pbSncpProtectGmplsCallName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpWorkorProtToCC_cookie<s(0)(0)(0)>[&];(D1:pbSncpWorkorProtToCC_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpDirection_cookie<s(0)(0)(0)>[&];(D1:pbSncpDirection_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpFrom_cookie<s(0)(0)(0)>[&];(D1:pbSncpFrom_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGmplsSncpDirection_cookie<s(0)(0)(0)>[&];(D1:pbGmplsSncpDirection_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSncpAction_cookie<s(0)(0)(0)>[&];(D1:pbSncpAction_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspConfigTable_cookie<s(0)(0)(0)>[&];(D1:pbMspConfigTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspGroupActPortType_cookie<s(0)(0)(0)>[&];(D1:pbMspGroupActPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspProtectChSlotNum_cookie<s(0)(0)(0)>[&];(D1:pbMspProtectChSlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspProtectChPortNum_cookie<s(0)(0)(0)>[&];(D1:pbMspProtectChPortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspProtectChPortType_cookie<s(0)(0)(0)>[&];(D1:pbMspProtectChPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspProtectChSignalState_cookie<s(0)(0)(0)>[&];(D1:pbMspProtectChSignalState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspGroupId_cookie<s(0)(0)(0)>[&];(D1:pbMspGroupId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspType_cookie<s(0)(0)(0)>[&];(D1:pbMspType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspSignalDircetion_cookie<s(0)(0)(0)>[&];(D1:pbMspSignalDircetion_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspRestoreMode_cookie<s(0)(0)(0)>[&];(D1:pbMspRestoreMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspExTrafficEnable_cookie<s(0)(0)(0)>[&];(D1:pbMspExTrafficEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspEnable_cookie<s(0)(0)(0)>[&];(D1:pbMspEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspExternalCmd_cookie<s(0)(0)(0)>[&];(D1:pbMspExternalCmd_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspExtCmdParam_cookie<s(0)(0)(0)>[&];(D1:pbMspExtCmdParam_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspExCmdRslt_cookie<s(0)(0)(0)>[&];(D1:pbMspExCmdRslt_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspSwitchState_cookie<s(0)(0)(0)>[&];(D1:pbMspSwitchState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspCurSwitchReq_cookie<s(0)(0)(0)>[&];(D1:pbMspCurSwitchReq_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspSwitchReason_cookie<s(0)(0)(0)>[&];(D1:pbMspSwitchReason_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWTR_cookie<s(0)(0)(0)>[&];(D1:pbMspWTR_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkChNum_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkChNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh1SlotNum_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh1SlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh1PortNum_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh1PortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh1PortType_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh1PortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh1SignalState_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh1SignalState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh1PriState_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh1PriState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh2SlotNum_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh2SlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh2PortNum_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh2PortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh2PortType_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh2PortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh2SignalState_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh2SignalState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh2PriState_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh2PriState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh3SlotNum_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh3SlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh3PortNum_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh3PortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh3PortType_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh3PortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh3SignalState_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh3SignalState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh3PriState_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh3PriState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh4SlotNum_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh4SlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh4PortNum_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh4PortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh4PortType_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh4PortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh4SignalState_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh4SignalState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh4PriState_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh4PriState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh5SlotNum_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh5SlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh5PortNum_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh5PortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh5PortType_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh5PortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh5SignalState_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh5SignalState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh5PriState_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh5PriState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh6SlotNum_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh6SlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh6PortNum_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh6PortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh6PortType_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh6PortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh6SignalState_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh6SignalState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh6PriState_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh6PriState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh7SlotNum_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh7SlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh7PortNum_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh7PortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh7PortType_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh7PortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh7SignalState_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh7SignalState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh7PriState_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh7PriState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh8SlotNum_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh8SlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh8PortNum_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh8PortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh8PortType_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh8PortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh8SignalState_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh8SignalState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh8PriState_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh8PriState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh9SlotNum_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh9SlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh9PortNum_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh9PortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh9PortType_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh9PortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh9SignalState_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh9SignalState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh9PriState_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh9PriState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh10SlotNum_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh10SlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh10PortNum_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh10PortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh10PortType_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh10PortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh10SignalState_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh10SignalState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh10PriState_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh10PriState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh11SlotNum_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh11SlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh11PortNum_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh11PortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh11PortType_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh11PortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh11SignalState_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh11SignalState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh11PriState_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh11PriState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh12SlotNum_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh12SlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh12PortNum_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh12PortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh12PortType_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh12PortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh12SignalState_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh12SignalState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh12PriState_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh12PriState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh13SlotNum_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh13SlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh13PortNum_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh13PortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh13PortType_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh13PortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh13SignalState_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh13SignalState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh13PriState_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh13PriState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh14SlotNum_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh14SlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh14PortNum_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh14PortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh14PortType_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh14PortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh14SignalState_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh14SignalState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspWorkCh14PriState_cookie<s(0)(0)(0)>[&];(D1:pbMspWorkCh14PriState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspK2Bit5Mismatch_cookie<s(0)(0)(0)>[&];(D1:pbMspK2Bit5Mismatch_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspK1Bit1to4Mismatch_cookie<s(0)(0)(0)>[&];(D1:pbMspK1Bit1to4Mismatch_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspK1Bit5to8Mismatch_cookie<s(0)(0)(0)>[&];(D1:pbMspK1Bit5to8Mismatch_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspReceiveK1_cookie<s(0)(0)(0)>[&];(D1:pbMspReceiveK1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspReceiveK2_cookie<s(0)(0)(0)>[&];(D1:pbMspReceiveK2_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspSendoutK1_cookie<s(0)(0)(0)>[&];(D1:pbMspSendoutK1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspSendoutK2_cookie<s(0)(0)(0)>[&];(D1:pbMspSendoutK2_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspRowStatus_cookie<s(0)(0)(0)>[&];(D1:pbMspRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspFreeze_cookie<s(0)(0)(0)>[&];(D1:pbMspFreeze_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMspLable_cookie<s(0)(0)(0)>[&];(D1:pbMspLable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMConfigTable_cookie<s(0)(0)(0)>[&];(D1:pbMSMConfigTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMStatusTable_cookie<s(0)(0)(0)>[&];(D1:pbMSMStatusTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMNodeStatusTable_cookie<s(0)(0)(0)>[&];(D1:pbMSMNodeStatusTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoConfigTable_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoConfigTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMSquelchTable_cookie<s(0)(0)(0)>[&];(D1:pbMSMSquelchTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMCommandTable_cookie<s(0)(0)(0)>[&];(D1:pbMSMCommandTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAutoMappingTable_cookie<s(0)(0)(0)>[&];(D1:pbAutoMappingTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMSNMRingId_cookie<s(0)(0)(0)>[&];(D1:pbMSMSNMRingId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAutoNodeId_cookie<s(0)(0)(0)>[&];(D1:pbAutoNodeId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortMappingString_cookie<s(0)(0)(0)>[&];(D1:pbPortMappingString_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAutoMappingRowStatus_cookie<s(0)(0)(0)>[&];(D1:pbAutoMappingRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMSNMRingId_cookie<s(0)(0)(0)>[&];(D1:pbMSMSNMRingId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMCommandCurrentSide_cookie<s(0)(0)(0)>[&];(D1:pbMSMCommandCurrentSide_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMCommandSwitch_cookie<s(0)(0)(0)>[&];(D1:pbMSMCommandSwitch_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMLastCommandStatus_cookie<s(0)(0)(0)>[&];(D1:pbMSMLastCommandStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMCommandResult_cookie<s(0)(0)(0)>[&];(D1:pbMSMCommandResult_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMSNMRingId_cookie<s(0)(0)(0)>[&];(D1:pbMSMSNMRingId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMSquelchSide_cookie<s(0)(0)(0)>[&];(D1:pbMSMSquelchSide_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMSquelchGress_cookie<s(0)(0)(0)>[&];(D1:pbMSMSquelchGress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMSquelchTimeSlot_cookie<s(0)(0)(0)>[&];(D1:pbMSMSquelchTimeSlot_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMSquelchOrder_cookie<s(0)(0)(0)>[&];(D1:pbMSMSquelchOrder_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMSquelchType_cookie<s(0)(0)(0)>[&];(D1:pbMSMSquelchType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMSquelchSrcNodeId_cookie<s(0)(0)(0)>[&];(D1:pbMSMSquelchSrcNodeId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMSquelchDstNodeId_cookie<s(0)(0)(0)>[&];(D1:pbMSMSquelchDstNodeId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMSquelchReference_cookie<s(0)(0)(0)>[&];(D1:pbMSMSquelchReference_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMSquelchOpTimeSlot_cookie<s(0)(0)(0)>[&];(D1:pbMSMSquelchOpTimeSlot_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMSquelchRowStatus_cookie<s(0)(0)(0)>[&];(D1:pbMSMSquelchRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMSNMRingId_cookie<s(0)(0)(0)>[&];(D1:pbMSMSNMRingId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoNumOfNodes_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoNumOfNodes_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoNodeId0_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoNodeId0_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoNodeId1_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoNodeId1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoNodeId2_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoNodeId2_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoNodeId3_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoNodeId3_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoNodeId4_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoNodeId4_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoNodeId5_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoNodeId5_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoNodeId6_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoNodeId6_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoNodeId7_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoNodeId7_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoNodeId8_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoNodeId8_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoNodeId9_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoNodeId9_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoNodeId10_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoNodeId10_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoNodeId11_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoNodeId11_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoNodeId12_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoNodeId12_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoNodeId13_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoNodeId13_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoNodeId14_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoNodeId14_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoNodeId15_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoNodeId15_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoStatus_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoConfig_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoConfig_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoNodeId0IpAddress_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoNodeId0IpAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoNodeId1IpAddress_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoNodeId1IpAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoNodeId2IpAddress_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoNodeId2IpAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoNodeId3IpAddress_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoNodeId3IpAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoNodeId4IpAddress_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoNodeId4IpAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoNodeId5IpAddress_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoNodeId5IpAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoNodeId6IpAddress_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoNodeId6IpAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoNodeId7IpAddress_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoNodeId7IpAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoNodeId8IpAddress_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoNodeId8IpAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoNodeId9IpAddress_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoNodeId9IpAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoNodeId10IpAddress_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoNodeId10IpAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoNodeId11IpAddress_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoNodeId11IpAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoNodeId12IpAddress_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoNodeId12IpAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoNodeId13IpAddress_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoNodeId13IpAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoNodeId14IpAddress_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoNodeId14IpAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTopoNodeId15IpAddress_cookie<s(0)(0)(0)>[&];(D1:pbMSMTopoNodeId15IpAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMSNMRingId_cookie<s(0)(0)(0)>[&];(D1:pbMSMSNMRingId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMNodeAgentState_cookie<s(0)(0)(0)>[&];(D1:pbMSMNodeAgentState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMNodeState_cookie<s(0)(0)(0)>[&];(D1:pbMSMNodeState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMNodeCurrentSide_cookie<s(0)(0)(0)>[&];(D1:pbMSMNodeCurrentSide_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMNodeCurrentReq_cookie<s(0)(0)(0)>[&];(D1:pbMSMNodeCurrentReq_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMNodeCurrentSrc_cookie<s(0)(0)(0)>[&];(D1:pbMSMNodeCurrentSrc_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMNodeKExpressMode_cookie<s(0)(0)(0)>[&];(D1:pbMSMNodeKExpressMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMEastSwitchCommand_cookie<s(0)(0)(0)>[&];(D1:pbMSMEastSwitchCommand_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMEastLineReq_cookie<s(0)(0)(0)>[&];(D1:pbMSMEastLineReq_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMEastLastSwitchCmd_cookie<s(0)(0)(0)>[&];(D1:pbMSMEastLastSwitchCmd_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMEastIsSquelched_cookie<s(0)(0)(0)>[&];(D1:pbMSMEastIsSquelched_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMWestSwitchCommand_cookie<s(0)(0)(0)>[&];(D1:pbMSMWestSwitchCommand_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMWestLineReq_cookie<s(0)(0)(0)>[&];(D1:pbMSMWestLineReq_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMWestLastSwitchCmd_cookie<s(0)(0)(0)>[&];(D1:pbMSMWestLastSwitchCmd_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMWestIsSquelched_cookie<s(0)(0)(0)>[&];(D1:pbMSMWestIsSquelched_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMEastSwitchStatus_cookie<s(0)(0)(0)>[&];(D1:pbMSMEastSwitchStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMWestSwitchStatus_cookie<s(0)(0)(0)>[&];(D1:pbMSMWestSwitchStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMPassNodeId_cookie<s(0)(0)(0)>[&];(D1:pbMSMPassNodeId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMSNMRingId_cookie<s(0)(0)(0)>[&];(D1:pbMSMSNMRingId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMSide_cookie<s(0)(0)(0)>[&];(D1:pbMSMSide_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTransBridgeReq_cookie<s(0)(0)(0)>[&];(D1:pbMSMTransBridgeReq_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTransDestNodeId_cookie<s(0)(0)(0)>[&];(D1:pbMSMTransDestNodeId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTransSrcNodeId_cookie<s(0)(0)(0)>[&];(D1:pbMSMTransSrcNodeId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTransLongShort_cookie<s(0)(0)(0)>[&];(D1:pbMSMTransLongShort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMTransStatus_cookie<s(0)(0)(0)>[&];(D1:pbMSMTransStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMReceiveBridgeReq_cookie<s(0)(0)(0)>[&];(D1:pbMSMReceiveBridgeReq_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMReceiveDestNodeId_cookie<s(0)(0)(0)>[&];(D1:pbMSMReceiveDestNodeId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMReceiveSrcNodeId_cookie<s(0)(0)(0)>[&];(D1:pbMSMReceiveSrcNodeId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMReceiveLongShort_cookie<s(0)(0)(0)>[&];(D1:pbMSMReceiveLongShort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMReceiveStatus_cookie<s(0)(0)(0)>[&];(D1:pbMSMReceiveStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMSideReq_cookie<s(0)(0)(0)>[&];(D1:pbMSMSideReq_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMSideSrc_cookie<s(0)(0)(0)>[&];(D1:pbMSMSideSrc_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMSwitchCommand_cookie<s(0)(0)(0)>[&];(D1:pbMSMSwitchCommand_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMLineReq_cookie<s(0)(0)(0)>[&];(D1:pbMSMLineReq_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMCmndReq_cookie<s(0)(0)(0)>[&];(D1:pbMSMCmndReq_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMIsSquelched_cookie<s(0)(0)(0)>[&];(D1:pbMSMIsSquelched_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMSNMRingId_cookie<s(0)(0)(0)>[&];(D1:pbMSMSNMRingId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMProtectMode_cookie<s(0)(0)(0)>[&];(D1:pbMSMProtectMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMSNMRingName_cookie<s(0)(0)(0)>[&];(D1:pbMSMSNMRingName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMRingIdx_cookie<s(0)(0)(0)>[&];(D1:pbMSMRingIdx_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMWestSideSlotNum_cookie<s(0)(0)(0)>[&];(D1:pbMSMWestSideSlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMWestSidePortType_cookie<s(0)(0)(0)>[&];(D1:pbMSMWestSidePortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMWestSidePortNum_cookie<s(0)(0)(0)>[&];(D1:pbMSMWestSidePortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMWestProtSlotNum_cookie<s(0)(0)(0)>[&];(D1:pbMSMWestProtSlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMWestProtPortType_cookie<s(0)(0)(0)>[&];(D1:pbMSMWestProtPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMWestProtPortNum_cookie<s(0)(0)(0)>[&];(D1:pbMSMWestProtPortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMEastSideSlotNum_cookie<s(0)(0)(0)>[&];(D1:pbMSMEastSideSlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMEastSidePortType_cookie<s(0)(0)(0)>[&];(D1:pbMSMEastSidePortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMEastSidePortNum_cookie<s(0)(0)(0)>[&];(D1:pbMSMEastSidePortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMEastProtSlotNum_cookie<s(0)(0)(0)>[&];(D1:pbMSMEastProtSlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMEastProtPortType_cookie<s(0)(0)(0)>[&];(D1:pbMSMEastProtPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMEastProtPortNum_cookie<s(0)(0)(0)>[&];(D1:pbMSMEastProtPortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMAutoSquelchDiscovery_cookie<s(0)(0)(0)>[&];(D1:pbMSMAutoSquelchDiscovery_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMAutoRingDiscovery_cookie<s(0)(0)(0)>[&];(D1:pbMSMAutoRingDiscovery_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMPeerWestAddress_cookie<s(0)(0)(0)>[&];(D1:pbMSMPeerWestAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMPeerWestSlotNum_cookie<s(0)(0)(0)>[&];(D1:pbMSMPeerWestSlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMPeerWestPortType_cookie<s(0)(0)(0)>[&];(D1:pbMSMPeerWestPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMPeerWestPortNum_cookie<s(0)(0)(0)>[&];(D1:pbMSMPeerWestPortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMPeerEastAddress_cookie<s(0)(0)(0)>[&];(D1:pbMSMPeerEastAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMPeerEastSlotNum_cookie<s(0)(0)(0)>[&];(D1:pbMSMPeerEastSlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMPeerEastPortType_cookie<s(0)(0)(0)>[&];(D1:pbMSMPeerEastPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMPeerEastPortNum_cookie<s(0)(0)(0)>[&];(D1:pbMSMPeerEastPortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMConfigSdBerThreshold_cookie<s(0)(0)(0)>[&];(D1:pbMSMConfigSdBerThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMConfigSfBerThreshold_cookie<s(0)(0)(0)>[&];(D1:pbMSMConfigSfBerThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMConfigWaitToRestore_cookie<s(0)(0)(0)>[&];(D1:pbMSMConfigWaitToRestore_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMConfigExtraTraffic_cookie<s(0)(0)(0)>[&];(D1:pbMSMConfigExtraTraffic_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMConfigEnable_cookie<s(0)(0)(0)>[&];(D1:pbMSMConfigEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMConfigDelete_cookie<s(0)(0)(0)>[&];(D1:pbMSMConfigDelete_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMSquelchFin_cookie<s(0)(0)(0)>[&];(D1:pbMSMSquelchFin_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMCardFunction_cookie<s(0)(0)(0)>[&];(D1:pbMSMCardFunction_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMChannelInfo_cookie<s(0)(0)(0)>[&];(D1:pbMSMChannelInfo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMSelfAddress_cookie<s(0)(0)(0)>[&];(D1:pbMSMSelfAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMStartAutoSquelch_cookie<s(0)(0)(0)>[&];(D1:pbMSMStartAutoSquelch_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMAutoMappingEnable_cookie<s(0)(0)(0)>[&];(D1:pbMSMAutoMappingEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMSMPortMapRefresh_cookie<s(0)(0)(0)>[&];(D1:pbMSMPortMapRefresh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEpgTable_cookie<s(0)(0)(0)>[&];(D1:pbEpgTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCpgTable_cookie<s(0)(0)(0)>[&];(D1:pbCpgTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] scEpgGroup_cookie<s(0)(0)(0)>[&];(D1:scEpgGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] scEpgScWorkerSlot_cookie<s(0)(0)(0)>[&];(D1:scEpgScWorkerSlot_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] scEpgSc1Status_cookie<s(0)(0)(0)>[&];(D1:scEpgSc1Status_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] scEpgSc2Status_cookie<s(0)(0)(0)>[&];(D1:scEpgSc2Status_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] scEpgRequest_cookie<s(0)(0)(0)>[&];(D1:scEpgRequest_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] scEpgLastSwichReason_cookie<s(0)(0)(0)>[&];(D1:scEpgLastSwichReason_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] scEpgStandbySc_cookie<s(0)(0)(0)>[&];(D1:scEpgStandbySc_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] scEpgASCSwithchState_cookie<s(0)(0)(0)>[&];(D1:scEpgASCSwithchState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCpgIndexNo_cookie<s(0)(0)(0)>[&];(D1:pbCpgIndexNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCpgWorkerSlot_cookie<s(0)(0)(0)>[&];(D1:pbCpgWorkerSlot_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCpgProtectorSlot_cookie<s(0)(0)(0)>[&];(D1:pbCpgProtectorSlot_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCpgProtectStatus_cookie<s(0)(0)(0)>[&];(D1:pbCpgProtectStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbWorkerStatus_cookie<s(0)(0)(0)>[&];(D1:pbWorkerStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbProtectorStatus_cookie<s(0)(0)(0)>[&];(D1:pbProtectorStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCpgAct_cookie<s(0)(0)(0)>[&];(D1:pbCpgAct_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCpgActStatus_cookie<s(0)(0)(0)>[&];(D1:pbCpgActStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCpgCurActStatus_cookie<s(0)(0)(0)>[&];(D1:pbCpgCurActStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCpgReadyToSwitch_cookie<s(0)(0)(0)>[&];(D1:pbCpgReadyToSwitch_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEpgId_cookie<s(0)(0)(0)>[&];(D1:pbEpgId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEpgBoardType_cookie<s(0)(0)(0)>[&];(D1:pbEpgBoardType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEpgType_cookie<s(0)(0)(0)>[&];(D1:pbEpgType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEpgProtMode_cookie<s(0)(0)(0)>[&];(D1:pbEpgProtMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEpgEnable_cookie<s(0)(0)(0)>[&];(D1:pbEpgEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEpgExtCmd_cookie<s(0)(0)(0)>[&];(D1:pbEpgExtCmd_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEpgExtCmdParam_cookie<s(0)(0)(0)>[&];(D1:pbEpgExtCmdParam_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEpgExtCmdResult_cookie<s(0)(0)(0)>[&];(D1:pbEpgExtCmdResult_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEpgWtr_cookie<s(0)(0)(0)>[&];(D1:pbEpgWtr_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEpgPreSwitchReason_cookie<s(0)(0)(0)>[&];(D1:pbEpgPreSwitchReason_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEpgCurRequest_cookie<s(0)(0)(0)>[&];(D1:pbEpgCurRequest_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEpgProtState_cookie<s(0)(0)(0)>[&];(D1:pbEpgProtState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEpgHoldOffTime_cookie<s(0)(0)(0)>[&];(D1:pbEpgHoldOffTime_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEpgProtSlotNum_cookie<s(0)(0)(0)>[&];(D1:pbEpgProtSlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEpgProtSlotState_cookie<s(0)(0)(0)>[&];(D1:pbEpgProtSlotState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEpgWorkSlotNum1_cookie<s(0)(0)(0)>[&];(D1:pbEpgWorkSlotNum1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEpgWorkSlot1State_cookie<s(0)(0)(0)>[&];(D1:pbEpgWorkSlot1State_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEpgWorkSlotNum2_cookie<s(0)(0)(0)>[&];(D1:pbEpgWorkSlotNum2_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEpgWorkSlot2State_cookie<s(0)(0)(0)>[&];(D1:pbEpgWorkSlot2State_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEpgWorkSlotNum3_cookie<s(0)(0)(0)>[&];(D1:pbEpgWorkSlotNum3_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEpgWorkSlot3State_cookie<s(0)(0)(0)>[&];(D1:pbEpgWorkSlot3State_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEpgWorkSlotNum4_cookie<s(0)(0)(0)>[&];(D1:pbEpgWorkSlotNum4_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEpgWorkSlot4State_cookie<s(0)(0)(0)>[&];(D1:pbEpgWorkSlot4State_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEpgWorkSlotNum5_cookie<s(0)(0)(0)>[&];(D1:pbEpgWorkSlotNum5_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEpgWorkSlot5State_cookie<s(0)(0)(0)>[&];(D1:pbEpgWorkSlot5State_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEpgWorkSlotNum6_cookie<s(0)(0)(0)>[&];(D1:pbEpgWorkSlotNum6_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEpgWorkSlot6State_cookie<s(0)(0)(0)>[&];(D1:pbEpgWorkSlot6State_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEpgWorkSlotNum7_cookie<s(0)(0)(0)>[&];(D1:pbEpgWorkSlotNum7_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEpgWorkSlot7State_cookie<s(0)(0)(0)>[&];(D1:pbEpgWorkSlot7State_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEpgWorkSlotNum8_cookie<s(0)(0)(0)>[&];(D1:pbEpgWorkSlotNum8_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEpgWorkSlot8State_cookie<s(0)(0)(0)>[&];(D1:pbEpgWorkSlot8State_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEpgRowStatus_cookie<s(0)(0)(0)>[&];(D1:pbEpgRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIpTunnelCfgTable_cookie<s(0)(0)(0)>[&];(D1:pbIpTunnelCfgTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSdhServerType_cookie<s(0)(0)(0)>[&];(D1:pbSdhServerType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLapdNetworkSide_cookie<s(0)(0)(0)>[&];(D1:pbLapdNetworkSide_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLapdT200_cookie<s(0)(0)(0)>[&];(D1:pbLapdT200_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLapdT203_cookie<s(0)(0)(0)>[&];(D1:pbLapdT203_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLapdN200_cookie<s(0)(0)(0)>[&];(D1:pbLapdN200_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLapdAITS_cookie<s(0)(0)(0)>[&];(D1:pbLapdAITS_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLapdWindow_cookie<s(0)(0)(0)>[&];(D1:pbLapdWindow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIpTunnelSrcIpAddress_cookie<s(0)(0)(0)>[&];(D1:pbIpTunnelSrcIpAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIpTunnelDesIpAddress_cookie<s(0)(0)(0)>[&];(D1:pbIpTunnelDesIpAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIpTunnelByPass_cookie<s(0)(0)(0)>[&];(D1:pbIpTunnelByPass_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIpTunnelDstSlot_cookie<s(0)(0)(0)>[&];(D1:pbIpTunnelDstSlot_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIpTunnelDstPort_cookie<s(0)(0)(0)>[&];(D1:pbIpTunnelDstPort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIpTunnelDstMode_cookie<s(0)(0)(0)>[&];(D1:pbIpTunnelDstMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIpTunnelStatus_cookie<s(0)(0)(0)>[&];(D1:pbIpTunnelStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOsiConfigTable_cookie<s(0)(0)(0)>[&];(D1:pbOsiConfigTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] osiTunnelConfigTable_cookie<s(0)(0)(0)>[&];(D1:osiTunnelConfigTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSdhServerType_cookie<s(0)(0)(0)>[&];(D1:pbSdhServerType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] osiTunnelNetworkSide_cookie<s(0)(0)(0)>[&];(D1:osiTunnelNetworkSide_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] osiTunnelT200_cookie<s(0)(0)(0)>[&];(D1:osiTunnelT200_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] osiTunnelT203_cookie<s(0)(0)(0)>[&];(D1:osiTunnelT203_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] osiTunnelN200_cookie<s(0)(0)(0)>[&];(D1:osiTunnelN200_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] osiTunnelAITS_cookie<s(0)(0)(0)>[&];(D1:osiTunnelAITS_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] osiTunnelWindow_cookie<s(0)(0)(0)>[&];(D1:osiTunnelWindow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] osiTunnelConfigTimer_cookie<s(0)(0)(0)>[&];(D1:osiTunnelConfigTimer_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] osiTunnelTTL_cookie<s(0)(0)(0)>[&];(D1:osiTunnelTTL_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] osiTunnelLocalNasp_cookie<s(0)(0)(0)>[&];(D1:osiTunnelLocalNasp_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] osiTunnelRemoteNasp_cookie<s(0)(0)(0)>[&];(D1:osiTunnelRemoteNasp_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] osiTunnelSrcIpAddress_cookie<s(0)(0)(0)>[&];(D1:osiTunnelSrcIpAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] osiTunnelDesIpAddress_cookie<s(0)(0)(0)>[&];(D1:osiTunnelDesIpAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] osiTunnelIpIfMtu_cookie<s(0)(0)(0)>[&];(D1:osiTunnelIpIfMtu_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] osiTunnelStatus_cookie<s(0)(0)(0)>[&];(D1:osiTunnelStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] osiTunnelIndex_cookie<s(0)(0)(0)>[&];(D1:osiTunnelIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOsiNetworkSide_cookie<s(0)(0)(0)>[&];(D1:pbOsiNetworkSide_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOsiT200_cookie<s(0)(0)(0)>[&];(D1:pbOsiT200_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOsiT203_cookie<s(0)(0)(0)>[&];(D1:pbOsiT203_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOsiN200_cookie<s(0)(0)(0)>[&];(D1:pbOsiN200_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOsiAITS_cookie<s(0)(0)(0)>[&];(D1:pbOsiAITS_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOsiWindow_cookie<s(0)(0)(0)>[&];(D1:pbOsiWindow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOsiConfigTimer_cookie<s(0)(0)(0)>[&];(D1:pbOsiConfigTimer_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOsiTTL_cookie<s(0)(0)(0)>[&];(D1:pbOsiTTL_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOsiLocalNasp_cookie<s(0)(0)(0)>[&];(D1:pbOsiLocalNasp_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOsiRemoteNasp_cookie<s(0)(0)(0)>[&];(D1:pbOsiRemoteNasp_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOsiSrcIpAddress_cookie<s(0)(0)(0)>[&];(D1:pbOsiSrcIpAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOsiDesIpAddress_cookie<s(0)(0)(0)>[&];(D1:pbOsiDesIpAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOsiIpIfMtu_cookie<s(0)(0)(0)>[&];(D1:pbOsiIpIfMtu_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOATable_cookie<s(0)(0)(0)>[&];(D1:pbOATable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOASlotNo_cookie<s(0)(0)(0)>[&];(D1:pbOASlotNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOAPortNo_cookie<s(0)(0)(0)>[&];(D1:pbOAPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOAModuleConfiguration_cookie<s(0)(0)(0)>[&];(D1:pbOAModuleConfiguration_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOAModuleType_cookie<s(0)(0)(0)>[&];(D1:pbOAModuleType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOAHWVersion_cookie<s(0)(0)(0)>[&];(D1:pbOAHWVersion_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOASWVersion_cookie<s(0)(0)(0)>[&];(D1:pbOASWVersion_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOASerialNumber_cookie<s(0)(0)(0)>[&];(D1:pbOASerialNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOAInputPower_cookie<s(0)(0)(0)>[&];(D1:pbOAInputPower_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOACurrentOutputPower_cookie<s(0)(0)(0)>[&];(D1:pbOACurrentOutputPower_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOACurrentModuleGain_cookie<s(0)(0)(0)>[&];(D1:pbOACurrentModuleGain_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOAPump1Power_cookie<s(0)(0)(0)>[&];(D1:pbOAPump1Power_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOAPump2Power_cookie<s(0)(0)(0)>[&];(D1:pbOAPump2Power_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOATemperature_cookie<s(0)(0)(0)>[&];(D1:pbOATemperature_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOAPump1DriveCurrent_cookie<s(0)(0)(0)>[&];(D1:pbOAPump1DriveCurrent_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOAPump2DriveCurrent_cookie<s(0)(0)(0)>[&];(D1:pbOAPump2DriveCurrent_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOAPowerSupplyVoltage_cookie<s(0)(0)(0)>[&];(D1:pbOAPowerSupplyVoltage_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOAOperationMode_cookie<s(0)(0)(0)>[&];(D1:pbOAOperationMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOAExpectedOutputPower_cookie<s(0)(0)(0)>[&];(D1:pbOAExpectedOutputPower_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOAExpectedModuleGain_cookie<s(0)(0)(0)>[&];(D1:pbOAExpectedModuleGain_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOAInputThreshold_cookie<s(0)(0)(0)>[&];(D1:pbOAInputThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOAOutputThreshold_cookie<s(0)(0)(0)>[&];(D1:pbOAOutputThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOAShutdownThreshold_cookie<s(0)(0)(0)>[&];(D1:pbOAShutdownThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOALowTThreshold_cookie<s(0)(0)(0)>[&];(D1:pbOALowTThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOAHighTThreshold_cookie<s(0)(0)(0)>[&];(D1:pbOAHighTThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOAAutoShutdown_cookie<s(0)(0)(0)>[&];(D1:pbOAAutoShutdown_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOAMaxoutputpower_cookie<s(0)(0)(0)>[&];(D1:pbOAMaxoutputpower_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOAMaxPump1Current_cookie<s(0)(0)(0)>[&];(D1:pbOAMaxPump1Current_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOAMaxPump2Current_cookie<s(0)(0)(0)>[&];(D1:pbOAMaxPump2Current_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOARealOperationMode_cookie<s(0)(0)(0)>[&];(D1:pbOARealOperationMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOARealExpectedOutputPower_cookie<s(0)(0)(0)>[&];(D1:pbOARealExpectedOutputPower_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOARealExpectedModuleGain_cookie<s(0)(0)(0)>[&];(D1:pbOARealExpectedModuleGain_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOARealInputThreshold_cookie<s(0)(0)(0)>[&];(D1:pbOARealInputThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOARealOutputThreshold_cookie<s(0)(0)(0)>[&];(D1:pbOARealOutputThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOARealShutdownThreshold_cookie<s(0)(0)(0)>[&];(D1:pbOARealShutdownThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOARealLowTThreshold_cookie<s(0)(0)(0)>[&];(D1:pbOARealLowTThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOARealHighTThreshold_cookie<s(0)(0)(0)>[&];(D1:pbOARealHighTThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOARealAutoShutdown_cookie<s(0)(0)(0)>[&];(D1:pbOARealAutoShutdown_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOARealCoolPumpTemp_cookie<s(0)(0)(0)>[&];(D1:pbOARealCoolPumpTemp_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprGeneral_cookie<s(0)(0)(0)>[&];(D1:rprGeneral_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprProtocols_cookie<s(0)(0)(0)>[&];(D1:rprProtocols_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprService_cookie<s(0)(0)(0)>[&];(D1:rprService_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprWan_cookie<s(0)(0)(0)>[&];(D1:rprWan_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprHwPassThrough_cookie<s(0)(0)(0)>[&];(D1:rprHwPassThrough_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprHwpXcTable_cookie<s(0)(0)(0)>[&];(D1:rprHwpXcTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprHwpXcCapacity_cookie<s(0)(0)(0)>[&];(D1:rprHwpXcCapacity_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprHwpXcSrcSlot_cookie<s(0)(0)(0)>[&];(D1:rprHwpXcSrcSlot_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprHwpXcSrcPort_cookie<s(0)(0)(0)>[&];(D1:rprHwpXcSrcPort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprHwpXcSource_cookie<s(0)(0)(0)>[&];(D1:rprHwpXcSource_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprHwpXcDstSlot_cookie<s(0)(0)(0)>[&];(D1:rprHwpXcDstSlot_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprHwpXcDstPort_cookie<s(0)(0)(0)>[&];(D1:rprHwpXcDstPort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprHwpXcDestination_cookie<s(0)(0)(0)>[&];(D1:rprHwpXcDestination_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprHwpXcSrcPortType_cookie<s(0)(0)(0)>[&];(D1:rprHwpXcSrcPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprHwpXcDstPortType_cookie<s(0)(0)(0)>[&];(D1:rprHwpXcDstPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprHwpXcConnectId_cookie<s(0)(0)(0)>[&];(D1:rprHwpXcConnectId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprHwpXcCircuitDirection_cookie<s(0)(0)(0)>[&];(D1:rprHwpXcCircuitDirection_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprHwpXcCcsRpmMsgType_cookie<s(0)(0)(0)>[&];(D1:rprHwpXcCcsRpmMsgType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprHwpXcCcsRpmMsgState_cookie<s(0)(0)(0)>[&];(D1:rprHwpXcCcsRpmMsgState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprHwpXcCcsRpmMsgPriority_cookie<s(0)(0)(0)>[&];(D1:rprHwpXcCcsRpmMsgPriority_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprHwpXcSrcSlotCard_cookie<s(0)(0)(0)>[&];(D1:rprHwpXcSrcSlotCard_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprHwpXcDstSlotCard_cookie<s(0)(0)(0)>[&];(D1:rprHwpXcDstSlotCard_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprHwpXcReason_cookie<s(0)(0)(0)>[&];(D1:rprHwpXcReason_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprHwpXcRowStatus_cookie<s(0)(0)(0)>[&];(D1:rprHwpXcRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprHwpXcTableClass_cookie<s(0)(0)(0)>[&];(D1:rprHwpXcTableClass_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprWanConfigTable_cookie<s(0)(0)(0)>[&];(D1:pbRprWanConfigTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprLCASBase_cookie<s(0)(0)(0)>[&];(D1:pbRprLCASBase_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSOLCASConfigTable_cookie<s(0)(0)(0)>[&];(D1:pbRprSOLCASConfigTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSKLCASConfigTable_cookie<s(0)(0)(0)>[&];(D1:pbRprSKLCASConfigTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTpType_cookie<s(0)(0)(0)>[&];(D1:pbTpType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTpIndex_cookie<s(0)(0)(0)>[&];(D1:pbTpIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSKLCASWanPort_cookie<s(0)(0)(0)>[&];(D1:pbRprSKLCASWanPort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSKLCASState_cookie<s(0)(0)(0)>[&];(D1:pbRprSKLCASState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTpType_cookie<s(0)(0)(0)>[&];(D1:pbTpType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTpIndex_cookie<s(0)(0)(0)>[&];(D1:pbTpIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSOLCASActive_cookie<s(0)(0)(0)>[&];(D1:pbRprSOLCASActive_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSOLCASWanPort_cookie<s(0)(0)(0)>[&];(D1:pbRprSOLCASWanPort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSOLCASState_cookie<s(0)(0)(0)>[&];(D1:pbRprSOLCASState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprWanPortLabel_cookie<s(0)(0)(0)>[&];(D1:pbRprWanPortLabel_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprWanPortCapacity_cookie<s(0)(0)(0)>[&];(D1:pbRprWanPortCapacity_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprWanPortMonitored_cookie<s(0)(0)(0)>[&];(D1:pbRprWanPortMonitored_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprWanPortXVType_cookie<s(0)(0)(0)>[&];(D1:pbRprWanPortXVType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprWanLCASSupport_cookie<s(0)(0)(0)>[&];(D1:pbRprWanLCASSupport_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprWanPortCapacityTrigger_cookie<s(0)(0)(0)>[&];(D1:pbRprWanPortCapacityTrigger_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprWanGFPFCS_cookie<s(0)(0)(0)>[&];(D1:pbRprWanGFPFCS_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprWanGFPFCSAutoDetect_cookie<s(0)(0)(0)>[&];(D1:pbRprWanGFPFCSAutoDetect_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprWanFlowControl_cookie<s(0)(0)(0)>[&];(D1:pbRprWanFlowControl_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprServiceTable_cookie<s(0)(0)(0)>[&];(D1:rprServiceTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprRateProfileTable_cookie<s(0)(0)(0)>[&];(D1:rprRateProfileTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprMultiCastTable_cookie<s(0)(0)(0)>[&];(D1:pbRprMultiCastTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprAclTable_cookie<s(0)(0)(0)>[&];(D1:pbRprAclTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprMultiBroadCastTable_cookie<s(0)(0)(0)>[&];(D1:pbRprMultiBroadCastTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfIndex_cookie<s(0)(0)(0)>[&];(D1:rprIfIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprMultiBroadCastId_cookie<s(0)(0)(0)>[&];(D1:rprMultiBroadCastId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprMultiBroadCastTimeInterval_cookie<s(0)(0)(0)>[&];(D1:rprMultiBroadCastTimeInterval_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprMultiBroadCastPacketsInterval_cookie<s(0)(0)(0)>[&];(D1:rprMultiBroadCastPacketsInterval_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfIndex_cookie<s(0)(0)(0)>[&];(D1:rprIfIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprServiceId_cookie<s(0)(0)(0)>[&];(D1:rprServiceId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprAclMacAddress_cookie<s(0)(0)(0)>[&];(D1:rprAclMacAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprAclMacType_cookie<s(0)(0)(0)>[&];(D1:rprAclMacType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprAclDoubleVlanId_cookie<s(0)(0)(0)>[&];(D1:rprAclDoubleVlanId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprAclPortsList_cookie<s(0)(0)(0)>[&];(D1:rprAclPortsList_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprAclMode_cookie<s(0)(0)(0)>[&];(D1:rprAclMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprAclRowStatus_cookie<s(0)(0)(0)>[&];(D1:rprAclRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprAclTblIdx_cookie<s(0)(0)(0)>[&];(D1:rprAclTblIdx_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfIndex_cookie<s(0)(0)(0)>[&];(D1:rprIfIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprServiceId_cookie<s(0)(0)(0)>[&];(D1:rprServiceId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprMultiCastMacAddress_cookie<s(0)(0)(0)>[&];(D1:rprMultiCastMacAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprMultiCastDoubleVlanId_cookie<s(0)(0)(0)>[&];(D1:rprMultiCastDoubleVlanId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprMultiCastPortsList_cookie<s(0)(0)(0)>[&];(D1:rprMultiCastPortsList_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprMultiCastGMRP_cookie<s(0)(0)(0)>[&];(D1:rprMultiCastGMRP_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprMultiCastRowStatus_cookie<s(0)(0)(0)>[&];(D1:rprMultiCastRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfIndex_cookie<s(0)(0)(0)>[&];(D1:rprIfIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprRateProfNo_cookie<s(0)(0)(0)>[&];(D1:rprRateProfNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprTokenRate_cookie<s(0)(0)(0)>[&];(D1:rprTokenRate_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprBurstSize_cookie<s(0)(0)(0)>[&];(D1:rprBurstSize_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprExcessBurstSize_cookie<s(0)(0)(0)>[&];(D1:rprExcessBurstSize_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfIndex_cookie<s(0)(0)(0)>[&];(D1:rprIfIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprServiceId_cookie<s(0)(0)(0)>[&];(D1:rprServiceId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprLocalEthPortNo_cookie<s(0)(0)(0)>[&];(D1:rprLocalEthPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprLocalVID_cookie<s(0)(0)(0)>[&];(D1:rprLocalVID_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprLocalVPrio_cookie<s(0)(0)(0)>[&];(D1:rprLocalVPrio_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSvcClassifyType_cookie<s(0)(0)(0)>[&];(D1:rprSvcClassifyType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprServiceType_cookie<s(0)(0)(0)>[&];(D1:rprServiceType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSvcMode_cookie<s(0)(0)(0)>[&];(D1:rprSvcMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprRmtStationMac_cookie<s(0)(0)(0)>[&];(D1:rprRmtStationMac_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSvcRingletSel_cookie<s(0)(0)(0)>[&];(D1:rprSvcRingletSel_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSvcRealRingletSel_cookie<s(0)(0)(0)>[&];(D1:rprSvcRealRingletSel_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSvcAutoRingletSelEn_cookie<s(0)(0)(0)>[&];(D1:rprSvcAutoRingletSelEn_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSvcCos_cookie<s(0)(0)(0)>[&];(D1:rprSvcCos_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSvcTtlMode_cookie<s(0)(0)(0)>[&];(D1:rprSvcTtlMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSvcTtl0_cookie<s(0)(0)(0)>[&];(D1:rprSvcTtl0_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSvcTtl1_cookie<s(0)(0)(0)>[&];(D1:rprSvcTtl1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSvcRealTtl0_cookie<s(0)(0)(0)>[&];(D1:rprSvcRealTtl0_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSvcRealTtl1_cookie<s(0)(0)(0)>[&];(D1:rprSvcRealTtl1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSvcWe_cookie<s(0)(0)(0)>[&];(D1:rprSvcWe_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSvcSteered_cookie<s(0)(0)(0)>[&];(D1:rprSvcSteered_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSvcRateProfIndex_cookie<s(0)(0)(0)>[&];(D1:rprSvcRateProfIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSvcTokenRate_cookie<s(0)(0)(0)>[&];(D1:rprSvcTokenRate_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSvcBurstSize_cookie<s(0)(0)(0)>[&];(D1:rprSvcBurstSize_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSvcMaxDelay_cookie<s(0)(0)(0)>[&];(D1:rprSvcMaxDelay_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSvcMaxJitter_cookie<s(0)(0)(0)>[&];(D1:rprSvcMaxJitter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSvcWeight_cookie<s(0)(0)(0)>[&];(D1:rprSvcWeight_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprGmiiSel_cookie<s(0)(0)(0)>[&];(D1:rprGmiiSel_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprDoubleVlanEn_cookie<s(0)(0)(0)>[&];(D1:rprDoubleVlanEn_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprDoubleVID_cookie<s(0)(0)(0)>[&];(D1:rprDoubleVID_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprDoubleVPrio_cookie<s(0)(0)(0)>[&];(D1:rprDoubleVPrio_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSvcLoop_cookie<s(0)(0)(0)>[&];(D1:rprSvcLoop_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSvcActive_cookie<s(0)(0)(0)>[&];(D1:rprSvcActive_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSvcCurStatus_cookie<s(0)(0)(0)>[&];(D1:rprSvcCurStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSvcReason_cookie<s(0)(0)(0)>[&];(D1:rprSvcReason_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSvcLabel_cookie<s(0)(0)(0)>[&];(D1:rprSvcLabel_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprFlowRuleID_cookie<s(0)(0)(0)>[&];(D1:rprFlowRuleID_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSvcMulBrdCastID_cookie<s(0)(0)(0)>[&];(D1:rprSvcMulBrdCastID_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSvcMulBrdCastEn_cookie<s(0)(0)(0)>[&];(D1:rprSvcMulBrdCastEn_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSvcRowStatus_cookie<s(0)(0)(0)>[&];(D1:rprSvcRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprTopoImageTable_cookie<s(0)(0)(0)>[&];(D1:rprTopoImageTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprFairnessTable_cookie<s(0)(0)(0)>[&];(D1:rprFairnessTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprOamTable_cookie<s(0)(0)(0)>[&];(D1:rprOamTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprTopoRingInfoTable_cookie<s(0)(0)(0)>[&];(D1:rprTopoRingInfoTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfIndex_cookie<s(0)(0)(0)>[&];(D1:rprIfIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprRingMultiChoke0_cookie<s(0)(0)(0)>[&];(D1:rprRingMultiChoke0_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprRingMultiChoke1_cookie<s(0)(0)(0)>[&];(D1:rprRingMultiChoke1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprRingMtuSize_cookie<s(0)(0)(0)>[&];(D1:rprRingMtuSize_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprRingTotalHopsTx0_cookie<s(0)(0)(0)>[&];(D1:rprRingTotalHopsTx0_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprRingTotalHopsTx1_cookie<s(0)(0)(0)>[&];(D1:rprRingTotalHopsTx1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprRingLastNeighborMac0_cookie<s(0)(0)(0)>[&];(D1:rprRingLastNeighborMac0_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprRingLastNeighborMac1_cookie<s(0)(0)(0)>[&];(D1:rprRingLastNeighborMac1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprRingCheckSum_cookie<s(0)(0)(0)>[&];(D1:rprRingCheckSum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprRingNeighborCheckSum0_cookie<s(0)(0)(0)>[&];(D1:rprRingNeighborCheckSum0_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprRingNeighborCheckSum1_cookie<s(0)(0)(0)>[&];(D1:rprRingNeighborCheckSum1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprRingCheckSumValid_cookie<s(0)(0)(0)>[&];(D1:rprRingCheckSumValid_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprRingNeighborCksValid0_cookie<s(0)(0)(0)>[&];(D1:rprRingNeighborCksValid0_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprRingNeighborCksValid1_cookie<s(0)(0)(0)>[&];(D1:rprRingNeighborCksValid1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfIndex_cookie<s(0)(0)(0)>[&];(D1:rprIfIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprOamActionType_cookie<s(0)(0)(0)>[&];(D1:rprOamActionType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprOamDestAddress_cookie<s(0)(0)(0)>[&];(D1:rprOamDestAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprOamRequestRinglet_cookie<s(0)(0)(0)>[&];(D1:rprOamRequestRinglet_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprOamResponseRinglet_cookie<s(0)(0)(0)>[&];(D1:rprOamResponseRinglet_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprOamClassOfService_cookie<s(0)(0)(0)>[&];(D1:rprOamClassOfService_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprOamUserData_cookie<s(0)(0)(0)>[&];(D1:rprOamUserData_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprOamProtected_cookie<s(0)(0)(0)>[&];(D1:rprOamProtected_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprOamRequestCount_cookie<s(0)(0)(0)>[&];(D1:rprOamRequestCount_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprOamTimeout_cookie<s(0)(0)(0)>[&];(D1:rprOamTimeout_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprOamControl_cookie<s(0)(0)(0)>[&];(D1:rprOamControl_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprOamResponseCount_cookie<s(0)(0)(0)>[&];(D1:rprOamResponseCount_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprOamAvResponseTime_cookie<s(0)(0)(0)>[&];(D1:rprOamAvResponseTime_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprOamResponseStatus_cookie<s(0)(0)(0)>[&];(D1:rprOamResponseStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfIndex_cookie<s(0)(0)(0)>[&];(D1:rprIfIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprFairnessRinglet_cookie<s(0)(0)(0)>[&];(D1:rprFairnessRinglet_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprFairnessRingletWeight_cookie<s(0)(0)(0)>[&];(D1:rprFairnessRingletWeight_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprFairnessReservedRate_cookie<s(0)(0)(0)>[&];(D1:rprFairnessReservedRate_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprFairnessMaxAllowed_cookie<s(0)(0)(0)>[&];(D1:rprFairnessMaxAllowed_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprFairnessAgeCoef_cookie<s(0)(0)(0)>[&];(D1:rprFairnessAgeCoef_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprFairnessLpCoef_cookie<s(0)(0)(0)>[&];(D1:rprFairnessLpCoef_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprFairnessAdvertisementRatio_cookie<s(0)(0)(0)>[&];(D1:rprFairnessAdvertisementRatio_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprFairnessMcffReportCoef_cookie<s(0)(0)(0)>[&];(D1:rprFairnessMcffReportCoef_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprFairnessActiveWeightsCoef_cookie<s(0)(0)(0)>[&];(D1:rprFairnessActiveWeightsCoef_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprFairnessSTQHighThreshold_cookie<s(0)(0)(0)>[&];(D1:rprFairnessSTQHighThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprFairnessSTQMedThreshold_cookie<s(0)(0)(0)>[&];(D1:rprFairnessSTQMedThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprFairnessSTQLowThreshold_cookie<s(0)(0)(0)>[&];(D1:rprFairnessSTQLowThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprFairnessRateHighThreshold_cookie<s(0)(0)(0)>[&];(D1:rprFairnessRateHighThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprFairnessRateLowThreshold_cookie<s(0)(0)(0)>[&];(D1:rprFairnessRateLowThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprFairnessResetWaterMarks_cookie<s(0)(0)(0)>[&];(D1:rprFairnessResetWaterMarks_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprFairnessSTQHighWaterMark_cookie<s(0)(0)(0)>[&];(D1:rprFairnessSTQHighWaterMark_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprFairnessSTQLowWaterMark_cookie<s(0)(0)(0)>[&];(D1:rprFairnessSTQLowWaterMark_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprFairnessRampUpCoef_cookie<s(0)(0)(0)>[&];(D1:rprFairnessRampUpCoef_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprFairnessRampDnCoef_cookie<s(0)(0)(0)>[&];(D1:rprFairnessRampDnCoef_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfIndex_cookie<s(0)(0)(0)>[&];(D1:rprIfIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprTopoImageMacAddress_cookie<s(0)(0)(0)>[&];(D1:rprTopoImageMacAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprTopoImageSecMacAddress1_cookie<s(0)(0)(0)>[&];(D1:rprTopoImageSecMacAddress1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprTopoImageSecMacAddress2_cookie<s(0)(0)(0)>[&];(D1:rprTopoImageSecMacAddress2_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprTopoImageStationIfIndex_cookie<s(0)(0)(0)>[&];(D1:rprTopoImageStationIfIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprTopoImageStationName_cookie<s(0)(0)(0)>[&];(D1:rprTopoImageStationName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprTopoImageCapability_cookie<s(0)(0)(0)>[&];(D1:rprTopoImageCapability_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprTopoImageRinglet0Hops_cookie<s(0)(0)(0)>[&];(D1:rprTopoImageRinglet0Hops_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprTopoImageRinglet0ReservedRate_cookie<s(0)(0)(0)>[&];(D1:rprTopoImageRinglet0ReservedRate_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprTopoImageRinglet1Hops_cookie<s(0)(0)(0)>[&];(D1:rprTopoImageRinglet1Hops_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprTopoImageRinglet1ReservedRate_cookie<s(0)(0)(0)>[&];(D1:rprTopoImageRinglet1ReservedRate_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprTopoImageWestProtectionStatus_cookie<s(0)(0)(0)>[&];(D1:rprTopoImageWestProtectionStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprTopoImageWestWeight_cookie<s(0)(0)(0)>[&];(D1:rprTopoImageWestWeight_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprTopoImageEastProtectionStatus_cookie<s(0)(0)(0)>[&];(D1:rprTopoImageEastProtectionStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprTopoImageEastWeight_cookie<s(0)(0)(0)>[&];(D1:rprTopoImageEastWeight_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprTopoImageStatus_cookie<s(0)(0)(0)>[&];(D1:rprTopoImageStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprTopoImageRemoteNEAddress_cookie<s(0)(0)(0)>[&];(D1:rprTopoImageRemoteNEAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprTopoImageRemoteSlotNumber_cookie<s(0)(0)(0)>[&];(D1:rprTopoImageRemoteSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfTable_cookie<s(0)(0)(0)>[&];(D1:rprIfTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSpanTable_cookie<s(0)(0)(0)>[&];(D1:rprSpanTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSpanProtectionTable_cookie<s(0)(0)(0)>[&];(D1:rprSpanProtectionTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprCardProtectionTable_cookie<s(0)(0)(0)>[&];(D1:rprCardProtectionTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfIndex_cookie<s(0)(0)(0)>[&];(D1:rprIfIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprCardProtectionId_cookie<s(0)(0)(0)>[&];(D1:rprCardProtectionId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprCpfWorkSlot_cookie<s(0)(0)(0)>[&];(D1:rprCpfWorkSlot_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprCpfProtSlot_cookie<s(0)(0)(0)>[&];(D1:rprCpfProtSlot_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprCpfActiveSlot_cookie<s(0)(0)(0)>[&];(D1:rprCpfActiveSlot_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprCpfCoordSlot_cookie<s(0)(0)(0)>[&];(D1:rprCpfCoordSlot_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprCpfCoordProtGroup_cookie<s(0)(0)(0)>[&];(D1:rprCpfCoordProtGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprCpfEnable_cookie<s(0)(0)(0)>[&];(D1:rprCpfEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfIndex_cookie<s(0)(0)(0)>[&];(D1:rprIfIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSpanId_cookie<s(0)(0)(0)>[&];(D1:rprSpanId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSpanProtectionNeighborValid_cookie<s(0)(0)(0)>[&];(D1:rprSpanProtectionNeighborValid_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSpanProtectionHoldOffTimer_cookie<s(0)(0)(0)>[&];(D1:rprSpanProtectionHoldOffTimer_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSpanProtectionCommand_cookie<s(0)(0)(0)>[&];(D1:rprSpanProtectionCommand_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSpanProtectionCount_cookie<s(0)(0)(0)>[&];(D1:rprSpanProtectionCount_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSpanProtectionDuration_cookie<s(0)(0)(0)>[&];(D1:rprSpanProtectionDuration_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSpanProtectionLastActivationTime_cookie<s(0)(0)(0)>[&];(D1:rprSpanProtectionLastActivationTime_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSpanProtectionCountReset_cookie<s(0)(0)(0)>[&];(D1:rprSpanProtectionCountReset_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfIndex_cookie<s(0)(0)(0)>[&];(D1:rprIfIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSpanId_cookie<s(0)(0)(0)>[&];(D1:rprSpanId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSpanTotalRingletReservedRate_cookie<s(0)(0)(0)>[&];(D1:rprSpanTotalRingletReservedRate_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSpanCurrentStatus_cookie<s(0)(0)(0)>[&];(D1:rprSpanCurrentStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSpanWanPortNo_cookie<s(0)(0)(0)>[&];(D1:rprSpanWanPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSpanHopsToWrap_cookie<s(0)(0)(0)>[&];(D1:rprSpanHopsToWrap_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfIndex_cookie<s(0)(0)(0)>[&];(D1:rprIfIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfStationsOnRing_cookie<s(0)(0)(0)>[&];(D1:rprIfStationsOnRing_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfReversionMode_cookie<s(0)(0)(0)>[&];(D1:rprIfReversionMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfProtectionWTR_cookie<s(0)(0)(0)>[&];(D1:rprIfProtectionWTR_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfProtectionFastTimer_cookie<s(0)(0)(0)>[&];(D1:rprIfProtectionFastTimer_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfProtectionSlowTimer_cookie<s(0)(0)(0)>[&];(D1:rprIfProtectionSlowTimer_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfAtdTimer_cookie<s(0)(0)(0)>[&];(D1:rprIfAtdTimer_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfKeepaliveTimeout_cookie<s(0)(0)(0)>[&];(D1:rprIfKeepaliveTimeout_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfFairnessMode_cookie<s(0)(0)(0)>[&];(D1:rprIfFairnessMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfPtqSize_cookie<s(0)(0)(0)>[&];(D1:rprIfPtqSize_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfStqSize_cookie<s(0)(0)(0)>[&];(D1:rprIfStqSize_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfSTQFullThreshold_cookie<s(0)(0)(0)>[&];(D1:rprIfSTQFullThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfIdleThreshold_cookie<s(0)(0)(0)>[&];(D1:rprIfIdleThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfSesThreshold_cookie<s(0)(0)(0)>[&];(D1:rprIfSesThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfProtectionMode_cookie<s(0)(0)(0)>[&];(D1:rprIfProtectionMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfJumboFramePreferred_cookie<s(0)(0)(0)>[&];(D1:rprIfJumboFramePreferred_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfMacOperModes_cookie<s(0)(0)(0)>[&];(D1:rprIfMacOperModes_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfRingOperModes_cookie<s(0)(0)(0)>[&];(D1:rprIfRingOperModes_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfCurrentStatus_cookie<s(0)(0)(0)>[&];(D1:rprIfCurrentStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfLinkRate_cookie<s(0)(0)(0)>[&];(D1:rprIfLinkRate_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfMplsMode_cookie<s(0)(0)(0)>[&];(D1:rprIfMplsMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfMplsTypeTag_cookie<s(0)(0)(0)>[&];(D1:rprIfMplsTypeTag_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfVlanPrioEn_cookie<s(0)(0)(0)>[&];(D1:rprIfVlanPrioEn_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfMyMacAddress_cookie<s(0)(0)(0)>[&];(D1:rprIfMyMacAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfPassThroughEn_cookie<s(0)(0)(0)>[&];(D1:rprIfPassThroughEn_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfHwPassThrough_cookie<s(0)(0)(0)>[&];(D1:rprIfHwPassThrough_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfHwPassThroughStatus_cookie<s(0)(0)(0)>[&];(D1:rprIfHwPassThroughStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfResRateR0_cookie<s(0)(0)(0)>[&];(D1:rprIfResRateR0_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfResRateR1_cookie<s(0)(0)(0)>[&];(D1:rprIfResRateR1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfA0RateR0_cookie<s(0)(0)(0)>[&];(D1:rprIfA0RateR0_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfA0RateR1_cookie<s(0)(0)(0)>[&];(D1:rprIfA0RateR1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfA1RateR0_cookie<s(0)(0)(0)>[&];(D1:rprIfA1RateR0_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfA1RateR1_cookie<s(0)(0)(0)>[&];(D1:rprIfA1RateR1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfBcirRateR0_cookie<s(0)(0)(0)>[&];(D1:rprIfBcirRateR0_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfBcirRateR1_cookie<s(0)(0)(0)>[&];(D1:rprIfBcirRateR1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfRealA0RateR0_cookie<s(0)(0)(0)>[&];(D1:rprIfRealA0RateR0_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfRealA0RateR1_cookie<s(0)(0)(0)>[&];(D1:rprIfRealA0RateR1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfRealA1RateR0_cookie<s(0)(0)(0)>[&];(D1:rprIfRealA1RateR0_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfRealA1RateR1_cookie<s(0)(0)(0)>[&];(D1:rprIfRealA1RateR1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfRealBcirRateR0_cookie<s(0)(0)(0)>[&];(D1:rprIfRealBcirRateR0_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfRealBcirRateR1_cookie<s(0)(0)(0)>[&];(D1:rprIfRealBcirRateR1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfAlarmMon_cookie<s(0)(0)(0)>[&];(D1:rprIfAlarmMon_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfStationName_cookie<s(0)(0)(0)>[&];(D1:rprIfStationName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfInterWorking_cookie<s(0)(0)(0)>[&];(D1:rprIfInterWorking_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfBandMode_cookie<s(0)(0)(0)>[&];(D1:rprIfBandMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfMulBrdCastEn_cookie<s(0)(0)(0)>[&];(D1:rprIfMulBrdCastEn_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfCardProtection_cookie<s(0)(0)(0)>[&];(D1:rprIfCardProtection_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfCardProtectionState_cookie<s(0)(0)(0)>[&];(D1:rprIfCardProtectionState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfL2RateLimitMode_cookie<s(0)(0)(0)>[&];(D1:rprIfL2RateLimitMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfCrossPortsList_cookie<s(0)(0)(0)>[&];(D1:rprIfCrossPortsList_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfLogSave_cookie<s(0)(0)(0)>[&];(D1:rprIfLogSave_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfL2CosFlowControl_cookie<s(0)(0)(0)>[&];(D1:rprIfL2CosFlowControl_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXConConnectCapacity_cookie<s(0)(0)(0)>[&];(D1:pbXConConnectCapacity_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXConConnectSrcSlot_cookie<s(0)(0)(0)>[&];(D1:pbXConConnectSrcSlot_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXConConnectSrcPort_cookie<s(0)(0)(0)>[&];(D1:pbXConConnectSrcPort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXConConnectSrcPortType_cookie<s(0)(0)(0)>[&];(D1:pbXConConnectSrcPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXConConnectSource_cookie<s(0)(0)(0)>[&];(D1:pbXConConnectSource_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXConConnectDstSlot_cookie<s(0)(0)(0)>[&];(D1:pbXConConnectDstSlot_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXConConnectDstPort_cookie<s(0)(0)(0)>[&];(D1:pbXConConnectDstPort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXConConnectDstPortType_cookie<s(0)(0)(0)>[&];(D1:pbXConConnectDstPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXConConnectDestination_cookie<s(0)(0)(0)>[&];(D1:pbXConConnectDestination_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXConConnectId_cookie<s(0)(0)(0)>[&];(D1:pbXConConnectId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXConConnectCircuitId_cookie<s(0)(0)(0)>[&];(D1:pbXConConnectCircuitId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXConConnectStatus_cookie<s(0)(0)(0)>[&];(D1:pbXConConnectStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXConConnectReason_cookie<s(0)(0)(0)>[&];(D1:pbXConConnectReason_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXConConnectType_cookie<s(0)(0)(0)>[&];(D1:pbXConConnectType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXConConnectCircuitDirection_cookie<s(0)(0)(0)>[&];(D1:pbXConConnectCircuitDirection_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXConConnectAction_cookie<s(0)(0)(0)>[&];(D1:pbXConConnectAction_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXConFrom_cookie<s(0)(0)(0)>[&];(D1:pbXConFrom_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXConRowStatus_cookie<s(0)(0)(0)>[&];(D1:pbXConRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXConConnectReqNo_cookie<s(0)(0)(0)>[&];(D1:pbXConConnectReqNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXCGmplsVcNumber_cookie<s(0)(0)(0)>[&];(D1:pbXCGmplsVcNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXCGmplsCallName_cookie<s(0)(0)(0)>[&];(D1:pbXCGmplsCallName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGmplsCcDirection_cookie<s(0)(0)(0)>[&];(D1:pbGmplsCcDirection_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXCExtendObjects_cookie<s(0)(0)(0)>[&];(D1:pbXCExtendObjects_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSdhXcNewContextTable_cookie<s(0)(0)(0)>[&];(D1:pbSdhXcNewContextTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSdhXcNewLoMapTable_cookie<s(0)(0)(0)>[&];(D1:pbSdhXcNewLoMapTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXcMigrationGroup_cookie<s(0)(0)(0)>[&];(D1:pbXcMigrationGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbForwardXcId_cookie<s(0)(0)(0)>[&];(D1:pbForwardXcId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbReverseXcId_cookie<s(0)(0)(0)>[&];(D1:pbReverseXcId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXcMigrationCommand_cookie<s(0)(0)(0)>[&];(D1:pbXcMigrationCommand_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXcMigrationStatus_cookie<s(0)(0)(0)>[&];(D1:pbXcMigrationStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXConLoMapLOCCSlot_cookie<s(0)(0)(0)>[&];(D1:pbXConLoMapLOCCSlot_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXConLoMapLOCCPortType_cookie<s(0)(0)(0)>[&];(D1:pbXConLoMapLOCCPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXConLoMapLOCCPort_cookie<s(0)(0)(0)>[&];(D1:pbXConLoMapLOCCPort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXConLoMapHOCCIndex_cookie<s(0)(0)(0)>[&];(D1:pbXConLoMapHOCCIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXConLoMapLCSlot_cookie<s(0)(0)(0)>[&];(D1:pbXConLoMapLCSlot_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXConLoMapLCPortType_cookie<s(0)(0)(0)>[&];(D1:pbXConLoMapLCPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXConLoMapLCPort_cookie<s(0)(0)(0)>[&];(D1:pbXConLoMapLCPort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXConLoMapLCTP_cookie<s(0)(0)(0)>[&];(D1:pbXConLoMapLCTP_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] gmplsReservationStatus_cookie<s(0)(0)(0)>[&];(D1:gmplsReservationStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] gmplsReservationOperate_cookie<s(0)(0)(0)>[&];(D1:gmplsReservationOperate_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXConContextLOCCBusNum_cookie<s(0)(0)(0)>[&];(D1:pbXConContextLOCCBusNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXConContextLOCCAuNum_cookie<s(0)(0)(0)>[&];(D1:pbXConContextLOCCAuNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXConContextHOCCAu3Num_cookie<s(0)(0)(0)>[&];(D1:pbXConContextHOCCAu3Num_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXConContextHOCCAu3Step_cookie<s(0)(0)(0)>[&];(D1:pbXConContextHOCCAu3Step_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXConContextHOCCAu3Count_cookie<s(0)(0)(0)>[&];(D1:pbXConContextHOCCAu3Count_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthGlobalPortTable_cookie<s(0)(0)(0)>[&];(D1:pbEthGlobalPortTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthConfigTable_cookie<s(0)(0)(0)>[&];(D1:pbEthConfigTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthWanConfigTable_cookie<s(0)(0)(0)>[&];(D1:pbEthWanConfigTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthStaticMACTable_cookie<s(0)(0)(0)>[&];(D1:pbEthStaticMACTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthStaticMulticastTable_cookie<s(0)(0)(0)>[&];(D1:pbEthStaticMulticastTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbVlanPortCoSTable_cookie<s(0)(0)(0)>[&];(D1:pbVlanPortCoSTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanNameTable_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanNameTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortQueueTable_cookie<s(0)(0)(0)>[&];(D1:pbPortQueueTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthACLTable_cookie<s(0)(0)(0)>[&];(D1:pbEthACLTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpBase_cookie<s(0)(0)(0)>[&];(D1:pbRstpBase_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthStatusTable_cookie<s(0)(0)(0)>[&];(D1:pbEthStatusTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbVlanPortQinQTable_cookie<s(0)(0)(0)>[&];(D1:pbVlanPortQinQTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthProtPktACLTable_cookie<s(0)(0)(0)>[&];(D1:pbEthProtPktACLTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthReservedTable_cookie<s(0)(0)(0)>[&];(D1:pbEthReservedTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIGMPSnooping_cookie<s(0)(0)(0)>[&];(D1:pbIGMPSnooping_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstpBase_cookie<s(0)(0)(0)>[&];(D1:pbMstpBase_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLagConfigTable_cookie<s(0)(0)(0)>[&];(D1:pbLagConfigTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpConfig_cookie<s(0)(0)(0)>[&];(D1:pbLacpConfig_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthStaticMplsTable_cookie<s(0)(0)(0)>[&];(D1:pbEthStaticMplsTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] eosMapper_cookie<s(0)(0)(0)>[&];(D1:eosMapper_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGvrpBase_cookie<s(0)(0)(0)>[&];(D1:pbGvrpBase_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPolicingTable_cookie<s(0)(0)(0)>[&];(D1:pbEthPolicingTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthColorTable_cookie<s(0)(0)(0)>[&];(D1:pbEthColorTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthWredTable_cookie<s(0)(0)(0)>[&];(D1:pbEthWredTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPortBasedACLTable_cookie<s(0)(0)(0)>[&];(D1:pbEthPortBasedACLTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGmrpBase_cookie<s(0)(0)(0)>[&];(D1:pbGmrpBase_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGmrpBridgeTable_cookie<s(0)(0)(0)>[&];(D1:pbGmrpBridgeTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGmrpPortTable_cookie<s(0)(0)(0)>[&];(D1:pbGmrpPortTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbVlanGmrpTable_cookie<s(0)(0)(0)>[&];(D1:pbVlanGmrpTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGmrpDMacTable_cookie<s(0)(0)(0)>[&];(D1:pbGmrpDMacTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGmrpVlanId_cookie<s(0)(0)(0)>[&];(D1:pbGmrpVlanId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGmrpMacAddr_cookie<s(0)(0)(0)>[&];(D1:pbGmrpMacAddr_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGmrpMacMemberPort1_cookie<s(0)(0)(0)>[&];(D1:pbGmrpMacMemberPort1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGmrpMacMemberPort2_cookie<s(0)(0)(0)>[&];(D1:pbGmrpMacMemberPort2_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGmrpVlanNumber_cookie<s(0)(0)(0)>[&];(D1:pbGmrpVlanNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbVlanGmrpEnable_cookie<s(0)(0)(0)>[&];(D1:pbVlanGmrpEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbVlanGmrpRowStatus_cookie<s(0)(0)(0)>[&];(D1:pbVlanGmrpRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGmrpPortType_cookie<s(0)(0)(0)>[&];(D1:pbGmrpPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGmrpPortNo_cookie<s(0)(0)(0)>[&];(D1:pbGmrpPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGmrpPortEnable_cookie<s(0)(0)(0)>[&];(D1:pbGmrpPortEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGmrpPortRegAdminCtrl_cookie<s(0)(0)(0)>[&];(D1:pbGmrpPortRegAdminCtrl_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGmrpPortApplAdminCtrl_cookie<s(0)(0)(0)>[&];(D1:pbGmrpPortApplAdminCtrl_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGmrpForwardAllEnable_cookie<s(0)(0)(0)>[&];(D1:pbGmrpForwardAllEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGmrpBlockPortEnable_cookie<s(0)(0)(0)>[&];(D1:pbGmrpBlockPortEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGmrpBridgeAddress_cookie<s(0)(0)(0)>[&];(D1:pbGmrpBridgeAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGmrpEnable_cookie<s(0)(0)(0)>[&];(D1:pbGmrpEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGmrpJoinTimer_cookie<s(0)(0)(0)>[&];(D1:pbGmrpJoinTimer_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGmrpLeaveTimer_cookie<s(0)(0)(0)>[&];(D1:pbGmrpLeaveTimer_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGmrpLeaveallTimer_cookie<s(0)(0)(0)>[&];(D1:pbGmrpLeaveallTimer_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGmrpMaxDMacNum_cookie<s(0)(0)(0)>[&];(D1:pbGmrpMaxDMacNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPortCls_cookie<s(0)(0)(0)>[&];(D1:pbEthPortCls_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPortBasedACLMacAddr_cookie<s(0)(0)(0)>[&];(D1:pbEthPortBasedACLMacAddr_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPortBasedACLVid_cookie<s(0)(0)(0)>[&];(D1:pbEthPortBasedACLVid_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPortBasedACLItemType_cookie<s(0)(0)(0)>[&];(D1:pbEthPortBasedACLItemType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPortBasedACLRateLimit_cookie<s(0)(0)(0)>[&];(D1:pbEthPortBasedACLRateLimit_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPortBasedACLCoS_cookie<s(0)(0)(0)>[&];(D1:pbEthPortBasedACLCoS_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPortBasedACLIndex_cookie<s(0)(0)(0)>[&];(D1:pbEthPortBasedACLIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPortBasedACLEntryRowStatus_cookie<s(0)(0)(0)>[&];(D1:pbEthPortBasedACLEntryRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthWredIndex_cookie<s(0)(0)(0)>[&];(D1:pbEthWredIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthWredLowThr0_cookie<s(0)(0)(0)>[&];(D1:pbEthWredLowThr0_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthWredUpThr0_cookie<s(0)(0)(0)>[&];(D1:pbEthWredUpThr0_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthWredLowThr1_cookie<s(0)(0)(0)>[&];(D1:pbEthWredLowThr1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthWredUpThr1_cookie<s(0)(0)(0)>[&];(D1:pbEthWredUpThr1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthWredLowThr2_cookie<s(0)(0)(0)>[&];(D1:pbEthWredLowThr2_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthWredUpThr2_cookie<s(0)(0)(0)>[&];(D1:pbEthWredUpThr2_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthWredRowStatus_cookie<s(0)(0)(0)>[&];(D1:pbEthWredRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthWredCount_cookie<s(0)(0)(0)>[&];(D1:pbEthWredCount_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthColorIndex_cookie<s(0)(0)(0)>[&];(D1:pbEthColorIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPrio0Color_cookie<s(0)(0)(0)>[&];(D1:pbEthPrio0Color_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPrio1Color_cookie<s(0)(0)(0)>[&];(D1:pbEthPrio1Color_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPrio2Color_cookie<s(0)(0)(0)>[&];(D1:pbEthPrio2Color_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPrio3Color_cookie<s(0)(0)(0)>[&];(D1:pbEthPrio3Color_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPrio4Color_cookie<s(0)(0)(0)>[&];(D1:pbEthPrio4Color_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPrio5Color_cookie<s(0)(0)(0)>[&];(D1:pbEthPrio5Color_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPrio6Color_cookie<s(0)(0)(0)>[&];(D1:pbEthPrio6Color_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPrio7Color_cookie<s(0)(0)(0)>[&];(D1:pbEthPrio7Color_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthColorRowStatus_cookie<s(0)(0)(0)>[&];(D1:pbEthColorRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthColorCount_cookie<s(0)(0)(0)>[&];(D1:pbEthColorCount_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPolicingIndex_cookie<s(0)(0)(0)>[&];(D1:pbEthPolicingIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPolicingName_cookie<s(0)(0)(0)>[&];(D1:pbEthPolicingName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPolicingMode_cookie<s(0)(0)(0)>[&];(D1:pbEthPolicingMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPolicingEIRPIR_cookie<s(0)(0)(0)>[&];(D1:pbEthPolicingEIRPIR_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPolicingCIR_cookie<s(0)(0)(0)>[&];(D1:pbEthPolicingCIR_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPolicingEBSPBS_cookie<s(0)(0)(0)>[&];(D1:pbEthPolicingEBSPBS_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPolicingCBS_cookie<s(0)(0)(0)>[&];(D1:pbEthPolicingCBS_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPolicingColorAware_cookie<s(0)(0)(0)>[&];(D1:pbEthPolicingColorAware_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPolicingDiscardColor_cookie<s(0)(0)(0)>[&];(D1:pbEthPolicingDiscardColor_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPolicingRowStatus_cookie<s(0)(0)(0)>[&];(D1:pbEthPolicingRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPolicingCount_cookie<s(0)(0)(0)>[&];(D1:pbEthPolicingCount_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGvrpBridgeTable_cookie<s(0)(0)(0)>[&];(D1:pbGvrpBridgeTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGvrpPortTable_cookie<s(0)(0)(0)>[&];(D1:pbGvrpPortTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGvrpDVlanTable_cookie<s(0)(0)(0)>[&];(D1:pbGvrpDVlanTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGvrpDPortType_cookie<s(0)(0)(0)>[&];(D1:pbGvrpDPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGvrpDPortNo_cookie<s(0)(0)(0)>[&];(D1:pbGvrpDPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGvrpDVlanList_cookie<s(0)(0)(0)>[&];(D1:pbGvrpDVlanList_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGvrpPortType_cookie<s(0)(0)(0)>[&];(D1:pbGvrpPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGvrpPortNo_cookie<s(0)(0)(0)>[&];(D1:pbGvrpPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGvrpPortEnable_cookie<s(0)(0)(0)>[&];(D1:pbGvrpPortEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGvrpPortRegAdminCtrl_cookie<s(0)(0)(0)>[&];(D1:pbGvrpPortRegAdminCtrl_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGvrpPortApplAdminCtrl_cookie<s(0)(0)(0)>[&];(D1:pbGvrpPortApplAdminCtrl_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGvrpBlockPortEnable_cookie<s(0)(0)(0)>[&];(D1:pbGvrpBlockPortEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGvrpBridgeAddress_cookie<s(0)(0)(0)>[&];(D1:pbGvrpBridgeAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGvrpEnable_cookie<s(0)(0)(0)>[&];(D1:pbGvrpEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGvrpJoinTimer_cookie<s(0)(0)(0)>[&];(D1:pbGvrpJoinTimer_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGvrpLeaveTimer_cookie<s(0)(0)(0)>[&];(D1:pbGvrpLeaveTimer_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGvrpLeaveallTimer_cookie<s(0)(0)(0)>[&];(D1:pbGvrpLeaveallTimer_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGvrpVlanList_cookie<s(0)(0)(0)>[&];(D1:pbGvrpVlanList_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGvrpMaxDVlanNum_cookie<s(0)(0)(0)>[&];(D1:pbGvrpMaxDVlanNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vcgConfigTable_cookie<s(0)(0)(0)>[&];(D1:vcgConfigTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] eosGlobalConfigTable_cookie<s(0)(0)(0)>[&];(D1:eosGlobalConfigTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSOLCASConfigTable_cookie<s(0)(0)(0)>[&];(D1:pbSOLCASConfigTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSKLCASConfigTable_cookie<s(0)(0)(0)>[&];(D1:pbSKLCASConfigTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTpType_cookie<s(0)(0)(0)>[&];(D1:pbTpType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTpIndex_cookie<s(0)(0)(0)>[&];(D1:pbTpIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSKLCASVCGPort_cookie<s(0)(0)(0)>[&];(D1:pbSKLCASVCGPort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSKLCASState_cookie<s(0)(0)(0)>[&];(D1:pbSKLCASState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTpType_cookie<s(0)(0)(0)>[&];(D1:pbTpType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTpIndex_cookie<s(0)(0)(0)>[&];(D1:pbTpIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSOLCASActive_cookie<s(0)(0)(0)>[&];(D1:pbSOLCASActive_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSOLCASVCGPort_cookie<s(0)(0)(0)>[&];(D1:pbSOLCASVCGPort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSOLCASState_cookie<s(0)(0)(0)>[&];(D1:pbSOLCASState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] eosIPGConfig_cookie<s(0)(0)(0)>[&];(D1:eosIPGConfig_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] eosMTUSize_cookie<s(0)(0)(0)>[&];(D1:eosMTUSize_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] eosEslConfig_cookie<s(0)(0)(0)>[&];(D1:eosEslConfig_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vcgNo_cookie<s(0)(0)(0)>[&];(D1:vcgNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vcgLabel_cookie<s(0)(0)(0)>[&];(D1:vcgLabel_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vcgXVType_cookie<s(0)(0)(0)>[&];(D1:vcgXVType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vcgChannelId_cookie<s(0)(0)(0)>[&];(D1:vcgChannelId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vcgLCASSupport_cookie<s(0)(0)(0)>[&];(D1:vcgLCASSupport_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vcgCapacityTrigger_cookie<s(0)(0)(0)>[&];(D1:vcgCapacityTrigger_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vcgPauseTransparent_cookie<s(0)(0)(0)>[&];(D1:vcgPauseTransparent_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vcgLcasHoldOffTime_cookie<s(0)(0)(0)>[&];(D1:vcgLcasHoldOffTime_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vcgGfpMode_cookie<s(0)(0)(0)>[&];(D1:vcgGfpMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vcgGfpType_cookie<s(0)(0)(0)>[&];(D1:vcgGfpType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vcgGfpFCS_cookie<s(0)(0)(0)>[&];(D1:vcgGfpFCS_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vcgGfpFcsAutoDetect_cookie<s(0)(0)(0)>[&];(D1:vcgGfpFcsAutoDetect_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vcgGfpCsfAutoMode_cookie<s(0)(0)(0)>[&];(D1:vcgGfpCsfAutoMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vcgPortMonMode_cookie<s(0)(0)(0)>[&];(D1:vcgPortMonMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vcgPortAlarmDisable_cookie<s(0)(0)(0)>[&];(D1:vcgPortAlarmDisable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vcgPLCTThreshold_cookie<s(0)(0)(0)>[&];(D1:vcgPLCTThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vcgPLCRThreshold_cookie<s(0)(0)(0)>[&];(D1:vcgPLCRThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthLspLabel_cookie<s(0)(0)(0)>[&];(D1:pbEthLspLabel_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthInPort_cookie<s(0)(0)(0)>[&];(D1:pbEthInPort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthInPortType_cookie<s(0)(0)(0)>[&];(D1:pbEthInPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPort_cookie<s(0)(0)(0)>[&];(D1:pbEthPort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthOutPortType_cookie<s(0)(0)(0)>[&];(D1:pbEthOutPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthStaticMplsPolicingID_cookie<s(0)(0)(0)>[&];(D1:pbEthStaticMplsPolicingID_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthStaticMplsColorID_cookie<s(0)(0)(0)>[&];(D1:pbEthStaticMplsColorID_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthStaticMplsStatus_cookie<s(0)(0)(0)>[&];(D1:pbEthStaticMplsStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthLspName_cookie<s(0)(0)(0)>[&];(D1:pbEthLspName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpGlobalCfgTable_cookie<s(0)(0)(0)>[&];(D1:pbLacpGlobalCfgTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpAgConfigTable_cookie<s(0)(0)(0)>[&];(D1:pbLacpAgConfigTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpAgInformTable_cookie<s(0)(0)(0)>[&];(D1:pbLacpAgInformTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpApConfigTable_cookie<s(0)(0)(0)>[&];(D1:pbLacpApConfigTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpApInformTable_cookie<s(0)(0)(0)>[&];(D1:pbLacpApInformTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpPortType_cookie<s(0)(0)(0)>[&];(D1:pbLacpPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpPortLinkState_cookie<s(0)(0)(0)>[&];(D1:pbLacpPortLinkState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpPortBelongAg_cookie<s(0)(0)(0)>[&];(D1:pbLacpPortBelongAg_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpPortSync_cookie<s(0)(0)(0)>[&];(D1:pbLacpPortSync_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpPortOperKey_cookie<s(0)(0)(0)>[&];(D1:pbLacpPortOperKey_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpPartnerPortNo_cookie<s(0)(0)(0)>[&];(D1:pbLacpPartnerPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpPartnerPortMode_cookie<s(0)(0)(0)>[&];(D1:pbLacpPartnerPortMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpPartnerPortPri_cookie<s(0)(0)(0)>[&];(D1:pbLacpPartnerPortPri_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpPartnerOperKey_cookie<s(0)(0)(0)>[&];(D1:pbLacpPartnerOperKey_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpPartnerPortState_cookie<s(0)(0)(0)>[&];(D1:pbLacpPartnerPortState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpPortType_cookie<s(0)(0)(0)>[&];(D1:pbLacpPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpTimeoutMode_cookie<s(0)(0)(0)>[&];(D1:pbLacpTimeoutMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpPortIndiv_cookie<s(0)(0)(0)>[&];(D1:pbLacpPortIndiv_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpActiveMode_cookie<s(0)(0)(0)>[&];(D1:pbLacpActiveMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpDesigAggor_cookie<s(0)(0)(0)>[&];(D1:pbLacpDesigAggor_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpPortPri_cookie<s(0)(0)(0)>[&];(D1:pbLacpPortPri_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpPortBpduMode_cookie<s(0)(0)(0)>[&];(D1:pbLacpPortBpduMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpAgNo_cookie<s(0)(0)(0)>[&];(D1:pbLacpAgNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpAgOperKey_cookie<s(0)(0)(0)>[&];(D1:pbLacpAgOperKey_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpPortList_cookie<s(0)(0)(0)>[&];(D1:pbLacpPortList_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpPartnerMac_cookie<s(0)(0)(0)>[&];(D1:pbLacpPartnerMac_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpPartnerSysPri_cookie<s(0)(0)(0)>[&];(D1:pbLacpPartnerSysPri_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpPartnerAgOperKey_cookie<s(0)(0)(0)>[&];(D1:pbLacpPartnerAgOperKey_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpPortTypeInAg_cookie<s(0)(0)(0)>[&];(D1:pbLacpPortTypeInAg_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpPortSpeedInAg_cookie<s(0)(0)(0)>[&];(D1:pbLacpPortSpeedInAg_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpAgNo_cookie<s(0)(0)(0)>[&];(D1:pbLacpAgNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpAgName_cookie<s(0)(0)(0)>[&];(D1:pbLacpAgName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpAgMac_cookie<s(0)(0)(0)>[&];(D1:pbLacpAgMac_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpAgMode_cookie<s(0)(0)(0)>[&];(D1:pbLacpAgMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpAgRowState_cookie<s(0)(0)(0)>[&];(D1:pbLacpAgRowState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpEnable_cookie<s(0)(0)(0)>[&];(D1:pbLacpEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpSystemID_cookie<s(0)(0)(0)>[&];(D1:pbLacpSystemID_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpSystemPri_cookie<s(0)(0)(0)>[&];(D1:pbLacpSystemPri_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLacpHashMode_cookie<s(0)(0)(0)>[&];(D1:pbLacpHashMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLagId_cookie<s(0)(0)(0)>[&];(D1:pbLagId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLagType_cookie<s(0)(0)(0)>[&];(D1:pbLagType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLagFlowControl_cookie<s(0)(0)(0)>[&];(D1:pbLagFlowControl_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLagPvid_cookie<s(0)(0)(0)>[&];(D1:pbLagPvid_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLagVlan_cookie<s(0)(0)(0)>[&];(D1:pbLagVlan_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLagTagMode_cookie<s(0)(0)(0)>[&];(D1:pbLagTagMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLagInputRateLimit_cookie<s(0)(0)(0)>[&];(D1:pbLagInputRateLimit_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLagBroadCastRateLimit_cookie<s(0)(0)(0)>[&];(D1:pbLagBroadCastRateLimit_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLagDefaultVlanPriority_cookie<s(0)(0)(0)>[&];(D1:pbLagDefaultVlanPriority_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLagTxPriAlg_cookie<s(0)(0)(0)>[&];(D1:pbLagTxPriAlg_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLagTxEnableHol_cookie<s(0)(0)(0)>[&];(D1:pbLagTxEnableHol_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLagChangeCoS_cookie<s(0)(0)(0)>[&];(D1:pbLagChangeCoS_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLagQinQStatus_cookie<s(0)(0)(0)>[&];(D1:pbLagQinQStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLagQinQNewVlan_cookie<s(0)(0)(0)>[&];(D1:pbLagQinQNewVlan_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLagQinQNewVlanPriority_cookie<s(0)(0)(0)>[&];(D1:pbLagQinQNewVlanPriority_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLagPortList_cookie<s(0)(0)(0)>[&];(D1:pbLagPortList_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLagEnableWred_cookie<s(0)(0)(0)>[&];(D1:pbLagEnableWred_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstpBridgeBase_cookie<s(0)(0)(0)>[&];(D1:pbMstpBridgeBase_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstpPortBase_cookie<s(0)(0)(0)>[&];(D1:pbMstpPortBase_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstpBridgeStateBase_cookie<s(0)(0)(0)>[&];(D1:pbMstpBridgeStateBase_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstpPortStateBase_cookie<s(0)(0)(0)>[&];(D1:pbMstpPortStateBase_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCistPortStateTable_cookie<s(0)(0)(0)>[&];(D1:pbCistPortStateTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstiPortStateTable_cookie<s(0)(0)(0)>[&];(D1:pbMstiPortStateTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstPortType_cookie<s(0)(0)(0)>[&];(D1:pbMstPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstiNumber_cookie<s(0)(0)(0)>[&];(D1:pbMstiNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstiPPVector1_cookie<s(0)(0)(0)>[&];(D1:pbMstiPPVector1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstiPPVector2_cookie<s(0)(0)(0)>[&];(D1:pbMstiPPVector2_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstiDPVector1_cookie<s(0)(0)(0)>[&];(D1:pbMstiDPVector1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstiDPVector2_cookie<s(0)(0)(0)>[&];(D1:pbMstiDPVector2_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstiMPVector1_cookie<s(0)(0)(0)>[&];(D1:pbMstiMPVector1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstiMPVector2_cookie<s(0)(0)(0)>[&];(D1:pbMstiMPVector2_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstiPTimes_cookie<s(0)(0)(0)>[&];(D1:pbMstiPTimes_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstiDTimes_cookie<s(0)(0)(0)>[&];(D1:pbMstiDTimes_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstiMTimes_cookie<s(0)(0)(0)>[&];(D1:pbMstiMTimes_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstiPState_cookie<s(0)(0)(0)>[&];(D1:pbMstiPState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstiPInfoIs_cookie<s(0)(0)(0)>[&];(D1:pbMstiPInfoIs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstiPRole_cookie<s(0)(0)(0)>[&];(D1:pbMstiPRole_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstiPSelectedRole_cookie<s(0)(0)(0)>[&];(D1:pbMstiPSelectedRole_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstPortType_cookie<s(0)(0)(0)>[&];(D1:pbMstPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCistPortEnable_cookie<s(0)(0)(0)>[&];(D1:pbCistPortEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCistPPVector1_cookie<s(0)(0)(0)>[&];(D1:pbCistPPVector1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCistPPVector2_cookie<s(0)(0)(0)>[&];(D1:pbCistPPVector2_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCistPPVector3_cookie<s(0)(0)(0)>[&];(D1:pbCistPPVector3_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCistDPVector1_cookie<s(0)(0)(0)>[&];(D1:pbCistDPVector1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCistDPVector2_cookie<s(0)(0)(0)>[&];(D1:pbCistDPVector2_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCistDPVector3_cookie<s(0)(0)(0)>[&];(D1:pbCistDPVector3_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCistMPVector1_cookie<s(0)(0)(0)>[&];(D1:pbCistMPVector1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCistMPVector2_cookie<s(0)(0)(0)>[&];(D1:pbCistMPVector2_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCistMPVector3_cookie<s(0)(0)(0)>[&];(D1:pbCistMPVector3_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCistPTimes_cookie<s(0)(0)(0)>[&];(D1:pbCistPTimes_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCistDTimes_cookie<s(0)(0)(0)>[&];(D1:pbCistDTimes_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCistMTimes_cookie<s(0)(0)(0)>[&];(D1:pbCistMTimes_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCistPState_cookie<s(0)(0)(0)>[&];(D1:pbCistPState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCistPInfoIs_cookie<s(0)(0)(0)>[&];(D1:pbCistPInfoIs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCistPRole_cookie<s(0)(0)(0)>[&];(D1:pbCistPRole_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCistPPState_cookie<s(0)(0)(0)>[&];(D1:pbCistPPState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstRcvdInternal_cookie<s(0)(0)(0)>[&];(D1:pbMstRcvdInternal_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortBpduRule_cookie<s(0)(0)(0)>[&];(D1:pbPortBpduRule_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortOperEdge_cookie<s(0)(0)(0)>[&];(D1:pbPortOperEdge_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCistBridgeStateTable_cookie<s(0)(0)(0)>[&];(D1:pbCistBridgeStateTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstiBridgeStateTable_cookie<s(0)(0)(0)>[&];(D1:pbMstiBridgeStateTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstiNumber_cookie<s(0)(0)(0)>[&];(D1:pbMstiNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstiRPVector1_cookie<s(0)(0)(0)>[&];(D1:pbMstiRPVector1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstiRPVector2_cookie<s(0)(0)(0)>[&];(D1:pbMstiRPVector2_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstiRootRemainingHops_cookie<s(0)(0)(0)>[&];(D1:pbMstiRootRemainingHops_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstiRootPortId_cookie<s(0)(0)(0)>[&];(D1:pbMstiRootPortId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstBaseNumPorts_cookie<s(0)(0)(0)>[&];(D1:pbMstBaseNumPorts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCistRPVector1_cookie<s(0)(0)(0)>[&];(D1:pbCistRPVector1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCistRPVector2_cookie<s(0)(0)(0)>[&];(D1:pbCistRPVector2_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCistRPVector3_cookie<s(0)(0)(0)>[&];(D1:pbCistRPVector3_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstRootMaxAge_cookie<s(0)(0)(0)>[&];(D1:pbMstRootMaxAge_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstRootMsgAge_cookie<s(0)(0)(0)>[&];(D1:pbMstRootMsgAge_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstRootHelloTime_cookie<s(0)(0)(0)>[&];(D1:pbMstRootHelloTime_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstRootForwardDelay_cookie<s(0)(0)(0)>[&];(D1:pbMstRootForwardDelay_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCistRootRemainingHops_cookie<s(0)(0)(0)>[&];(D1:pbCistRootRemainingHops_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCistRootPortId_cookie<s(0)(0)(0)>[&];(D1:pbCistRootPortId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstCfgDigest_cookie<s(0)(0)(0)>[&];(D1:pbMstCfgDigest_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCistPortTable_cookie<s(0)(0)(0)>[&];(D1:pbCistPortTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstiPortTable_cookie<s(0)(0)(0)>[&];(D1:pbMstiPortTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstPortType_cookie<s(0)(0)(0)>[&];(D1:pbMstPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstiNumber_cookie<s(0)(0)(0)>[&];(D1:pbMstiNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstiPortPriority_cookie<s(0)(0)(0)>[&];(D1:pbMstiPortPriority_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstiPortPathCost_cookie<s(0)(0)(0)>[&];(D1:pbMstiPortPathCost_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstPortType_cookie<s(0)(0)(0)>[&];(D1:pbMstPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstPort_cookie<s(0)(0)(0)>[&];(D1:pbMstPort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCistPortPriority_cookie<s(0)(0)(0)>[&];(D1:pbCistPortPriority_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCistExPortPathCost_cookie<s(0)(0)(0)>[&];(D1:pbCistExPortPathCost_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCistInPortPathCost_cookie<s(0)(0)(0)>[&];(D1:pbCistInPortPathCost_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstPortAdminEdgePort_cookie<s(0)(0)(0)>[&];(D1:pbMstPortAdminEdgePort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstPortAdminPointToPoint_cookie<s(0)(0)(0)>[&];(D1:pbMstPortAdminPointToPoint_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstPortEnable_cookie<s(0)(0)(0)>[&];(D1:pbMstPortEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstPortCheck_cookie<s(0)(0)(0)>[&];(D1:pbMstPortCheck_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstPortBpduMode_cookie<s(0)(0)(0)>[&];(D1:pbMstPortBpduMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCistBridgeTable_cookie<s(0)(0)(0)>[&];(D1:pbCistBridgeTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstiBridgeTable_cookie<s(0)(0)(0)>[&];(D1:pbMstiBridgeTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstiNumber_cookie<s(0)(0)(0)>[&];(D1:pbMstiNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstiVlanNumber_cookie<s(0)(0)(0)>[&];(D1:pbMstiVlanNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstiPriority_cookie<s(0)(0)(0)>[&];(D1:pbMstiPriority_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstBaseBridgeAddress_cookie<s(0)(0)(0)>[&];(D1:pbMstBaseBridgeAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCistPriority_cookie<s(0)(0)(0)>[&];(D1:pbCistPriority_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstForceVersion_cookie<s(0)(0)(0)>[&];(D1:pbMstForceVersion_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstBridgeMaxAge_cookie<s(0)(0)(0)>[&];(D1:pbMstBridgeMaxAge_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstBridgeHelloTime_cookie<s(0)(0)(0)>[&];(D1:pbMstBridgeHelloTime_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstBridgeForwardDelay_cookie<s(0)(0)(0)>[&];(D1:pbMstBridgeForwardDelay_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstTxHoldCount_cookie<s(0)(0)(0)>[&];(D1:pbMstTxHoldCount_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstMaxHops_cookie<s(0)(0)(0)>[&];(D1:pbMstMaxHops_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstMstpBEGIN_cookie<s(0)(0)(0)>[&];(D1:pbMstMstpBEGIN_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstMstpConfigName_cookie<s(0)(0)(0)>[&];(D1:pbMstMstpConfigName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstMstpRevisonLevel_cookie<s(0)(0)(0)>[&];(D1:pbMstMstpRevisonLevel_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMstEventSwitch_cookie<s(0)(0)(0)>[&];(D1:pbMstEventSwitch_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIgmpSnoopingGlobalTable_cookie<s(0)(0)(0)>[&];(D1:pbIgmpSnoopingGlobalTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbVlanIgmpSnoopingTable_cookie<s(0)(0)(0)>[&];(D1:pbVlanIgmpSnoopingTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIgmpSnoopingIpGroupTable_cookie<s(0)(0)(0)>[&];(D1:pbIgmpSnoopingIpGroupTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIgmpSnoopingMacGroupTable_cookie<s(0)(0)(0)>[&];(D1:pbIgmpSnoopingMacGroupTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIgmpSnoopingMulRouterTable_cookie<s(0)(0)(0)>[&];(D1:pbIgmpSnoopingMulRouterTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIgmpVlanNumber_cookie<s(0)(0)(0)>[&];(D1:pbIgmpVlanNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIgmpMulRouterPort_cookie<s(0)(0)(0)>[&];(D1:pbIgmpMulRouterPort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIgmpVlanNumber_cookie<s(0)(0)(0)>[&];(D1:pbIgmpVlanNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIgmpMacAddr_cookie<s(0)(0)(0)>[&];(D1:pbIgmpMacAddr_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIgmpMacMemberPort_cookie<s(0)(0)(0)>[&];(D1:pbIgmpMacMemberPort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIgmpVlanNumber_cookie<s(0)(0)(0)>[&];(D1:pbIgmpVlanNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGroupIp_cookie<s(0)(0)(0)>[&];(D1:pbGroupIp_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIgmpMacAddr_cookie<s(0)(0)(0)>[&];(D1:pbIgmpMacAddr_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIgmpIpMemberPort_cookie<s(0)(0)(0)>[&];(D1:pbIgmpIpMemberPort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIgmpVlanNumber_cookie<s(0)(0)(0)>[&];(D1:pbIgmpVlanNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbVlanIgmpSnoopingEnable_cookie<s(0)(0)(0)>[&];(D1:pbVlanIgmpSnoopingEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbVlanIgmpSnoopingRowStatus_cookie<s(0)(0)(0)>[&];(D1:pbVlanIgmpSnoopingRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIgmpSnoopingEnable_cookie<s(0)(0)(0)>[&];(D1:pbIgmpSnoopingEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIgmpSnoopingAgingTime_cookie<s(0)(0)(0)>[&];(D1:pbIgmpSnoopingAgingTime_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthReserveIndex_cookie<s(0)(0)(0)>[&];(D1:pbEthReserveIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthReservedCfg_cookie<s(0)(0)(0)>[&];(D1:pbEthReservedCfg_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthReservedRowStatus_cookie<s(0)(0)(0)>[&];(D1:pbEthReservedRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthACLMacAddr_cookie<s(0)(0)(0)>[&];(D1:pbEthACLMacAddr_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthProtPktACLPort_cookie<s(0)(0)(0)>[&];(D1:pbEthProtPktACLPort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthProtPktACLIndex_cookie<s(0)(0)(0)>[&];(D1:pbEthProtPktACLIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthProtPktACLRowStatus_cookie<s(0)(0)(0)>[&];(D1:pbEthProtPktACLRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPortCls_cookie<s(0)(0)(0)>[&];(D1:pbEthPortCls_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlan_cookie<s(0)(0)(0)>[&];(D1:pbEthVlan_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthQinQNewVlanId_cookie<s(0)(0)(0)>[&];(D1:pbEthQinQNewVlanId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthQinQNewVlanPriority_cookie<s(0)(0)(0)>[&];(D1:pbEthQinQNewVlanPriority_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbVlanPortQinQIndex_cookie<s(0)(0)(0)>[&];(D1:pbVlanPortQinQIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanPortQinQRowStatus_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanPortQinQRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthQinQNewVlanPriMode_cookie<s(0)(0)(0)>[&];(D1:pbEthQinQNewVlanPriMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthQinQVlanSwapEnable_cookie<s(0)(0)(0)>[&];(D1:pbEthQinQVlanSwapEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthQinQVlanSwapVid_cookie<s(0)(0)(0)>[&];(D1:pbEthQinQVlanSwapVid_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthQinQVlanSwapMode_cookie<s(0)(0)(0)>[&];(D1:pbEthQinQVlanSwapMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthStatusPortStyle_cookie<s(0)(0)(0)>[&];(D1:pbEthStatusPortStyle_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthStatusPortType_cookie<s(0)(0)(0)>[&];(D1:pbEthStatusPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthStatusPortOperStatus_cookie<s(0)(0)(0)>[&];(D1:pbEthStatusPortOperStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthStatusLaserIBias_cookie<s(0)(0)(0)>[&];(D1:pbEthStatusLaserIBias_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthStatusLaserRecvPwr_cookie<s(0)(0)(0)>[&];(D1:pbEthStatusLaserRecvPwr_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthStatusLaserTransPwr_cookie<s(0)(0)(0)>[&];(D1:pbEthStatusLaserTransPwr_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthStatusLaserTemp_cookie<s(0)(0)(0)>[&];(D1:pbEthStatusLaserTemp_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthStatusCompliance8472_cookie<s(0)(0)(0)>[&];(D1:pbEthStatusCompliance8472_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthStatusNominalMBps_cookie<s(0)(0)(0)>[&];(D1:pbEthStatusNominalMBps_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthStatusWavelength_cookie<s(0)(0)(0)>[&];(D1:pbEthStatusWavelength_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthStatusLinkLength9125_cookie<s(0)(0)(0)>[&];(D1:pbEthStatusLinkLength9125_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthStatusLinkLength50125_cookie<s(0)(0)(0)>[&];(D1:pbEthStatusLinkLength50125_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthStatusLinkLength62125_cookie<s(0)(0)(0)>[&];(D1:pbEthStatusLinkLength62125_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthStatusLinkLengthCopper_cookie<s(0)(0)(0)>[&];(D1:pbEthStatusLinkLengthCopper_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthStatusVendorName_cookie<s(0)(0)(0)>[&];(D1:pbEthStatusVendorName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthStatusVendorPN_cookie<s(0)(0)(0)>[&];(D1:pbEthStatusVendorPN_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthStatusVendorSN_cookie<s(0)(0)(0)>[&];(D1:pbEthStatusVendorSN_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthStatusManuDate_cookie<s(0)(0)(0)>[&];(D1:pbEthStatusManuDate_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthStatusTransCode_cookie<s(0)(0)(0)>[&];(D1:pbEthStatusTransCode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthStatusVendorOUI_cookie<s(0)(0)(0)>[&];(D1:pbEthStatusVendorOUI_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthStatusConnectorType_cookie<s(0)(0)(0)>[&];(D1:pbEthStatusConnectorType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthsSAGPartNumber_cookie<s(0)(0)(0)>[&];(D1:pbEthsSAGPartNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthnClLaserTemp_cookie<s(0)(0)(0)>[&];(D1:pbEthnClLaserTemp_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthnTECCurrent_cookie<s(0)(0)(0)>[&];(D1:pbEthnTECCurrent_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpBridgeTable_cookie<s(0)(0)(0)>[&];(D1:pbRstpBridgeTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpPortTable_cookie<s(0)(0)(0)>[&];(D1:pbRstpPortTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpBridgeStateTable_cookie<s(0)(0)(0)>[&];(D1:pbRstpBridgeStateTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpPortStateTable_cookie<s(0)(0)(0)>[&];(D1:pbRstpPortStateTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpPortType_cookie<s(0)(0)(0)>[&];(D1:pbRstpPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpPortNo_cookie<s(0)(0)(0)>[&];(D1:pbRstpPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpPEnable_cookie<s(0)(0)(0)>[&];(D1:pbRstpPEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpPPVector1_cookie<s(0)(0)(0)>[&];(D1:pbRstpPPVector1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpPPVector2_cookie<s(0)(0)(0)>[&];(D1:pbRstpPPVector2_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpDsgPVector1_cookie<s(0)(0)(0)>[&];(D1:pbRstpDsgPVector1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpDsgPVector2_cookie<s(0)(0)(0)>[&];(D1:pbRstpDsgPVector2_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpMsgPVector1_cookie<s(0)(0)(0)>[&];(D1:pbRstpMsgPVector1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpMsgPVector2_cookie<s(0)(0)(0)>[&];(D1:pbRstpMsgPVector2_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpPTimes_cookie<s(0)(0)(0)>[&];(D1:pbRstpPTimes_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpDsgTimes_cookie<s(0)(0)(0)>[&];(D1:pbRstpDsgTimes_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpMsgTimes_cookie<s(0)(0)(0)>[&];(D1:pbRstpMsgTimes_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpPForward_cookie<s(0)(0)(0)>[&];(D1:pbRstpPForward_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpPLearn_cookie<s(0)(0)(0)>[&];(D1:pbRstpPLearn_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpPInfoIs_cookie<s(0)(0)(0)>[&];(D1:pbRstpPInfoIs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpPRole_cookie<s(0)(0)(0)>[&];(D1:pbRstpPRole_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpPSelectedRole_cookie<s(0)(0)(0)>[&];(D1:pbRstpPSelectedRole_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpRPVector1_cookie<s(0)(0)(0)>[&];(D1:pbRstpRPVector1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpRPVector2_cookie<s(0)(0)(0)>[&];(D1:pbRstpRPVector2_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpRootMaxAge_cookie<s(0)(0)(0)>[&];(D1:pbRstpRootMaxAge_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpRootHelloTime_cookie<s(0)(0)(0)>[&];(D1:pbRstpRootHelloTime_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpRootForwardDelay_cookie<s(0)(0)(0)>[&];(D1:pbRstpRootForwardDelay_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpRootPortId_cookie<s(0)(0)(0)>[&];(D1:pbRstpRootPortId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpPortType_cookie<s(0)(0)(0)>[&];(D1:pbRstpPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpPortNo_cookie<s(0)(0)(0)>[&];(D1:pbRstpPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpPortPriority_cookie<s(0)(0)(0)>[&];(D1:pbRstpPortPriority_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpPortEnable_cookie<s(0)(0)(0)>[&];(D1:pbRstpPortEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpPortPathCost_cookie<s(0)(0)(0)>[&];(D1:pbRstpPortPathCost_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpPortAdminEdgePort_cookie<s(0)(0)(0)>[&];(D1:pbRstpPortAdminEdgePort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpPortAdminPointToPoint_cookie<s(0)(0)(0)>[&];(D1:pbRstpPortAdminPointToPoint_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpBridgeAddress_cookie<s(0)(0)(0)>[&];(D1:pbRstpBridgeAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpBridgePriority_cookie<s(0)(0)(0)>[&];(D1:pbRstpBridgePriority_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpBridgeMaxAge_cookie<s(0)(0)(0)>[&];(D1:pbRstpBridgeMaxAge_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpBridgeHelloTime_cookie<s(0)(0)(0)>[&];(D1:pbRstpBridgeHelloTime_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpBridgeForwardDelay_cookie<s(0)(0)(0)>[&];(D1:pbRstpBridgeForwardDelay_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpTxHoldCount_cookie<s(0)(0)(0)>[&];(D1:pbRstpTxHoldCount_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpBEGIN_cookie<s(0)(0)(0)>[&];(D1:pbRstpBEGIN_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRstpEventSwitch_cookie<s(0)(0)(0)>[&];(D1:pbRstpEventSwitch_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthACLMacAddr_cookie<s(0)(0)(0)>[&];(D1:pbEthACLMacAddr_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthACLVid_cookie<s(0)(0)(0)>[&];(D1:pbEthACLVid_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthACLItemType_cookie<s(0)(0)(0)>[&];(D1:pbEthACLItemType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthACLRateLimit_cookie<s(0)(0)(0)>[&];(D1:pbEthACLRateLimit_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthACLCoS_cookie<s(0)(0)(0)>[&];(D1:pbEthACLCoS_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthACLIndex_cookie<s(0)(0)(0)>[&];(D1:pbEthACLIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthACLEntryRowStatus_cookie<s(0)(0)(0)>[&];(D1:pbEthACLEntryRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPortStyle_cookie<s(0)(0)(0)>[&];(D1:pbEthPortStyle_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthTxQueNo_cookie<s(0)(0)(0)>[&];(D1:pbEthTxQueNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPortQueueWeight_cookie<s(0)(0)(0)>[&];(D1:pbEthPortQueueWeight_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthQueueWredID_cookie<s(0)(0)(0)>[&];(D1:pbEthQueueWredID_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthNamedVlan_cookie<s(0)(0)(0)>[&];(D1:pbEthNamedVlan_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanName_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanRowStatus_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanEnableMacLearning_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanEnableMacLearning_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPortCls_cookie<s(0)(0)(0)>[&];(D1:pbEthPortCls_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlan_cookie<s(0)(0)(0)>[&];(D1:pbEthVlan_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRateLimitValue_cookie<s(0)(0)(0)>[&];(D1:pbEthRateLimitValue_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanCoS_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanCoS_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanDisable_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanDisable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRedirectionPort_cookie<s(0)(0)(0)>[&];(D1:pbEthRedirectionPort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbVlanPortCoSIndex_cookie<s(0)(0)(0)>[&];(D1:pbVlanPortCoSIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanPortCoSRowStatus_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanPortCoSRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanPolicingID_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanPolicingID_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanColorID_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanColorID_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbStaticMulticastMacAddr_cookie<s(0)(0)(0)>[&];(D1:pbStaticMulticastMacAddr_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbStaticMulticastVlan_cookie<s(0)(0)(0)>[&];(D1:pbStaticMulticastVlan_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbStaticMulticastPortList_cookie<s(0)(0)(0)>[&];(D1:pbStaticMulticastPortList_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbStaticMulticastIndex_cookie<s(0)(0)(0)>[&];(D1:pbStaticMulticastIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbStaticMulticastRowStatus_cookie<s(0)(0)(0)>[&];(D1:pbStaticMulticastRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbStaticMulticastForGmrp_cookie<s(0)(0)(0)>[&];(D1:pbStaticMulticastForGmrp_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMACEntryMacAddr_cookie<s(0)(0)(0)>[&];(D1:pbMACEntryMacAddr_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMACEntryVid_cookie<s(0)(0)(0)>[&];(D1:pbMACEntryVid_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMACEntryPort_cookie<s(0)(0)(0)>[&];(D1:pbMACEntryPort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMACEntryTagged_cookie<s(0)(0)(0)>[&];(D1:pbMACEntryTagged_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMACEntryIndex_cookie<s(0)(0)(0)>[&];(D1:pbMACEntryIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMACEntryRowStatus_cookie<s(0)(0)(0)>[&];(D1:pbMACEntryRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbWanLabel_cookie<s(0)(0)(0)>[&];(D1:pbWanLabel_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbWanVlanList_cookie<s(0)(0)(0)>[&];(D1:pbWanVlanList_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbWanTaggedVlanList_cookie<s(0)(0)(0)>[&];(D1:pbWanTaggedVlanList_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbWanDefaultVlanPriority_cookie<s(0)(0)(0)>[&];(D1:pbWanDefaultVlanPriority_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbWanChangeCoS_cookie<s(0)(0)(0)>[&];(D1:pbWanChangeCoS_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbWanPvid_cookie<s(0)(0)(0)>[&];(D1:pbWanPvid_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbWanTagMode_cookie<s(0)(0)(0)>[&];(D1:pbWanTagMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbWanFlowControl_cookie<s(0)(0)(0)>[&];(D1:pbWanFlowControl_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbWanTxPriAlg_cookie<s(0)(0)(0)>[&];(D1:pbWanTxPriAlg_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbWanTxEnableHol_cookie<s(0)(0)(0)>[&];(D1:pbWanTxEnableHol_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbWanQinQStatus_cookie<s(0)(0)(0)>[&];(D1:pbWanQinQStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbWanQinQNewVlan_cookie<s(0)(0)(0)>[&];(D1:pbWanQinQNewVlan_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbWanQinQNewVlanPriority_cookie<s(0)(0)(0)>[&];(D1:pbWanQinQNewVlanPriority_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbWanTPID_cookie<s(0)(0)(0)>[&];(D1:pbWanTPID_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbWanMirrorPort_cookie<s(0)(0)(0)>[&];(D1:pbWanMirrorPort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbWanLinkStatus_cookie<s(0)(0)(0)>[&];(D1:pbWanLinkStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbWanPortWorkMode_cookie<s(0)(0)(0)>[&];(D1:pbWanPortWorkMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbWanEnableWred_cookie<s(0)(0)(0)>[&];(D1:pbWanEnableWred_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPortType_cookie<s(0)(0)(0)>[&];(D1:pbEthPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPortAdminStatus_cookie<s(0)(0)(0)>[&];(D1:pbEthPortAdminStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortLinkStatus_cookie<s(0)(0)(0)>[&];(D1:pbPortLinkStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPortAutoNego_cookie<s(0)(0)(0)>[&];(D1:pbEthPortAutoNego_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPortFlowControl_cookie<s(0)(0)(0)>[&];(D1:pbEthPortFlowControl_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPortSpeed_cookie<s(0)(0)(0)>[&];(D1:pbEthPortSpeed_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPortDuplex_cookie<s(0)(0)(0)>[&];(D1:pbEthPortDuplex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPortVlan_cookie<s(0)(0)(0)>[&];(D1:pbEthPortVlan_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPortPvid_cookie<s(0)(0)(0)>[&];(D1:pbEthPortPvid_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUnTagMode_cookie<s(0)(0)(0)>[&];(D1:pbUnTagMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortInputRateLimit_cookie<s(0)(0)(0)>[&];(D1:pbPortInputRateLimit_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPortMode_cookie<s(0)(0)(0)>[&];(D1:pbEthPortMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPortBroadCastRateLimit_cookie<s(0)(0)(0)>[&];(D1:pbEthPortBroadCastRateLimit_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortDefaultVlanPriority_cookie<s(0)(0)(0)>[&];(D1:pbPortDefaultVlanPriority_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPortLabel_cookie<s(0)(0)(0)>[&];(D1:pbEthPortLabel_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLanTxPriAlg_cookie<s(0)(0)(0)>[&];(D1:pbLanTxPriAlg_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLanTaggedVlan_cookie<s(0)(0)(0)>[&];(D1:pbLanTaggedVlan_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPortLoopback_cookie<s(0)(0)(0)>[&];(D1:pbEthPortLoopback_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthTxEnableHol_cookie<s(0)(0)(0)>[&];(D1:pbEthTxEnableHol_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthAutoLaserShutdown_cookie<s(0)(0)(0)>[&];(D1:pbEthAutoLaserShutdown_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthAlsMode_cookie<s(0)(0)(0)>[&];(D1:pbEthAlsMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPortAlarmDisable_cookie<s(0)(0)(0)>[&];(D1:pbEthPortAlarmDisable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ethPortOnCSF_cookie<s(0)(0)(0)>[&];(D1:ethPortOnCSF_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ethMDIorMDIX_cookie<s(0)(0)(0)>[&];(D1:ethMDIorMDIX_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLanChangeCoS_cookie<s(0)(0)(0)>[&];(D1:pbLanChangeCoS_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLanQinQStatus_cookie<s(0)(0)(0)>[&];(D1:pbLanQinQStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLanQinQNewVlan_cookie<s(0)(0)(0)>[&];(D1:pbLanQinQNewVlan_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLanQinQNewVlanPriority_cookie<s(0)(0)(0)>[&];(D1:pbLanQinQNewVlanPriority_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLanTPID_cookie<s(0)(0)(0)>[&];(D1:pbLanTPID_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLanMirrorPort_cookie<s(0)(0)(0)>[&];(D1:pbLanMirrorPort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPortClassifier_cookie<s(0)(0)(0)>[&];(D1:pbEthPortClassifier_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPortWorkMode_cookie<s(0)(0)(0)>[&];(D1:pbEthPortWorkMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthEnableWred_cookie<s(0)(0)(0)>[&];(D1:pbEthEnableWred_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSFPWorkMode_cookie<s(0)(0)(0)>[&];(D1:pbSFPWorkMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortTagProtocol_cookie<s(0)(0)(0)>[&];(D1:pbPortTagProtocol_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAgingTime_cookie<s(0)(0)(0)>[&];(D1:pbAgingTime_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIPGConfig_cookie<s(0)(0)(0)>[&];(D1:pbIPGConfig_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbVlanTagProtocolType_cookie<s(0)(0)(0)>[&];(D1:pbVlanTagProtocolType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMTUSize_cookie<s(0)(0)(0)>[&];(D1:pbMTUSize_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthACLType_cookie<s(0)(0)(0)>[&];(D1:pbEthACLType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthBroadcastEnableHol_cookie<s(0)(0)(0)>[&];(D1:pbEthBroadcastEnableHol_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthTunnelingRxTPID_cookie<s(0)(0)(0)>[&];(D1:pbEthTunnelingRxTPID_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthQoSIEEE802Version_cookie<s(0)(0)(0)>[&];(D1:pbEthQoSIEEE802Version_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthChangeCoSMode_cookie<s(0)(0)(0)>[&];(D1:pbEthChangeCoSMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthLabelBase_cookie<s(0)(0)(0)>[&];(D1:pbEthLabelBase_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthWredDropProbability_cookie<s(0)(0)(0)>[&];(D1:pbEthWredDropProbability_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIpRouteTable_cookie<s(0)(0)(0)>[&];(D1:pbIpRouteTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] dccCfgTable_cookie<s(0)(0)(0)>[&];(D1:dccCfgTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipInIpCfgTable_cookie<s(0)(0)(0)>[&];(D1:ipInIpCfgTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mpBundleCfgTable_cookie<s(0)(0)(0)>[&];(D1:mpBundleCfgTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbStaticIpRouteTable_cookie<s(0)(0)(0)>[&];(D1:pbStaticIpRouteTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tracertCfgTable_cookie<s(0)(0)(0)>[&];(D1:tracertCfgTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tracertResultTable_cookie<s(0)(0)(0)>[&];(D1:tracertResultTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pingCfgTable_cookie<s(0)(0)(0)>[&];(D1:pingCfgTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pingResultTable_cookie<s(0)(0)(0)>[&];(D1:pingResultTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] dccReservePortTable_cookie<s(0)(0)(0)>[&];(D1:dccReservePortTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] phyPortNum_cookie<s(0)(0)(0)>[&];(D1:phyPortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] logPortNum_cookie<s(0)(0)(0)>[&];(D1:logPortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pingIndex_cookie<s(0)(0)(0)>[&];(D1:pingIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pingTargetIpAddrDis_cookie<s(0)(0)(0)>[&];(D1:pingTargetIpAddrDis_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pingDataSizeDis_cookie<s(0)(0)(0)>[&];(D1:pingDataSizeDis_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pingTripTime_cookie<s(0)(0)(0)>[&];(D1:pingTripTime_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pingTtlnumber_cookie<s(0)(0)(0)>[&];(D1:pingTtlnumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pingResult_cookie<s(0)(0)(0)>[&];(D1:pingResult_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pingRstRowStatus_cookie<s(0)(0)(0)>[&];(D1:pingRstRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pingTargetIpAddr_cookie<s(0)(0)(0)>[&];(D1:pingTargetIpAddr_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pingDataSize_cookie<s(0)(0)(0)>[&];(D1:pingDataSize_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pingCounts_cookie<s(0)(0)(0)>[&];(D1:pingCounts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pingTimeout_cookie<s(0)(0)(0)>[&];(D1:pingTimeout_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pingRowStatus_cookie<s(0)(0)(0)>[&];(D1:pingRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pingStart_cookie<s(0)(0)(0)>[&];(D1:pingStart_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tracertTtlNumber_cookie<s(0)(0)(0)>[&];(D1:tracertTtlNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tracertTripTime1_cookie<s(0)(0)(0)>[&];(D1:tracertTripTime1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tracertTripTime2_cookie<s(0)(0)(0)>[&];(D1:tracertTripTime2_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tracertTripTime3_cookie<s(0)(0)(0)>[&];(D1:tracertTripTime3_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tracertPeerIpAddrDis_cookie<s(0)(0)(0)>[&];(D1:tracertPeerIpAddrDis_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tracertRstRowStatus_cookie<s(0)(0)(0)>[&];(D1:tracertRstRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tracertPeerIpAddr_cookie<s(0)(0)(0)>[&];(D1:tracertPeerIpAddr_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tracertTimeout_cookie<s(0)(0)(0)>[&];(D1:tracertTimeout_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tracertRowStatus_cookie<s(0)(0)(0)>[&];(D1:tracertRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tracertStart_cookie<s(0)(0)(0)>[&];(D1:tracertStart_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbStaticIpRouteDest_cookie<s(0)(0)(0)>[&];(D1:pbStaticIpRouteDest_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbStaticIpRouteMask_cookie<s(0)(0)(0)>[&];(D1:pbStaticIpRouteMask_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbStaticIpRouteProto_cookie<s(0)(0)(0)>[&];(D1:pbStaticIpRouteProto_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbStaticIpRouteIfIndex_cookie<s(0)(0)(0)>[&];(D1:pbStaticIpRouteIfIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbStaticIpRouteNextHop_cookie<s(0)(0)(0)>[&];(D1:pbStaticIpRouteNextHop_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbStaticIpRouteAdminStatus_cookie<s(0)(0)(0)>[&];(D1:pbStaticIpRouteAdminStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbStaticIpRouteOperStatus_cookie<s(0)(0)(0)>[&];(D1:pbStaticIpRouteOperStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbStaticIpRouteMetricType_cookie<s(0)(0)(0)>[&];(D1:pbStaticIpRouteMetricType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbStaticIpRouteCost_cookie<s(0)(0)(0)>[&];(D1:pbStaticIpRouteCost_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] bundlePeerIpAddr_cookie<s(0)(0)(0)>[&];(D1:bundlePeerIpAddr_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] bundleIndex_cookie<s(0)(0)(0)>[&];(D1:bundleIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] bundleStatus_cookie<s(0)(0)(0)>[&];(D1:bundleStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] bundleNumber_cookie<s(0)(0)(0)>[&];(D1:bundleNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] bundleRowStatus_cookie<s(0)(0)(0)>[&];(D1:bundleRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] bundleTOS_cookie<s(0)(0)(0)>[&];(D1:bundleTOS_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipInIpIfIpAddr_cookie<s(0)(0)(0)>[&];(D1:ipInIpIfIpAddr_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipInIpIfMask_cookie<s(0)(0)(0)>[&];(D1:ipInIpIfMask_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipInIpDestIpAddr_cookie<s(0)(0)(0)>[&];(D1:ipInIpDestIpAddr_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipInIpSourcIpAddr_cookie<s(0)(0)(0)>[&];(D1:ipInIpSourcIpAddr_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipInIpIfIndex_cookie<s(0)(0)(0)>[&];(D1:ipInIpIfIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipInIpIfMtu_cookie<s(0)(0)(0)>[&];(D1:ipInIpIfMtu_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipInIpRowStatus_cookie<s(0)(0)(0)>[&];(D1:ipInIpRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipInIpPeerIfIpAddr_cookie<s(0)(0)(0)>[&];(D1:ipInIpPeerIfIpAddr_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mode_cookie<s(0)(0)(0)>[&];(D1:mode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] state_cookie<s(0)(0)(0)>[&];(D1:state_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] protocol_cookie<s(0)(0)(0)>[&];(D1:protocol_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] dccBundleNumber_cookie<s(0)(0)(0)>[&];(D1:dccBundleNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] linkStatus_cookie<s(0)(0)(0)>[&];(D1:linkStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mspStatus_cookie<s(0)(0)(0)>[&];(D1:mspStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] destSlot_cookie<s(0)(0)(0)>[&];(D1:destSlot_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] destPort_cookie<s(0)(0)(0)>[&];(D1:destPort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mtu_cookie<s(0)(0)(0)>[&];(D1:mtu_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] crcMode_cookie<s(0)(0)(0)>[&];(D1:crcMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] hcocIndex_cookie<s(0)(0)(0)>[&];(D1:hcocIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] multilink_cookie<s(0)(0)(0)>[&];(D1:multilink_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIpRouteDest_cookie<s(0)(0)(0)>[&];(D1:pbIpRouteDest_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIpRouteMask_cookie<s(0)(0)(0)>[&];(D1:pbIpRouteMask_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIpRouteProto_cookie<s(0)(0)(0)>[&];(D1:pbIpRouteProto_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIpRouteIfIndex_cookie<s(0)(0)(0)>[&];(D1:pbIpRouteIfIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIpRouteNextHop_cookie<s(0)(0)(0)>[&];(D1:pbIpRouteNextHop_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIpRouteType_cookie<s(0)(0)(0)>[&];(D1:pbIpRouteType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIpRouteAge_cookie<s(0)(0)(0)>[&];(D1:pbIpRouteAge_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIpRouteMetric1_cookie<s(0)(0)(0)>[&];(D1:pbIpRouteMetric1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIpRouteMetric2_cookie<s(0)(0)(0)>[&];(D1:pbIpRouteMetric2_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIpRouteMetric3_cookie<s(0)(0)(0)>[&];(D1:pbIpRouteMetric3_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIpRouteMetric4_cookie<s(0)(0)(0)>[&];(D1:pbIpRouteMetric4_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIpRouteMetric5_cookie<s(0)(0)(0)>[&];(D1:pbIpRouteMetric5_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSRefSourceTable_cookie<s(0)(0)(0)>[&];(D1:pbTMSRefSourceTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSSysTimingGroup_cookie<s(0)(0)(0)>[&];(D1:pbTMSSysTimingGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSStClkInTable_cookie<s(0)(0)(0)>[&];(D1:pbTMSStClkInTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSStClkOutTable_cookie<s(0)(0)(0)>[&];(D1:pbTMSStClkOutTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSStClkOutIndex_cookie<s(0)(0)(0)>[&];(D1:pbTMSStClkOutIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSStClkOutType_cookie<s(0)(0)(0)>[&];(D1:pbTMSStClkOutType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSStClkOutMonitored_cookie<s(0)(0)(0)>[&];(D1:pbTMSStClkOutMonitored_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSStClkOutSaBit_cookie<s(0)(0)(0)>[&];(D1:pbTMSStClkOutSaBit_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSStClkOutQlThreshold_cookie<s(0)(0)(0)>[&];(D1:pbTMSStClkOutQlThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSStClkOutSquelchMode_cookie<s(0)(0)(0)>[&];(D1:pbTMSStClkOutSquelchMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tMSStClkOutOhm_cookie<s(0)(0)(0)>[&];(D1:tMSStClkOutOhm_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSStClkOutQlIn_cookie<s(0)(0)(0)>[&];(D1:pbTMSStClkOutQlIn_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSStClkOutQl_cookie<s(0)(0)(0)>[&];(D1:pbTMSStClkOutQl_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tmsStClkOutputMode_cookie<s(0)(0)(0)>[&];(D1:tmsStClkOutputMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSStClkOutState_cookie<s(0)(0)(0)>[&];(D1:pbTMSStClkOutState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSStClkInIndex_cookie<s(0)(0)(0)>[&];(D1:pbTMSStClkInIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSStClkInType_cookie<s(0)(0)(0)>[&];(D1:pbTMSStClkInType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSStClkInMonitored_cookie<s(0)(0)(0)>[&];(D1:pbTMSStClkInMonitored_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSStClkInSaBit_cookie<s(0)(0)(0)>[&];(D1:pbTMSStClkInSaBit_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tMSStClkInOhm_cookie<s(0)(0)(0)>[&];(D1:tMSStClkInOhm_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSSwitchRequest_cookie<s(0)(0)(0)>[&];(D1:pbTMSSwitchRequest_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSActiveTimingSource_cookie<s(0)(0)(0)>[&];(D1:pbTMSActiveTimingSource_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSTimingState_cookie<s(0)(0)(0)>[&];(D1:pbTMSTimingState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSSysTimingMode_cookie<s(0)(0)(0)>[&];(D1:pbTMSSysTimingMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSSwitchRequestStatus_cookie<s(0)(0)(0)>[&];(D1:pbTMSSwitchRequestStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSHoldoverDTS_cookie<s(0)(0)(0)>[&];(D1:pbTMSHoldoverDTS_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSStaClkOutSource_cookie<s(0)(0)(0)>[&];(D1:pbTMSStaClkOutSource_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSQlEnabled_cookie<s(0)(0)(0)>[&];(D1:pbTMSQlEnabled_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSExpectedSMMB_cookie<s(0)(0)(0)>[&];(D1:pbTMSExpectedSMMB_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSStClkAutoLoopPrevention_cookie<s(0)(0)(0)>[&];(D1:pbTMSStClkAutoLoopPrevention_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tmsSysSrcFDThreshold_cookie<s(0)(0)(0)>[&];(D1:tmsSysSrcFDThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tmsSysFDValue_cookie<s(0)(0)(0)>[&];(D1:tmsSysFDValue_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSRefSourceIndex_cookie<s(0)(0)(0)>[&];(D1:pbTMSRefSourceIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSRefSourceSlot_cookie<s(0)(0)(0)>[&];(D1:pbTMSRefSourceSlot_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSRefSourcePort_cookie<s(0)(0)(0)>[&];(D1:pbTMSRefSourcePort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSRefSourceMonitored_cookie<s(0)(0)(0)>[&];(D1:pbTMSRefSourceMonitored_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSSignalStatus_cookie<s(0)(0)(0)>[&];(D1:pbTMSSignalStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSRefSourcePriority_cookie<s(0)(0)(0)>[&];(D1:pbTMSRefSourcePriority_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSRefSourceLockOut_cookie<s(0)(0)(0)>[&];(D1:pbTMSRefSourceLockOut_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSRefSourceQlIn_cookie<s(0)(0)(0)>[&];(D1:pbTMSRefSourceQlIn_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSRefSourceQl_cookie<s(0)(0)(0)>[&];(D1:pbTMSRefSourceQl_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSQlProvionedMode_cookie<s(0)(0)(0)>[&];(D1:pbTMSQlProvionedMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSQlProvioned_cookie<s(0)(0)(0)>[&];(D1:pbTMSQlProvioned_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSRefSourceValid_cookie<s(0)(0)(0)>[&];(D1:pbTMSRefSourceValid_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSRefSourceWTR_cookie<s(0)(0)(0)>[&];(D1:pbTMSRefSourceWTR_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tMSIfSdhQLType_cookie<s(0)(0)(0)>[&];(D1:tMSIfSdhQLType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tMSRefSourceQLOut_cookie<s(0)(0)(0)>[&];(D1:tMSRefSourceQLOut_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tMSForceDnu_cookie<s(0)(0)(0)>[&];(D1:tMSForceDnu_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tMSSupportQlOut_cookie<s(0)(0)(0)>[&];(D1:tMSSupportQlOut_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tMSPortType_cookie<s(0)(0)(0)>[&];(D1:tMSPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tmsRefSourceFDUpband_cookie<s(0)(0)(0)>[&];(D1:tmsRefSourceFDUpband_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tmsRefSourceFDLowband_cookie<s(0)(0)(0)>[&];(D1:tmsRefSourceFDLowband_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tmsRefSourceFDValue_cookie<s(0)(0)(0)>[&];(D1:tmsRefSourceFDValue_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tmsStoredDrvClkNum_cookie<s(0)(0)(0)>[&];(D1:tmsStoredDrvClkNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDigitalTransport_cookie<s(0)(0)(0)>[&];(D1:pbDigitalTransport_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSonetSdh_cookie<s(0)(0)(0)>[&];(D1:pbSonetSdh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortConfigTable_cookie<s(0)(0)(0)>[&];(D1:pbPortConfigTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortStatusTable_cookie<s(0)(0)(0)>[&];(D1:pbPortStatusTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortHoTpReserveTable_cookie<s(0)(0)(0)>[&];(D1:pbPortHoTpReserveTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTPConfigTable_cookie<s(0)(0)(0)>[&];(D1:pbTPConfigTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOTUPortConfigTable_cookie<s(0)(0)(0)>[&];(D1:pbOTUPortConfigTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSdhPmUpLoadInfo_cookie<s(0)(0)(0)>[&];(D1:pbSdhPmUpLoadInfo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSdhMostRecentIndex_cookie<s(0)(0)(0)>[&];(D1:pbSdhMostRecentIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSdhRecentUapPerfMon_cookie<s(0)(0)(0)>[&];(D1:pbSdhRecentUapPerfMon_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSdhUapPerfMon_cookie<s(0)(0)(0)>[&];(D1:pbSdhUapPerfMon_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSdhRecentPerfMon_cookie<s(0)(0)(0)>[&];(D1:pbSdhRecentPerfMon_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSdhCurPerfMon_cookie<s(0)(0)(0)>[&];(D1:pbSdhCurPerfMon_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPRBSPortHisTable_cookie<s(0)(0)(0)>[&];(D1:pbPRBSPortHisTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPRBSPortCurTable_cookie<s(0)(0)(0)>[&];(D1:pbPRBSPortCurTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOTUPortStatusTable_cookie<s(0)(0)(0)>[&];(D1:pbOTUPortStatusTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOTUTPConfigTable_cookie<s(0)(0)(0)>[&];(D1:pbOTUTPConfigTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPMFilterConfigGroup_cookie<s(0)(0)(0)>[&];(D1:pbPMFilterConfigGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPMFilterTable_cookie<s(0)(0)(0)>[&];(D1:pbPMFilterTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPmFilterType_cookie<s(0)(0)(0)>[&];(D1:pbPmFilterType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortType_cookie<s(0)(0)(0)>[&];(D1:pbPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTpType_cookie<s(0)(0)(0)>[&];(D1:pbTpType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTpIndex_cookie<s(0)(0)(0)>[&];(D1:pbTpIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTableType_cookie<s(0)(0)(0)>[&];(D1:pbTableType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPmEthId_cookie<s(0)(0)(0)>[&];(D1:pbPmEthId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPmReserved_cookie<s(0)(0)(0)>[&];(D1:pbPmReserved_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPmDeleteAllFilter_cookie<s(0)(0)(0)>[&];(D1:pbPmDeleteAllFilter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPmDeleteSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbPmDeleteSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPmDeleteSlotFilter_cookie<s(0)(0)(0)>[&];(D1:pbPmDeleteSlotFilter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPmDeleteFilterTypeId_cookie<s(0)(0)(0)>[&];(D1:pbPmDeleteFilterTypeId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPmDeleteFilterType_cookie<s(0)(0)(0)>[&];(D1:pbPmDeleteFilterType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortType_cookie<s(0)(0)(0)>[&];(D1:pbPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOTUTpChannelId_cookie<s(0)(0)(0)>[&];(D1:pbOTUTpChannelId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOTUTpSegment_cookie<s(0)(0)(0)>[&];(D1:pbOTUTpSegment_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOTUTpType_cookie<s(0)(0)(0)>[&];(D1:pbOTUTpType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOTUMonitored_cookie<s(0)(0)(0)>[&];(D1:pbOTUMonitored_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOTUTimAlmEnable_cookie<s(0)(0)(0)>[&];(D1:pbOTUTimAlmEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOTUTimActEnable_cookie<s(0)(0)(0)>[&];(D1:pbOTUTimActEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOTUTxTti_cookie<s(0)(0)(0)>[&];(D1:pbOTUTxTti_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOTUExpTti_cookie<s(0)(0)(0)>[&];(D1:pbOTUExpTti_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOTURxTti_cookie<s(0)(0)(0)>[&];(D1:pbOTURxTti_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOTUDegEnable_cookie<s(0)(0)(0)>[&];(D1:pbOTUDegEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOTUDegThreshold_cookie<s(0)(0)(0)>[&];(D1:pbOTUDegThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOTUDegIntervals_cookie<s(0)(0)(0)>[&];(D1:pbOTUDegIntervals_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOTUSendMaintenanceType_cookie<s(0)(0)(0)>[&];(D1:pbOTUSendMaintenanceType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOTURecvMaintenanceType_cookie<s(0)(0)(0)>[&];(D1:pbOTURecvMaintenanceType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOTUPlmAlmEnable_cookie<s(0)(0)(0)>[&];(D1:pbOTUPlmAlmEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOTUMsimAlmEnable_cookie<s(0)(0)(0)>[&];(D1:pbOTUMsimAlmEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOTUPtAlmEnable_cookie<s(0)(0)(0)>[&];(D1:pbOTUPtAlmEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOTUTxPt_cookie<s(0)(0)(0)>[&];(D1:pbOTUTxPt_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOTUExpPt_cookie<s(0)(0)(0)>[&];(D1:pbOTUExpPt_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOTURxPt_cookie<s(0)(0)(0)>[&];(D1:pbOTURxPt_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pmOTUNearEnd15minMonitored_cookie<s(0)(0)(0)>[&];(D1:pmOTUNearEnd15minMonitored_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pmOTUFarEnd15minMonitored_cookie<s(0)(0)(0)>[&];(D1:pmOTUFarEnd15minMonitored_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pmOTUNearEnd24hrMonitored_cookie<s(0)(0)(0)>[&];(D1:pmOTUNearEnd24hrMonitored_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pmOTUFarEnd24hrMonitored_cookie<s(0)(0)(0)>[&];(D1:pmOTUFarEnd24hrMonitored_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortType_cookie<s(0)(0)(0)>[&];(D1:pbPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSMRxTti_cookie<s(0)(0)(0)>[&];(D1:pbSMRxTti_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRxPt_cookie<s(0)(0)(0)>[&];(D1:pbRxPt_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRxChannelId_cookie<s(0)(0)(0)>[&];(D1:pbRxChannelId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortType_cookie<s(0)(0)(0)>[&];(D1:pbPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPRBSEnable_cookie<s(0)(0)(0)>[&];(D1:pbPRBSEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPRBSPattern_cookie<s(0)(0)(0)>[&];(D1:pbPRBSPattern_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPRBSErrorBlocks_cookie<s(0)(0)(0)>[&];(D1:pbPRBSErrorBlocks_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPRBSErrorSeconds_cookie<s(0)(0)(0)>[&];(D1:pbPRBSErrorSeconds_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPRBSStatus_cookie<s(0)(0)(0)>[&];(D1:pbPRBSStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPRBSActualPortType_cookie<s(0)(0)(0)>[&];(D1:pbPRBSActualPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] prbsMode_cookie<s(0)(0)(0)>[&];(D1:prbsMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortType_cookie<s(0)(0)(0)>[&];(D1:pbPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPRBSHisErrorSeconds_cookie<s(0)(0)(0)>[&];(D1:pbPRBSHisErrorSeconds_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPRBSHisMeanError_cookie<s(0)(0)(0)>[&];(D1:pbPRBSHisMeanError_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPRBSTrapTimeStamp_cookie<s(0)(0)(0)>[&];(D1:pbPRBSTrapTimeStamp_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPRBSHisActualPortType_cookie<s(0)(0)(0)>[&];(D1:pbPRBSHisActualPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSdhCurPMTable_cookie<s(0)(0)(0)>[&];(D1:pbSdhCurPMTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurPMTable_cookie<s(0)(0)(0)>[&];(D1:pbEthCurPMTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPmMonTimeIntervalSet_cookie<s(0)(0)(0)>[&];(D1:pbEthPmMonTimeIntervalSet_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthPmMonTable_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthPmMonTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientCurPMTable_cookie<s(0)(0)(0)>[&];(D1:pbRprClientCurPMTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanCurPMTable_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanCurPMTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhCurSlipTable_cookie<s(0)(0)(0)>[&];(D1:pbPdhCurSlipTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPmMonitoredNumberTable_cookie<s(0)(0)(0)>[&];(D1:pbPmMonitoredNumberTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhPmSlipEventEnable_cookie<s(0)(0)(0)>[&];(D1:pbPdhPmSlipEventEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthPMTable_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthPMTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhCurPMTable_cookie<s(0)(0)(0)>[&];(D1:pbPdhCurPMTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanPMTable_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanPMTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthVlanPMTable_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthVlanPMTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthTcaPMTable_cookie<s(0)(0)(0)>[&];(D1:pbEthTcaPMTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecCurPMTable_cookie<s(0)(0)(0)>[&];(D1:pbFecCurPMTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuCurPMTable_cookie<s(0)(0)(0)>[&];(D1:pbOtuCurPMTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortType_cookie<s(0)(0)(0)>[&];(D1:pbPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuTableType_cookie<s(0)(0)(0)>[&];(D1:pbOtuTableType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbChannelID_cookie<s(0)(0)(0)>[&];(D1:pbChannelID_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSegmentNum_cookie<s(0)(0)(0)>[&];(D1:pbSegmentNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuPmMonitor_cookie<s(0)(0)(0)>[&];(D1:pbOtuPmMonitor_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuEsPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbOtuEsPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuBbePmCounter_cookie<s(0)(0)(0)>[&];(D1:pbOtuBbePmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuSesPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbOtuSesPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuUasPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbOtuUasPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuCsesPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbOtuCsesPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuFcPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbOtuFcPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuOfsPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbOtuOfsPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuIaesPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbOtuIaesPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuBiaesPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbOtuBiaesPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuPmTableReset_cookie<s(0)(0)(0)>[&];(D1:pbOtuPmTableReset_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuPmTimeStart_cookie<s(0)(0)(0)>[&];(D1:pbOtuPmTimeStart_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuPmTimeElapse_cookie<s(0)(0)(0)>[&];(D1:pbOtuPmTimeElapse_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuPmSuspect_cookie<s(0)(0)(0)>[&];(D1:pbOtuPmSuspect_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortType_cookie<s(0)(0)(0)>[&];(D1:pbPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecTableType_cookie<s(0)(0)(0)>[&];(D1:pbFecTableType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecPmMonitor_cookie<s(0)(0)(0)>[&];(D1:pbFecPmMonitor_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecTecPmCounterHigh_cookie<s(0)(0)(0)>[&];(D1:pbFecTecPmCounterHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecTecPmCounterLow_cookie<s(0)(0)(0)>[&];(D1:pbFecTecPmCounterLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecZecPmCounterHigh_cookie<s(0)(0)(0)>[&];(D1:pbFecZecPmCounterHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecZecPmCounterLow_cookie<s(0)(0)(0)>[&];(D1:pbFecZecPmCounterLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecOecPmCounterHigh_cookie<s(0)(0)(0)>[&];(D1:pbFecOecPmCounterHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecOecPmCounterLow_cookie<s(0)(0)(0)>[&];(D1:pbFecOecPmCounterLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecFcPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbFecFcPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecPmTableReset_cookie<s(0)(0)(0)>[&];(D1:pbFecPmTableReset_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecPmTimeStart_cookie<s(0)(0)(0)>[&];(D1:pbFecPmTimeStart_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecPmTimeElapse_cookie<s(0)(0)(0)>[&];(D1:pbFecPmTimeElapse_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecPmSuspect_cookie<s(0)(0)(0)>[&];(D1:pbFecPmSuspect_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecUncorrectedBlkHigh_cookie<s(0)(0)(0)>[&];(D1:pbFecUncorrectedBlkHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecUncorrectedBlkLow_cookie<s(0)(0)(0)>[&];(D1:pbFecUncorrectedBlkLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPmPortType_cookie<s(0)(0)(0)>[&];(D1:pbEthPmPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPmBbrEnable_cookie<s(0)(0)(0)>[&];(D1:pbEthPmBbrEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPmBbrThresholdValue_cookie<s(0)(0)(0)>[&];(D1:pbEthPmBbrThresholdValue_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPmBprEnable_cookie<s(0)(0)(0)>[&];(D1:pbEthPmBprEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPmBprThresholdValue_cookie<s(0)(0)(0)>[&];(D1:pbEthPmBprThresholdValue_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPmPortType_cookie<s(0)(0)(0)>[&];(D1:pbEthPmPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanNo_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthVlanPmEnableStatus_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthVlanPmEnableStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthVlanPmTimeStart_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthVlanPmTimeStart_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthVlanPmStartFlag_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthVlanPmStartFlag_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanTableType_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanTableType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPmPortType_cookie<s(0)(0)(0)>[&];(D1:pbEthPmPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanNo_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanPmMonitor_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanPmMonitor_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanPmTimeStart_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanPmTimeStart_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanPmTimeElapse_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanPmTimeElapse_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanPmTimeSuspect_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanPmTimeSuspect_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanPmTableReset_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanPmTableReset_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanInPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanInPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanInPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanInPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanInBytesHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanInBytesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanInBytesLow_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanInBytesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanDropPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanDropPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanDropPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanDropPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanRcvUnicastFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanRcvUnicastFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanRcvUnicastFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanRcvUnicastFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanRcvTotalFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanRcvTotalFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanRcvTotalFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanRcvTotalFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanRcvUnicastBytesHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanRcvUnicastBytesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanRcvUnicastBytesLow_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanRcvUnicastBytesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanRcvTotalBytesHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanRcvTotalBytesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanRcvTotalBytesLow_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanRcvTotalBytesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanPmEnableStatus_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanPmEnableStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortType_cookie<s(0)(0)(0)>[&];(D1:pbPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhTableType_cookie<s(0)(0)(0)>[&];(D1:pbPdhTableType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhPmMonitor_cookie<s(0)(0)(0)>[&];(D1:pbPdhPmMonitor_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhEsPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbPdhEsPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhEsPmThresholdEnable_cookie<s(0)(0)(0)>[&];(D1:pbPdhEsPmThresholdEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhEsPmThresholdLow_cookie<s(0)(0)(0)>[&];(D1:pbPdhEsPmThresholdLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhEsPmThresholdHigh_cookie<s(0)(0)(0)>[&];(D1:pbPdhEsPmThresholdHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhBbePmCounter_cookie<s(0)(0)(0)>[&];(D1:pbPdhBbePmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhBbePmThresholdEnable_cookie<s(0)(0)(0)>[&];(D1:pbPdhBbePmThresholdEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhBbePmThresholdLow_cookie<s(0)(0)(0)>[&];(D1:pbPdhBbePmThresholdLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhBbePmThresholdHigh_cookie<s(0)(0)(0)>[&];(D1:pbPdhBbePmThresholdHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhSesPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbPdhSesPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhSesPmThresholdEnable_cookie<s(0)(0)(0)>[&];(D1:pbPdhSesPmThresholdEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhSesPmThresholdLow_cookie<s(0)(0)(0)>[&];(D1:pbPdhSesPmThresholdLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhSesPmThresholdHigh_cookie<s(0)(0)(0)>[&];(D1:pbPdhSesPmThresholdHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhUasPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbPdhUasPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhUasPmThresholdEnable_cookie<s(0)(0)(0)>[&];(D1:pbPdhUasPmThresholdEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhUasPmThresholdLow_cookie<s(0)(0)(0)>[&];(D1:pbPdhUasPmThresholdLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhUasPmThresholdHigh_cookie<s(0)(0)(0)>[&];(D1:pbPdhUasPmThresholdHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhCsesPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbPdhCsesPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhCsesPmThresholdEnable_cookie<s(0)(0)(0)>[&];(D1:pbPdhCsesPmThresholdEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhCsesPmThresholdLow_cookie<s(0)(0)(0)>[&];(D1:pbPdhCsesPmThresholdLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhCsesPmThresholdHigh_cookie<s(0)(0)(0)>[&];(D1:pbPdhCsesPmThresholdHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhFcPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbPdhFcPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhFcPmThresholdEnable_cookie<s(0)(0)(0)>[&];(D1:pbPdhFcPmThresholdEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhFcPmThresholdLow_cookie<s(0)(0)(0)>[&];(D1:pbPdhFcPmThresholdLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhFcPmThresholdHigh_cookie<s(0)(0)(0)>[&];(D1:pbPdhFcPmThresholdHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhPmTableReset_cookie<s(0)(0)(0)>[&];(D1:pbPdhPmTableReset_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhPmTimeStart_cookie<s(0)(0)(0)>[&];(D1:pbPdhPmTimeStart_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhPmTimeElapse_cookie<s(0)(0)(0)>[&];(D1:pbPdhPmTimeElapse_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhPmSuspect_cookie<s(0)(0)(0)>[&];(D1:pbPdhPmSuspect_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthCurPmPortType_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthCurPmPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthPmEnableStatus_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthPmEnableStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthPmTimeStart_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthPmTimeStart_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthPmStartFlag_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthPmStartFlag_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSdhFtpCmndHostIP_cookie<s(0)(0)(0)>[&];(D1:pbSdhFtpCmndHostIP_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPmMonitoredAll_cookie<s(0)(0)(0)>[&];(D1:pbPmMonitoredAll_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPmMonitoredCtp_cookie<s(0)(0)(0)>[&];(D1:pbPmMonitoredCtp_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPmMonitoredTtp_cookie<s(0)(0)(0)>[&];(D1:pbPmMonitoredTtp_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPmMonitoredEth_cookie<s(0)(0)(0)>[&];(D1:pbPmMonitoredEth_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPmMonitoredRprClient_cookie<s(0)(0)(0)>[&];(D1:pbPmMonitoredRprClient_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPmMonitoredRprSpan_cookie<s(0)(0)(0)>[&];(D1:pbPmMonitoredRprSpan_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPmMonitoredAtm_cookie<s(0)(0)(0)>[&];(D1:pbPmMonitoredAtm_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPmMonitoredPdhSlip_cookie<s(0)(0)(0)>[&];(D1:pbPmMonitoredPdhSlip_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPmMonitoredPdhCrc_cookie<s(0)(0)(0)>[&];(D1:pbPmMonitoredPdhCrc_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPmMonitoredFec_cookie<s(0)(0)(0)>[&];(D1:pbPmMonitoredFec_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPmMonitoredOtu_cookie<s(0)(0)(0)>[&];(D1:pbPmMonitoredOtu_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortType_cookie<s(0)(0)(0)>[&];(D1:pbPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlipTableType_cookie<s(0)(0)(0)>[&];(D1:pbSlipTableType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlipMonitor_cookie<s(0)(0)(0)>[&];(D1:pbSlipMonitor_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPSlipCounter_cookie<s(0)(0)(0)>[&];(D1:pbPSlipCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPSlipThresholdEnable_cookie<s(0)(0)(0)>[&];(D1:pbPSlipThresholdEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPSlipThreshold_cookie<s(0)(0)(0)>[&];(D1:pbPSlipThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbNSlipCounter_cookie<s(0)(0)(0)>[&];(D1:pbNSlipCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbNSlipThresholdEnable_cookie<s(0)(0)(0)>[&];(D1:pbNSlipThresholdEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbNSlipThreshold_cookie<s(0)(0)(0)>[&];(D1:pbNSlipThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlipTableReset_cookie<s(0)(0)(0)>[&];(D1:pbSlipTableReset_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlipTimeStart_cookie<s(0)(0)(0)>[&];(D1:pbSlipTimeStart_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlipTimeElapse_cookie<s(0)(0)(0)>[&];(D1:pbSlipTimeElapse_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlipSuspect_cookie<s(0)(0)(0)>[&];(D1:pbSlipSuspect_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfIndex_cookie<s(0)(0)(0)>[&];(D1:rprIfIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSpanId_cookie<s(0)(0)(0)>[&];(D1:rprSpanId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanTableType_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanTableType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanPmMonitor_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanPmMonitor_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanPmTimeStart_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanPmTimeStart_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanPmTimeElapse_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanPmTimeElapse_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanPmTimeSuspect_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanPmTimeSuspect_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanPmTableReset_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanPmTableReset_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInAllFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInAllFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInAllFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInAllFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInWrapFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInWrapFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInWrapFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInWrapFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInDataFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInDataFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInDataFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInDataFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInCtrlFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInCtrlFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInCtrlFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInCtrlFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInFaFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInFaFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInFaFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInFaFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutAllFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutAllFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutAllFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutAllFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutAddFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutAddFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutAddFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutAddFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutTransitFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutTransitFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutTransitFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutTransitFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutWrapFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutWrapFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutWrapFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutWrapFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutTpFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutTpFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutTpFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutTpFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutFaFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutFaFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutFaFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutFaFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutOamFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutOamFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutOamFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutOamFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanErrHecFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanErrHecFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanErrHecFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanErrHecFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanErrParityFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanErrParityFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanErrParityFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanErrParityFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanErrFcsFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanErrFcsFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanErrFcsFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanErrFcsFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanErrEdgeFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanErrEdgeFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanErrEdgeFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanErrEdgeFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanErrSelfSourceFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanErrSelfSourceFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanErrSelfSourceFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanErrSelfSourceFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInUcastClassAFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInUcastClassAFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInUcastClassAFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInUcastClassAFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInUcastClassAOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInUcastClassAOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInUcastClassAOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInUcastClassAOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInUcastClassBCirFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInUcastClassBCirFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInUcastClassBCirFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInUcastClassBCirFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInUcastClassBCirOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInUcastClassBCirOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInUcastClassBCirOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInUcastClassBCirOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInUcastClassBEirFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInUcastClassBEirFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInUcastClassBEirFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInUcastClassBEirFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInUcastClassBEirOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInUcastClassBEirOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInUcastClassBEirOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInUcastClassBEirOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInUcastClassCFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInUcastClassCFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInUcastClassCFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInUcastClassCFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInUcastClassCOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInUcastClassCOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInUcastClassCOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInUcastClassCOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInMcastClassAFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInMcastClassAFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInMcastClassAFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInMcastClassAFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInMcastClassAOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInMcastClassAOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInMcastClassAOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInMcastClassAOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInMcastClassBCirFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInMcastClassBCirFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInMcastClassBCirFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInMcastClassBCirFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInMcastClassBCirOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInMcastClassBCirOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInMcastClassBCirOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInMcastClassBCirOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInMcastClassBEirFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInMcastClassBEirFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInMcastClassBEirFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInMcastClassBEirFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInMcastClassBEirOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInMcastClassBEirOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInMcastClassBEirOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInMcastClassBEirOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInMcastClassCFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInMcastClassCFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInMcastClassCFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInMcastClassCFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInMcastClassCOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInMcastClassCOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanInMcastClassCOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanInMcastClassCOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutUcastClassAFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutUcastClassAFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutUcastClassAFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutUcastClassAFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutUcastClassAOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutUcastClassAOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutUcastClassAOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutUcastClassAOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutUcastClassBCirFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutUcastClassBCirFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutUcastClassBCirFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutUcastClassBCirFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutUcastClassBCirOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutUcastClassBCirOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutUcastClassBCirOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutUcastClassBCirOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutUcastClassBEirFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutUcastClassBEirFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutUcastClassBEirFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutUcastClassBEirFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutUcastClassBEirOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutUcastClassBEirOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutUcastClassBEirOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutUcastClassBEirOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutUcastClassCFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutUcastClassCFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutUcastClassCFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutUcastClassCFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutUcastClassCOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutUcastClassCOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutUcastClassCOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutUcastClassCOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutMcastClassAFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutMcastClassAFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutMcastClassAFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutMcastClassAFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutMcastClassAOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutMcastClassAOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutMcastClassAOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutMcastClassAOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutMcastClassBCirFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutMcastClassBCirFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutMcastClassBCirFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutMcastClassBCirFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutMcastClassBCirOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutMcastClassBCirOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutMcastClassBCirOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutMcastClassBCirOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutMcastClassBEirFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutMcastClassBEirFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutMcastClassBEirFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutMcastClassBEirFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutMcastClassBEirOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutMcastClassBEirOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutMcastClassBEirOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutMcastClassBEirOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutMcastClassCFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutMcastClassCFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutMcastClassCFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutMcastClassCFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutMcastClassCOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutMcastClassCOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanOutMcastClassCOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanOutMcastClassCOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfIndex_cookie<s(0)(0)(0)>[&];(D1:rprIfIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientTableType_cookie<s(0)(0)(0)>[&];(D1:pbRprClientTableType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientPmMonitor_cookie<s(0)(0)(0)>[&];(D1:pbRprClientPmMonitor_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientPmTimeStart_cookie<s(0)(0)(0)>[&];(D1:pbRprClientPmTimeStart_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientPmTimeElapse_cookie<s(0)(0)(0)>[&];(D1:pbRprClientPmTimeElapse_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientPmTimeSuspect_cookie<s(0)(0)(0)>[&];(D1:pbRprClientPmTimeSuspect_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientPmTableReset_cookie<s(0)(0)(0)>[&];(D1:pbRprClientPmTableReset_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientInAllFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientInAllFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientInAllFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientInAllFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutAllFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutAllFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutAllFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutAllFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutPassFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutPassFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutPassFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutPassFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutDropFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutDropFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutDropFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutDropFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutErrLenFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutErrLenFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutErrLenFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutErrLenFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutErrCrcFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutErrCrcFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutErrCrcFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutErrCrcFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientInUcastClassAFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientInUcastClassAFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientInUcastClassAFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientInUcastClassAFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientInUcastClassAOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientInUcastClassAOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientInUcastClassAOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientInUcastClassAOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientInUcastClassBCirFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientInUcastClassBCirFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientInUcastClassBCirFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientInUcastClassBCirFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientInUcastClassBCirOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientInUcastClassBCirOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientInUcastClassBCirOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientInUcastClassBCirOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientInUcastClassBEirFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientInUcastClassBEirFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientInUcastClassBEirFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientInUcastClassBEirFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientInUcastClassBEirOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientInUcastClassBEirOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientInUcastClassBEirOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientInUcastClassBEirOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientInUcastClassCFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientInUcastClassCFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientInUcastClassCFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientInUcastClassCFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientInUcastClassCOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientInUcastClassCOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientInUcastClassCOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientInUcastClassCOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientInMcastClassAFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientInMcastClassAFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientInMcastClassAFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientInMcastClassAFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientInMcastClassAOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientInMcastClassAOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientInMcastClassAOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientInMcastClassAOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientInMcastClassBCirFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientInMcastClassBCirFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientInMcastClassBCirFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientInMcastClassBCirFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientInMcastClassBCirOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientInMcastClassBCirOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientInMcastClassBCirOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientInMcastClassBCirOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientInMcastClassBEirFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientInMcastClassBEirFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientInMcastClassBEirFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientInMcastClassBEirFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientInMcastClassBEirOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientInMcastClassBEirOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientInMcastClassBEirOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientInMcastClassBEirOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientInMcastClassCFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientInMcastClassCFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientInMcastClassCFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientInMcastClassCFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientInMcastClassCOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientInMcastClassCOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientInMcastClassCOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientInMcastClassCOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutUcastClassAFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutUcastClassAFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutUcastClassAFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutUcastClassAFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutUcastClassAOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutUcastClassAOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutUcastClassAOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutUcastClassAOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutUcastClassBCirFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutUcastClassBCirFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutUcastClassBCirFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutUcastClassBCirFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutUcastClassBCirOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutUcastClassBCirOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutUcastClassBCirOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutUcastClassBCirOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutUcastClassBEirFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutUcastClassBEirFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutUcastClassBEirFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutUcastClassBEirFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutUcastClassBEirOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutUcastClassBEirOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutUcastClassBEirOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutUcastClassBEirOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutUcastClassCFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutUcastClassCFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutUcastClassCFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutUcastClassCFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutUcastClassCOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutUcastClassCOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutUcastClassCOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutUcastClassCOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutMcastClassAFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutMcastClassAFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutMcastClassAFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutMcastClassAFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutMcastClassAOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutMcastClassAOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutMcastClassAOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutMcastClassAOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutMcastClassBCirFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutMcastClassBCirFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutMcastClassBCirFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutMcastClassBCirFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutMcastClassBCirOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutMcastClassBCirOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutMcastClassBCirOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutMcastClassBCirOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutMcastClassBEirFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutMcastClassBEirFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutMcastClassBEirFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutMcastClassBEirFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutMcastClassBEirOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutMcastClassBEirOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutMcastClassBEirOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutMcastClassBEirOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutMcastClassCFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutMcastClassCFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutMcastClassCFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutMcastClassCFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutMcastClassCOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutMcastClassCOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientOutMcastClassCOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientOutMcastClassCOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthPmPortType_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthPmPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthPmReportStatus_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthPmReportStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthPmMonitorStatus_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthPmMonitorStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthPmFtpHostIP_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthPmFtpHostIP_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthPmFtpPath_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthPmFtpPath_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthPmFtpFileName_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthPmFtpFileName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthPmFtpUsername_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthPmFtpUsername_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthPmFtpPassword_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthPmFtpPassword_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthPmRequestId_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthPmRequestId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthPmRespMsg_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthPmRespMsg_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthTableType_cookie<s(0)(0)(0)>[&];(D1:pbEthTableType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPmPortType_cookie<s(0)(0)(0)>[&];(D1:pbEthPmPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPmMonitor_cookie<s(0)(0)(0)>[&];(D1:pbEthPmMonitor_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPmTimeStart_cookie<s(0)(0)(0)>[&];(D1:pbEthPmTimeStart_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPmTimeElapse_cookie<s(0)(0)(0)>[&];(D1:pbEthPmTimeElapse_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPmTimeSuspect_cookie<s(0)(0)(0)>[&];(D1:pbEthPmTimeSuspect_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPmTableReset_cookie<s(0)(0)(0)>[&];(D1:pbEthPmTableReset_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthInUnicastPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthInUnicastPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthInUnicastPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthInUnicastPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthInMulcastPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthInMulcastPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthInMulcastPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthInMulcastPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthInBrdcastPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthInBrdcastPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthInBrdcastPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthInBrdcastPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthInAllBadPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthInAllBadPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthInAllBadPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthInAllBadPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthInAllBadBytesHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthInAllBadBytesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthInAllBadBytesLow_cookie<s(0)(0)(0)>[&];(D1:pbEthInAllBadBytesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthInAllGoodPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthInAllGoodPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthInAllGoodPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthInAllGoodPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthInAllGoodBytesHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthInAllGoodBytesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthInAllGoodBytesLow_cookie<s(0)(0)(0)>[&];(D1:pbEthInAllGoodBytesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthInOverSizePktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthInOverSizePktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthInOverSizePktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthInOverSizePktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthInUnderSizePktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthInUnderSizePktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthInUnderSizePktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthInUnderSizePktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthInCRCErrPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthInCRCErrPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthInCRCErrPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthInCRCErrPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthOutUnicastPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthOutUnicastPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthOutUnicastPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthOutUnicastPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthOutMulcastPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthOutMulcastPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthOutMulcastPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthOutMulcastPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthOutBrdcastPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthOutBrdcastPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthOutBrdcastPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthOutBrdcastPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthOutAllGoodPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthOutAllGoodPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthOutAllGoodPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthOutAllGoodPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthOutAllGoodBytesHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthOutAllGoodBytesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthOutAllGoodBytesLow_cookie<s(0)(0)(0)>[&];(D1:pbEthOutAllGoodBytesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthBbrEnable_cookie<s(0)(0)(0)>[&];(D1:pbEthBbrEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthBbrThresholdValue_cookie<s(0)(0)(0)>[&];(D1:pbEthBbrThresholdValue_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthBprEnable_cookie<s(0)(0)(0)>[&];(D1:pbEthBprEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthBprThresholdValue_cookie<s(0)(0)(0)>[&];(D1:pbEthBprThresholdValue_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurInAllBytesHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthCurInAllBytesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurInAllBytesLow_cookie<s(0)(0)(0)>[&];(D1:pbEthCurInAllBytesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurInAllPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthCurInAllPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurInAllPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthCurInAllPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurInAllGoodPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthCurInAllGoodPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurInAllGoodPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthCurInAllGoodPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurInAllBadPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthCurInAllBadPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurInAllBadPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthCurInAllBadPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurInUnicastPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthCurInUnicastPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurInUnicastPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthCurInUnicastPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurInMulcastPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthCurInMulcastPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurInMulcastPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthCurInMulcastPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurInBrdcastPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthCurInBrdcastPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurInBrdcastPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthCurInBrdcastPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurInDropPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthCurInDropPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurInDropPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthCurInDropPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurInUndersizeGoodPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthCurInUndersizeGoodPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurInUndersizeGoodPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthCurInUndersizeGoodPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurInOversizeGoodPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthCurInOversizeGoodPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurInOversizeGoodPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthCurInOversizeGoodPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurIn64PktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthCurIn64PktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurIn64PktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthCurIn64PktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurIn65To127PktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthCurIn65To127PktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurIn65To127PktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthCurIn65To127PktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurIn128To255PktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthCurIn128To255PktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurIn128To255PktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthCurIn128To255PktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurIn256To511PktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthCurIn256To511PktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurIn256To511PktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthCurIn256To511PktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurIn512To1023PktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthCurIn512To1023PktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurIn512To1023PktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthCurIn512To1023PktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurIn1024To1518PktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthCurIn1024To1518PktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurIn1024To1518PktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthCurIn1024To1518PktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurInPausePktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthCurInPausePktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurInPausePktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthCurInPausePktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurInFragmentPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthCurInFragmentPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurInFragmentPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthCurInFragmentPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurInJabberPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthCurInJabberPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurInJabberPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthCurInJabberPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurInAlignmentErrorPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthCurInAlignmentErrorPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurInAlignmentErrorPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthCurInAlignmentErrorPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurOutAllBytesHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthCurOutAllBytesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurOutAllBytesLow_cookie<s(0)(0)(0)>[&];(D1:pbEthCurOutAllBytesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurOutAllPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthCurOutAllPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurOutAllPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthCurOutAllPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurOutUnicastPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthCurOutUnicastPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurOutUnicastPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthCurOutUnicastPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurOutMulcastPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthCurOutMulcastPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurOutMulcastPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthCurOutMulcastPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurOutBrdcastPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthCurOutBrdcastPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurOutBrdcastPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthCurOutBrdcastPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurOutGoodPausePktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthCurOutGoodPausePktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurOutGoodPausePktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthCurOutGoodPausePktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurOutCollisionPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthCurOutCollisionPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthCurOutCollisionPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthCurOutCollisionPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCurOutInvalidSymbolsHigh_cookie<s(0)(0)(0)>[&];(D1:pbCurOutInvalidSymbolsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCurOutInvalidSymbolsLow_cookie<s(0)(0)(0)>[&];(D1:pbCurOutInvalidSymbolsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCurOutSuperblockCrcErrorHigh_cookie<s(0)(0)(0)>[&];(D1:pbCurOutSuperblockCrcErrorHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCurOutSuperblockCrcErrorLow_cookie<s(0)(0)(0)>[&];(D1:pbCurOutSuperblockCrcErrorLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCurOutSuperblockCorrectableCrcErrorHigh_cookie<s(0)(0)(0)>[&];(D1:pbCurOutSuperblockCorrectableCrcErrorHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCurOutSuperblockCorrectableCrcErrorLow_cookie<s(0)(0)(0)>[&];(D1:pbCurOutSuperblockCorrectableCrcErrorLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortType_cookie<s(0)(0)(0)>[&];(D1:pbPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTpType_cookie<s(0)(0)(0)>[&];(D1:pbTpType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTpIndex_cookie<s(0)(0)(0)>[&];(D1:pbTpIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTableType_cookie<s(0)(0)(0)>[&];(D1:pbTableType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPmActualPortType_cookie<s(0)(0)(0)>[&];(D1:pbPmActualPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSdhPmMonitor_cookie<s(0)(0)(0)>[&];(D1:pbSdhPmMonitor_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEsPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbEsPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEsPmThresholdEnable_cookie<s(0)(0)(0)>[&];(D1:pbEsPmThresholdEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEsPmThresholdLow_cookie<s(0)(0)(0)>[&];(D1:pbEsPmThresholdLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEsPmThresholdHigh_cookie<s(0)(0)(0)>[&];(D1:pbEsPmThresholdHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbBbePmCounter_cookie<s(0)(0)(0)>[&];(D1:pbBbePmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbBbePmThresholdEnable_cookie<s(0)(0)(0)>[&];(D1:pbBbePmThresholdEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbBbePmThresholdLow_cookie<s(0)(0)(0)>[&];(D1:pbBbePmThresholdLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbBbePmThresholdHigh_cookie<s(0)(0)(0)>[&];(D1:pbBbePmThresholdHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSesPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbSesPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSesPmThresholdEnable_cookie<s(0)(0)(0)>[&];(D1:pbSesPmThresholdEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSesPmThresholdLow_cookie<s(0)(0)(0)>[&];(D1:pbSesPmThresholdLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSesPmThresholdHigh_cookie<s(0)(0)(0)>[&];(D1:pbSesPmThresholdHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUasPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbUasPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUasPmThresholdEnable_cookie<s(0)(0)(0)>[&];(D1:pbUasPmThresholdEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUasPmThresholdLow_cookie<s(0)(0)(0)>[&];(D1:pbUasPmThresholdLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUasPmThresholdHigh_cookie<s(0)(0)(0)>[&];(D1:pbUasPmThresholdHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCsesPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbCsesPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCsesPmThresholdEnable_cookie<s(0)(0)(0)>[&];(D1:pbCsesPmThresholdEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCsesPmThresholdLow_cookie<s(0)(0)(0)>[&];(D1:pbCsesPmThresholdLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCsesPmThresholdHigh_cookie<s(0)(0)(0)>[&];(D1:pbCsesPmThresholdHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFcPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbFcPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFcPmThresholdEnable_cookie<s(0)(0)(0)>[&];(D1:pbFcPmThresholdEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFcPmThresholdLow_cookie<s(0)(0)(0)>[&];(D1:pbFcPmThresholdLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFcPmThresholdHigh_cookie<s(0)(0)(0)>[&];(D1:pbFcPmThresholdHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOfsPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbOfsPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOfsPmThresholdEnable_cookie<s(0)(0)(0)>[&];(D1:pbOfsPmThresholdEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOfsPmThresholdLow_cookie<s(0)(0)(0)>[&];(D1:pbOfsPmThresholdLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOfsPmThresholdHigh_cookie<s(0)(0)(0)>[&];(D1:pbOfsPmThresholdHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPpjcPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbPpjcPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPpjcPmThresholdEnable_cookie<s(0)(0)(0)>[&];(D1:pbPpjcPmThresholdEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPpjcPmThresholdLow_cookie<s(0)(0)(0)>[&];(D1:pbPpjcPmThresholdLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPpjcPmThresholdHigh_cookie<s(0)(0)(0)>[&];(D1:pbPpjcPmThresholdHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbNpjcPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbNpjcPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbNpjcPmThresholdEnable_cookie<s(0)(0)(0)>[&];(D1:pbNpjcPmThresholdEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbNpjcPmThresholdLow_cookie<s(0)(0)(0)>[&];(D1:pbNpjcPmThresholdLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbNpjcPmThresholdHigh_cookie<s(0)(0)(0)>[&];(D1:pbNpjcPmThresholdHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPmTableReset_cookie<s(0)(0)(0)>[&];(D1:pbPmTableReset_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPmTimeStart_cookie<s(0)(0)(0)>[&];(D1:pbPmTimeStart_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPmTimeElapse_cookie<s(0)(0)(0)>[&];(D1:pbPmTimeElapse_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPmProtStatus_cookie<s(0)(0)(0)>[&];(D1:pbPmProtStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPmTpStatus_cookie<s(0)(0)(0)>[&];(D1:pbPmTpStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPmSuspect_cookie<s(0)(0)(0)>[&];(D1:pbPmSuspect_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSdhRecentPMTable_cookie<s(0)(0)(0)>[&];(D1:pbSdhRecentPMTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentPMTable_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentPMTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentPMTable_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentPMTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentPMTable_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentPMTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhRecentSlipTable_cookie<s(0)(0)(0)>[&];(D1:pbPdhRecentSlipTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRecentPMTable_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRecentPMTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhRecentPMTable_cookie<s(0)(0)(0)>[&];(D1:pbPdhRecentPMTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanRecentPMTable_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanRecentPMTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthVlanRecentPMTable_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthVlanRecentPMTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecRecentPMTable_cookie<s(0)(0)(0)>[&];(D1:pbFecRecentPMTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuRecentPMTable_cookie<s(0)(0)(0)>[&];(D1:pbOtuRecentPMTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortType_cookie<s(0)(0)(0)>[&];(D1:pbPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuRecentChannelID_cookie<s(0)(0)(0)>[&];(D1:pbOtuRecentChannelID_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuRecentSegmentNum_cookie<s(0)(0)(0)>[&];(D1:pbOtuRecentSegmentNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuRecentTableType_cookie<s(0)(0)(0)>[&];(D1:pbOtuRecentTableType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuRecentTimesIndex_cookie<s(0)(0)(0)>[&];(D1:pbOtuRecentTimesIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuRecentEsPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbOtuRecentEsPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuRecentBbePmCounter_cookie<s(0)(0)(0)>[&];(D1:pbOtuRecentBbePmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuRecentSesPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbOtuRecentSesPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuRecentUasPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbOtuRecentUasPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuRecentCsesPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbOtuRecentCsesPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuRecentFcPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbOtuRecentFcPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuRecentOfsPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbOtuRecentOfsPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuRecentIaesPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbOtuRecentIaesPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuRecentBiaesPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbOtuRecentBiaesPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuRecentPmTimeEnd_cookie<s(0)(0)(0)>[&];(D1:pbOtuRecentPmTimeEnd_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuSuspect_cookie<s(0)(0)(0)>[&];(D1:pbOtuSuspect_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuComplete_cookie<s(0)(0)(0)>[&];(D1:pbOtuComplete_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortType_cookie<s(0)(0)(0)>[&];(D1:pbPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecRecentTableType_cookie<s(0)(0)(0)>[&];(D1:pbFecRecentTableType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecRecentTimesIndex_cookie<s(0)(0)(0)>[&];(D1:pbFecRecentTimesIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecRecentTecPmCounterHigh_cookie<s(0)(0)(0)>[&];(D1:pbFecRecentTecPmCounterHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecRecentTecPmCounterLow_cookie<s(0)(0)(0)>[&];(D1:pbFecRecentTecPmCounterLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecRecentZecPmCounterHigh_cookie<s(0)(0)(0)>[&];(D1:pbFecRecentZecPmCounterHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecRecentZecPmCounterLow_cookie<s(0)(0)(0)>[&];(D1:pbFecRecentZecPmCounterLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecRecentOecPmCounterHigh_cookie<s(0)(0)(0)>[&];(D1:pbFecRecentOecPmCounterHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecRecentOecPmCounterLow_cookie<s(0)(0)(0)>[&];(D1:pbFecRecentOecPmCounterLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecRecentFcPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbFecRecentFcPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecRecentPmTimeEnd_cookie<s(0)(0)(0)>[&];(D1:pbFecRecentPmTimeEnd_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecSuspect_cookie<s(0)(0)(0)>[&];(D1:pbFecSuspect_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecComplete_cookie<s(0)(0)(0)>[&];(D1:pbFecComplete_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecRecUncorrectedBlkHigh_cookie<s(0)(0)(0)>[&];(D1:pbFecRecUncorrectedBlkHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecRecUncorrectedBlkLow_cookie<s(0)(0)(0)>[&];(D1:pbFecRecUncorrectedBlkLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPmPortType_cookie<s(0)(0)(0)>[&];(D1:pbEthPmPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanNo_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthVlanTimesIndex_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthVlanTimesIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthVlanRecentPmStartFlag_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthVlanRecentPmStartFlag_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthVlanRecentInPkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthVlanRecentInPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthVlanRecentInBytes_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthVlanRecentInBytes_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthVlanRecentDropPkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthVlanRecentDropPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthVlanRecentRcvUnicastFrames_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthVlanRecentRcvUnicastFrames_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthVlanRecentRcvTotalFrames_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthVlanRecentRcvTotalFrames_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthVlanRecentRcvUnicastBytes_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthVlanRecentRcvUnicastBytes_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthVlanRecentRcvTotalBytes_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthVlanRecentRcvTotalBytes_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthVlanFrmStartIndex_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthVlanFrmStartIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanRecentTableType_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanRecentTableType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPmPortType_cookie<s(0)(0)(0)>[&];(D1:pbEthPmPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanNo_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanRecentTimesIndex_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanRecentTimesIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanRecentPmTimeEnd_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanRecentPmTimeEnd_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanRecentPmTimeSuspect_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanRecentPmTimeSuspect_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanRecentInPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanRecentInPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanRecentInPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanRecentInPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanRecentInBytesHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanRecentInBytesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanRecentInBytesLow_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanRecentInBytesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanRecentDropPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanRecentDropPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanRecentDropPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanRecentDropPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanRecentRcvUnicastFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanRecentRcvUnicastFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanRecentRcvUnicastFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanRecentRcvUnicastFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanRecentRcvTotalFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanRecentRcvTotalFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanRecentRcvTotalFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanRecentRcvTotalFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanRecentRcvUnicastBytesHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanRecentRcvUnicastBytesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanRecentRcvUnicastBytesLow_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanRecentRcvUnicastBytesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanRecentRcvTotalBytesHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanRecentRcvTotalBytesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanRecentRcvTotalBytesLow_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanRecentRcvTotalBytesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortType_cookie<s(0)(0)(0)>[&];(D1:pbPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhRecentTableType_cookie<s(0)(0)(0)>[&];(D1:pbPdhRecentTableType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhRecentTimesIndex_cookie<s(0)(0)(0)>[&];(D1:pbPdhRecentTimesIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhRecentEsPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbPdhRecentEsPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhRecentBbePmCounter_cookie<s(0)(0)(0)>[&];(D1:pbPdhRecentBbePmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhRecentSesPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbPdhRecentSesPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhRecentUasPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbPdhRecentUasPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhRecentCsesPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbPdhRecentCsesPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhRecentFcPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbPdhRecentFcPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhRecentPmTimeEnd_cookie<s(0)(0)(0)>[&];(D1:pbPdhRecentPmTimeEnd_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhSuspect_cookie<s(0)(0)(0)>[&];(D1:pbPdhSuspect_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhComplete_cookie<s(0)(0)(0)>[&];(D1:pbPdhComplete_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRecentPmPortType_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRecentPmPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthTimesIndex_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthTimesIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRecentPmStartFlag_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRecentPmStartFlag_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRecentInUnicastPkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRecentInUnicastPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRecentInMulcastPkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRecentInMulcastPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRecentInBrdcastPkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRecentInBrdcastPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRecentInAllBadPkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRecentInAllBadPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRecentInAllBadBytes_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRecentInAllBadBytes_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRecentInAllGoodPkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRecentInAllGoodPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRecentInAllGoodBytes_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRecentInAllGoodBytes_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRecentInOverSizePkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRecentInOverSizePkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRecentInUnderSizePkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRecentInUnderSizePkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRecentInCRCErrPkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRecentInCRCErrPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRecentOutUnicastPkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRecentOutUnicastPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRecentOutMulcastPkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRecentOutMulcastPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRecentOutBrdcastPkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRecentOutBrdcastPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRecentOutAllGoodPkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRecentOutAllGoodPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRecentOutAllGoodBytes_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRecentOutAllGoodBytes_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthFrmStartIndex_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthFrmStartIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRcntInAllBytes_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRcntInAllBytes_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRcntInAllPkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRcntInAllPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRcntInAllGoodPkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRcntInAllGoodPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRcntInAllBadPkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRcntInAllBadPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRcntInUnicastPkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRcntInUnicastPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRcntInMulcastPkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRcntInMulcastPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRcntInBrdcastPkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRcntInBrdcastPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRcntInDropPkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRcntInDropPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRcntInUndersizeGoodPkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRcntInUndersizeGoodPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRcntInOversizeGoodPkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRcntInOversizeGoodPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRcntIn64Pkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRcntIn64Pkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRcntIn65To127Pkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRcntIn65To127Pkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRcntIn128To255Pkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRcntIn128To255Pkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRcntIn256To511Pkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRcntIn256To511Pkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRcntIn512To1023Pkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRcntIn512To1023Pkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRcntIn1024To1518Pkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRcntIn1024To1518Pkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRcntInPausePkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRcntInPausePkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRcntInFragmentPkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRcntInFragmentPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRcntInJabberPkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRcntInJabberPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRcntInAlignmentErrorPkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRcntInAlignmentErrorPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRcntOutAllBytes_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRcntOutAllBytes_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRcntOutAllPkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRcntOutAllPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRcntOutUnicastPkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRcntOutUnicastPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRcntOutMulcastPkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRcntOutMulcastPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRcntOutBrdcastPkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRcntOutBrdcastPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRcntOutGoodPausePkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRcntOutGoodPausePkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRcntOutCollisionPkts_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRcntOutCollisionPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortType_cookie<s(0)(0)(0)>[&];(D1:pbPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRecentSlipTableType_cookie<s(0)(0)(0)>[&];(D1:pbRecentSlipTableType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRecentSlipTimesIndex_cookie<s(0)(0)(0)>[&];(D1:pbRecentSlipTimesIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRecentPSlipCounter_cookie<s(0)(0)(0)>[&];(D1:pbRecentPSlipCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRecentNSlipCounter_cookie<s(0)(0)(0)>[&];(D1:pbRecentNSlipCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlipTimeEnd_cookie<s(0)(0)(0)>[&];(D1:pbSlipTimeEnd_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRecentSlipSuspect_cookie<s(0)(0)(0)>[&];(D1:pbRecentSlipSuspect_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfIndex_cookie<s(0)(0)(0)>[&];(D1:rprIfIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSpanId_cookie<s(0)(0)(0)>[&];(D1:rprSpanId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentTableType_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentTableType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanTableRecentTimesIndex_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanTableRecentTimesIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentPmTimeEnd_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentPmTimeEnd_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentPmTimeSuspect_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentPmTimeSuspect_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInAllFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInAllFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInAllFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInAllFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInWrapFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInWrapFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInWrapFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInWrapFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInDataFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInDataFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInDataFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInDataFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInCtrlFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInCtrlFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInCtrlFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInCtrlFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInFaFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInFaFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInFaFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInFaFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutAllFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutAllFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutAllFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutAllFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutAddFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutAddFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutAddFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutAddFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutTransitFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutTransitFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutTransitFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutTransitFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutWrapFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutWrapFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutWrapFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutWrapFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutTpFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutTpFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutTpFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutTpFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutFaFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutFaFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutFaFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutFaFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutOamFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutOamFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutOamFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutOamFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentErrHecFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentErrHecFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentErrHecFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentErrHecFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentErrParityFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentErrParityFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentErrParityFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentErrParityFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentErrFcsFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentErrFcsFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentErrFcsFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentErrFcsFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentErrEdgeFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentErrEdgeFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentErrEdgeFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentErrEdgeFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentErrSelfSourceFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentErrSelfSourceFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentErrSelfSourceFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentErrSelfSourceFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInUcastClassAFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInUcastClassAFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInUcastClassAFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInUcastClassAFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInUcastClassAOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInUcastClassAOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInUcastClassAOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInUcastClassAOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInUcastClassBCirFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInUcastClassBCirFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInUcastClassBCirFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInUcastClassBCirFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInUcastClassBCirOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInUcastClassBCirOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInUcastClassBCirOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInUcastClassBCirOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInUcastClassBEirFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInUcastClassBEirFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInUcastClassBEirFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInUcastClassBEirFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInUcastClassBEirOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInUcastClassBEirOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInUcastClassBEirOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInUcastClassBEirOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInUcastClassCFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInUcastClassCFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInUcastClassCFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInUcastClassCFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInUcastClassCOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInUcastClassCOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInUcastClassCOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInUcastClassCOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInMcastClassAFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInMcastClassAFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInMcastClassAFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInMcastClassAFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInMcastClassAOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInMcastClassAOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInMcastClassAOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInMcastClassAOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInMcastClassBCirFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInMcastClassBCirFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInMcastClassBCirFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInMcastClassBCirFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInMcastClassBCirOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInMcastClassBCirOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInMcastClassBCirOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInMcastClassBCirOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInMcastClassBEirFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInMcastClassBEirFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInMcastClassBEirFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInMcastClassBEirFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInMcastClassBEirOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInMcastClassBEirOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInMcastClassBEirOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInMcastClassBEirOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInMcastClassCFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInMcastClassCFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInMcastClassCFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInMcastClassCFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInMcastClassCOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInMcastClassCOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentInMcastClassCOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentInMcastClassCOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutUcastClassAFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutUcastClassAFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutUcastClassAFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutUcastClassAFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutUcastClassAOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutUcastClassAOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutUcastClassAOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutUcastClassAOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutUcastClassBCirFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutUcastClassBCirFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutUcastClassBCirFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutUcastClassBCirFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutUcastClassBCirOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutUcastClassBCirOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutUcastClassBCirOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutUcastClassBCirOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutUcastClassBEirFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutUcastClassBEirFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutUcastClassBEirFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutUcastClassBEirFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutUcastClassBEirOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutUcastClassBEirOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutUcastClassBEirOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutUcastClassBEirOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutUcastClassCFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutUcastClassCFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutUcastClassCFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutUcastClassCFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutUcastClassCOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutUcastClassCOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutUcastClassCOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutUcastClassCOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutMcastClassAFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutMcastClassAFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutMcastClassAFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutMcastClassAFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutMcastClassAOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutMcastClassAOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutMcastClassAOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutMcastClassAOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutMcastClassBCirFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutMcastClassBCirFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutMcastClassBCirFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutMcastClassBCirFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutMcastClassBCirOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutMcastClassBCirOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutMcastClassBCirOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutMcastClassBCirOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutMcastClassBEirFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutMcastClassBEirFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutMcastClassBEirFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutMcastClassBEirFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutMcastClassBEirOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutMcastClassBEirOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutMcastClassBEirOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutMcastClassBEirOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutMcastClassCFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutMcastClassCFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutMcastClassCFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutMcastClassCFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutMcastClassCOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutMcastClassCOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentOutMcastClassCOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentOutMcastClassCOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfIndex_cookie<s(0)(0)(0)>[&];(D1:rprIfIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentTableType_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentTableType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientTableRecentTimesIndex_cookie<s(0)(0)(0)>[&];(D1:pbRprClientTableRecentTimesIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentPmTimeEnd_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentPmTimeEnd_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentPmTimeSuspect_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentPmTimeSuspect_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentInAllFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentInAllFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentInAllFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentInAllFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutAllFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutAllFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutAllFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutAllFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutPassFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutPassFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutPassFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutPassFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutDropFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutDropFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutDropFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutDropFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutErrLenFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutErrLenFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutErrLenFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutErrLenFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutErrCrcFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutErrCrcFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutErrCrcFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutErrCrcFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentInUcastClassAFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentInUcastClassAFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentInUcastClassAFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentInUcastClassAFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentInUcastClassAOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentInUcastClassAOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentInUcastClassAOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentInUcastClassAOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentInUcastClassBCirFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentInUcastClassBCirFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentInUcastClassBCirFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentInUcastClassBCirFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentInUcastClassBCirOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentInUcastClassBCirOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentInUcastClassBCirOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentInUcastClassBCirOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentInUcastClassBEirFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentInUcastClassBEirFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentInUcastClassBEirFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentInUcastClassBEirFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentInUcastClassBEirOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentInUcastClassBEirOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentInUcastClassBEirOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentInUcastClassBEirOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentInUcastClassCFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentInUcastClassCFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentInUcastClassCFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentInUcastClassCFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentInUcastClassCOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentInUcastClassCOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentInUcastClassCOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentInUcastClassCOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentInMcastClassAFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentInMcastClassAFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentInMcastClassAFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentInMcastClassAFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentInMcastClassAOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentInMcastClassAOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentInMcastClassAOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentInMcastClassAOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentInMcastClassBCirFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentInMcastClassBCirFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentInMcastClassBCirFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentInMcastClassBCirFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentInMcastClassBCirOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentInMcastClassBCirOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentInMcastClassBCirOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentInMcastClassBCirOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentInMcastClassBEirFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentInMcastClassBEirFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentInMcastClassBEirFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentInMcastClassBEirFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentInMcastClassBEirOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentInMcastClassBEirOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentInMcastClassBEirOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentInMcastClassBEirOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentInMcastClassCFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentInMcastClassCFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentInMcastClassCFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentInMcastClassCFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentInMcastClassCOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentInMcastClassCOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentInMcastClassCOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentInMcastClassCOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutUcastClassAFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutUcastClassAFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutUcastClassAFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutUcastClassAFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutUcastClassAOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutUcastClassAOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutUcastClassAOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutUcastClassAOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutUcastClassBCirFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutUcastClassBCirFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutUcastClassBCirFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutUcastClassBCirFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutUcastClassBCirOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutUcastClassBCirOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutUcastClassBCirOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutUcastClassBCirOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutUcastClassBEirFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutUcastClassBEirFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutUcastClassBEirFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutUcastClassBEirFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutUcastClassBEirOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutUcastClassBEirOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutUcastClassBEirOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutUcastClassBEirOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutUcastClassCFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutUcastClassCFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutUcastClassCFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutUcastClassCFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutUcastClassCOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutUcastClassCOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutUcastClassCOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutUcastClassCOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutMcastClassAFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutMcastClassAFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutMcastClassAFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutMcastClassAFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutMcastClassAOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutMcastClassAOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutMcastClassAOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutMcastClassAOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutMcastClassBCirFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutMcastClassBCirFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutMcastClassBCirFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutMcastClassBCirFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutMcastClassBCirOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutMcastClassBCirOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutMcastClassBCirOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutMcastClassBCirOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutMcastClassBEirFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutMcastClassBEirFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutMcastClassBEirFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutMcastClassBEirFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutMcastClassBEirOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutMcastClassBEirOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutMcastClassBEirOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutMcastClassBEirOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutMcastClassCFramesHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutMcastClassCFramesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutMcastClassCFramesLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutMcastClassCFramesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutMcastClassCOctetsHigh_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutMcastClassCOctetsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentOutMcastClassCOctetsLow_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentOutMcastClassCOctetsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentTableType_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentTableType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentPmPortType_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentPmPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentTimesIndex_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentTimesIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentPmTimeEnd_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentPmTimeEnd_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentPmTimeSuspect_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentPmTimeSuspect_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentInUnicastPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentInUnicastPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentInUnicastPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentInUnicastPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentInMulcastPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentInMulcastPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentInMulcastPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentInMulcastPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentInBrdcastPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentInBrdcastPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentInBrdcastPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentInBrdcastPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentInAllBadPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentInAllBadPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentInAllBadPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentInAllBadPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentInAllBadBytesHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentInAllBadBytesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentInAllBadBytesLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentInAllBadBytesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentInAllGoodPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentInAllGoodPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentInAllGoodPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentInAllGoodPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentInAllGoodBytesHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentInAllGoodBytesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentInAllGoodBytesLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentInAllGoodBytesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentInOverSizePktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentInOverSizePktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentInOverSizePktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentInOverSizePktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentInUnderSizePktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentInUnderSizePktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentInUnderSizePktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentInUnderSizePktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentInCRCErrPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentInCRCErrPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentInCRCErrPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentInCRCErrPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentOutUnicastPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentOutUnicastPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentOutUnicastPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentOutUnicastPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentOutMulcastPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentOutMulcastPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentOutMulcastPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentOutMulcastPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentOutBrdcastPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentOutBrdcastPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentOutBrdcastPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentOutBrdcastPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentOutAllGoodPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentOutAllGoodPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentOutAllGoodPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentOutAllGoodPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentOutAllGoodBytesHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentOutAllGoodBytesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentOutAllGoodBytesLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentOutAllGoodBytesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntInAllBytesHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntInAllBytesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntInAllBytesLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntInAllBytesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntInAllPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntInAllPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntInAllPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntInAllPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntInAllGoodPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntInAllGoodPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntInAllGoodPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntInAllGoodPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntInAllBadPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntInAllBadPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntInAllBadPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntInAllBadPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntInUnicastPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntInUnicastPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntInUnicastPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntInUnicastPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntInMulcastPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntInMulcastPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntInMulcastPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntInMulcastPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntInBrdcastPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntInBrdcastPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntInBrdcastPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntInBrdcastPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntInDropPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntInDropPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntInDropPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntInDropPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntInUndersizeGoodPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntInUndersizeGoodPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntInUndersizeGoodPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntInUndersizeGoodPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntInOversizeGoodPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntInOversizeGoodPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntInOversizeGoodPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntInOversizeGoodPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntIn64PktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntIn64PktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntIn64PktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntIn64PktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntIn65To127PktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntIn65To127PktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntIn65To127PktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntIn65To127PktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntIn128To255PktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntIn128To255PktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntIn128To255PktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntIn128To255PktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntIn256To511PktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntIn256To511PktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntIn256To511PktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntIn256To511PktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntIn512To1023PktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntIn512To1023PktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntIn512To1023PktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntIn512To1023PktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntIn1024To1518PktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntIn1024To1518PktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntIn1024To1518PktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntIn1024To1518PktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntInPausePktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntInPausePktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntInPausePktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntInPausePktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntInFragmentPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntInFragmentPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntInFragmentPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntInFragmentPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntInJabberPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntInJabberPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntInJabberPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntInJabberPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntInAlignmentErrorPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntInAlignmentErrorPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntInAlignmentErrorPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntInAlignmentErrorPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntOutAllBytesHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntOutAllBytesHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntOutAllBytesLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntOutAllBytesLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntOutAllPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntOutAllPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntOutAllPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntOutAllPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntOutUnicastPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntOutUnicastPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntOutUnicastPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntOutUnicastPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntOutMulcastPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntOutMulcastPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntOutMulcastPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntOutMulcastPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntOutBrdcastPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntOutBrdcastPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntOutBrdcastPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntOutBrdcastPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntOutGoodPausePktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntOutGoodPausePktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntOutGoodPausePktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntOutGoodPausePktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntOutCollisionPktsHigh_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntOutCollisionPktsHigh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRcntOutCollisionPktsLow_cookie<s(0)(0)(0)>[&];(D1:pbEthRcntOutCollisionPktsLow_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortType_cookie<s(0)(0)(0)>[&];(D1:pbPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTpType_cookie<s(0)(0)(0)>[&];(D1:pbTpType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTpIndex_cookie<s(0)(0)(0)>[&];(D1:pbTpIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRecentTableType_cookie<s(0)(0)(0)>[&];(D1:pbRecentTableType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRecentTimesIndex_cookie<s(0)(0)(0)>[&];(D1:pbRecentTimesIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRecentEsPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbRecentEsPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRecentBbePmCounter_cookie<s(0)(0)(0)>[&];(D1:pbRecentBbePmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRecentSesPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbRecentSesPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRecentUasPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbRecentUasPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRecentCsesPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbRecentCsesPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRecentFcPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbRecentFcPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRecentOfsPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbRecentOfsPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRecentPpjcPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbRecentPpjcPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRecentNpjcPmCounter_cookie<s(0)(0)(0)>[&];(D1:pbRecentNpjcPmCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRecentPmTimeEnd_cookie<s(0)(0)(0)>[&];(D1:pbRecentPmTimeEnd_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSuspect_cookie<s(0)(0)(0)>[&];(D1:pbSuspect_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbComplete_cookie<s(0)(0)(0)>[&];(D1:pbComplete_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSdhUapPMTable_cookie<s(0)(0)(0)>[&];(D1:pbSdhUapPMTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhUapPMTable_cookie<s(0)(0)(0)>[&];(D1:pbPdhUapPMTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuUapPMTable_cookie<s(0)(0)(0)>[&];(D1:pbOtuUapPMTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortType_cookie<s(0)(0)(0)>[&];(D1:pbPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUapChannelID_cookie<s(0)(0)(0)>[&];(D1:pbUapChannelID_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUapSegmentNum_cookie<s(0)(0)(0)>[&];(D1:pbUapSegmentNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuUapType_cookie<s(0)(0)(0)>[&];(D1:pbOtuUapType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuIsAtUap_cookie<s(0)(0)(0)>[&];(D1:pbOtuIsAtUap_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuUAPCounter_cookie<s(0)(0)(0)>[&];(D1:pbOtuUAPCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuUapTimeStart_cookie<s(0)(0)(0)>[&];(D1:pbOtuUapTimeStart_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuUapTimeElapse_cookie<s(0)(0)(0)>[&];(D1:pbOtuUapTimeElapse_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuUAPReset_cookie<s(0)(0)(0)>[&];(D1:pbOtuUAPReset_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortType_cookie<s(0)(0)(0)>[&];(D1:pbPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhUapType_cookie<s(0)(0)(0)>[&];(D1:pbPdhUapType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhIsAtUap_cookie<s(0)(0)(0)>[&];(D1:pbPdhIsAtUap_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhUAPCounter_cookie<s(0)(0)(0)>[&];(D1:pbPdhUAPCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhUapTimeStart_cookie<s(0)(0)(0)>[&];(D1:pbPdhUapTimeStart_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhUapTimeElapse_cookie<s(0)(0)(0)>[&];(D1:pbPdhUapTimeElapse_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhUAPReset_cookie<s(0)(0)(0)>[&];(D1:pbPdhUAPReset_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortType_cookie<s(0)(0)(0)>[&];(D1:pbPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTpType_cookie<s(0)(0)(0)>[&];(D1:pbTpType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTpIndex_cookie<s(0)(0)(0)>[&];(D1:pbTpIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPmUapType_cookie<s(0)(0)(0)>[&];(D1:pbPmUapType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIsAtUap_cookie<s(0)(0)(0)>[&];(D1:pbIsAtUap_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUAPCounter_cookie<s(0)(0)(0)>[&];(D1:pbUAPCounter_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUapTimeStart_cookie<s(0)(0)(0)>[&];(D1:pbUapTimeStart_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUapTimeElapse_cookie<s(0)(0)(0)>[&];(D1:pbUapTimeElapse_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUAPReset_cookie<s(0)(0)(0)>[&];(D1:pbUAPReset_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSdhRecentUapPMTable_cookie<s(0)(0)(0)>[&];(D1:pbSdhRecentUapPMTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhRecentUapPMTable_cookie<s(0)(0)(0)>[&];(D1:pbPdhRecentUapPMTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuRecentUapPMTable_cookie<s(0)(0)(0)>[&];(D1:pbOtuRecentUapPMTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortType_cookie<s(0)(0)(0)>[&];(D1:pbPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuRecUapChannelID_cookie<s(0)(0)(0)>[&];(D1:pbOtuRecUapChannelID_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuRecUapSegmentNum_cookie<s(0)(0)(0)>[&];(D1:pbOtuRecUapSegmentNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuRecUapType_cookie<s(0)(0)(0)>[&];(D1:pbOtuRecUapType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuUapTimesIndex_cookie<s(0)(0)(0)>[&];(D1:pbOtuUapTimesIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuRecentUapTimeStart_cookie<s(0)(0)(0)>[&];(D1:pbOtuRecentUapTimeStart_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuRecentUapTimeEnd_cookie<s(0)(0)(0)>[&];(D1:pbOtuRecentUapTimeEnd_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortType_cookie<s(0)(0)(0)>[&];(D1:pbPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhRecUapType_cookie<s(0)(0)(0)>[&];(D1:pbPdhRecUapType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhUapTimesIndex_cookie<s(0)(0)(0)>[&];(D1:pbPdhUapTimesIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhRecentUapTimeStart_cookie<s(0)(0)(0)>[&];(D1:pbPdhRecentUapTimeStart_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhRecentUapTimeEnd_cookie<s(0)(0)(0)>[&];(D1:pbPdhRecentUapTimeEnd_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortType_cookie<s(0)(0)(0)>[&];(D1:pbPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTpType_cookie<s(0)(0)(0)>[&];(D1:pbTpType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTpIndex_cookie<s(0)(0)(0)>[&];(D1:pbTpIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPmRecUapType_cookie<s(0)(0)(0)>[&];(D1:pbPmRecUapType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUapTimesIndex_cookie<s(0)(0)(0)>[&];(D1:pbUapTimesIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRecentUapTimeStart_cookie<s(0)(0)(0)>[&];(D1:pbRecentUapTimeStart_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRecentUapTimeEnd_cookie<s(0)(0)(0)>[&];(D1:pbRecentUapTimeEnd_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSdhMostRecentIndexTable_cookie<s(0)(0)(0)>[&];(D1:pbSdhMostRecentIndexTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthMostRecentIndexTable_cookie<s(0)(0)(0)>[&];(D1:pbEthMostRecentIndexTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientMostRecentIndexTable_cookie<s(0)(0)(0)>[&];(D1:pbRprClientMostRecentIndexTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanMostRecentIndexTable_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanMostRecentIndexTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlipMostRecentIndexTable_cookie<s(0)(0)(0)>[&];(D1:pbSlipMostRecentIndexTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthIndexTable_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthIndexTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhMostRecentIndexTable_cookie<s(0)(0)(0)>[&];(D1:pbPdhMostRecentIndexTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanMostRecentIndexTable_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanMostRecentIndexTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthVlanIndexTable_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthVlanIndexTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecMostRecentIndexTable_cookie<s(0)(0)(0)>[&];(D1:pbFecMostRecentIndexTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuMostRecentIndexTable_cookie<s(0)(0)(0)>[&];(D1:pbOtuMostRecentIndexTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortType_cookie<s(0)(0)(0)>[&];(D1:pbPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuRecChannelID_cookie<s(0)(0)(0)>[&];(D1:pbOtuRecChannelID_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuRecSegmentNum_cookie<s(0)(0)(0)>[&];(D1:pbOtuRecSegmentNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuRecIntervalTblType_cookie<s(0)(0)(0)>[&];(D1:pbOtuRecIntervalTblType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuRecentIntervalTblMRI_cookie<s(0)(0)(0)>[&];(D1:pbOtuRecentIntervalTblMRI_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuRecentIntervalUpMaxIndex_cookie<s(0)(0)(0)>[&];(D1:pbOtuRecentIntervalUpMaxIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuRecentUapTblMRI_cookie<s(0)(0)(0)>[&];(D1:pbOtuRecentUapTblMRI_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOtuRecentUapUpMaxIndex_cookie<s(0)(0)(0)>[&];(D1:pbOtuRecentUapUpMaxIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortType_cookie<s(0)(0)(0)>[&];(D1:pbPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecRecIntervalTblType_cookie<s(0)(0)(0)>[&];(D1:pbFecRecIntervalTblType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecRecentIntervalTblMRI_cookie<s(0)(0)(0)>[&];(D1:pbFecRecentIntervalTblMRI_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecRecentIntervalUpMaxIndex_cookie<s(0)(0)(0)>[&];(D1:pbFecRecentIntervalUpMaxIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPmPortType_cookie<s(0)(0)(0)>[&];(D1:pbEthPmPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanNo_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthVlanRecentIntervalTblMRI_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthVlanRecentIntervalTblMRI_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthVlanRecentIntervalUpMaxIndex_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthVlanRecentIntervalUpMaxIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthVlanRecentIndex_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthVlanRecentIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanIndexTableType_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanIndexTableType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthPmPortType_cookie<s(0)(0)(0)>[&];(D1:pbEthPmPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanNo_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanRecentIntervalTblMRI_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanRecentIntervalTblMRI_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthVlanRecentIntervalUpMaxIndex_cookie<s(0)(0)(0)>[&];(D1:pbEthVlanRecentIntervalUpMaxIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortType_cookie<s(0)(0)(0)>[&];(D1:pbPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhRecIntervalTblType_cookie<s(0)(0)(0)>[&];(D1:pbPdhRecIntervalTblType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhRecentIntervalTblMRI_cookie<s(0)(0)(0)>[&];(D1:pbPdhRecentIntervalTblMRI_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhRecentIntervalUpMaxIndex_cookie<s(0)(0)(0)>[&];(D1:pbPdhRecentIntervalUpMaxIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhRecentUapTblMRI_cookie<s(0)(0)(0)>[&];(D1:pbPdhRecentUapTblMRI_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhRecentUapUpMaxIndex_cookie<s(0)(0)(0)>[&];(D1:pbPdhRecentUapUpMaxIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthIndexPortType_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthIndexPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRecentIntervalTblMRI_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRecentIntervalTblMRI_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRecentIntervalUpMaxIndex_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRecentIntervalUpMaxIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthRecentIndex_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthRecentIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortType_cookie<s(0)(0)(0)>[&];(D1:pbPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlipRecentTblMRI_cookie<s(0)(0)(0)>[&];(D1:pbSlipRecentTblMRI_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfIndex_cookie<s(0)(0)(0)>[&];(D1:rprIfIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprSpanId_cookie<s(0)(0)(0)>[&];(D1:rprSpanId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanIndexTableType_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanIndexTableType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentIntervalTblMRI_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentIntervalTblMRI_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprSpanRecentIntervalUpMaxIndex_cookie<s(0)(0)(0)>[&];(D1:pbRprSpanRecentIntervalUpMaxIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] rprIfIndex_cookie<s(0)(0)(0)>[&];(D1:rprIfIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientIndexTableType_cookie<s(0)(0)(0)>[&];(D1:pbRprClientIndexTableType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentIntervalTblMRI_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentIntervalTblMRI_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprClientRecentIntervalUpMaxIndex_cookie<s(0)(0)(0)>[&];(D1:pbRprClientRecentIntervalUpMaxIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthIndexTableType_cookie<s(0)(0)(0)>[&];(D1:pbEthIndexTableType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthIndexPmPortType_cookie<s(0)(0)(0)>[&];(D1:pbEthIndexPmPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentIntervalTblMRI_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentIntervalTblMRI_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthRecentIntervalUpMaxIndex_cookie<s(0)(0)(0)>[&];(D1:pbEthRecentIntervalUpMaxIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortType_cookie<s(0)(0)(0)>[&];(D1:pbPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTpType_cookie<s(0)(0)(0)>[&];(D1:pbTpType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTpIndex_cookie<s(0)(0)(0)>[&];(D1:pbTpIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPmRecIntervalTblType_cookie<s(0)(0)(0)>[&];(D1:pbPmRecIntervalTblType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRecentIntervalTblMRI_cookie<s(0)(0)(0)>[&];(D1:pbRecentIntervalTblMRI_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRecentIntervalUpMaxIndex_cookie<s(0)(0)(0)>[&];(D1:pbRecentIntervalUpMaxIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRecentUapTblMRI_cookie<s(0)(0)(0)>[&];(D1:pbRecentUapTblMRI_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRecentUapUpMaxIndex_cookie<s(0)(0)(0)>[&];(D1:pbRecentUapUpMaxIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSdhPMUpLoadTable_cookie<s(0)(0)(0)>[&];(D1:pbSdhPMUpLoadTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthUploadTable_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthUploadTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthFtpHostIP_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthFtpHostIP_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthFtpFileName_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthFtpFileName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthFtpUsername_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthFtpUsername_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbxSecEthFtpPassword_cookie<s(0)(0)(0)>[&];(D1:pbxSecEthFtpPassword_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSdhFtpCmndHostIP_cookie<s(0)(0)(0)>[&];(D1:pbSdhFtpCmndHostIP_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSdhFtpCmndPath_cookie<s(0)(0)(0)>[&];(D1:pbSdhFtpCmndPath_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSdhFtpFileName_cookie<s(0)(0)(0)>[&];(D1:pbSdhFtpFileName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSdhFtpCmndUsername_cookie<s(0)(0)(0)>[&];(D1:pbSdhFtpCmndUsername_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSdhFtpCmndPassword_cookie<s(0)(0)(0)>[&];(D1:pbSdhFtpCmndPassword_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSdhFtpCmndLastState_cookie<s(0)(0)(0)>[&];(D1:pbSdhFtpCmndLastState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAdjustTimeDircetion_cookie<s(0)(0)(0)>[&];(D1:pbAdjustTimeDircetion_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAdjustTimeDays_cookie<s(0)(0)(0)>[&];(D1:pbAdjustTimeDays_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAdjustTimeHours_cookie<s(0)(0)(0)>[&];(D1:pbAdjustTimeHours_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAdjustTimeMins_cookie<s(0)(0)(0)>[&];(D1:pbAdjustTimeMins_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAdjustTimeSecs_cookie<s(0)(0)(0)>[&];(D1:pbAdjustTimeSecs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUpLoadStatus_cookie<s(0)(0)(0)>[&];(D1:pbUpLoadStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortType_cookie<s(0)(0)(0)>[&];(D1:pbPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOTUPortLabel_cookie<s(0)(0)(0)>[&];(D1:pbOTUPortLabel_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOTUPortMode_cookie<s(0)(0)(0)>[&];(D1:pbOTUPortMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOTUPortAlarmDisable_cookie<s(0)(0)(0)>[&];(D1:pbOTUPortAlarmDisable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOTUPortLoopback_cookie<s(0)(0)(0)>[&];(D1:pbOTUPortLoopback_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecEnable_cookie<s(0)(0)(0)>[&];(D1:pbFecEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbInsFecErrEnable_cookie<s(0)(0)(0)>[&];(D1:pbInsFecErrEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbInsFecErrRate_cookie<s(0)(0)(0)>[&];(D1:pbInsFecErrRate_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbWaveLengthId_cookie<s(0)(0)(0)>[&];(D1:pbWaveLengthId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSMTimAlmEnable_cookie<s(0)(0)(0)>[&];(D1:pbSMTimAlmEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSMTimActEnable_cookie<s(0)(0)(0)>[&];(D1:pbSMTimActEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSMTxTti_cookie<s(0)(0)(0)>[&];(D1:pbSMTxTti_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSMExpTti_cookie<s(0)(0)(0)>[&];(D1:pbSMExpTti_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPTAlmEnable_cookie<s(0)(0)(0)>[&];(D1:pbPTAlmEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTxPt_cookie<s(0)(0)(0)>[&];(D1:pbTxPt_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbExpPt_cookie<s(0)(0)(0)>[&];(D1:pbExpPt_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCIDAlmEnable_cookie<s(0)(0)(0)>[&];(D1:pbCIDAlmEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTxChannelId_cookie<s(0)(0)(0)>[&];(D1:pbTxChannelId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAutoAdjustManulStopEnable_cookie<s(0)(0)(0)>[&];(D1:pbAutoAdjustManulStopEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortPathMapping_cookie<s(0)(0)(0)>[&];(D1:pbPortPathMapping_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOTUFecMode_cookie<s(0)(0)(0)>[&];(D1:pbOTUFecMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOTUPortAdminStatus_cookie<s(0)(0)(0)>[&];(D1:pbOTUPortAdminStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOTUPortUsageStatus_cookie<s(0)(0)(0)>[&];(D1:pbOTUPortUsageStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortType_cookie<s(0)(0)(0)>[&];(D1:pbPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTpType_cookie<s(0)(0)(0)>[&];(D1:pbTpType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTpIndex_cookie<s(0)(0)(0)>[&];(D1:pbTpIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMonitored_cookie<s(0)(0)(0)>[&];(D1:pbMonitored_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOutSignalType_cookie<s(0)(0)(0)>[&];(D1:pbOutSignalType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbInSignalType_cookie<s(0)(0)(0)>[&];(D1:pbInSignalType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTransPsl_cookie<s(0)(0)(0)>[&];(D1:pbTransPsl_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbExpPsl_cookie<s(0)(0)(0)>[&];(D1:pbExpPsl_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSLEnable_cookie<s(0)(0)(0)>[&];(D1:pbSLEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSLAccept_cookie<s(0)(0)(0)>[&];(D1:pbSLAccept_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTtiEnabled_cookie<s(0)(0)(0)>[&];(D1:pbTtiEnabled_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTimAisDis_cookie<s(0)(0)(0)>[&];(D1:pbTimAisDis_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTtiTransmitMode_cookie<s(0)(0)(0)>[&];(D1:pbTtiTransmitMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTtiReceiveMode_cookie<s(0)(0)(0)>[&];(D1:pbTtiReceiveMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTtiOctetTransmitted_cookie<s(0)(0)(0)>[&];(D1:pbTtiOctetTransmitted_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTtiOctetExpected_cookie<s(0)(0)(0)>[&];(D1:pbTtiOctetExpected_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTtiOctetAccepted_cookie<s(0)(0)(0)>[&];(D1:pbTtiOctetAccepted_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSdMode_cookie<s(0)(0)(0)>[&];(D1:pbSdMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbBurstyEnable_cookie<s(0)(0)(0)>[&];(D1:pbBurstyEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbBurstyPeriod_cookie<s(0)(0)(0)>[&];(D1:pbBurstyPeriod_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbBurstyPercent_cookie<s(0)(0)(0)>[&];(D1:pbBurstyPercent_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDegEnable_cookie<s(0)(0)(0)>[&];(D1:pbDegEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDegThreshold_cookie<s(0)(0)(0)>[&];(D1:pbDegThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbExcEnable_cookie<s(0)(0)(0)>[&];(D1:pbExcEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbExcThreshold_cookie<s(0)(0)(0)>[&];(D1:pbExcThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAISEnable_cookie<s(0)(0)(0)>[&];(D1:pbAISEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRDIEnable_cookie<s(0)(0)(0)>[&];(D1:pbRDIEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pmNearEnd15minMonitored_cookie<s(0)(0)(0)>[&];(D1:pmNearEnd15minMonitored_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pmFarEnd15minMonitored_cookie<s(0)(0)(0)>[&];(D1:pmFarEnd15minMonitored_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pmNearEnd24hrMonitored_cookie<s(0)(0)(0)>[&];(D1:pmNearEnd24hrMonitored_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pmFarEnd24hrMonitored_cookie<s(0)(0)(0)>[&];(D1:pmFarEnd24hrMonitored_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortType_cookie<s(0)(0)(0)>[&];(D1:pbPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vc4ReservationStatus_cookie<s(0)(0)(0)>[&];(D1:vc4ReservationStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] vc4ReservationOperate_cookie<s(0)(0)(0)>[&];(D1:vc4ReservationOperate_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tpOperationLock_cookie<s(0)(0)(0)>[&];(D1:tpOperationLock_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortType_cookie<s(0)(0)(0)>[&];(D1:pbPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortStatus_cookie<s(0)(0)(0)>[&];(D1:pbPortStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortOperStatus_cookie<s(0)(0)(0)>[&];(D1:pbPortOperStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLaserIBias_cookie<s(0)(0)(0)>[&];(D1:pbLaserIBias_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLaserRecvPwr_cookie<s(0)(0)(0)>[&];(D1:pbLaserRecvPwr_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLaserTransPwr_cookie<s(0)(0)(0)>[&];(D1:pbLaserTransPwr_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLaserTemp_cookie<s(0)(0)(0)>[&];(D1:pbLaserTemp_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCompliance8472_cookie<s(0)(0)(0)>[&];(D1:pbCompliance8472_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbnNominalMBps_cookie<s(0)(0)(0)>[&];(D1:pbnNominalMBps_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbnWavelength_cookie<s(0)(0)(0)>[&];(D1:pbnWavelength_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbnLinkLength9125_cookie<s(0)(0)(0)>[&];(D1:pbnLinkLength9125_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbnLinkLength50125_cookie<s(0)(0)(0)>[&];(D1:pbnLinkLength50125_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbnLinkLength62125_cookie<s(0)(0)(0)>[&];(D1:pbnLinkLength62125_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbnLinkLengthCopper_cookie<s(0)(0)(0)>[&];(D1:pbnLinkLengthCopper_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbsVendorName_cookie<s(0)(0)(0)>[&];(D1:pbsVendorName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbsVendorPN_cookie<s(0)(0)(0)>[&];(D1:pbsVendorPN_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbsVendorSN_cookie<s(0)(0)(0)>[&];(D1:pbsVendorSN_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbsManuDate_cookie<s(0)(0)(0)>[&];(D1:pbsManuDate_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbnTransCode_cookie<s(0)(0)(0)>[&];(D1:pbnTransCode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbsVendorOUI_cookie<s(0)(0)(0)>[&];(D1:pbsVendorOUI_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbnConnectorType_cookie<s(0)(0)(0)>[&];(D1:pbnConnectorType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbnClLaserTemp_cookie<s(0)(0)(0)>[&];(D1:pbnClLaserTemp_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbnTECCurrent_cookie<s(0)(0)(0)>[&];(D1:pbnTECCurrent_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbsSAGPartNumber_cookie<s(0)(0)(0)>[&];(D1:pbsSAGPartNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortType_cookie<s(0)(0)(0)>[&];(D1:pbPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortNo_cookie<s(0)(0)(0)>[&];(D1:pbPortNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortLabel_cookie<s(0)(0)(0)>[&];(D1:pbPortLabel_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortMode_cookie<s(0)(0)(0)>[&];(D1:pbPortMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPdhPortMap_cookie<s(0)(0)(0)>[&];(D1:pbPdhPortMap_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortAdminStatus_cookie<s(0)(0)(0)>[&];(D1:pbPortAdminStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortMapRefresh_cookie<s(0)(0)(0)>[&];(D1:pbPortMapRefresh_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortAutoLaserShutdown_cookie<s(0)(0)(0)>[&];(D1:pbPortAutoLaserShutdown_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortLoopback_cookie<s(0)(0)(0)>[&];(D1:pbPortLoopback_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFecMode_cookie<s(0)(0)(0)>[&];(D1:pbFecMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbActualPortType_cookie<s(0)(0)(0)>[&];(D1:pbActualPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbImpedance_cookie<s(0)(0)(0)>[&];(D1:pbImpedance_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCodeType_cookie<s(0)(0)(0)>[&];(D1:pbCodeType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbHaulType_cookie<s(0)(0)(0)>[&];(D1:pbHaulType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRetimingStatus_cookie<s(0)(0)(0)>[&];(D1:pbRetimingStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortAlsMode_cookie<s(0)(0)(0)>[&];(D1:pbPortAlsMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortAlarmDisable_cookie<s(0)(0)(0)>[&];(D1:pbPortAlarmDisable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] expectedFrameStructure_cookie<s(0)(0)(0)>[&];(D1:expectedFrameStructure_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] crcMultiframeDetector_cookie<s(0)(0)(0)>[&];(D1:crcMultiframeDetector_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] portClassification_cookie<s(0)(0)(0)>[&];(D1:portClassification_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] portUsageStatus_cookie<s(0)(0)(0)>[&];(D1:portUsageStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] portMappingString_cookie<s(0)(0)(0)>[&];(D1:portMappingString_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] portOperationLock_cookie<s(0)(0)(0)>[&];(D1:portOperationLock_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbActiveAlarmTable_cookie<s(0)(0)(0)>[&];(D1:pbActiveAlarmTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAlarmTypeCfgTable_cookie<s(0)(0)(0)>[&];(D1:pbAlarmTypeCfgTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCurrentEventsTable_cookie<s(0)(0)(0)>[&];(D1:pbCurrentEventsTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEventTypeCfgTable_cookie<s(0)(0)(0)>[&];(D1:pbEventTypeCfgTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLogSizeGroup_cookie<s(0)(0)(0)>[&];(D1:pbLogSizeGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] alarmPersistentTime_cookie<s(0)(0)(0)>[&];(D1:alarmPersistentTime_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] logPolicyGroup_cookie<s(0)(0)(0)>[&];(D1:logPolicyGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAlarmStatGroup_cookie<s(0)(0)(0)>[&];(D1:pbAlarmStatGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLogClearGroup_cookie<s(0)(0)(0)>[&];(D1:pbLogClearGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbClearAlarmLog_cookie<s(0)(0)(0)>[&];(D1:pbClearAlarmLog_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbClearEventsLog_cookie<s(0)(0)(0)>[&];(D1:pbClearEventsLog_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbNumberOfCriticalAlarms_cookie<s(0)(0)(0)>[&];(D1:pbNumberOfCriticalAlarms_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbNumberOfMajorAlarms_cookie<s(0)(0)(0)>[&];(D1:pbNumberOfMajorAlarms_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbNumberOfMinorAlarms_cookie<s(0)(0)(0)>[&];(D1:pbNumberOfMinorAlarms_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbNumberOfWarningAlarms_cookie<s(0)(0)(0)>[&];(D1:pbNumberOfWarningAlarms_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbNumberOfIndeterminateAlarms_cookie<s(0)(0)(0)>[&];(D1:pbNumberOfIndeterminateAlarms_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbNumberOfEvents_cookie<s(0)(0)(0)>[&];(D1:pbNumberOfEvents_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] eventLogPolicy_cookie<s(0)(0)(0)>[&];(D1:eventLogPolicy_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] alarmDetectionPersistentTime_cookie<s(0)(0)(0)>[&];(D1:alarmDetectionPersistentTime_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] alarmClearingPersistentTime_cookie<s(0)(0)(0)>[&];(D1:alarmClearingPersistentTime_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAlarmLogSize_cookie<s(0)(0)(0)>[&];(D1:pbAlarmLogSize_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEventLogSize_cookie<s(0)(0)(0)>[&];(D1:pbEventLogSize_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEventTypeID_cookie<s(0)(0)(0)>[&];(D1:pbEventTypeID_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEventTypeCategory_cookie<s(0)(0)(0)>[&];(D1:pbEventTypeCategory_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEventTypeName_cookie<s(0)(0)(0)>[&];(D1:pbEventTypeName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEventTypeSendTrap_cookie<s(0)(0)(0)>[&];(D1:pbEventTypeSendTrap_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCurrentEventIndex_cookie<s(0)(0)(0)>[&];(D1:pbCurrentEventIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCurrentEventID_cookie<s(0)(0)(0)>[&];(D1:pbCurrentEventID_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCurrentEventDTS_cookie<s(0)(0)(0)>[&];(D1:pbCurrentEventDTS_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCurrentEventName_cookie<s(0)(0)(0)>[&];(D1:pbCurrentEventName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCurrentEventCategory_cookie<s(0)(0)(0)>[&];(D1:pbCurrentEventCategory_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCurrentEventDetails_cookie<s(0)(0)(0)>[&];(D1:pbCurrentEventDetails_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAlarmTypeID_cookie<s(0)(0)(0)>[&];(D1:pbAlarmTypeID_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAlarmTypeCode_cookie<s(0)(0)(0)>[&];(D1:pbAlarmTypeCode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAlarmTypeDesc_cookie<s(0)(0)(0)>[&];(D1:pbAlarmTypeDesc_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAlarmTypeCategory_cookie<s(0)(0)(0)>[&];(D1:pbAlarmTypeCategory_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAlarmTypeSeverity_cookie<s(0)(0)(0)>[&];(D1:pbAlarmTypeSeverity_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAlarmTypeInhibit_cookie<s(0)(0)(0)>[&];(D1:pbAlarmTypeInhibit_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAlarmTypeMDO1_cookie<s(0)(0)(0)>[&];(D1:pbAlarmTypeMDO1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAlarmTypeMDO2_cookie<s(0)(0)(0)>[&];(D1:pbAlarmTypeMDO2_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAlarmTypeTrapID_cookie<s(0)(0)(0)>[&];(D1:pbAlarmTypeTrapID_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAlarmTypeMDO3_cookie<s(0)(0)(0)>[&];(D1:pbAlarmTypeMDO3_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAlarmTypeMDO4_cookie<s(0)(0)(0)>[&];(D1:pbAlarmTypeMDO4_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAlmClassID_cookie<s(0)(0)(0)>[&];(D1:pbAlmClassID_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAlarmTypeMDO5_cookie<s(0)(0)(0)>[&];(D1:pbAlarmTypeMDO5_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAlarmTypeMDO6_cookie<s(0)(0)(0)>[&];(D1:pbAlarmTypeMDO6_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAlarmTypeMDO7_cookie<s(0)(0)(0)>[&];(D1:pbAlarmTypeMDO7_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAlarmTypeMDO8_cookie<s(0)(0)(0)>[&];(D1:pbAlarmTypeMDO8_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbActiveAlarmIndex_cookie<s(0)(0)(0)>[&];(D1:pbActiveAlarmIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbActiveAlarmCode_cookie<s(0)(0)(0)>[&];(D1:pbActiveAlarmCode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbActiveAlarmSeverity_cookie<s(0)(0)(0)>[&];(D1:pbActiveAlarmSeverity_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbActiveAlarmSource_cookie<s(0)(0)(0)>[&];(D1:pbActiveAlarmSource_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbActiveAlarmDTS_cookie<s(0)(0)(0)>[&];(D1:pbActiveAlarmDTS_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbActiveAlarmClearDTS_cookie<s(0)(0)(0)>[&];(D1:pbActiveAlarmClearDTS_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbActiveAlarmSlotNum_cookie<s(0)(0)(0)>[&];(D1:pbActiveAlarmSlotNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbActiveAlarmPortNum_cookie<s(0)(0)(0)>[&];(D1:pbActiveAlarmPortNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbActiveAlarmPortType_cookie<s(0)(0)(0)>[&];(D1:pbActiveAlarmPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbActiveAlarmDesc_cookie<s(0)(0)(0)>[&];(D1:pbActiveAlarmDesc_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbActiveAlarmTypeID_cookie<s(0)(0)(0)>[&];(D1:pbActiveAlarmTypeID_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbActiveAlarmCategory_cookie<s(0)(0)(0)>[&];(D1:pbActiveAlarmCategory_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbActiveAlarmPathType_cookie<s(0)(0)(0)>[&];(D1:pbActiveAlarmPathType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbActiveAlarmSeqNum_cookie<s(0)(0)(0)>[&];(D1:pbActiveAlarmSeqNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbActiveAlarmAcknowledge_cookie<s(0)(0)(0)>[&];(D1:pbActiveAlarmAcknowledge_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbActiveAlarmState_cookie<s(0)(0)(0)>[&];(D1:pbActiveAlarmState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbActiveAlarmBoardStyle_cookie<s(0)(0)(0)>[&];(D1:pbActiveAlarmBoardStyle_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbActiveAlarmActualPortType_cookie<s(0)(0)(0)>[&];(D1:pbActiveAlarmActualPortType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] addressGroup_cookie<s(0)(0)(0)>[&];(D1:addressGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] systemGroup_cookie<s(0)(0)(0)>[&];(D1:systemGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ledGroup_cookie<s(0)(0)(0)>[&];(D1:ledGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotTable_cookie<s(0)(0)(0)>[&];(D1:pbSlotTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMibSaveRestoreGroup_cookie<s(0)(0)(0)>[&];(D1:pbMibSaveRestoreGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbInterfaceGroup_cookie<s(0)(0)(0)>[&];(D1:pbInterfaceGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUpgradeGroup_cookie<s(0)(0)(0)>[&];(D1:pbUpgradeGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbConfigCmndGroup_cookie<s(0)(0)(0)>[&];(D1:pbConfigCmndGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbStatsGroup_cookie<s(0)(0)(0)>[&];(D1:pbStatsGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] alarmGroup_cookie<s(0)(0)(0)>[&];(D1:alarmGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbNodeGroup_cookie<s(0)(0)(0)>[&];(D1:pbNodeGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] nodeControlGroup_cookie<s(0)(0)(0)>[&];(D1:nodeControlGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ntpGroup_cookie<s(0)(0)(0)>[&];(D1:ntpGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDateTimeStampGroup_cookie<s(0)(0)(0)>[&];(D1:pbDateTimeStampGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCFCardGroup_cookie<s(0)(0)(0)>[&];(D1:pbCFCardGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] flashSpaceGroup_cookie<s(0)(0)(0)>[&];(D1:flashSpaceGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbExtensionShelfTable_cookie<s(0)(0)(0)>[&];(D1:pbExtensionShelfTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] nodePropertyGroup_cookie<s(0)(0)(0)>[&];(D1:nodePropertyGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] eowFunctionGroup_cookie<s(0)(0)(0)>[&];(D1:eowFunctionGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] gmplsLicenseGroup_cookie<s(0)(0)(0)>[&];(D1:gmplsLicenseGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] e2romConfigGroup_cookie<s(0)(0)(0)>[&];(D1:e2romConfigGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] systemMonitorGroup_cookie<s(0)(0)(0)>[&];(D1:systemMonitorGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] cpuUtilEventGroup_cookie<s(0)(0)(0)>[&];(D1:cpuUtilEventGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] memUtilEventGroup_cookie<s(0)(0)(0)>[&];(D1:memUtilEventGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] cfCardUtilEventGroup_cookie<s(0)(0)(0)>[&];(D1:cfCardUtilEventGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] flashUtilEventGroup_cookie<s(0)(0)(0)>[&];(D1:flashUtilEventGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] flashUtilThreshold_cookie<s(0)(0)(0)>[&];(D1:flashUtilThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] flashUtilEventEnable_cookie<s(0)(0)(0)>[&];(D1:flashUtilEventEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] cfCardUtilThreshold_cookie<s(0)(0)(0)>[&];(D1:cfCardUtilThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] cfCardUtilEventEnable_cookie<s(0)(0)(0)>[&];(D1:cfCardUtilEventEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] memUtilThreshold_cookie<s(0)(0)(0)>[&];(D1:memUtilThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] memUtilEventEnable_cookie<s(0)(0)(0)>[&];(D1:memUtilEventEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] cpuUtilThreshold_cookie<s(0)(0)(0)>[&];(D1:cpuUtilThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] cpuUtilEventEnable_cookie<s(0)(0)(0)>[&];(D1:cpuUtilEventEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbE2RomConfigTable_cookie<s(0)(0)(0)>[&];(D1:pbE2RomConfigTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbE2RomPageNo_cookie<s(0)(0)(0)>[&];(D1:pbE2RomPageNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbE2RomTlvData_cookie<s(0)(0)(0)>[&];(D1:pbE2RomTlvData_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] gmplsLicenseStatus_cookie<s(0)(0)(0)>[&];(D1:gmplsLicenseStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] gmplsLicenseSyncFlag_cookie<s(0)(0)(0)>[&];(D1:gmplsLicenseSyncFlag_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] eowOhccTable_cookie<s(0)(0)(0)>[&];(D1:eowOhccTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] siGlobalTable_cookie<s(0)(0)(0)>[&];(D1:siGlobalTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] siChannelManageTable_cookie<s(0)(0)(0)>[&];(D1:siChannelManageTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifIdx_cookie<s(0)(0)(0)>[&];(D1:ifIdx_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] siChannelID_cookie<s(0)(0)(0)>[&];(D1:siChannelID_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] siChannelGroup_cookie<s(0)(0)(0)>[&];(D1:siChannelGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] siChannelName_cookie<s(0)(0)(0)>[&];(D1:siChannelName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] siChannelEnable_cookie<s(0)(0)(0)>[&];(D1:siChannelEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] siChannelNoiseDetect_cookie<s(0)(0)(0)>[&];(D1:siChannelNoiseDetect_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] siChannelNoiseState_cookie<s(0)(0)(0)>[&];(D1:siChannelNoiseState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] siChannelRingManage_cookie<s(0)(0)(0)>[&];(D1:siChannelRingManage_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] siChannelRingManageState_cookie<s(0)(0)(0)>[&];(D1:siChannelRingManageState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] siChannelRingManageDelta_cookie<s(0)(0)(0)>[&];(D1:siChannelRingManageDelta_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] siChannelRingManageSwitch_cookie<s(0)(0)(0)>[&];(D1:siChannelRingManageSwitch_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] siChannelGroupSetting_cookie<s(0)(0)(0)>[&];(D1:siChannelGroupSetting_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifIdx_cookie<s(0)(0)(0)>[&];(D1:ifIdx_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] siName_cookie<s(0)(0)(0)>[&];(D1:siName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] siPhoneNum_cookie<s(0)(0)(0)>[&];(D1:siPhoneNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] siClipper_cookie<s(0)(0)(0)>[&];(D1:siClipper_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] siEnsThreshold_cookie<s(0)(0)(0)>[&];(D1:siEnsThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] siErmThreshold_cookie<s(0)(0)(0)>[&];(D1:siErmThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] siErmAtt_cookie<s(0)(0)(0)>[&];(D1:siErmAtt_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] siErmStep_cookie<s(0)(0)(0)>[&];(D1:siErmStep_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] siWorkingMode_cookie<s(0)(0)(0)>[&];(D1:siWorkingMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] siUpdateDsp_cookie<s(0)(0)(0)>[&];(D1:siUpdateDsp_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] siUpdateDspState_cookie<s(0)(0)(0)>[&];(D1:siUpdateDspState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] eowOhccDestination_cookie<s(0)(0)(0)>[&];(D1:eowOhccDestination_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] eowOhccSource_cookie<s(0)(0)(0)>[&];(D1:eowOhccSource_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] eowOhccRingManaged_cookie<s(0)(0)(0)>[&];(D1:eowOhccRingManaged_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] nodeHoccCapability_cookie<s(0)(0)(0)>[&];(D1:nodeHoccCapability_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] nodeLoccCapability_cookie<s(0)(0)(0)>[&];(D1:nodeLoccCapability_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbExtensionShelfID_cookie<s(0)(0)(0)>[&];(D1:pbExtensionShelfID_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMainShelfIP_cookie<s(0)(0)(0)>[&];(D1:pbMainShelfIP_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMainShelfReadString_cookie<s(0)(0)(0)>[&];(D1:pbMainShelfReadString_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMainShelfWriteString_cookie<s(0)(0)(0)>[&];(D1:pbMainShelfWriteString_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMainShelfSlot_cookie<s(0)(0)(0)>[&];(D1:pbMainShelfSlot_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMainShelfPort_cookie<s(0)(0)(0)>[&];(D1:pbMainShelfPort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbExtesionShelfIP_cookie<s(0)(0)(0)>[&];(D1:pbExtesionShelfIP_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbExtesionShelfReadString_cookie<s(0)(0)(0)>[&];(D1:pbExtesionShelfReadString_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbExtesionShelfWriteString_cookie<s(0)(0)(0)>[&];(D1:pbExtesionShelfWriteString_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbExtesionShelfSlot_cookie<s(0)(0)(0)>[&];(D1:pbExtesionShelfSlot_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbExtesionShelfPort_cookie<s(0)(0)(0)>[&];(D1:pbExtesionShelfPort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbExtesionShelfLabel_cookie<s(0)(0)(0)>[&];(D1:pbExtesionShelfLabel_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbExtesionShelfDesc_cookie<s(0)(0)(0)>[&];(D1:pbExtesionShelfDesc_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbExtesionShelfRowStatus_cookie<s(0)(0)(0)>[&];(D1:pbExtesionShelfRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] boardFlashFreeSpace_cookie<s(0)(0)(0)>[&];(D1:boardFlashFreeSpace_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] cfCardFreeSpace_cookie<s(0)(0)(0)>[&];(D1:cfCardFreeSpace_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCFCardStatus_cookie<s(0)(0)(0)>[&];(D1:pbCFCardStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCFCardMIBValidity_cookie<s(0)(0)(0)>[&];(D1:pbCFCardMIBValidity_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbStandbyCFCardStatus_cookie<s(0)(0)(0)>[&];(D1:pbStandbyCFCardStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDateTimeStampSet_cookie<s(0)(0)(0)>[&];(D1:pbDateTimeStampSet_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDateTimeStampGet_cookie<s(0)(0)(0)>[&];(D1:pbDateTimeStampGet_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTimeZone_cookie<s(0)(0)(0)>[&];(D1:pbTimeZone_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbNTPEnabled_cookie<s(0)(0)(0)>[&];(D1:pbNTPEnabled_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbNTPIpAddress_cookie<s(0)(0)(0)>[&];(D1:pbNTPIpAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbNTPRequestPeriods_cookie<s(0)(0)(0)>[&];(D1:pbNTPRequestPeriods_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbWarmRebootNode_cookie<s(0)(0)(0)>[&];(D1:pbWarmRebootNode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbColdRebootNode_cookie<s(0)(0)(0)>[&];(D1:pbColdRebootNode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbResetNode_cookie<s(0)(0)(0)>[&];(D1:pbResetNode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbNodeShutDown_cookie<s(0)(0)(0)>[&];(D1:pbNodeShutDown_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbNodePowerOff_cookie<s(0)(0)(0)>[&];(D1:pbNodePowerOff_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbNodeType_cookie<s(0)(0)(0)>[&];(D1:pbNodeType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbNodeSoftwareVersion_cookie<s(0)(0)(0)>[&];(D1:pbNodeSoftwareVersion_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbNodeIntSoftwareVersion_cookie<s(0)(0)(0)>[&];(D1:pbNodeIntSoftwareVersion_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDatabaseVersion_cookie<s(0)(0)(0)>[&];(D1:pbDatabaseVersion_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbNodeAlarmEnabling_cookie<s(0)(0)(0)>[&];(D1:pbNodeAlarmEnabling_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAISEnabled_cookie<s(0)(0)(0)>[&];(D1:pbAISEnabled_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRDIEnabled_cookie<s(0)(0)(0)>[&];(D1:pbRDIEnabled_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAlarmSuppress_cookie<s(0)(0)(0)>[&];(D1:pbAlarmSuppress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAlarmCutOff_cookie<s(0)(0)(0)>[&];(D1:pbAlarmCutOff_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbACOGroup_cookie<s(0)(0)(0)>[&];(D1:pbACOGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIoaTable_cookie<s(0)(0)(0)>[&];(D1:pbIoaTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDataExcDegTpNum_cookie<s(0)(0)(0)>[&];(D1:pbDataExcDegTpNum_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] alarmRuleSwitchGroup_cookie<s(0)(0)(0)>[&];(D1:alarmRuleSwitchGroup_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSEFEnabled_cookie<s(0)(0)(0)>[&];(D1:pbSEFEnabled_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] lofMonitoringSwitch_cookie<s(0)(0)(0)>[&];(D1:lofMonitoringSwitch_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] lomMonitoringSwitch_cookie<s(0)(0)(0)>[&];(D1:lomMonitoringSwitch_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] lopMonitoringSwitch_cookie<s(0)(0)(0)>[&];(D1:lopMonitoringSwitch_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIoaIndexNo_cookie<s(0)(0)(0)>[&];(D1:pbIoaIndexNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIoaLabel_cookie<s(0)(0)(0)>[&];(D1:pbIoaLabel_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIoaEnableStatus_cookie<s(0)(0)(0)>[&];(D1:pbIoaEnableStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIoaStatus_cookie<s(0)(0)(0)>[&];(D1:pbIoaStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAudibleACO_cookie<s(0)(0)(0)>[&];(D1:pbAudibleACO_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbVisualACO_cookie<s(0)(0)(0)>[&];(D1:pbVisualACO_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbExtAudible_cookie<s(0)(0)(0)>[&];(D1:pbExtAudible_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbExtVisual_cookie<s(0)(0)(0)>[&];(D1:pbExtVisual_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbNumberOfReboots_cookie<s(0)(0)(0)>[&];(D1:pbNumberOfReboots_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbNodeDownDTS_cookie<s(0)(0)(0)>[&];(D1:pbNodeDownDTS_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] nodeMibCmnd_cookie<s(0)(0)(0)>[&];(D1:nodeMibCmnd_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] nodeMibCmndState_cookie<s(0)(0)(0)>[&];(D1:nodeMibCmndState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] nodeMibCmndCancel_cookie<s(0)(0)(0)>[&];(D1:nodeMibCmndCancel_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] nodeMibNmsOperateArea_cookie<s(0)(0)(0)>[&];(D1:nodeMibNmsOperateArea_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] nodeMibUpDownLoadStatus_cookie<s(0)(0)(0)>[&];(D1:nodeMibUpDownLoadStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] nodeMibLastCommand_cookie<s(0)(0)(0)>[&];(D1:nodeMibLastCommand_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] nodeMibFailedIndex_cookie<s(0)(0)(0)>[&];(D1:nodeMibFailedIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbBackupMIBState_cookie<s(0)(0)(0)>[&];(D1:pbBackupMIBState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMIBOperationDateTimeStamp_cookie<s(0)(0)(0)>[&];(D1:pbMIBOperationDateTimeStamp_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] nodeMIBFilesNoCheck_cookie<s(0)(0)(0)>[&];(D1:nodeMIBFilesNoCheck_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUpgradeCurrRelease_cookie<s(0)(0)(0)>[&];(D1:pbUpgradeCurrRelease_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUpgradeBackupRelease_cookie<s(0)(0)(0)>[&];(D1:pbUpgradeBackupRelease_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUpgradeHostIP_cookie<s(0)(0)(0)>[&];(D1:pbUpgradeHostIP_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUpgradeHostUsername_cookie<s(0)(0)(0)>[&];(D1:pbUpgradeHostUsername_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUpgradeHostPassword_cookie<s(0)(0)(0)>[&];(D1:pbUpgradeHostPassword_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUpgradeHostFileName_cookie<s(0)(0)(0)>[&];(D1:pbUpgradeHostFileName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUpgradeCommand_cookie<s(0)(0)(0)>[&];(D1:pbUpgradeCommand_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUpgradeCmndState_cookie<s(0)(0)(0)>[&];(D1:pbUpgradeCmndState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUpgradeStateDescr_cookie<s(0)(0)(0)>[&];(D1:pbUpgradeStateDescr_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbUpgradeLoadCancel_cookie<s(0)(0)(0)>[&];(D1:pbUpgradeLoadCancel_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] nodeUpgradeLastCommand_cookie<s(0)(0)(0)>[&];(D1:nodeUpgradeLastCommand_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] nodeUpgradeFailedIndex_cookie<s(0)(0)(0)>[&];(D1:nodeUpgradeFailedIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] nodeUpgradeSwitchPhySlot_cookie<s(0)(0)(0)>[&];(D1:nodeUpgradeSwitchPhySlot_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] upgradeSoftwareInfoTable_cookie<s(0)(0)(0)>[&];(D1:upgradeSoftwareInfoTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] upgradeSoftwareSlotNumber_cookie<s(0)(0)(0)>[&];(D1:upgradeSoftwareSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] upgradeSoftwareIndication_cookie<s(0)(0)(0)>[&];(D1:upgradeSoftwareIndication_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] upgradeSoftwareRole_cookie<s(0)(0)(0)>[&];(D1:upgradeSoftwareRole_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] upgradeSoftwareName_cookie<s(0)(0)(0)>[&];(D1:upgradeSoftwareName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] upgradeSoftwareDatetime_cookie<s(0)(0)(0)>[&];(D1:upgradeSoftwareDatetime_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPhysicalAdjacencyTable_cookie<s(0)(0)(0)>[&];(D1:pbPhysicalAdjacencyTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAutoLinkStarted_cookie<s(0)(0)(0)>[&];(D1:pbAutoLinkStarted_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAutoLinkTable_cookie<s(0)(0)(0)>[&];(D1:pbAutoLinkTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLocalSlot_cookie<s(0)(0)(0)>[&];(D1:pbLocalSlot_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLocalPort_cookie<s(0)(0)(0)>[&];(D1:pbLocalPort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRemoteIPAddress_cookie<s(0)(0)(0)>[&];(D1:pbRemoteIPAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRemoteSlot_cookie<s(0)(0)(0)>[&];(D1:pbRemoteSlot_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRemotePort_cookie<s(0)(0)(0)>[&];(D1:pbRemotePort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLocalSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbLocalSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLocalPortNumber_cookie<s(0)(0)(0)>[&];(D1:pbLocalPortNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRemoteNodeMolnAdjacencyStatus_cookie<s(0)(0)(0)>[&];(D1:pbRemoteNodeMolnAdjacencyStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRemoteNodeIPAddress_cookie<s(0)(0)(0)>[&];(D1:pbRemoteNodeIPAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRemoteSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbRemoteSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRemotePortNumber_cookie<s(0)(0)(0)>[&];(D1:pbRemotePortNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLinkOperationalStatus_cookie<s(0)(0)(0)>[&];(D1:pbLinkOperationalStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbInterfaceDescr_cookie<s(0)(0)(0)>[&];(D1:pbInterfaceDescr_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLinkGeneralType_cookie<s(0)(0)(0)>[&];(D1:pbLinkGeneralType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLinkRowStatus_cookie<s(0)(0)(0)>[&];(D1:pbLinkRowStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAutoSaver_cookie<s(0)(0)(0)>[&];(D1:pbAutoSaver_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAutoSaverFirstTimer_cookie<s(0)(0)(0)>[&];(D1:pbAutoSaverFirstTimer_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbAutoSaverLastTimer_cookie<s(0)(0)(0)>[&];(D1:pbAutoSaverLastTimer_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbConfigType_cookie<s(0)(0)(0)>[&];(D1:pbConfigType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSaveMib_cookie<s(0)(0)(0)>[&];(D1:pbSaveMib_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbClearMibSet_cookie<s(0)(0)(0)>[&];(D1:pbClearMibSet_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotType_cookie<s(0)(0)(0)>[&];(D1:pbSlotType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbBoardType_cookie<s(0)(0)(0)>[&];(D1:pbBoardType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbBoardFunction_cookie<s(0)(0)(0)>[&];(D1:pbBoardFunction_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCardState_cookie<s(0)(0)(0)>[&];(D1:pbCardState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCardDesiredState_cookie<s(0)(0)(0)>[&];(D1:pbCardDesiredState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNumberDisplay_cookie<s(0)(0)(0)>[&];(D1:pbSlotNumberDisplay_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotReset_cookie<s(0)(0)(0)>[&];(D1:pbSlotReset_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotNoFailuresTotal_cookie<s(0)(0)(0)>[&];(D1:pbSlotNoFailuresTotal_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotResetNoFailures_cookie<s(0)(0)(0)>[&];(D1:pbSlotResetNoFailures_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotResetDuration_cookie<s(0)(0)(0)>[&];(D1:pbSlotResetDuration_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotName_cookie<s(0)(0)(0)>[&];(D1:pbSlotName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotDescr_cookie<s(0)(0)(0)>[&];(D1:pbSlotDescr_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotIfCardDumb_cookie<s(0)(0)(0)>[&];(D1:pbSlotIfCardDumb_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotCrashDumpAvail_cookie<s(0)(0)(0)>[&];(D1:pbSlotCrashDumpAvail_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotLastBoardType_cookie<s(0)(0)(0)>[&];(D1:pbSlotLastBoardType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotBoardTypeDifference_cookie<s(0)(0)(0)>[&];(D1:pbSlotBoardTypeDifference_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotExplicitDeletion_cookie<s(0)(0)(0)>[&];(D1:pbSlotExplicitDeletion_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbProvisionedCardType_cookie<s(0)(0)(0)>[&];(D1:pbProvisionedCardType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotCardSpecificInfo_cookie<s(0)(0)(0)>[&];(D1:pbSlotCardSpecificInfo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotTemperatureThreshold_cookie<s(0)(0)(0)>[&];(D1:pbSlotTemperatureThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotTemperatureHysteresis_cookie<s(0)(0)(0)>[&];(D1:pbSlotTemperatureHysteresis_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotTemperatureCleanThreshold_cookie<s(0)(0)(0)>[&];(D1:pbSlotTemperatureCleanThreshold_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotLastBoardFunction_cookie<s(0)(0)(0)>[&];(D1:pbSlotLastBoardFunction_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDiagMode_cookie<s(0)(0)(0)>[&];(D1:pbDiagMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDiagActive_cookie<s(0)(0)(0)>[&];(D1:pbDiagActive_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLogicalSlotNumber_cookie<s(0)(0)(0)>[&];(D1:pbLogicalSlotNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotDisable_cookie<s(0)(0)(0)>[&];(D1:pbSlotDisable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbForceResetSlot_cookie<s(0)(0)(0)>[&];(D1:pbForceResetSlot_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotFailureLedColor_cookie<s(0)(0)(0)>[&];(D1:pbSlotFailureLedColor_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotActiveLedColor_cookie<s(0)(0)(0)>[&];(D1:pbSlotActiveLedColor_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbBoardSerialNumber_cookie<s(0)(0)(0)>[&];(D1:pbBoardSerialNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbBoardOption_cookie<s(0)(0)(0)>[&];(D1:pbBoardOption_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbCode_cookie<s(0)(0)(0)>[&];(D1:pbCode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLatchState_cookie<s(0)(0)(0)>[&];(D1:pbLatchState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlotAlarmDisable_cookie<s(0)(0)(0)>[&];(D1:pbSlotAlarmDisable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] provisionedCardFunction_cookie<s(0)(0)(0)>[&];(D1:provisionedCardFunction_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] slotConfigOption_cookie<s(0)(0)(0)>[&];(D1:slotConfigOption_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] cardSoftwareVersion_cookie<s(0)(0)(0)>[&];(D1:cardSoftwareVersion_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] cardBootVersion_cookie<s(0)(0)(0)>[&];(D1:cardBootVersion_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] cardBootDatetime_cookie<s(0)(0)(0)>[&];(D1:cardBootDatetime_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] cardHardwareVersion_cookie<s(0)(0)(0)>[&];(D1:cardHardwareVersion_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] cardFusionVersion_cookie<s(0)(0)(0)>[&];(D1:cardFusionVersion_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] cardFpgaVersion_cookie<s(0)(0)(0)>[&];(D1:cardFpgaVersion_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] macAddress_cookie<s(0)(0)(0)>[&];(D1:macAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] slotMaxDCCNumber_cookie<s(0)(0)(0)>[&];(D1:slotMaxDCCNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] slotMapValue_cookie<s(0)(0)(0)>[&];(D1:slotMapValue_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLedTest_cookie<s(0)(0)(0)>[&];(D1:pbLedTest_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLedTable_cookie<s(0)(0)(0)>[&];(D1:pbLedTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLedSlotNo_cookie<s(0)(0)(0)>[&];(D1:pbLedSlotNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLedIndexNo_cookie<s(0)(0)(0)>[&];(D1:pbLedIndexNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLedLabel_cookie<s(0)(0)(0)>[&];(D1:pbLedLabel_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLedColor_cookie<s(0)(0)(0)>[&];(D1:pbLedColor_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMode_cookie<s(0)(0)(0)>[&];(D1:pbMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLabel_cookie<s(0)(0)(0)>[&];(D1:pbLabel_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbLocation_cookie<s(0)(0)(0)>[&];(D1:pbLocation_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDescription_cookie<s(0)(0)(0)>[&];(D1:pbDescription_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbContact_cookie<s(0)(0)(0)>[&];(D1:pbContact_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSerialNumber_cookie<s(0)(0)(0)>[&];(D1:pbSerialNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRelease_cookie<s(0)(0)(0)>[&];(D1:pbRelease_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbBootImageVersion_cookie<s(0)(0)(0)>[&];(D1:pbBootImageVersion_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbBackplaneHwVersion_cookie<s(0)(0)(0)>[&];(D1:pbBackplaneHwVersion_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbBackplaneCode_cookie<s(0)(0)(0)>[&];(D1:pbBackplaneCode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIpAddress_cookie<s(0)(0)(0)>[&];(D1:pbIpAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIpMask_cookie<s(0)(0)(0)>[&];(D1:pbIpMask_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGatewayAddress_cookie<s(0)(0)(0)>[&];(D1:pbGatewayAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthernetAddress_cookie<s(0)(0)(0)>[&];(D1:pbEthernetAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthernetMask_cookie<s(0)(0)(0)>[&];(D1:pbEthernetMask_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSystemMacAddress_cookie<s(0)(0)(0)>[&];(D1:pbSystemMacAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSlaveEthernetAddress_cookie<s(0)(0)(0)>[&];(D1:pbSlaveEthernetAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthernetAddressSecondary_cookie<s(0)(0)(0)>[&];(D1:pbEthernetAddressSecondary_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthernetMaskSecondary_cookie<s(0)(0)(0)>[&];(D1:pbEthernetMaskSecondary_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthernetEnable_cookie<s(0)(0)(0)>[&];(D1:pbEthernetEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGMPLSIPAddress_cookie<s(0)(0)(0)>[&];(D1:pbGMPLSIPAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGMPLSIPMask_cookie<s(0)(0)(0)>[&];(D1:pbGMPLSIPMask_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMgmtPort1Status_cookie<s(0)(0)(0)>[&];(D1:pbMgmtPort1Status_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbMgmtPort2Status_cookie<s(0)(0)(0)>[&];(D1:pbMgmtPort2Status_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] enterpriseModules_cookie<s(0)(0)(0)>[&];(D1:enterpriseModules_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] enterpriseNetworkingProducts_cookie<s(0)(0)(0)>[&];(D1:enterpriseNetworkingProducts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] product1Reg_cookie<s(0)(0)(0)>[&];(D1:product1Reg_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] enterpriseGlobalRegModule_cookie<s(0)(0)(0)>[&];(D1:enterpriseGlobalRegModule_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] productSeries1MibModule_cookie<s(0)(0)(0)>[&];(D1:productSeries1MibModule_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSecurityModule_cookie<s(0)(0)(0)>[&];(D1:pbSecurityModule_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEventsModule_cookie<s(0)(0)(0)>[&];(D1:pbEventsModule_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSonetModule_cookie<s(0)(0)(0)>[&];(D1:pbSonetModule_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] enterpriseGlobalTCModule_cookie<s(0)(0)(0)>[&];(D1:enterpriseGlobalTCModule_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] enterpriseOAModule_cookie<s(0)(0)(0)>[&];(D1:enterpriseOAModule_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSDHProtectionModule_cookie<s(0)(0)(0)>[&];(D1:pbSDHProtectionModule_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] enterpriseRstpMIB_cookie<s(0)(0)(0)>[&];(D1:enterpriseRstpMIB_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbEthernetModule_cookie<s(0)(0)(0)>[&];(D1:pbEthernetModule_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbTMSModule_cookie<s(0)(0)(0)>[&];(D1:pbTMSModule_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXCContextModule_cookie<s(0)(0)(0)>[&];(D1:pbXCContextModule_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbXCModule_cookie<s(0)(0)(0)>[&];(D1:pbXCModule_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbSonetSDHPMModule_cookie<s(0)(0)(0)>[&];(D1:pbSonetSDHPMModule_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbNodeModule_cookie<s(0)(0)(0)>[&];(D1:pbNodeModule_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbRprModule_cookie<s(0)(0)(0)>[&];(D1:pbRprModule_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDccModule_cookie<s(0)(0)(0)>[&];(D1:pbDccModule_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGvrpModule_cookie<s(0)(0)(0)>[&];(D1:pbGvrpModule_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbOsiModule_cookie<s(0)(0)(0)>[&];(D1:pbOsiModule_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIpTunnelModule_cookie<s(0)(0)(0)>[&];(D1:pbIpTunnelModule_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] enterpriseMstpMIB_cookie<s(0)(0)(0)>[&];(D1:enterpriseMstpMIB_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] enterpriseEOSModule_cookie<s(0)(0)(0)>[&];(D1:enterpriseEOSModule_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbGmrpModule_cookie<s(0)(0)(0)>[&];(D1:pbGmrpModule_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPrivateManagement_cookie<s(0)(0)(0)>[&];(D1:pbPrivateManagement_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] mib_2_cookie<s(0)(0)(0)>[&];(D1:mib_2_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] system_cookie<s(0)(0)(0)>[&];(D1:system_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] at_cookie<s(0)(0)(0)>[&];(D1:at_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] interfaces_cookie<s(0)(0)(0)>[&];(D1:interfaces_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ip_cookie<s(0)(0)(0)>[&];(D1:ip_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] icmp_cookie<s(0)(0)(0)>[&];(D1:icmp_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tcp_cookie<s(0)(0)(0)>[&];(D1:tcp_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] udp_cookie<s(0)(0)(0)>[&];(D1:udp_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] egp_cookie<s(0)(0)(0)>[&];(D1:egp_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] transmission_cookie<s(0)(0)(0)>[&];(D1:transmission_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmp_cookie<s(0)(0)(0)>[&];(D1:snmp_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ianaifType_cookie<s(0)(0)(0)>[&];(D1:ianaifType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifMIB_cookie<s(0)(0)(0)>[&];(D1:ifMIB_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxMIB_cookie<s(0)(0)(0)>[&];(D1:agentxMIB_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxObjects_cookie<s(0)(0)(0)>[&];(D1:agentxObjects_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxConformance_cookie<s(0)(0)(0)>[&];(D1:agentxConformance_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxMIBGroups_cookie<s(0)(0)(0)>[&];(D1:agentxMIBGroups_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxMIBCompliances_cookie<s(0)(0)(0)>[&];(D1:agentxMIBCompliances_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxGeneral_cookie<s(0)(0)(0)>[&];(D1:agentxGeneral_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxConnection_cookie<s(0)(0)(0)>[&];(D1:agentxConnection_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxSession_cookie<s(0)(0)(0)>[&];(D1:agentxSession_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxRegistration_cookie<s(0)(0)(0)>[&];(D1:agentxRegistration_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxRegistrationTableLastChange_cookie<s(0)(0)(0)>[&];(D1:agentxRegistrationTableLastChange_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxRegistrationTable_cookie<s(0)(0)(0)>[&];(D1:agentxRegistrationTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxConnIndex_cookie<s(0)(0)(0)>[&];(D1:agentxConnIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxSessionIndex_cookie<s(0)(0)(0)>[&];(D1:agentxSessionIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxRegIndex_cookie<s(0)(0)(0)>[&];(D1:agentxRegIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxRegContext_cookie<s(0)(0)(0)>[&];(D1:agentxRegContext_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxRegStart_cookie<s(0)(0)(0)>[&];(D1:agentxRegStart_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxRegRangeSubId_cookie<s(0)(0)(0)>[&];(D1:agentxRegRangeSubId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxRegUpperBound_cookie<s(0)(0)(0)>[&];(D1:agentxRegUpperBound_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxRegPriority_cookie<s(0)(0)(0)>[&];(D1:agentxRegPriority_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxRegTimeout_cookie<s(0)(0)(0)>[&];(D1:agentxRegTimeout_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxRegInstance_cookie<s(0)(0)(0)>[&];(D1:agentxRegInstance_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxSessionTableLastChange_cookie<s(0)(0)(0)>[&];(D1:agentxSessionTableLastChange_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxSessionTable_cookie<s(0)(0)(0)>[&];(D1:agentxSessionTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxConnIndex_cookie<s(0)(0)(0)>[&];(D1:agentxConnIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxSessionIndex_cookie<s(0)(0)(0)>[&];(D1:agentxSessionIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxSessionObjectID_cookie<s(0)(0)(0)>[&];(D1:agentxSessionObjectID_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxSessionDescr_cookie<s(0)(0)(0)>[&];(D1:agentxSessionDescr_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxSessionAdminStatus_cookie<s(0)(0)(0)>[&];(D1:agentxSessionAdminStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxSessionOpenTime_cookie<s(0)(0)(0)>[&];(D1:agentxSessionOpenTime_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxSessionAgentXVer_cookie<s(0)(0)(0)>[&];(D1:agentxSessionAgentXVer_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxSessionTimeout_cookie<s(0)(0)(0)>[&];(D1:agentxSessionTimeout_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxConnTableLastChange_cookie<s(0)(0)(0)>[&];(D1:agentxConnTableLastChange_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxConnectionTable_cookie<s(0)(0)(0)>[&];(D1:agentxConnectionTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxConnIndex_cookie<s(0)(0)(0)>[&];(D1:agentxConnIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxConnOpenTime_cookie<s(0)(0)(0)>[&];(D1:agentxConnOpenTime_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxConnTransportDomain_cookie<s(0)(0)(0)>[&];(D1:agentxConnTransportDomain_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxConnTransportAddress_cookie<s(0)(0)(0)>[&];(D1:agentxConnTransportAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxDefaultTimeout_cookie<s(0)(0)(0)>[&];(D1:agentxDefaultTimeout_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] agentxMasterAgentXVer_cookie<s(0)(0)(0)>[&];(D1:agentxMasterAgentXVer_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifMIBObjects_cookie<s(0)(0)(0)>[&];(D1:ifMIBObjects_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifConformance_cookie<s(0)(0)(0)>[&];(D1:ifConformance_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifGroups_cookie<s(0)(0)(0)>[&];(D1:ifGroups_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifCompliances_cookie<s(0)(0)(0)>[&];(D1:ifCompliances_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifXTable_cookie<s(0)(0)(0)>[&];(D1:ifXTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifTableLastChange_cookie<s(0)(0)(0)>[&];(D1:ifTableLastChange_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifTestTable_cookie<s(0)(0)(0)>[&];(D1:ifTestTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifRcvAddressTable_cookie<s(0)(0)(0)>[&];(D1:ifRcvAddressTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifStackTable_cookie<s(0)(0)(0)>[&];(D1:ifStackTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifStackLastChange_cookie<s(0)(0)(0)>[&];(D1:ifStackLastChange_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifStackHigherLayer_cookie<s(0)(0)(0)>[&];(D1:ifStackHigherLayer_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifStackLowerLayer_cookie<s(0)(0)(0)>[&];(D1:ifStackLowerLayer_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifStackStatus_cookie<s(0)(0)(0)>[&];(D1:ifStackStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifIndex_cookie<s(0)(0)(0)>[&];(D1:ifIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifRcvAddressAddress_cookie<s(0)(0)(0)>[&];(D1:ifRcvAddressAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifRcvAddressStatus_cookie<s(0)(0)(0)>[&];(D1:ifRcvAddressStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifRcvAddressType_cookie<s(0)(0)(0)>[&];(D1:ifRcvAddressType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifIndex_cookie<s(0)(0)(0)>[&];(D1:ifIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifTestId_cookie<s(0)(0)(0)>[&];(D1:ifTestId_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifTestStatus_cookie<s(0)(0)(0)>[&];(D1:ifTestStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifTestType_cookie<s(0)(0)(0)>[&];(D1:ifTestType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifTestResult_cookie<s(0)(0)(0)>[&];(D1:ifTestResult_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifTestCode_cookie<s(0)(0)(0)>[&];(D1:ifTestCode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifTestOwner_cookie<s(0)(0)(0)>[&];(D1:ifTestOwner_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifIndex_cookie<s(0)(0)(0)>[&];(D1:ifIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifName_cookie<s(0)(0)(0)>[&];(D1:ifName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifInMulticastPkts_cookie<s(0)(0)(0)>[&];(D1:ifInMulticastPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifInBroadcastPkts_cookie<s(0)(0)(0)>[&];(D1:ifInBroadcastPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifOutMulticastPkts_cookie<s(0)(0)(0)>[&];(D1:ifOutMulticastPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifOutBroadcastPkts_cookie<s(0)(0)(0)>[&];(D1:ifOutBroadcastPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifHCInOctets_cookie<s(0)(0)(0)>[&];(D1:ifHCInOctets_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifHCInUcastPkts_cookie<s(0)(0)(0)>[&];(D1:ifHCInUcastPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifHCInMulticastPkts_cookie<s(0)(0)(0)>[&];(D1:ifHCInMulticastPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifHCInBroadcastPkts_cookie<s(0)(0)(0)>[&];(D1:ifHCInBroadcastPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifHCOutOctets_cookie<s(0)(0)(0)>[&];(D1:ifHCOutOctets_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifHCOutUcastPkts_cookie<s(0)(0)(0)>[&];(D1:ifHCOutUcastPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifHCOutMulticastPkts_cookie<s(0)(0)(0)>[&];(D1:ifHCOutMulticastPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifHCOutBroadcastPkts_cookie<s(0)(0)(0)>[&];(D1:ifHCOutBroadcastPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifLinkUpDownTrapEnable_cookie<s(0)(0)(0)>[&];(D1:ifLinkUpDownTrapEnable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifHighSpeed_cookie<s(0)(0)(0)>[&];(D1:ifHighSpeed_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifPromiscuousMode_cookie<s(0)(0)(0)>[&];(D1:ifPromiscuousMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifConnectorPresent_cookie<s(0)(0)(0)>[&];(D1:ifConnectorPresent_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifAlias_cookie<s(0)(0)(0)>[&];(D1:ifAlias_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifCounterDiscontinuityTime_cookie<s(0)(0)(0)>[&];(D1:ifCounterDiscontinuityTime_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpInPkts_cookie<s(0)(0)(0)>[&];(D1:snmpInPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpInBadVersions_cookie<s(0)(0)(0)>[&];(D1:snmpInBadVersions_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpOutPkts_cookie<s(0)(0)(0)>[&];(D1:snmpOutPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpInBadCommunityNames_cookie<s(0)(0)(0)>[&];(D1:snmpInBadCommunityNames_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpInBadCommunityUses_cookie<s(0)(0)(0)>[&];(D1:snmpInBadCommunityUses_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpInASNParseErrs_cookie<s(0)(0)(0)>[&];(D1:snmpInASNParseErrs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpEnableAuthenTraps_cookie<s(0)(0)(0)>[&];(D1:snmpEnableAuthenTraps_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpOutTraps_cookie<s(0)(0)(0)>[&];(D1:snmpOutTraps_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpOutGetResponses_cookie<s(0)(0)(0)>[&];(D1:snmpOutGetResponses_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpOutSetRequests_cookie<s(0)(0)(0)>[&];(D1:snmpOutSetRequests_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpOutGetNexts_cookie<s(0)(0)(0)>[&];(D1:snmpOutGetNexts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpOutGetRequests_cookie<s(0)(0)(0)>[&];(D1:snmpOutGetRequests_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpOutGenErrs_cookie<s(0)(0)(0)>[&];(D1:snmpOutGenErrs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpOutBadValues_cookie<s(0)(0)(0)>[&];(D1:snmpOutBadValues_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpOutNoSuchNames_cookie<s(0)(0)(0)>[&];(D1:snmpOutNoSuchNames_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpOutTooBigs_cookie<s(0)(0)(0)>[&];(D1:snmpOutTooBigs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpInTraps_cookie<s(0)(0)(0)>[&];(D1:snmpInTraps_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpInGetResponses_cookie<s(0)(0)(0)>[&];(D1:snmpInGetResponses_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpInSetRequests_cookie<s(0)(0)(0)>[&];(D1:snmpInSetRequests_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpInGetNexts_cookie<s(0)(0)(0)>[&];(D1:snmpInGetNexts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpInGetRequests_cookie<s(0)(0)(0)>[&];(D1:snmpInGetRequests_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpInTotalSetVars_cookie<s(0)(0)(0)>[&];(D1:snmpInTotalSetVars_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpInTotalReqVars_cookie<s(0)(0)(0)>[&];(D1:snmpInTotalReqVars_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpInGenErrs_cookie<s(0)(0)(0)>[&];(D1:snmpInGenErrs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpInReadOnlys_cookie<s(0)(0)(0)>[&];(D1:snmpInReadOnlys_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpInBadValues_cookie<s(0)(0)(0)>[&];(D1:snmpInBadValues_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpInNoSuchNames_cookie<s(0)(0)(0)>[&];(D1:snmpInNoSuchNames_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpInTooBigs_cookie<s(0)(0)(0)>[&];(D1:snmpInTooBigs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpSilentDrops_cookie<s(0)(0)(0)>[&];(D1:snmpSilentDrops_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] snmpProxyDrops_cookie<s(0)(0)(0)>[&];(D1:snmpProxyDrops_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] egpInMsgs_cookie<s(0)(0)(0)>[&];(D1:egpInMsgs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] egpInErrors_cookie<s(0)(0)(0)>[&];(D1:egpInErrors_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] egpOutMsgs_cookie<s(0)(0)(0)>[&];(D1:egpOutMsgs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] egpOutErrors_cookie<s(0)(0)(0)>[&];(D1:egpOutErrors_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] egpNeighTable_cookie<s(0)(0)(0)>[&];(D1:egpNeighTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] egpAs_cookie<s(0)(0)(0)>[&];(D1:egpAs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] egpNeighAddr_cookie<s(0)(0)(0)>[&];(D1:egpNeighAddr_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] egpNeighState_cookie<s(0)(0)(0)>[&];(D1:egpNeighState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] egpNeighAs_cookie<s(0)(0)(0)>[&];(D1:egpNeighAs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] egpNeighInMsgs_cookie<s(0)(0)(0)>[&];(D1:egpNeighInMsgs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] egpNeighInErrs_cookie<s(0)(0)(0)>[&];(D1:egpNeighInErrs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] egpNeighOutMsgs_cookie<s(0)(0)(0)>[&];(D1:egpNeighOutMsgs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] egpNeighOutErrs_cookie<s(0)(0)(0)>[&];(D1:egpNeighOutErrs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] egpNeighInErrMsgs_cookie<s(0)(0)(0)>[&];(D1:egpNeighInErrMsgs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] egpNeighOutErrMsgs_cookie<s(0)(0)(0)>[&];(D1:egpNeighOutErrMsgs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] egpNeighStateUps_cookie<s(0)(0)(0)>[&];(D1:egpNeighStateUps_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] egpNeighStateDowns_cookie<s(0)(0)(0)>[&];(D1:egpNeighStateDowns_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] egpNeighIntervalHello_cookie<s(0)(0)(0)>[&];(D1:egpNeighIntervalHello_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] egpNeighIntervalPoll_cookie<s(0)(0)(0)>[&];(D1:egpNeighIntervalPoll_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] egpNeighMode_cookie<s(0)(0)(0)>[&];(D1:egpNeighMode_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] egpNeighEventTrigger_cookie<s(0)(0)(0)>[&];(D1:egpNeighEventTrigger_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] udpInDatagrams_cookie<s(0)(0)(0)>[&];(D1:udpInDatagrams_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] udpNoPorts_cookie<s(0)(0)(0)>[&];(D1:udpNoPorts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] udpInErrors_cookie<s(0)(0)(0)>[&];(D1:udpInErrors_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] udpOutDatagrams_cookie<s(0)(0)(0)>[&];(D1:udpOutDatagrams_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] udpTable_cookie<s(0)(0)(0)>[&];(D1:udpTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] udpLocalAddress_cookie<s(0)(0)(0)>[&];(D1:udpLocalAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] udpLocalPort_cookie<s(0)(0)(0)>[&];(D1:udpLocalPort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tcpRtoAlgorithm_cookie<s(0)(0)(0)>[&];(D1:tcpRtoAlgorithm_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tcpRtoMin_cookie<s(0)(0)(0)>[&];(D1:tcpRtoMin_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tcpRtoMax_cookie<s(0)(0)(0)>[&];(D1:tcpRtoMax_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tcpMaxConn_cookie<s(0)(0)(0)>[&];(D1:tcpMaxConn_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tcpActiveOpens_cookie<s(0)(0)(0)>[&];(D1:tcpActiveOpens_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tcpPassiveOpens_cookie<s(0)(0)(0)>[&];(D1:tcpPassiveOpens_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tcpAttemptFails_cookie<s(0)(0)(0)>[&];(D1:tcpAttemptFails_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tcpEstabResets_cookie<s(0)(0)(0)>[&];(D1:tcpEstabResets_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tcpCurrEstab_cookie<s(0)(0)(0)>[&];(D1:tcpCurrEstab_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tcpInSegs_cookie<s(0)(0)(0)>[&];(D1:tcpInSegs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tcpOutSegs_cookie<s(0)(0)(0)>[&];(D1:tcpOutSegs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tcpRetransSegs_cookie<s(0)(0)(0)>[&];(D1:tcpRetransSegs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tcpConnTable_cookie<s(0)(0)(0)>[&];(D1:tcpConnTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tcpInErrs_cookie<s(0)(0)(0)>[&];(D1:tcpInErrs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tcpOutRsts_cookie<s(0)(0)(0)>[&];(D1:tcpOutRsts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tcpConnLocalAddress_cookie<s(0)(0)(0)>[&];(D1:tcpConnLocalAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tcpConnLocalPort_cookie<s(0)(0)(0)>[&];(D1:tcpConnLocalPort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tcpConnRemAddress_cookie<s(0)(0)(0)>[&];(D1:tcpConnRemAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tcpConnRemPort_cookie<s(0)(0)(0)>[&];(D1:tcpConnRemPort_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] tcpConnState_cookie<s(0)(0)(0)>[&];(D1:tcpConnState_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] icmpInMsgs_cookie<s(0)(0)(0)>[&];(D1:icmpInMsgs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] icmpInErrors_cookie<s(0)(0)(0)>[&];(D1:icmpInErrors_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] icmpInDestUnreachs_cookie<s(0)(0)(0)>[&];(D1:icmpInDestUnreachs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] icmpInTimeExcds_cookie<s(0)(0)(0)>[&];(D1:icmpInTimeExcds_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] icmpInParmProbs_cookie<s(0)(0)(0)>[&];(D1:icmpInParmProbs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] icmpInSrcQuenchs_cookie<s(0)(0)(0)>[&];(D1:icmpInSrcQuenchs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] icmpInRedirects_cookie<s(0)(0)(0)>[&];(D1:icmpInRedirects_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] icmpInEchos_cookie<s(0)(0)(0)>[&];(D1:icmpInEchos_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] icmpInEchoReps_cookie<s(0)(0)(0)>[&];(D1:icmpInEchoReps_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] icmpInTimestamps_cookie<s(0)(0)(0)>[&];(D1:icmpInTimestamps_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] icmpInTimestampReps_cookie<s(0)(0)(0)>[&];(D1:icmpInTimestampReps_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] icmpInAddrMasks_cookie<s(0)(0)(0)>[&];(D1:icmpInAddrMasks_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] icmpInAddrMaskReps_cookie<s(0)(0)(0)>[&];(D1:icmpInAddrMaskReps_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] icmpOutMsgs_cookie<s(0)(0)(0)>[&];(D1:icmpOutMsgs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] icmpOutErrors_cookie<s(0)(0)(0)>[&];(D1:icmpOutErrors_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] icmpOutDestUnreachs_cookie<s(0)(0)(0)>[&];(D1:icmpOutDestUnreachs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] icmpOutTimeExcds_cookie<s(0)(0)(0)>[&];(D1:icmpOutTimeExcds_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] icmpOutParmProbs_cookie<s(0)(0)(0)>[&];(D1:icmpOutParmProbs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] icmpOutSrcQuenchs_cookie<s(0)(0)(0)>[&];(D1:icmpOutSrcQuenchs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] icmpOutRedirects_cookie<s(0)(0)(0)>[&];(D1:icmpOutRedirects_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] icmpOutEchos_cookie<s(0)(0)(0)>[&];(D1:icmpOutEchos_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] icmpOutEchoReps_cookie<s(0)(0)(0)>[&];(D1:icmpOutEchoReps_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] icmpOutTimestamps_cookie<s(0)(0)(0)>[&];(D1:icmpOutTimestamps_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] icmpOutTimestampReps_cookie<s(0)(0)(0)>[&];(D1:icmpOutTimestampReps_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] icmpOutAddrMasks_cookie<s(0)(0)(0)>[&];(D1:icmpOutAddrMasks_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] icmpOutAddrMaskReps_cookie<s(0)(0)(0)>[&];(D1:icmpOutAddrMaskReps_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipForwarding_cookie<s(0)(0)(0)>[&];(D1:ipForwarding_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipDefaultTTL_cookie<s(0)(0)(0)>[&];(D1:ipDefaultTTL_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipInReceives_cookie<s(0)(0)(0)>[&];(D1:ipInReceives_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipInHdrErrors_cookie<s(0)(0)(0)>[&];(D1:ipInHdrErrors_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipInAddrErrors_cookie<s(0)(0)(0)>[&];(D1:ipInAddrErrors_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipForwDatagrams_cookie<s(0)(0)(0)>[&];(D1:ipForwDatagrams_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipInUnknownProtos_cookie<s(0)(0)(0)>[&];(D1:ipInUnknownProtos_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipInDiscards_cookie<s(0)(0)(0)>[&];(D1:ipInDiscards_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipInDelivers_cookie<s(0)(0)(0)>[&];(D1:ipInDelivers_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipOutRequests_cookie<s(0)(0)(0)>[&];(D1:ipOutRequests_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipOutDiscards_cookie<s(0)(0)(0)>[&];(D1:ipOutDiscards_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipOutNoRoutes_cookie<s(0)(0)(0)>[&];(D1:ipOutNoRoutes_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipReasmTimeout_cookie<s(0)(0)(0)>[&];(D1:ipReasmTimeout_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipReasmReqds_cookie<s(0)(0)(0)>[&];(D1:ipReasmReqds_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipReasmOKs_cookie<s(0)(0)(0)>[&];(D1:ipReasmOKs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipReasmFails_cookie<s(0)(0)(0)>[&];(D1:ipReasmFails_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipFragOKs_cookie<s(0)(0)(0)>[&];(D1:ipFragOKs_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipFragFails_cookie<s(0)(0)(0)>[&];(D1:ipFragFails_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipFragCreates_cookie<s(0)(0)(0)>[&];(D1:ipFragCreates_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipAddrTable_cookie<s(0)(0)(0)>[&];(D1:ipAddrTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipRouteTable_cookie<s(0)(0)(0)>[&];(D1:ipRouteTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipNetToMediaTable_cookie<s(0)(0)(0)>[&];(D1:ipNetToMediaTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipRoutingDiscards_cookie<s(0)(0)(0)>[&];(D1:ipRoutingDiscards_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipNetToMediaIfIndex_cookie<s(0)(0)(0)>[&];(D1:ipNetToMediaIfIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipNetToMediaNetAddress_cookie<s(0)(0)(0)>[&];(D1:ipNetToMediaNetAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipNetToMediaPhysAddress_cookie<s(0)(0)(0)>[&];(D1:ipNetToMediaPhysAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipNetToMediaType_cookie<s(0)(0)(0)>[&];(D1:ipNetToMediaType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipRouteDest_cookie<s(0)(0)(0)>[&];(D1:ipRouteDest_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipRouteIfIndex_cookie<s(0)(0)(0)>[&];(D1:ipRouteIfIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipRouteMetric1_cookie<s(0)(0)(0)>[&];(D1:ipRouteMetric1_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipRouteMetric2_cookie<s(0)(0)(0)>[&];(D1:ipRouteMetric2_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipRouteMetric3_cookie<s(0)(0)(0)>[&];(D1:ipRouteMetric3_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipRouteMetric4_cookie<s(0)(0)(0)>[&];(D1:ipRouteMetric4_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipRouteNextHop_cookie<s(0)(0)(0)>[&];(D1:ipRouteNextHop_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipRouteType_cookie<s(0)(0)(0)>[&];(D1:ipRouteType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipRouteProto_cookie<s(0)(0)(0)>[&];(D1:ipRouteProto_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipRouteAge_cookie<s(0)(0)(0)>[&];(D1:ipRouteAge_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipRouteMask_cookie<s(0)(0)(0)>[&];(D1:ipRouteMask_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipRouteMetric5_cookie<s(0)(0)(0)>[&];(D1:ipRouteMetric5_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipRouteInfo_cookie<s(0)(0)(0)>[&];(D1:ipRouteInfo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipAdEntAddr_cookie<s(0)(0)(0)>[&];(D1:ipAdEntAddr_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipAdEntIfIndex_cookie<s(0)(0)(0)>[&];(D1:ipAdEntIfIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipAdEntNetMask_cookie<s(0)(0)(0)>[&];(D1:ipAdEntNetMask_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipAdEntBcastAddr_cookie<s(0)(0)(0)>[&];(D1:ipAdEntBcastAddr_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ipAdEntReasmMaxSize_cookie<s(0)(0)(0)>[&];(D1:ipAdEntReasmMaxSize_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifNumber_cookie<s(0)(0)(0)>[&];(D1:ifNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifTable_cookie<s(0)(0)(0)>[&];(D1:ifTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifIndex_cookie<s(0)(0)(0)>[&];(D1:ifIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifDescr_cookie<s(0)(0)(0)>[&];(D1:ifDescr_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifType_cookie<s(0)(0)(0)>[&];(D1:ifType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifMtu_cookie<s(0)(0)(0)>[&];(D1:ifMtu_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifSpeed_cookie<s(0)(0)(0)>[&];(D1:ifSpeed_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifPhysAddress_cookie<s(0)(0)(0)>[&];(D1:ifPhysAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifAdminStatus_cookie<s(0)(0)(0)>[&];(D1:ifAdminStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifOperStatus_cookie<s(0)(0)(0)>[&];(D1:ifOperStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifLastChange_cookie<s(0)(0)(0)>[&];(D1:ifLastChange_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifInOctets_cookie<s(0)(0)(0)>[&];(D1:ifInOctets_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifInUcastPkts_cookie<s(0)(0)(0)>[&];(D1:ifInUcastPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifInNUcastPkts_cookie<s(0)(0)(0)>[&];(D1:ifInNUcastPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifInDiscards_cookie<s(0)(0)(0)>[&];(D1:ifInDiscards_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifInErrors_cookie<s(0)(0)(0)>[&];(D1:ifInErrors_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifInUnknownProtos_cookie<s(0)(0)(0)>[&];(D1:ifInUnknownProtos_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifOutOctets_cookie<s(0)(0)(0)>[&];(D1:ifOutOctets_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifOutUcastPkts_cookie<s(0)(0)(0)>[&];(D1:ifOutUcastPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifOutNUcastPkts_cookie<s(0)(0)(0)>[&];(D1:ifOutNUcastPkts_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifOutDiscards_cookie<s(0)(0)(0)>[&];(D1:ifOutDiscards_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifOutErrors_cookie<s(0)(0)(0)>[&];(D1:ifOutErrors_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifOutQLen_cookie<s(0)(0)(0)>[&];(D1:ifOutQLen_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] ifSpecific_cookie<s(0)(0)(0)>[&];(D1:ifSpecific_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] atTable_cookie<s(0)(0)(0)>[&];(D1:atTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] atIfIndex_cookie<s(0)(0)(0)>[&];(D1:atIfIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] atNetAddress_cookie<s(0)(0)(0)>[&];(D1:atNetAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] atPhysAddress_cookie<s(0)(0)(0)>[&];(D1:atPhysAddress_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] sysDescr_cookie<s(0)(0)(0)>[&];(D1:sysDescr_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] sysObjectID_cookie<s(0)(0)(0)>[&];(D1:sysObjectID_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] sysUpTime_cookie<s(0)(0)(0)>[&];(D1:sysUpTime_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] sysContact_cookie<s(0)(0)(0)>[&];(D1:sysContact_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] sysName_cookie<s(0)(0)(0)>[&];(D1:sysName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] sysLocation_cookie<s(0)(0)(0)>[&];(D1:sysLocation_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] sysServices_cookie<s(0)(0)(0)>[&];(D1:sysServices_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] sysORLastChange_cookie<s(0)(0)(0)>[&];(D1:sysORLastChange_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] sysORTable_cookie<s(0)(0)(0)>[&];(D1:sysORTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] sysORIndex_cookie<s(0)(0)(0)>[&];(D1:sysORIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] sysORID_cookie<s(0)(0)(0)>[&];(D1:sysORID_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] sysORDescr_cookie<s(0)(0)(0)>[&];(D1:sysORDescr_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] sysORUpTime_cookie<s(0)(0)(0)>[&];(D1:sysORUpTime_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] applTable_cookie<s(0)(0)(0)>[&];(D1:applTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] aapplTable_cookie<s(0)(0)(0)>[&];(D1:aapplTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] bootpTable_cookie<s(0)(0)(0)>[&];(D1:bootpTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIntVcTable_cookie<s(0)(0)(0)>[&];(D1:pbIntVcTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFileSystemTable_cookie<s(0)(0)(0)>[&];(D1:pbFileSystemTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDivaMTable_cookie<s(0)(0)(0)>[&];(D1:pbDivaMTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] moduleTable_cookie<s(0)(0)(0)>[&];(D1:moduleTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] applTableVer_cookie<s(0)(0)(0)>[&];(D1:applTableVer_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortLedsTable_cookie<s(0)(0)(0)>[&];(D1:pbPortLedsTable_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortLedProxySlot_cookie<s(0)(0)(0)>[&];(D1:pbPortLedProxySlot_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortLedSlot_cookie<s(0)(0)(0)>[&];(D1:pbPortLedSlot_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortLedIndexNo_cookie<s(0)(0)(0)>[&];(D1:pbPortLedIndexNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbPortLedColor_cookie<s(0)(0)(0)>[&];(D1:pbPortLedColor_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] moduleIndex_cookie<s(0)(0)(0)>[&];(D1:moduleIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] moduleBoardFunction_cookie<s(0)(0)(0)>[&];(D1:moduleBoardFunction_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] moduleBoardProperty_cookie<s(0)(0)(0)>[&];(D1:moduleBoardProperty_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] moduleBoardStyle_cookie<s(0)(0)(0)>[&];(D1:moduleBoardStyle_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] moduleChassisType_cookie<s(0)(0)(0)>[&];(D1:moduleChassisType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] moduleName_cookie<s(0)(0)(0)>[&];(D1:moduleName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] moduleFname_cookie<s(0)(0)(0)>[&];(D1:moduleFname_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] moduleStart_cookie<s(0)(0)(0)>[&];(D1:moduleStart_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] moduleInit_cookie<s(0)(0)(0)>[&];(D1:moduleInit_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDivaMslotno_cookie<s(0)(0)(0)>[&];(D1:pbDivaMslotno_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDivaMportno_cookie<s(0)(0)(0)>[&];(D1:pbDivaMportno_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbDivaMmetric_cookie<s(0)(0)(0)>[&];(D1:pbDivaMmetric_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFileDir_cookie<s(0)(0)(0)>[&];(D1:pbFileDir_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFileName_cookie<s(0)(0)(0)>[&];(D1:pbFileName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFileSize_cookie<s(0)(0)(0)>[&];(D1:pbFileSize_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbFileSlot_cookie<s(0)(0)(0)>[&];(D1:pbFileSlot_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIntVcLocalIntf_cookie<s(0)(0)(0)>[&];(D1:pbIntVcLocalIntf_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIntVcLocalVpi_cookie<s(0)(0)(0)>[&];(D1:pbIntVcLocalVpi_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIntVcLocalVci_cookie<s(0)(0)(0)>[&];(D1:pbIntVcLocalVci_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIntVcRemoteIntf_cookie<s(0)(0)(0)>[&];(D1:pbIntVcRemoteIntf_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIntVcRemoteVpi_cookie<s(0)(0)(0)>[&];(D1:pbIntVcRemoteVpi_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] pbIntVcRemoteVci_cookie<s(0)(0)(0)>[&];(D1:pbIntVcRemoteVci_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] bootpBoardType_cookie<s(0)(0)(0)>[&];(D1:bootpBoardType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] bootpFname_cookie<s(0)(0)(0)>[&];(D1:bootpFname_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] aapplSlotNo_cookie<s(0)(0)(0)>[&];(D1:aapplSlotNo_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] aapplNumber_cookie<s(0)(0)(0)>[&];(D1:aapplNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] aapplName_cookie<s(0)(0)(0)>[&];(D1:aapplName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] aapplCpuUsage_cookie<s(0)(0)(0)>[&];(D1:aapplCpuUsage_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] aapplLogLevels_cookie<s(0)(0)(0)>[&];(D1:aapplLogLevels_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] aapplOptions_cookie<s(0)(0)(0)>[&];(D1:aapplOptions_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] aapplStatus_cookie<s(0)(0)(0)>[&];(D1:aapplStatus_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] aapplLoadOrder_cookie<s(0)(0)(0)>[&];(D1:aapplLoadOrder_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] applIndex_cookie<s(0)(0)(0)>[&];(D1:applIndex_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] applBoardFunction_cookie<s(0)(0)(0)>[&];(D1:applBoardFunction_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] applBoardProperty_cookie<s(0)(0)(0)>[&];(D1:applBoardProperty_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] applBoardStyle_cookie<s(0)(0)(0)>[&];(D1:applBoardStyle_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] applChassisType_cookie<s(0)(0)(0)>[&];(D1:applChassisType_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] applName_cookie<s(0)(0)(0)>[&];(D1:applName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] applNumber_cookie<s(0)(0)(0)>[&];(D1:applNumber_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] applFname_cookie<s(0)(0)(0)>[&];(D1:applFname_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] applEntryfn_cookie<s(0)(0)(0)>[&];(D1:applEntryfn_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] applTaskName_cookie<s(0)(0)(0)>[&];(D1:applTaskName_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] applTaskPri_cookie<s(0)(0)(0)>[&];(D1:applTaskPri_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] applTaskStack_cookie<s(0)(0)(0)>[&];(D1:applTaskStack_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] applLogLevels_cookie<s(0)(0)(0)>[&];(D1:applLogLevels_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] applOptions_cookie<s(0)(0)(0)>[&];(D1:applOptions_cookie:0)
extern LeafInfo<s(0)(0)(0)>[T] applStart_cookie<s(0)(0)(0)>[&];(D1:applStart_cookie:0)




 




















































































































































































































































































































































                                                         



 























































































































































































































































































































 





















































































































































































































































































































typedef enum
{
    FMA_ALM_CLEAR<s(0)(0)(0)>[&] = 0,
    FMA_ALM_SET<s(0)(0)(0)>[&] = 1
}                       FMA_ALM_STATE<s(0)(0)(0)>[&];(D1:FMA_ALM_STATE:1)[[TYPENAME:FMA_ALM_STATE]]

typedef struct
{
    unsigned int    entity<s(1)(1)(0)>[&];
    unsigned int    instance<s(1)(1)(0)>[&];
    HW_PORT_TYPE<s(1)(1)(0)>[T]    portType<s(1)(1)(0)>[&];
    SDH_TP_TYPE<s(1)(1)(0)>[T]     tpType<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]          e<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]          d<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]          c<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]          b<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]          a<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]          k<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]          l<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]          m<s(1)(1)(0)>[&];    
} FM_TP_PATH_T<s(0)(0)(0)>[&];(D1:FM_TP_PATH_T:1)[[TYPENAME:FM_TP_PATH_T]]

typedef struct {
    BOOL<s(1)(1)(0)>[T] phyPathValid<s(1)(1)(0)>[&];                      
    BOOL<s(1)(1)(0)>[T] realPathValid<s(1)(1)(0)>[&];                     
    BOOL<s(1)(1)(0)>[T] phyPathChanged<s(1)(1)(0)>[&];                    
    BOOL<s(1)(1)(0)>[T] realPathChanged<s(1)(1)(0)>[&];                   
    unsigned int oldRealEntity<s(1)(1)(0)>[&];             
    FM_TP_PATH_T<s(1)(1)(0)>[T] basePath<s(1)(1)(0)>[&];                  
    FM_TP_PATH_T<s(1)(1)(0)>[T] phyPath<s(1)(1)(0)>[&];                   
    FM_TP_PATH_T<s(1)(1)(0)>[T] realPath<s(1)(1)(0)>[&];                  
} FM_PCO_TP_T<s(0)(0)(0)>[&];(D1:FM_PCO_TP_T:1)[[TYPENAME:FM_PCO_TP_T]] 

 


 
typedef unsigned int    FM_AISMODE_T<s(0)(0)(0)>[&];(D1:FM_AISMODE_T:1)[[TYPENAME:FM_AISMODE_T]]



typedef unsigned int    FM_RDIMODE_T<s(0)(0)(0)>[&];(D1:FM_RDIMODE_T:1)[[TYPENAME:FM_RDIMODE_T]]



 










typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*FMA_AlmModDefectFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(FMA_AlmModDefectFunc)(UINT32<s(0)(0)(0)>[T] SlotId<s(0)(0)(0)>[&], INSTANCE_T<s(0)(0)(0)>[T] Instance<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] PortId<s(0)(0)(0)>[&], HW_PORT_TYPE<s(0)(0)(0)>[T] PortType<s(0)(0)(0)>[&], SDH_TP_TYPE<s(0)(0)(0)>[T] TpType<s(0)(0)(0)>[&], COMPACT_TP_T<s(0)(0)(0)>[T] TpIndex<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] DefectId<s(0)(0)(0)>[&], FMA_ALM_STATE<s(0)(0)(0)>[T] state<s(0)(0)(0)>[&]);(D1:state:0)

typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*FMC_AlmModDefectFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(FMC_AlmModDefectFunc)(UINT32<s(0)(0)(0)>[T] SlotId<s(0)(0)(0)>[&], INSTANCE_T<s(0)(0)(0)>[T] Instance<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] PortId<s(0)(0)(0)>[&], HW_PORT_TYPE<s(0)(0)(0)>[T] PortType<s(0)(0)(0)>[&], SDH_TP_TYPE<s(0)(0)(0)>[T] TpType<s(0)(0)(0)>[&], COMPACT_TP_T<s(0)(0)(0)>[T] TpIndex<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] DefectId<s(0)(0)(0)>[&], FMA_ALM_STATE<s(0)(0)(0)>[T] state<s(0)(0)(0)>[&]);(D1:state:0)

typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*FMA_AlmModDefectByBusFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(FMA_AlmModDefectByBusFunc)(UINT16<s(0)(0)(0)>[T] busNo<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] vc4No<s(0)(0)(0)>[&], TU_TP_T<s(0)(0)(0)>[T] tpIndex<s(0)(0)(0)>[&], SDH_TP_TYPE<s(0)(0)(0)>[T] tpType<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] defectId<s(0)(0)(0)>[&], FMA_ALM_STATE<s(0)(0)(0)>[T] state<s(0)(0)(0)>[&]);(D1:state:0)


 






typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T]  (*FMA_GetBusBySlot<s(0)(0)(0)>[&])TYPENAME:FUNC:(FMA_GetBusBySlot)(UINT32<s(0)(0)(0)>[T] slotId<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] portNo<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] portType<s(0)(0)(0)>[&], COMPACT_TP_T<s(0)(0)(0)>[T] tpIndex<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] * pBusNo<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] * pVc4No<s(0)(0)(0)>[&]);(D1:pVc4No:0)

typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T]  (*FMA_GetSlotByBus<s(0)(0)(0)>[&])TYPENAME:FUNC:(FMA_GetSlotByBus)(UINT16<s(0)(0)(0)>[T] busNo<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] vc4No<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] * pSlotId<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] * pPortNo<s(0)(0)(0)>[&],UINT32<s(0)(0)(0)>[T] * pEDCB<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] * pPortType<s(0)(0)(0)>[&]);(D1:pPortType:0)

extern PB_ERROR_CODE_T<s(0)(0)(0)>[T] FMA_RegisterBusBySlot<s(0)(0)(0)>[&](FMA_GetBusBySlot<s(0)(0)(0)>[T] pFmaBusBySlot<s(0)(0)(0)>[&]);(D1:pFmaBusBySlot:0)
extern PB_ERROR_CODE_T<s(0)(0)(0)>[T] FMA_RegisterSlotByBus<s(0)(0)(0)>[&](FMA_GetSlotByBus<s(0)(0)(0)>[T] pFmaSlotByBus<s(0)(0)(0)>[&]);(D1:pFmaSlotByBus:0)





 


































































































 
typedef enum
{
    TMS_SSF_CLEAR<s(0)(0)(0)>[&] = 0,
    TMS_SSF_SET<s(0)(0)(0)>[&] = 1
}TMS_SSF_ACTION<s(0)(0)(0)>[&];(D1:TMS_SSF_ACTION:1)[[TYPENAME:TMS_SSF_ACTION]]


 
typedef void (*TMA_S1ChangeCallbackFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(TMA_S1ChangeCallbackFunc)(UINT32<s(0)(0)(0)>[T] instance<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] port<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] ssmb<s(0)(0)(0)>[&]);(D1:ssmb:0)
extern void TMA_S1ChangeCallback<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] instance<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] port<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] ssmb<s(0)(0)(0)>[&]);(D1:ssmb:0)

 
typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*TMH_InitCCFPGAFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(TMH_InitCCFPGAFunc)(UINT32<s(0)(0)(0)>[T] instance<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] ccstate<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] cardstate<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] warm<s(0)(0)(0)>[&]);(D1:warm:0)
extern PB_ERROR_CODE_T<s(0)(0)(0)>[T] TMH_InitCCFPGA<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] instance<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] ccstate<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] cardstate<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] warm<s(0)(0)(0)>[&]);(D1:warm:0)

 
typedef void (*TMA_ModDefectFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(TMA_ModDefectFunc)(UINT32<s(0)(0)(0)>[T] instance<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] SlotId<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] PortId<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] DefectId<s(0)(0)(0)>[&], TMS_SSF_ACTION<s(0)(0)(0)>[T] state<s(0)(0)(0)>[&]);(D1:state:0)
extern void TMA_SetDefect<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] instance<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] SlotId<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] PortId<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] DefectId<s(0)(0)(0)>[&],TMS_SSF_ACTION<s(0)(0)(0)>[T] state<s(0)(0)(0)>[&]);(D1:state:0)

 
typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*TMH_SwitchHOCCFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(TMH_SwitchHOCCFunc)(BOOL<s(0)(0)(0)>[T] isWorkHOCC<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bCallTmaStep<s(0)(0)(0)>[&]);(D1:bCallTmaStep:0)
extern PB_ERROR_CODE_T<s(0)(0)(0)>[T] TMH_SwitchHOCC<s(0)(0)(0)>[&](BOOL<s(0)(0)(0)>[T] isWorkHOCC<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bCallTmaStep<s(0)(0)(0)>[&]);(D1:bCallTmaStep:0)

extern PB_ERROR_CODE_T<s(0)(0)(0)>[T] TMT_DetectCardState<s(0)(0)(0)>[&](INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] *pbActive<s(0)(0)(0)>[&]);(D1:pbActive:0)
extern PB_ERROR_CODE_T<s(0)(0)(0)>[T] TMT_DeActivateSICard<s(0)(0)(0)>[&] (INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&]);(D1:inst:0)
extern PB_ERROR_CODE_T<s(0)(0)(0)>[T] TMT_ActivateSICard<s(0)(0)(0)>[&] (INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bWarm<s(0)(0)(0)>[&]);(D1:bWarm:0)
extern PB_ERROR_CODE_T<s(0)(0)(0)>[T] TMT_InitSICard<s(0)(0)(0)>[&] (INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulStyle<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulOption<s(0)(0)(0)>[&]);(D1:ulOption:0)
extern void TMI_ReportAlarm<s(0)(0)(0)>[&](FMC_AlmModDefectFunc<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)

typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*TM_RptPLLUnlock<s(0)(0)(0)>[&])TYPENAME:FUNC:(TM_RptPLLUnlock)(SLOT_NUMBER_T<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bUnitFail<s(0)(0)(0)>[&]);(D1:bUnitFail:0)
void TMT_RegRptPLLUnlock<s(0)(0)(0)>[&](FMA_AlmModDefectFunc<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)
void TMH_RegRptPLLUnlock<s(0)(0)(0)>[&](TM_RptPLLUnlock<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)
void TMH_RegReportAlarmFunction<s(0)(0)(0)>[&](FMA_AlmModDefectFunc<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)













  









 
















typedef struct{
    UINT8<s(1)(1)(0)>[T] pbSlotNumber<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T] pbPortNo<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T] portType<s(1)(1)(0)>[&]; 
    TP_INDEX_T<s(1)(1)(0)>[T] tpIndex<s(1)(1)(0)>[&];
}__attribute__ ((packed))  PM_TP_NO_T<s(0)(0)(0)>[&];(D1:PM_TP_NO_T:1)[[TYPENAME:PM_TP_NO_T]]  

typedef struct {
    BOOL<s(1)(1)(0)>[T] bRsBipMon<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] bRsOfsMon<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] bMsBipMon<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] bMsReiMon<s(1)(1)(0)>[&];
}__attribute__ ((packed))  PMA_SOH_MON_T<s(0)(0)(0)>[&];(D1:PMA_SOH_MON_T:1)[[TYPENAME:PMA_SOH_MON_T]]

typedef struct {
    BOOL<s(1)(1)(0)>[T] bHpBipMon<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] bHpReiMon<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] bHpNpjcMon<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] bHpPpjcMon<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] bHpFeNpjcMon<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] bHpFePpjcMon<s(1)(1)(0)>[&];
}__attribute__ ((packed))  PMA_HP_MON_T<s(0)(0)(0)>[&];(D1:PMA_HP_MON_T:1)[[TYPENAME:PMA_HP_MON_T]]

typedef struct {
    BOOL<s(1)(1)(0)>[T] bLpBipMon<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] bLpReiMon<s(1)(1)(0)>[&];
}__attribute__ ((packed))  PMA_LP_MON_T<s(0)(0)(0)>[&];(D1:PMA_LP_MON_T:1)[[TYPENAME:PMA_LP_MON_T]]


typedef struct
{
    UINT8<s(1)(1)(0)>[T]    pbSlotNumber<s(1)(1)(0)>[&];                                 
    INSTANCE_T<s(1)(1)(0)>[T]            instance<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]        pbPortNo<s(1)(1)(0)>[&];                                                 
    UINT32<s(1)(1)(0)>[T] pbEthTableType<s(1)(1)(0)>[&];                                  
    UINT8<s(1)(1)(0)>[T]   pbEthPmPortType<s(1)(1)(0)>[&];                                  
    UINT32<s(1)(1)(0)>[T] pbEthPmMonitor<s(1)(1)(0)>[&];
    char        pbEthPmTimeStart<s(1)(1)(0)>[&][16];
    unsigned int    pbEthPmTimeElapse<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T]            pbEthPmTimeSuspect<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T]            pbEthPmTableReset<s(1)(1)(0)>[&];
    unsigned int    pbEthInUnicastPktsHigh<s(1)(1)(0)>[&];
    unsigned int    pbEthInUnicastPktsLow<s(1)(1)(0)>[&];
    unsigned int    pbEthInMulcastPktsHigh<s(1)(1)(0)>[&];
    unsigned int    pbEthInMulcastPktsLow<s(1)(1)(0)>[&];
    unsigned int    pbEthInBrdcastPktsHigh<s(1)(1)(0)>[&];
    unsigned int    pbEthInBrdcastPktsLow<s(1)(1)(0)>[&];
    unsigned int    pbEthInAllBadPktsHigh<s(1)(1)(0)>[&];
    unsigned int    pbEthInAllBadPktsLow<s(1)(1)(0)>[&];
    unsigned int    pbEthInAllBadBytesHigh<s(1)(1)(0)>[&];
    unsigned int    pbEthInAllBadBytesLow<s(1)(1)(0)>[&];
    unsigned int    pbEthInAllGoodPktsHigh<s(1)(1)(0)>[&];
    unsigned int    pbEthInAllGoodPktsLow<s(1)(1)(0)>[&];
    unsigned int    pbEthInAllGoodBytesHigh<s(1)(1)(0)>[&];
    unsigned int    pbEthInAllGoodBytesLow<s(1)(1)(0)>[&];
    unsigned int    pbEthInOverSizePktsHigh<s(1)(1)(0)>[&];
    unsigned int    pbEthInOverSizePktsLow<s(1)(1)(0)>[&];
    unsigned int    pbEthInUnderSizePktsHigh<s(1)(1)(0)>[&];
    unsigned int    pbEthInUnderSizePktsLow<s(1)(1)(0)>[&];
    unsigned int    pbEthInCRCErrPktsHigh<s(1)(1)(0)>[&];
    unsigned int    pbEthInCRCErrPktsLow<s(1)(1)(0)>[&];
    unsigned int    pbEthOutUnicastPktsHigh<s(1)(1)(0)>[&];
    unsigned int    pbEthOutUnicastPktsLow<s(1)(1)(0)>[&];
    unsigned int    pbEthOutMulcastPktsHigh<s(1)(1)(0)>[&];
    unsigned int    pbEthOutMulcastPktsLow<s(1)(1)(0)>[&];
    unsigned int    pbEthOutBrdcastPktsHigh<s(1)(1)(0)>[&];
    unsigned int    pbEthOutBrdcastPktsLow<s(1)(1)(0)>[&];
    unsigned int    pbEthOutAllGoodPktsHigh<s(1)(1)(0)>[&];
    unsigned int    pbEthOutAllGoodPktsLow<s(1)(1)(0)>[&];
    unsigned int    pbEthOutAllGoodBytesHigh<s(1)(1)(0)>[&];
    unsigned int    pbEthOutAllGoodBytesLow<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]          pbEthBbrEnable<s(1)(1)(0)>[&];
    int        pbEthBbrThresholdValue<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]         pbEthBprEnable<s(1)(1)(0)>[&];
    int        pbEthBprThresholdValue<s(1)(1)(0)>[&];
}__attribute__ ((packed))  ETH_PM_DTAT_T<s(0)(0)(0)>[&];(D1:ETH_PM_DTAT_T:1)[[TYPENAME:ETH_PM_DTAT_T]]  

typedef struct 
{  
    UINT8<s(1)(1)(0)>[T]                      slot<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]                      portType<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]                      actPortType<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]                      portNo<s(1)(1)(0)>[&];
    TP_INDEX_T<s(1)(1)(0)>[T]             tpIndex<s(1)(1)(0)>[&];
}__attribute__ ((packed))  PM_TP_INDEX_T<s(0)(0)(0)>[&];(D1:PM_TP_INDEX_T:1)[[TYPENAME:PM_TP_INDEX_T]]


typedef struct
{
	UINT8<s(1)(1)(0)>[T]			   instance<s(1)(1)(0)>[&];
       UINT8<s(1)(1)(0)>[T]                   slot<s(1)(1)(0)>[&];
       UINT8<s(1)(1)(0)>[T]                   portType<s(1)(1)(0)>[&];                         
       UINT8<s(1)(1)(0)>[T]                   portNo<s(1)(1)(0)>[&];                                  
}__attribute__ ((packed))  PM_ETH_INDEX_T<s(0)(0)(0)>[&];(D1:PM_ETH_INDEX_T:1)[[TYPENAME:PM_ETH_INDEX_T]]

 
typedef struct
{
    UINT8<s(1)(1)(0)>[T]  slot<s(1)(1)(0)>[&];
    int     rprIfIndex<s(1)(1)(0)>[&];
}__attribute__ ((packed))  PM_RPR_CLIENT_INDEX_T<s(0)(0)(0)>[&];(D1:PM_RPR_CLIENT_INDEX_T:1)[[TYPENAME:PM_RPR_CLIENT_INDEX_T]]

typedef struct
{
    UINT8<s(1)(1)(0)>[T]  slot<s(1)(1)(0)>[&];
    int     rprIfIndex<s(1)(1)(0)>[&];
    RprSpan_Tval<s(1)(1)(0)>[T] rprSpanId<s(1)(1)(0)>[&];
}__attribute__ ((packed))  PM_RPR_SPAN_INDEX_T<s(0)(0)(0)>[&];(D1:PM_RPR_SPAN_INDEX_T:1)[[TYPENAME:PM_RPR_SPAN_INDEX_T]]

typedef struct
{
    UINT8<s(1)(1)(0)>[T]         slot<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]         portType<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]         portNo<s(1)(1)(0)>[&];
}__attribute__ ((packed))  PM_PDH_SLIP_INDEX_T<s(0)(0)(0)>[&];(D1:PM_PDH_SLIP_INDEX_T:1)[[TYPENAME:PM_PDH_SLIP_INDEX_T]]

typedef struct
{
    UINT8<s(1)(1)(0)>[T]                 slot<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]                 portType<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]                 portNo<s(1)(1)(0)>[&];
}__attribute__ ((packed))  PM_PDH_INDEX_T<s(0)(0)(0)>[&];(D1:PM_PDH_INDEX_T:1)[[TYPENAME:PM_PDH_INDEX_T]]

typedef struct
{
    UINT8<s(1)(1)(0)>[T]                 slot<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]                 portType<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]                 portNo<s(1)(1)(0)>[&];
}__attribute__ ((packed))  PM_FEC_INDEX_T<s(0)(0)(0)>[&];(D1:PM_FEC_INDEX_T:1)[[TYPENAME:PM_FEC_INDEX_T]]


typedef struct 
{
	 
	

    
     
    UINT32<s(1)(1)(0)>[T]  ethInAllBytes<s(1)(1)(0)>[&]; 
    UINT32<s(1)(1)(0)>[T]  ethInAllPkts<s(1)(1)(0)>[&]; 
    UINT32<s(1)(1)(0)>[T]  ethInAllGoodPkts<s(1)(1)(0)>[&]; 
    UINT32<s(1)(1)(0)>[T]  ethInAllBadPkts<s(1)(1)(0)>[&];  
    UINT32<s(1)(1)(0)>[T]  ethInUnicastPkts<s(1)(1)(0)>[&]; 
    UINT32<s(1)(1)(0)>[T]  ethInMulcastPkts<s(1)(1)(0)>[&]; 
    UINT32<s(1)(1)(0)>[T]  ethInBrdcastPkts<s(1)(1)(0)>[&]; 
    UINT32<s(1)(1)(0)>[T]  ethInDropPkts<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]  ethInUndersizeGoodPkts<s(1)(1)(0)>[&]; 
    UINT32<s(1)(1)(0)>[T]  ethInOversizeGoodPkts<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]  ethIn64Pkts<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]  ethIn65To127Pkts<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]  ethIn128To255Pkts<s(1)(1)(0)>[&]; 
    UINT32<s(1)(1)(0)>[T]  ethIn256To511Pkts<s(1)(1)(0)>[&]; 
    UINT32<s(1)(1)(0)>[T]  ethIn512To1023Pkts<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]  ethIn1024To1518Pkts<s(1)(1)(0)>[&]; 
    UINT32<s(1)(1)(0)>[T]  ethInPausePkts<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]  ethInFragmentPkts<s(1)(1)(0)>[&]; 
    UINT32<s(1)(1)(0)>[T]  ethInJabberPkts<s(1)(1)(0)>[&]; 
    UINT32<s(1)(1)(0)>[T]  ethInAlignmentErrorPkts<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]  ethOutAllBytes<s(1)(1)(0)>[&]; 
    UINT32<s(1)(1)(0)>[T]  ethOutAllPkts<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]  ethOutUnicastPkts<s(1)(1)(0)>[&]; 
    UINT32<s(1)(1)(0)>[T]  ethOutMulcastPkts<s(1)(1)(0)>[&]; 
    UINT32<s(1)(1)(0)>[T]  ethOutBrdcastPkts<s(1)(1)(0)>[&]; 
    UINT32<s(1)(1)(0)>[T]  ethOutGoodPausePkts<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]  ethOutCollisionPkts<s(1)(1)(0)>[&];
}__attribute__ ((packed))  PM_ETH_DATA_T<s(0)(0)(0)>[&];(D1:PM_ETH_DATA_T:1)[[TYPENAME:PM_ETH_DATA_T]]

typedef struct
{
	UINT8<s(1)(1)(0)>[T] 				instance<s(1)(1)(0)>[&];
         UINT8<s(1)(1)(0)>[T]                slot<s(1)(1)(0)>[&];
         UINT8<s(1)(1)(0)>[T]                portNo<s(1)(1)(0)>[&]; 
         UINT8<s(1)(1)(0)>[T]                portType<s(1)(1)(0)>[&];
         UINT32<s(1)(1)(0)>[T]              vlanId<s(1)(1)(0)>[&];
}__attribute__ ((packed))  PM_ETH_VLAN_INDEX_T<s(0)(0)(0)>[&];(D1:PM_ETH_VLAN_INDEX_T:1)[[TYPENAME:PM_ETH_VLAN_INDEX_T]]      

typedef struct 
{
       UINT32<s(1)(1)(0)>[T]    ethVlanInBytes<s(1)(1)(0)>[&];
       UINT32<s(1)(1)(0)>[T]    ethVlanInPkts<s(1)(1)(0)>[&];  
       UINT32<s(1)(1)(0)>[T]    ethVlanDropPkts<s(1)(1)(0)>[&];    
       UINT32<s(1)(1)(0)>[T]    RcvUnicastFrames<s(1)(1)(0)>[&];
       UINT32<s(1)(1)(0)>[T]    RcvTotalFrames<s(1)(1)(0)>[&];
       UINT32<s(1)(1)(0)>[T]    RcvUnicastBytes<s(1)(1)(0)>[&];
       UINT32<s(1)(1)(0)>[T]    RcvTotalBytes<s(1)(1)(0)>[&];
}__attribute__ ((packed))  PM_ETH_VLAN_DATA_T<s(0)(0)(0)>[&];(D1:PM_ETH_VLAN_DATA_T:1)[[TYPENAME:PM_ETH_VLAN_DATA_T]]    

typedef void (*PMP_GetRsOofFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(PMP_GetRsOofFunc)(UINT8<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&],UINT16<s(0)(0)(0)>[T] port<s(0)(0)(0)>[&],HW_PORT_TYPE<s(0)(0)(0)>[T] portType<s(0)(0)(0)>[&]);(D1:portType:0)













 
































































 





























 



 
 
 
 
 
 
















































 

 



















 















 






  
























































 


























 



 



 
typedef enum
{
    TASK_CORE_SECTION<s(0)(0)(0)>[&]       = 0,  
    TASK_URGENT_SECTION<s(0)(0)(0)>[&]     = 1,  
    TASK_MANAGEMENT_SECTION<s(0)(0)(0)>[&] = 2,  
    TASK_NORMAL_SECTION<s(0)(0)(0)>[&]     = 3,  
    TASK_IDLE_SECTION<s(0)(0)(0)>[&]       = 4  
} TASK_PRIORITY_SECTION_T<s(0)(0)(0)>[&];(D1:TASK_PRIORITY_SECTION_T:1)[[TYPENAME:TASK_PRIORITY_SECTION_T]]












 
 
 
 
 

 








 
 
 




















































 






 



































 





 














 







 




















 

 







































 















 


































 























 










































 


 



 




 







 
















































































































































































 







typedef enum msp_switch_type<s(0)(0)(0)>[&]
{
    MSP_REQ_LP<s(0)(0)(0)>[&]        =     127,  
    MSP_REQ_SF_P<s(0)(0)(0)>[&]      =     126,  
    MSP_REQ_FS_W<s(0)(0)(0)>[&]      =     125,  
    MSP_REQ_FS_P<s(0)(0)(0)>[&]      =     123,  
    MSP_REQ_FS_2<s(0)(0)(0)>[&]      =     122,  
    MSP_REQ_FS_3<s(0)(0)(0)>[&]      =     121,  
    MSP_REQ_FS_4<s(0)(0)(0)>[&]      =     120,  
    MSP_REQ_FS_5<s(0)(0)(0)>[&]      =     119,  
    MSP_REQ_FS_6<s(0)(0)(0)>[&]      =     118,  
    MSP_REQ_FS_7<s(0)(0)(0)>[&]      =     117,  
    MSP_REQ_FS_8<s(0)(0)(0)>[&]      =     116,  
    MSP_REQ_FS_9<s(0)(0)(0)>[&]      =     115,  
    MSP_REQ_FS_10<s(0)(0)(0)>[&]     =     114,  
    MSP_REQ_FS_11<s(0)(0)(0)>[&]     =     113,  
    MSP_REQ_FS_12<s(0)(0)(0)>[&]     =     112,  
    MSP_REQ_FS_13<s(0)(0)(0)>[&]     =     111,  
    MSP_REQ_FS_14<s(0)(0)(0)>[&]     =     110,  
    MSP_REQ_FS_15<s(0)(0)(0)>[&]     =     109,  

    MSP_REQ_SF_W<s(0)(0)(0)>[&]      =     108,  
    MSP_REQ_SF_H_2<s(0)(0)(0)>[&]    =     107,  
    MSP_REQ_SF_H_3<s(0)(0)(0)>[&]    =     106,  
    MSP_REQ_SF_H_4<s(0)(0)(0)>[&]    =     105,  
    MSP_REQ_SF_H_5<s(0)(0)(0)>[&]    =     104,  
    MSP_REQ_SF_H_6<s(0)(0)(0)>[&]    =     103,  
    MSP_REQ_SF_H_7<s(0)(0)(0)>[&]    =     102,  
    MSP_REQ_SF_H_8<s(0)(0)(0)>[&]    =     101,  
    MSP_REQ_SF_H_9<s(0)(0)(0)>[&]    =     100,  
    MSP_REQ_SF_H_10<s(0)(0)(0)>[&]   =     99,  
    MSP_REQ_SF_H_11<s(0)(0)(0)>[&]   =     98,  
    MSP_REQ_SF_H_12<s(0)(0)(0)>[&]   =     97,  
    MSP_REQ_SF_H_13<s(0)(0)(0)>[&]   =     96,  
    MSP_REQ_SF_H_14<s(0)(0)(0)>[&]   =     95,  

    MSP_REQ_SF_L_1<s(0)(0)(0)>[&]    =     94,  
    MSP_REQ_SF_L_2<s(0)(0)(0)>[&]    =     93,  
    MSP_REQ_SF_L_3<s(0)(0)(0)>[&]    =     92,  
    MSP_REQ_SF_L_4<s(0)(0)(0)>[&]    =     91,  
    MSP_REQ_SF_L_5<s(0)(0)(0)>[&]    =     90,  
    MSP_REQ_SF_L_6<s(0)(0)(0)>[&]    =     89,  
    MSP_REQ_SF_L_7<s(0)(0)(0)>[&]    =     88,  
    MSP_REQ_SF_L_8<s(0)(0)(0)>[&]    =     87,  
    MSP_REQ_SF_L_9<s(0)(0)(0)>[&]    =     86,  
    MSP_REQ_SF_L_10<s(0)(0)(0)>[&]   =     85,  
    MSP_REQ_SF_L_11<s(0)(0)(0)>[&]   =     84,  
    MSP_REQ_SF_L_12<s(0)(0)(0)>[&]   =     83,  
    MSP_REQ_SF_L_13<s(0)(0)(0)>[&]   =     82,  
    MSP_REQ_SF_L_14<s(0)(0)(0)>[&]   =     81,  

    MSP_REQ_SD_P<s(0)(0)(0)>[&]      =     78,  
    MSP_REQ_SD_W<s(0)(0)(0)>[&]      =     76,  
    MSP_REQ_SD_H_2<s(0)(0)(0)>[&]    =     75,  
    MSP_REQ_SD_H_3<s(0)(0)(0)>[&]    =     74,  
    MSP_REQ_SD_H_4<s(0)(0)(0)>[&]    =     73,  
    MSP_REQ_SD_H_5<s(0)(0)(0)>[&]    =     72,  
    MSP_REQ_SD_H_6<s(0)(0)(0)>[&]    =     71,  
    MSP_REQ_SD_H_7<s(0)(0)(0)>[&]    =     70,  
    MSP_REQ_SD_H_8<s(0)(0)(0)>[&]    =     69,  
    MSP_REQ_SD_H_9<s(0)(0)(0)>[&]    =     68,  
    MSP_REQ_SD_H_10<s(0)(0)(0)>[&]   =     67,  
    MSP_REQ_SD_H_11<s(0)(0)(0)>[&]   =     66,  
    MSP_REQ_SD_H_12<s(0)(0)(0)>[&]   =     65,  
    MSP_REQ_SD_H_13<s(0)(0)(0)>[&]   =     64,  
    MSP_REQ_SD_H_14<s(0)(0)(0)>[&]   =     63,  

    MSP_REQ_SD_L_1<s(0)(0)(0)>[&]    =     62,  
    MSP_REQ_SD_L_2<s(0)(0)(0)>[&]    =     61,  
    MSP_REQ_SD_L_3<s(0)(0)(0)>[&]    =     60,  
    MSP_REQ_SD_L_4<s(0)(0)(0)>[&]    =     59,  
    MSP_REQ_SD_L_5<s(0)(0)(0)>[&]    =     58,  
    MSP_REQ_SD_L_6<s(0)(0)(0)>[&]    =     57,  
    MSP_REQ_SD_L_7<s(0)(0)(0)>[&]    =     56,  
    MSP_REQ_SD_L_8<s(0)(0)(0)>[&]    =     55,  
    MSP_REQ_SD_L_9<s(0)(0)(0)>[&]    =     54,  
    MSP_REQ_SD_L_10<s(0)(0)(0)>[&]   =     53,  
    MSP_REQ_SD_L_11<s(0)(0)(0)>[&]   =     52,  
    MSP_REQ_SD_L_12<s(0)(0)(0)>[&]   =     51,  
    MSP_REQ_SD_L_13<s(0)(0)(0)>[&]   =     50,  
    MSP_REQ_SD_L_14<s(0)(0)(0)>[&]   =     49,  

    MSP_REQ_MS_W<s(0)(0)(0)>[&]      =     46,  
    MSP_REQ_MS_P<s(0)(0)(0)>[&]      =     45,  
    MSP_REQ_MS_2<s(0)(0)(0)>[&]      =     44,  
    MSP_REQ_MS_3<s(0)(0)(0)>[&]      =     43,  
    MSP_REQ_MS_4<s(0)(0)(0)>[&]      =     42,  
    MSP_REQ_MS_5<s(0)(0)(0)>[&]      =     41,  
    MSP_REQ_MS_6<s(0)(0)(0)>[&]      =     40,  
    MSP_REQ_MS_7<s(0)(0)(0)>[&]      =     39,  
    MSP_REQ_MS_8<s(0)(0)(0)>[&]      =     38,  
    MSP_REQ_MS_9<s(0)(0)(0)>[&]      =     37,  
    MSP_REQ_MS_10<s(0)(0)(0)>[&]     =     36,  
    MSP_REQ_MS_11<s(0)(0)(0)>[&]     =     35,  
    MSP_REQ_MS_12<s(0)(0)(0)>[&]     =     34,  
    MSP_REQ_MS_13<s(0)(0)(0)>[&]     =     33,  
    MSP_REQ_MS_14<s(0)(0)(0)>[&]     =     32,  
    MSP_REQ_MS_15<s(0)(0)(0)>[&]     =     31,  
    MSP_REQ_WTR<s(0)(0)(0)>[&]       =     30,  
    MSP_REQ_EXER_0<s(0)(0)(0)>[&]    =     29,  
    MSP_REQ_EXER_1<s(0)(0)(0)>[&]    =     28,  
    MSP_REQ_EXER_2<s(0)(0)(0)>[&]    =     27,  
    MSP_REQ_EXER_3<s(0)(0)(0)>[&]    =     26,  
    MSP_REQ_EXER_4<s(0)(0)(0)>[&]    =     25,  
    MSP_REQ_EXER_5<s(0)(0)(0)>[&]    =     24,  
    MSP_REQ_EXER_6<s(0)(0)(0)>[&]    =     23,  
    MSP_REQ_EXER_7<s(0)(0)(0)>[&]    =     22,  
    MSP_REQ_EXER_8<s(0)(0)(0)>[&]    =     21,  
    MSP_REQ_EXER_9<s(0)(0)(0)>[&]    =     20,  
    MSP_REQ_EXER_10<s(0)(0)(0)>[&]   =     19,  
    MSP_REQ_EXER_11<s(0)(0)(0)>[&]   =     18,  
    MSP_REQ_EXER_12<s(0)(0)(0)>[&]   =     17,  
    MSP_REQ_EXER_13<s(0)(0)(0)>[&]   =     16,  
    MSP_REQ_EXER_14<s(0)(0)(0)>[&]   =     15,  
    MSP_REQ_EXER_15<s(0)(0)(0)>[&]   =     14,  
    MSP_REQ_RR<s(0)(0)(0)>[&]        =     13,  
    MSP_REQ_DNR<s(0)(0)(0)>[&]       =     12,  
    MSP_REQ_NRM<s(0)(0)(0)>[&]       =     0,  
    MSP_REQ_NR<s(0)(0)(0)>[&]        =     0,  
} MSP_SWITCH_REQ_T<s(0)(0)(0)>[&];(D1:MSP_SWITCH_REQ_T:1)[[TYPENAME:MSP_SWITCH_REQ_T]]

typedef enum msp_switch_type_t<s(0)(0)(0)>[&]
{
    MSP_NO_REQUEST<s(0)(0)(0)>[&] = 0,      
    MSP_DNOTREV_REQ<s(0)(0)(0)>[&],         
    MSP_REVERT_REQ<s(0)(0)(0)>[&],          
    MSP_UNUSED3_REQ<s(0)(0)(0)>[&],         
    MSP_EXERCISE_REQ<s(0)(0)(0)>[&],        
    MSP_UNUSED5_REQ<s(0)(0)(0)>[&],         
    MSP_WTR_REQ<s(0)(0)(0)>[&],             
    MSP_UNUSED7_REQ<s(0)(0)(0)>[&],         
    MSP_MAN_REQ<s(0)(0)(0)>[&],             
    MSP_UNUSED9_REQ<s(0)(0)(0)>[&],         
    MSP_SD_LPRI_REQ<s(0)(0)(0)>[&],         
    MSP_SD_HPRI_REQ<s(0)(0)(0)>[&],         
    MSP_SF_LPRI_REQ<s(0)(0)(0)>[&],         
    MSP_SF_HPRI_REQ<s(0)(0)(0)>[&],         
    MSP_FORCED_REQ<s(0)(0)(0)>[&],          
    MSP_LOCK_REQ<s(0)(0)(0)>[&],            
    MSP_UNKNOWN_REQ<s(0)(0)(0)>[&] = 0x10
} MSP_SWITCH_REQ_TYPE_T<s(0)(0)(0)>[&];(D1:MSP_SWITCH_REQ_TYPE_T:1)[[TYPENAME:MSP_SWITCH_REQ_TYPE_T]]

 



typedef enum
{
    CTD_MSP_SIG_STATE_UNKNOWN<s(0)(0)(0)>[&]   = 0x0,
    CTD_MSP_SIG_STATE_NORMAL<s(0)(0)(0)>[&]    = 0x1,
    CTD_MSP_SIG_STATE_DEGRADE<s(0)(0)(0)>[&]   = 0x2,
    CTD_MSP_SIG_STATE_FAIL<s(0)(0)(0)>[&]      = 0x3,
}CTD_MSP_SIG_STATE_T<s(0)(0)(0)>[&];(D1:CTD_MSP_SIG_STATE_T:1)[[TYPENAME:CTD_MSP_SIG_STATE_T]]

typedef enum
{
    CTD_MSP_UNIDIRECTION<s(0)(0)(0)>[&]    = 0x0,
    CTD_MSP_BIDIRECTION<s(0)(0)(0)>[&]     = 0x1,
}CTD_MSP_DIR_MODE_T<s(0)(0)(0)>[&];(D1:CTD_MSP_DIR_MODE_T:1)[[TYPENAME:CTD_MSP_DIR_MODE_T]]

typedef enum
{
    CTD_MSP_NONREVERTIVE<s(0)(0)(0)>[&] = 0x0,
    CTD_MSP_REVERTIVE<s(0)(0)(0)>[&]    = 0x1,
}CTD_MSP_RVT_MODE_T<s(0)(0)(0)>[&];(D1:CTD_MSP_RVT_MODE_T:1)[[TYPENAME:CTD_MSP_RVT_MODE_T]]

typedef enum
{
    CTD_MSP_ACTIVE<s(0)(0)(0)>[&]       = 0x0,
    CTD_MSP_STANDBY<s(0)(0)(0)>[&]      = 0x1,
}CTD_MSP_CH_STATE_T<s(0)(0)(0)>[&];(D1:CTD_MSP_CH_STATE_T:1)[[TYPENAME:CTD_MSP_CH_STATE_T]]

typedef enum
{
    CTD_MSP_PRIORI_HIGH<s(0)(0)(0)>[&]       = 0x0,
    CTD_MSP_PRIORI_LOW<s(0)(0)(0)>[&]        = 0x1,
}CTD_MSP_CH_PRIORITY_T<s(0)(0)(0)>[&];(D1:CTD_MSP_CH_PRIORITY_T:1)[[TYPENAME:CTD_MSP_CH_PRIORITY_T]]

typedef enum
{
    CTD_MSP_CMD_CLEAR<s(0)(0)(0)>[&]               = 0x7F,
    CTD_MSP_LOCK_OUT_PROT<s(0)(0)(0)>[&]           = 0x7E,
    CTD_MSP_FORCE_SWTICH_WORK<s(0)(0)(0)>[&]       = 0x7D,
    CTD_MSP_FORCE_SWITCH_PROT_1<s(0)(0)(0)>[&]     = 0x7B,
    CTD_MSP_FORCE_SWITCH_PROT_2<s(0)(0)(0)>[&]     = 0x7A,
    CTD_MSP_FORCE_SWITCH_PROT_3<s(0)(0)(0)>[&]     = 0x79,    
    CTD_MSP_FORCE_SWITCH_PROT_4<s(0)(0)(0)>[&]     = 0x78,    
    CTD_MSP_FORCE_SWITCH_PROT_5<s(0)(0)(0)>[&]     = 0x77,    
    CTD_MSP_FORCE_SWITCH_PROT_6<s(0)(0)(0)>[&]     = 0x76,    
    CTD_MSP_FORCE_SWITCH_PROT_7<s(0)(0)(0)>[&]     = 0x75,    
    CTD_MSP_FORCE_SWITCH_PROT_8<s(0)(0)(0)>[&]     = 0x74,    
    CTD_MSP_FORCE_SWITCH_PROT_9<s(0)(0)(0)>[&]     = 0x73,    
    CTD_MSP_FORCE_SWITCH_PROT_10<s(0)(0)(0)>[&]    = 0x72,        
    CTD_MSP_FORCE_SWITCH_PROT_11<s(0)(0)(0)>[&]    = 0x71,        
    CTD_MSP_FORCE_SWITCH_PROT_12<s(0)(0)(0)>[&]    = 0x70,        
    CTD_MSP_FORCE_SWITCH_PROT_13<s(0)(0)(0)>[&]    = 0x6F,        
    CTD_MSP_FORCE_SWITCH_PROT_14<s(0)(0)(0)>[&]    = 0x6E,
    CTD_MSP_FORCE_SWITCH_PROT_15<s(0)(0)(0)>[&]    = 0x6D,            
    CTD_MSP_MANUAL_SWITCH_WORK<s(0)(0)(0)>[&]      = 0x2E,
    CTD_MSP_MANUAL_SWITCH_PROT_1<s(0)(0)(0)>[&]    = 0x2D,
    CTD_MSP_MANUAL_SWITCH_PROT_2<s(0)(0)(0)>[&]    = 0x2C,
    CTD_MSP_MANUAL_SWITCH_PROT_3<s(0)(0)(0)>[&]    = 0x2B,
    CTD_MSP_MANUAL_SWITCH_PROT_4<s(0)(0)(0)>[&]    = 0x2A,
    CTD_MSP_MANUAL_SWITCH_PROT_5<s(0)(0)(0)>[&]    = 0x29,
    CTD_MSP_MANUAL_SWITCH_PROT_6<s(0)(0)(0)>[&]    = 0x28,
    CTD_MSP_MANUAL_SWITCH_PROT_7<s(0)(0)(0)>[&]    = 0x27,
    CTD_MSP_MANUAL_SWITCH_PROT_8<s(0)(0)(0)>[&]    = 0x26,
    CTD_MSP_MANUAL_SWITCH_PROT_9<s(0)(0)(0)>[&]    = 0x25,
    CTD_MSP_MANUAL_SWITCH_PROT_10<s(0)(0)(0)>[&]   = 0x24,
    CTD_MSP_MANUAL_SWITCH_PROT_11<s(0)(0)(0)>[&]   = 0x23,
    CTD_MSP_MANUAL_SWITCH_PROT_12<s(0)(0)(0)>[&]   = 0x22,
    CTD_MSP_MANUAL_SWITCH_PROT_13<s(0)(0)(0)>[&]   = 0x21,
    CTD_MSP_MANUAL_SWITCH_PROT_14<s(0)(0)(0)>[&]   = 0x20,
    CTD_MSP_MANUAL_SWITCH_PROT_15<s(0)(0)(0)>[&]   = 0x1F,
    CTD_MSP_EXER_0<s(0)(0)(0)>[&]                  = 0x1D,
    CTD_MSP_EXER_1<s(0)(0)(0)>[&]                  = 0x1C,
    CTD_MSP_EXER_2<s(0)(0)(0)>[&]                  = 0x1B,
    CTD_MSP_EXER_3<s(0)(0)(0)>[&]                  = 0x1A,
    CTD_MSP_EXER_4<s(0)(0)(0)>[&]                  = 0x19,
    CTD_MSP_EXER_5<s(0)(0)(0)>[&]                  = 0x18,
    CTD_MSP_EXER_6<s(0)(0)(0)>[&]                  = 0x17,
    CTD_MSP_EXER_7<s(0)(0)(0)>[&]                  = 0x16,
    CTD_MSP_EXER_8<s(0)(0)(0)>[&]                  = 0x15,
    CTD_MSP_EXER_9<s(0)(0)(0)>[&]                  = 0x14,
    CTD_MSP_EXER_10<s(0)(0)(0)>[&]                 = 0x13,
    CTD_MSP_EXER_11<s(0)(0)(0)>[&]                 = 0x12,
    CTD_MSP_EXER_12<s(0)(0)(0)>[&]                 = 0x11,
    CTD_MSP_EXER_13<s(0)(0)(0)>[&]                 = 0x10,    
    CTD_MSP_EXER_14<s(0)(0)(0)>[&]                 = 0x0F,    
    CTD_MSP_EXER_15<s(0)(0)(0)>[&]                 = 0x0E,
    CTD_MSP_NO_COMMAND<s(0)(0)(0)>[&]              = 0x00,
}CTD_MSP_CMD_TYPE_T<s(0)(0)(0)>[&];(D1:CTD_MSP_CMD_TYPE_T:1)[[TYPENAME:CTD_MSP_CMD_TYPE_T]]

typedef enum 
{
    CTD_MSP_CMD_RSLT_SUCC<s(0)(0)(0)>[&]        = 0x1,
    CTD_MSP_CMD_RSLT_LOWPRIORITY<s(0)(0)(0)>[&] = 0x2,
    CTD_MSP_CMD_SWITCH_TO_ACTIVE<s(0)(0)(0)>[&] = 0x3,
    CTD_MSP_CMD_SWITCH_FAIL<s(0)(0)(0)>[&]      = 0x4,   
}CTD_MSP_CMD_RSLT_T<s(0)(0)(0)>[&];(D1:CTD_MSP_CMD_RSLT_T:1)[[TYPENAME:CTD_MSP_CMD_RSLT_T]]

typedef enum
{
    CTD_MSP_RSN_CLEAR_CMD<s(0)(0)(0)>[&]         = 0x1,
    CTD_MSP_RSN_LP_CMD<s(0)(0)(0)>[&]            = 0x2,
    CTD_MSP_RSN_FORCED_SWITCH<s(0)(0)(0)>[&]     = 0x3,
    CTD_MSP_RSN_MANUAL_SWITCH<s(0)(0)(0)>[&]     = 0x4,
    CTD_MSP_RSN_SIGNAL_FAIL<s(0)(0)(0)>[&]       = 0x5,
    CTD_MSP_RSN_SIGNAL_FAIL_CLEAR<s(0)(0)(0)>[&] = 0x6,
    CTD_MSP_RSN_SIGNAL_DEG<s(0)(0)(0)>[&]        = 0x7,
    CTD_MSP_RSN_SIGNAL_DEG_CLEAR<s(0)(0)(0)>[&]  = 0x8,
    CTD_MSP_RSN_NO_SWITCH<s(0)(0)(0)>[&]         = 0x9,
} CTD_MSP_SWITCH_RSN_T<s(0)(0)(0)>[&];(D1:CTD_MSP_SWITCH_RSN_T:1)[[TYPENAME:CTD_MSP_SWITCH_RSN_T]]

typedef enum
{
    CTD_MSP_PRIO_LOW<s(0)(0)(0)>[&]              = 0x0,
    CTD_MSP_PRIO_HIGH<s(0)(0)(0)>[&]             = 0x1,
}CTD_MSP_PRIO_TYPE_T<s(0)(0)(0)>[&];(D1:CTD_MSP_PRIO_TYPE_T:1)[[TYPENAME:CTD_MSP_PRIO_TYPE_T]]

typedef struct
{
     
    CTD_MSP_SIG_STATE_T<s(1)(1)(0)>[T]  eWorkSigState<s(1)(1)(0)>[&][14];
    CTD_MSP_CH_STATE_T<s(1)(1)(0)>[T]   eWorkChState<s(1)(1)(0)>[&][14]; 
     
    CTD_MSP_SIG_STATE_T<s(1)(1)(0)>[T]  eProtSigState<s(1)(1)(0)>[&];
    CTD_MSP_CH_STATE_T<s(1)(1)(0)>[T]   eProtChState<s(1)(1)(0)>[&]; 
     
    CTD_MSP_CMD_TYPE_T<s(1)(1)(0)>[T]   eMspExtCmd<s(1)(1)(0)>[&];                          
    CTD_MSP_CMD_RSLT_T<s(1)(1)(0)>[T]   eMspExtCmdRslt<s(1)(1)(0)>[&];  
     
    MSP_SWITCH_REQ_T<s(1)(1)(0)>[T]     eMspCurSwitchReq<s(1)(1)(0)>[&];                         
    CTD_MSP_SWITCH_RSN_T<s(1)(1)(0)>[T] eMspSwitchReason<s(1)(1)(0)>[&];
     
    BOOL<s(1)(1)(0)>[T]                 bFopAlarm<s(1)(1)(0)>[&];
     
    UINT8<s(1)(1)(0)>[T]                ucRcvdK1Value<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]                ucRcvdK2Value<s(1)(1)(0)>[&];
     
    UINT8<s(1)(1)(0)>[T]                ucTransK1Value<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]                ucTransK2Value<s(1)(1)(0)>[&];
     
    BOOL<s(1)(1)(0)>[T]                 bIsExtra<s(1)(1)(0)>[&];
}CTD_MSP_STATE_T<s(0)(0)(0)>[&];(D1:CTD_MSP_STATE_T:1)[[TYPENAME:CTD_MSP_STATE_T]]

typedef struct
{
    UINT16<s(1)(1)(0)>[T]              usMspGrpNum<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]               ucMspWorkChNum<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]               ucMspType<s(1)(1)(0)>[&];   
    CTD_MSP_STATE_T<s(1)(1)(0)>[T]     *sMspState<s(1)(1)(0)>[&];
}CTD_HW_MSP_STATE_T<s(0)(0)(0)>[&];(D1:CTD_HW_MSP_STATE_T:1)[[TYPENAME:CTD_HW_MSP_STATE_T]]


 
typedef struct
{
     
    UINT16<s(1)(1)(0)>[T] usGrpId<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T] usProtSlot<s(1)(1)(0)>[&];                  
    UINT16<s(1)(1)(0)>[T] usProtPort<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]  ucProtPortType<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T] usWorkNum<s(1)(1)(0)>[&];                   
    UINT16<s(1)(1)(0)>[T] usWorkSlot<s(1)(1)(0)>[&][14];
    UINT16<s(1)(1)(0)>[T] usWorkPort<s(1)(1)(0)>[&][14];
    UINT8<s(1)(1)(0)>[T]  ucWorkPortType<s(1)(1)(0)>[&][14];
    UINT8<s(1)(1)(0)>[T]  ucWorkPrio<s(1)(1)(0)>[&][14];
    UINT32<s(1)(1)(0)>[T]              ulWtrVal<s(1)(1)(0)>[&];	    
    CTD_MSP_CMD_TYPE_T<s(1)(1)(0)>[T]  eCmdType<s(1)(1)(0)>[&];       
    BOOL<s(1)(1)(0)>[T]   bIsExtra<s(1)(1)(0)>[&];                    

    BOOL<s(1)(1)(0)>[T]   bEnable<s(1)(1)(0)>[&];                     
}CTD_MSP_1VSN_CFG_T<s(0)(0)(0)>[&];(D1:CTD_MSP_1VSN_CFG_T:1)[[TYPENAME:CTD_MSP_1VSN_CFG_T]]

typedef struct
{
    UINT16<s(1)(1)(0)>[T] usWorkNum<s(1)(1)(0)>[&];
    CTD_MSP_PRIO_TYPE_T<s(1)(1)(0)>[T] sPrio<s(1)(1)(0)>[&][14];
}CTD_MSP_PRIO_STAT_T<s(0)(0)(0)>[&];(D1:CTD_MSP_PRIO_STAT_T:1)[[TYPENAME:CTD_MSP_PRIO_STAT_T]]

 
typedef struct
{
    UINT16<s(1)(1)(0)>[T] usBusRx<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T] usBusTx<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T] usVc4<s(1)(1)(0)>[&];
}CTD_TP_PARAM_CFG_T<s(0)(0)(0)>[&];(D1:CTD_TP_PARAM_CFG_T:1)[[TYPENAME:CTD_TP_PARAM_CFG_T]]
typedef struct
{
    UINT16<s(1)(1)(0)>[T] usTpCount<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T] usGrpId<s(1)(1)(0)>[&];
    CTD_TP_PARAM_CFG_T<s(1)(1)(0)>[T] *tp<s(1)(1)(0)>[&];
}CTD_1ToNMSP_TP_CFG_T<s(0)(0)(0)>[&];(D1:CTD_1ToNMSP_TP_CFG_T:1)[[TYPENAME:CTD_1ToNMSP_TP_CFG_T]]
typedef struct
{
     
     
    CTD_1ToNMSP_TP_CFG_T<s(1)(1)(0)>[T] sProtTp<s(1)(1)(0)>[&];                  
    UINT16<s(1)(1)(0)>[T] usWorkNum<s(1)(1)(0)>[&];                   
    CTD_1ToNMSP_TP_CFG_T<s(1)(1)(0)>[T] sWorkTP<s(1)(1)(0)>[&][14];    
    UINT8<s(1)(1)(0)>[T] ucWorkPrio<s(1)(1)(0)>[&][14];    
    UINT32<s(1)(1)(0)>[T]              ulWtrVal<s(1)(1)(0)>[&];	    
    CTD_MSP_CMD_TYPE_T<s(1)(1)(0)>[T]  eCmdType<s(1)(1)(0)>[&];       
    BOOL<s(1)(1)(0)>[T]   bIsExtra<s(1)(1)(0)>[&];                    

    BOOL<s(1)(1)(0)>[T]   bEnable<s(1)(1)(0)>[&];                     
}CTD_MSP_1VSN_DRV_CFG_T<s(0)(0)(0)>[&];(D1:CTD_MSP_1VSN_DRV_CFG_T:1)[[TYPENAME:CTD_MSP_1VSN_DRV_CFG_T]]




typedef struct
{
    UINT16<s(1)(1)(0)>[T]              usGrpId<s(1)(1)(0)>[&];          
    UINT16<s(1)(1)(0)>[T]              usWorkSlot<s(1)(1)(0)>[&];	    
    UINT16<s(1)(1)(0)>[T]              usWorkPort<s(1)(1)(0)>[&];	    
    UINT16<s(1)(1)(0)>[T]              usProtSlot<s(1)(1)(0)>[&];     
    UINT16<s(1)(1)(0)>[T]              usProtPort<s(1)(1)(0)>[&];	    
    HW_PORT_TYPE<s(1)(1)(0)>[T]        ePortType<s(1)(1)(0)>[&];      
    CTD_MSP_DIR_MODE_T<s(1)(1)(0)>[T]  eDirMode<s(1)(1)(0)>[&];       
    CTD_MSP_RVT_MODE_T<s(1)(1)(0)>[T]  eRvtMode<s(1)(1)(0)>[&];       
    UINT32<s(1)(1)(0)>[T]              ulWtrVal<s(1)(1)(0)>[&];	    
    CTD_MSP_CMD_TYPE_T<s(1)(1)(0)>[T]  eCmdType<s(1)(1)(0)>[&];       
    BOOL<s(1)(1)(0)>[T]                bEnable<s(1)(1)(0)>[&];        
}CTD_MSP_1PLUS1_CFG_T<s(0)(0)(0)>[&];(D1:CTD_MSP_1PLUS1_CFG_T:1)[[TYPENAME:CTD_MSP_1PLUS1_CFG_T]]

typedef void (*MPA_Handle_RcvKbyte<s(0)(0)(0)>[&])TYPENAME:FUNC:(MPA_Handle_RcvKbyte)(UINT16<s(0)(0)(0)>[T] usSlot<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] ucPort<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] ucPorttype<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] ucK1<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] ucK2<s(0)(0)(0)>[&]);(D1:ucK2:0)
typedef void (*MPA_RcvPhyDefect<s(0)(0)(0)>[&])TYPENAME:FUNC:(MPA_RcvPhyDefect)(UINT16<s(0)(0)(0)>[T] usSlot<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] ucPort<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] ucPorttype<s(0)(0)(0)>[&], MSP_SWITCH_REQ_T<s(0)(0)(0)>[T] eType<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulFlag<s(0)(0)(0)>[&]);(D1:ulFlag:0)
typedef void (*MPA_RprtMspStatus<s(0)(0)(0)>[&])TYPENAME:FUNC:(MPA_RprtMspStatus)(UINT16<s(0)(0)(0)>[T] wMspGrpId<s(0)(0)(0)>[&], CTD_MSP_STATE_T<s(0)(0)(0)>[T] *psMspState<s(0)(0)(0)>[&]);(D1:psMspState:0)




 















 
 
 
 
 
 
 
 	
 
 













































	extern int stack<s(0)(0)(0)>[&](unsigned int *pStack<s(0)(0)(0)>[&][], int levels<s(0)(0)(0)>[&]);(D1:levels:0)
	extern void logBackN<s(0)(0)(0)>[&](const char *title<s(0)(0)(0)>[&], int n<s(0)(0)(0)>[&]);(D1:n:0)
	extern void logBackM<s(0)(0)(0)>[&](const char *title<s(0)(0)(0)>[&], int n<s(0)(0)(0)>[&]);(D1:n:0)
	extern void logExit<s(0)(0)(0)>[&](char *file<s(0)(0)(0)>[&], int line<s(0)(0)(0)>[&]);(D1:line:0)
	extern void logDump<s(0)(0)(0)>[&](char *file<s(0)(0)(0)>[&], int line<s(0)(0)(0)>[&]);(D1:line:0)
	extern void sys_panic<s(0)(0)(0)>[&](char *file<s(0)(0)(0)>[&], int line<s(0)(0)(0)>[&]);(D1:line:0)

















 




























	typedef struct {
		int head<s(1)(1)(0)>[&];
		int tail<s(1)(1)(0)>[&];
		command_tt<s(1)(1)(0)>[T] *queue<s(1)(1)(0)>[&][500 ];
	} LogQ_t<s(0)(0)(0)>[&];(D1:LogQ_t:1)[[TYPENAME:LogQ_t]]

	extern unsigned int utility_log<s(0)(0)(0)>[&];(D1:utility_log:0)
	extern unsigned int MsgRecvLogOpen<s(0)(0)(0)>[&];(D1:MsgRecvLogOpen:0)
	extern unsigned int COL_Log<s(0)(0)(0)>[&];(D1:COL_Log:0)
	
	
	extern LogQ_t<s(0)(0)(0)>[T] logq<s(0)(0)(0)>[&];(D1:logq:0)
	void debug_log_init<s(0)(0)(0)>[&](void);(D1:debug_log_init:0)
	void log_enqueue<s(0)(0)(0)>[&](command_tt<s(0)(0)(0)>[T] * log<s(0)(0)(0)>[&]);(D1:log:0)
	void log_clear<s(0)(0)(0)>[&](void);(D1:log_clear:0)
	void consoleLog<s(0)(0)(0)>[&](const char *fmt<s(0)(0)(0)>[&], ...);(D1:fmt:0)
 
	void ulogit<s(0)(0)(0)>[&](int line<s(0)(0)(0)>[&], const char *file_name<s(0)(0)(0)>[&], int global<s(0)(0)(0)>[&], const char *fmt<s(0)(0)(0)>[&], ...);(D1:fmt:0)













 


typedef enum 
{
    LC_UNKNOWN<s(0)(0)(0)>[&] = 0,      
    LC_CLEAR<s(0)(0)(0)>[&]   = 1,      
    LC_SD<s(0)(0)(0)>[&]      = 2,      
    LC_SF<s(0)(0)(0)>[&]      = 3,      
    LC_MAX<s(0)(0)(0)>[&]     = 4 
}LINE_COND_T<s(0)(0)(0)>[&];(D1:LINE_COND_T:1)[[TYPENAME:LINE_COND_T]]

typedef enum 
{
    KEXP_AUTO_MODE<s(0)(0)(0)>[&]      = 0,     
    KEXP_LOCAL_HW_MODE<s(0)(0)(0)>[&]  = 1,     
    KEXP_LOCAL_SW_MODE<s(0)(0)(0)>[&]  = 2,     
    KEXP_FORCE_MODE<s(0)(0)(0)>[&]     = 3,     
}CTD_KEXP_MODE_T<s(0)(0)(0)>[&];(D1:CTD_KEXP_MODE_T:1)[[TYPENAME:CTD_KEXP_MODE_T]]

typedef enum 
{
    KEXP_UNKNOWN_STATE<s(0)(0)(0)>[&]     = 0,     
    KEXP_AUTO_LOCAL_STATE<s(0)(0)(0)>[&]  = 1,     
    KEXP_AUTO_EXP_STATE<s(0)(0)(0)>[&]    = 2,     
    KEXP_FORCE_EXP_STATE<s(0)(0)(0)>[&]   = 3,     
    KEXP_FORCE_SW_STATE<s(0)(0)(0)>[&]    = 4,     
    KEXP_FORCE_HW_STATE<s(0)(0)(0)>[&]    = 5,     
}CTD_KEXP_STATE_T<s(0)(0)(0)>[&];(D1:CTD_KEXP_STATE_T:1)[[TYPENAME:CTD_KEXP_STATE_T]]

typedef struct
{
    UINT32<s(1)(1)(0)>[T]          ulSlot<s(1)(1)(0)>[&];
    HW_PORT_TYPE<s(1)(1)(0)>[T]    ePortType<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]          ulPort<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]          ulPeerSlot<s(1)(1)(0)>[&];
    HW_PORT_TYPE<s(1)(1)(0)>[T]    ePeerPortType<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]          ulPeerPort<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]           ucNodeId<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]           ucNodeNum<s(1)(1)(0)>[&];    
    CTD_KEXP_MODE_T<s(1)(1)(0)>[T] eMode<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T]            bEnable<s(1)(1)(0)>[&];
}CTD_MSSP_ENABLE_T<s(0)(0)(0)>[&];(D1:CTD_MSSP_ENABLE_T:1)[[TYPENAME:CTD_MSSP_ENABLE_T]]

typedef struct
{
    UINT32<s(1)(1)(0)>[T]              ulSlot<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]              ulPortType<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]              ulPort<s(1)(1)(0)>[&];
    union
    {
        struct
        {
            UINT8<s(3)(1)(0)>[T]       ucK1<s(3)(1)(0)>[&];
            UINT8<s(3)(1)(0)>[T]       ucK2<s(3)(1)(0)>[&];
            UINT16<s(3)(1)(0)>[T]      usBackup<s(3)(1)(0)>[&];
        } sKBytes<s(2)(0)(0)>[&];
        LINE_COND_T<s(2)(0)(0)>[T]     eLineCond<s(2)(0)(0)>[&];
    } uRptChange<s(1)(0)(0)>[&];
} CTD_MSSP_CHANGERPT_T<s(0)(0)(0)>[&];(D1:CTD_MSSP_CHANGERPT_T:1)[[TYPENAME:CTD_MSSP_CHANGERPT_T]]

typedef void (*MSA_ChangeKbyteBatch<s(0)(0)(0)>[&])TYPENAME:FUNC:(MSA_ChangeKbyteBatch)(CTD_MSSP_CHANGERPT_T<s(0)(0)(0)>[T] *pKb<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T]  batNo<s(0)(0)(0)>[&]);(D1:batNo:0)
typedef void (*MSA_ChangeLineCondBatch<s(0)(0)(0)>[&])TYPENAME:FUNC:(MSA_ChangeLineCondBatch)(CTD_MSSP_CHANGERPT_T<s(0)(0)(0)>[T] *pLc<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T]  batNo<s(0)(0)(0)>[&]);(D1:batNo:0)

typedef void (*MST_ChangeOfKb<s(0)(0)(0)>[&])TYPENAME:FUNC:(MST_ChangeOfKb)(UINT32<s(0)(0)(0)>[T] ulSlot<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] ucPortType<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] ucPort<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] ucK1<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] ucK2<s(0)(0)(0)>[&]);(D1:ucK2:0)
typedef void (*MST_ChangeOfLineCond<s(0)(0)(0)>[&])TYPENAME:FUNC:(MST_ChangeOfLineCond)(UINT32<s(0)(0)(0)>[T] ulSlot<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] ucPortType<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] ucPort<s(0)(0)(0)>[&], LINE_COND_T<s(0)(0)(0)>[T] eLcCond<s(0)(0)(0)>[&]);(D1:eLcCond:0)




 





 
 
 
 
 
 
 
 
 
 
 
 




























 
typedef enum 
{
    SNCP_BACK_TP<s(0)(0)(0)>[&]       = 0,
    SNCP_WORK_TP1<s(0)(0)(0)>[&]      = 1,
    SNCP_WORK_TP2<s(0)(0)(0)>[&]      = 2,
    SNCP_WORK_TP3<s(0)(0)(0)>[&]      = 3,
    SNCP_WORK_TP4<s(0)(0)(0)>[&]      = 4,
    SNCP_WORK_TP5<s(0)(0)(0)>[&]      = 5,
    SNCP_WORK_TP6<s(0)(0)(0)>[&]      = 6,
    SNCP_WORK_TP7<s(0)(0)(0)>[&]      = 7,
    SNCP_WORK_TP8<s(0)(0)(0)>[&]      = 8,
    SNCP_WORK_TP9<s(0)(0)(0)>[&]      = 9,
    SNCP_WORK_TP10<s(0)(0)(0)>[&]     = 10,
    SNCP_WORK_TP11<s(0)(0)(0)>[&]     = 11,
    SNCP_WORK_TP12<s(0)(0)(0)>[&]     = 12,
    SNCP_WORK_TP13<s(0)(0)(0)>[&]     = 13,
    SNCP_WORK_TP14<s(0)(0)(0)>[&]     = 14,
    SNCP_WORK_TP15<s(0)(0)(0)>[&]     = 15
}SNCP_TP_CHANNEL_T<s(0)(0)(0)>[&];(D1:SNCP_TP_CHANNEL_T:1)[[TYPENAME:SNCP_TP_CHANNEL_T]]

typedef enum 
{
    SNCP_LOGIC_TP<s(0)(0)(0)>[&]      = 0,
    SNCP_PHYSICAL_TP<s(0)(0)(0)>[&]   = 1,
    SNCP_PHYSICAL_TP1<s(0)(0)(0)>[&]  = 2
}SNCP_LOGIC_TP_DEFINE_T<s(0)(0)(0)>[&];(D1:SNCP_LOGIC_TP_DEFINE_T:1)[[TYPENAME:SNCP_LOGIC_TP_DEFINE_T]]


typedef enum 
{
    SNCP_I<s(0)(0)(0)>[&]             = 0,
    SNCP_N<s(0)(0)(0)>[&]             = 1,
}SNCP_INTRUSIVE_T<s(0)(0)(0)>[&];(D1:SNCP_INTRUSIVE_T:1)[[TYPENAME:SNCP_INTRUSIVE_T]]

typedef struct 
{
    UINT16<s(1)(1)(0)>[T]               usSlotNum<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]               usPortType<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]               usPortNum<s(1)(1)(0)>[&];
    TP_INDEX_T<s(1)(1)(0)>[T]           TpIndex<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T]                  bInUse<s(1)(1)(0)>[&];       
}__attribute__ ((packed))  SNCP_CHANNEL_T<s(0)(0)(0)>[&];(D1:SNCP_CHANNEL_T:1)[[TYPENAME:SNCP_CHANNEL_T]]


typedef enum 
{
    SPC_TP_TYPE_PROTECT<s(0)(0)(0)>[&]             = 0,
    SPC_TP_TYPE_PROTECT_MS_PROTECT<s(0)(0)(0)>[&],    
    SPC_TP_TYPE_WORK<s(0)(0)(0)>[&],
    SPC_TP_TYPE_WORK_MS_PROTECT<s(0)(0)(0)>[&],
    SPC_TP_TYPE_WORK2<s(0)(0)(0)>[&],
    SPC_TP_TYPE_WORK2_MS_PROTECT<s(0)(0)(0)>[&],
    SPC_TP_TYPE_WORK3<s(0)(0)(0)>[&],
    SPC_TP_TYPE_WORK3_MS_PROTECT<s(0)(0)(0)>[&],
    SPC_TP_TYPE_WORK4<s(0)(0)(0)>[&],
    SPC_TP_TYPE_WORK4_MS_PROTECT<s(0)(0)(0)>[&],
    SPC_TP_TYPE_WORK5<s(0)(0)(0)>[&],
    SPC_TP_TYPE_WORK5_MS_PROTECT<s(0)(0)(0)>[&],
    SPC_TP_TYPE_WORK6<s(0)(0)(0)>[&],
    SPC_TP_TYPE_WORK6_MS_PROTECT<s(0)(0)(0)>[&],
    SPC_TP_TYPE_WORK7<s(0)(0)(0)>[&],
    SPC_TP_TYPE_WORK7_MS_PROTECT<s(0)(0)(0)>[&],
    SPC_TP_TYPE_WORK8<s(0)(0)(0)>[&],
    SPC_TP_TYPE_WORK8_MS_PROTECT<s(0)(0)(0)>[&],
    SPC_TP_TYPE_WORK9<s(0)(0)(0)>[&],
    SPC_TP_TYPE_WORK9_MS_PROTECT<s(0)(0)(0)>[&],
    SPC_TP_TYPE_WORK10<s(0)(0)(0)>[&],
    SPC_TP_TYPE_WORK10_MS_PROTECT<s(0)(0)(0)>[&],
    SPC_TP_TYPE_WORK11<s(0)(0)(0)>[&],
    SPC_TP_TYPE_WORK11_MS_PROTECT<s(0)(0)(0)>[&],
    SPC_TP_TYPE_WORK12<s(0)(0)(0)>[&],
    SPC_TP_TYPE_WORK12_MS_PROTECT<s(0)(0)(0)>[&],
    SPC_TP_TYPE_WORK13<s(0)(0)(0)>[&],
    SPC_TP_TYPE_WORK13_MS_PROTECT<s(0)(0)(0)>[&],
    SPC_TP_TYPE_WORK14<s(0)(0)(0)>[&],
    SPC_TP_TYPE_WORK14_MS_PROTECT<s(0)(0)(0)>[&],
    SPC_TP_TYPE_WORK15<s(0)(0)(0)>[&],
    SPC_TP_TYPE_WORK15_MS_PROTECT<s(0)(0)(0)>[&]
}SNCP_TP_TYPE_T<s(0)(0)(0)>[&];(D1:SNCP_TP_TYPE_T:1)[[TYPENAME:SNCP_TP_TYPE_T]]


typedef enum
{
    SNCP_SIGNAL_UNKNOW<s(0)(0)(0)>[&]     = 0,
    SNCP_SIGNAL_NORMAL<s(0)(0)(0)>[&]     = 1,
    SNCP_SIGNAL_FAIL<s(0)(0)(0)>[&]       = 2,
    SNCP_SIGNAL_DEG<s(0)(0)(0)>[&]        = 3,
}SNCP_SIGNAL_STATE_T<s(0)(0)(0)>[&];(D1:SNCP_SIGNAL_STATE_T:1)[[TYPENAME:SNCP_SIGNAL_STATE_T]]

 
typedef enum
{
    SNCP_1J1_TYPE<s(0)(0)(0)>[&]      = 0,
    SNCP_1BN_TYPE<s(0)(0)(0)>[&]      = 1
}SNCP_GROUP_TYPE_T<s(0)(0)(0)>[&];(D1:SNCP_GROUP_TYPE_T:1)[[TYPENAME:SNCP_GROUP_TYPE_T]]

 
typedef struct 
{    
    BOOL<s(1)(1)(0)>[T]                  bEnableSncp<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]                ulSncpId<s(1)(1)(0)>[&];										
    UINT16<s(1)(1)(0)>[T]                usWorkBus<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]                 ucWorkVc4<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]                usProtBus<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]                 ucProtVc4<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]                usDestBus<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]                 ucDestVc4<s(1)(1)(0)>[&];
     
    BOOL<s(1)(1)(0)>[T]                 bXCEnable<s(1)(1)(0)>[&];
     
    UINT16<s(1)(1)(0)>[T]                usDestFirstBus<s(1)(1)(0)>[&]; 
    UINT8<s(1)(1)(0)>[T]                 ucDestFirstVc4<s(1)(1)(0)>[&];

    UINT8<s(1)(1)(0)>[T]                 ucSncpIntrusive<s(1)(1)(0)>[&];                
    UINT8<s(1)(1)(0)>[T]                 ucSncpRestoreMode<s(1)(1)(0)>[&];                
    UINT16<s(1)(1)(0)>[T]                usHoldOffTime<s(1)(1)(0)>[&];                    
    UINT16<s(1)(1)(0)>[T]                usSncpWTR<s(1)(1)(0)>[&];   
}__attribute__ ((packed))  HW_HO3P_SNCP_CONFIG_T<s(0)(0)(0)>[&];(D1:HW_HO3P_SNCP_CONFIG_T:1)[[TYPENAME:HW_HO3P_SNCP_CONFIG_T]]

typedef struct 
{
    UINT8<s(1)(1)(0)>[T]                ucBus<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]                ucVc4<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]               KLM<s(1)(1)(0)>[&];   
}__attribute__ ((packed))  LO_MATRIX_ITEM_T<s(0)(0)(0)>[&];(D1:LO_MATRIX_ITEM_T:1)[[TYPENAME:LO_MATRIX_ITEM_T]]

 
typedef struct 
{    
    BOOL<s(1)(1)(0)>[T]                    bEnableSncp<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]                  ulSncpId<s(1)(1)(0)>[&];										
    LO_MATRIX_ITEM_T<s(1)(1)(0)>[T]        WorkItem<s(1)(1)(0)>[&];
    LO_MATRIX_ITEM_T<s(1)(1)(0)>[T]        ProtItem<s(1)(1)(0)>[&];
    LO_MATRIX_ITEM_T<s(1)(1)(0)>[T]        DestItem<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]                	ucSncpIntrusive<s(1)(1)(0)>[&];                
    UINT8<s(1)(1)(0)>[T]                   ucSncpRestoreMode<s(1)(1)(0)>[&];  
    UINT8<s(1)(1)(0)>[T]                   ucSncpExtCmd<s(1)(1)(0)>[&];              
    UINT16<s(1)(1)(0)>[T]                  usHoldOffTime<s(1)(1)(0)>[&];                    
    UINT16<s(1)(1)(0)>[T]                  usSncpWTR<s(1)(1)(0)>[&];   
}__attribute__ ((packed))  HW_LO3P_SNCP_CONFIG_T<s(0)(0)(0)>[&];(D1:HW_LO3P_SNCP_CONFIG_T:1)[[TYPENAME:HW_LO3P_SNCP_CONFIG_T]]

typedef union
{
    HW_HO3P_SNCP_CONFIG_T<s(1)(1)(0)>[T]   HoSncpGroup<s(1)(1)(0)>[&];
    HW_LO3P_SNCP_CONFIG_T<s(1)(1)(0)>[T]   LoScnpGroup<s(1)(1)(0)>[&];
}__attribute__ ((packed))  HW_3P_SNCP_CONFIG_T<s(0)(0)(0)>[&];(D1:HW_3P_SNCP_CONFIG_T:1)[[TYPENAME:HW_3P_SNCP_CONFIG_T]]



 
typedef struct 
{    
    UINT32<s(1)(1)(0)>[T]                ulSncpId<s(1)(1)(0)>[&];													 
    SNCP_GROUP_TYPE_T<s(1)(1)(0)>[T]     GroupType<s(1)(1)(0)>[&];                          
    UINT8<s(1)(1)(0)>[T]                 ucWorkTpNum<s(1)(1)(0)>[&];                        
    UINT32<s(1)(1)(0)>[T]                ulTpType<s(1)(1)(0)>[&];                           
    SNCP_CHANNEL_T<s(1)(1)(0)>[T]  	  Tp<s(1)(1)(0)>[&][1  + 1][3 ];   
    SNCP_CHANNEL_T<s(1)(1)(0)>[T]        destOrSrcTp<s(1)(1)(0)>[&][1 +1];   
    UINT8<s(1)(1)(0)>[T]                 ucSncpIntrusive<s(1)(1)(0)>[&];                    
    UINT8<s(1)(1)(0)>[T]                 ucSncpRestoreMode<s(1)(1)(0)>[&];                  
    UINT16<s(1)(1)(0)>[T]                usHoldOffTime<s(1)(1)(0)>[&];                      
    UINT16<s(1)(1)(0)>[T]                usSncpWTR<s(1)(1)(0)>[&];   
	
 
    UINT8<s(1)(1)(0)>[T]                 ucSncpSignalDircetion<s(1)(1)(0)>[&];              
}__attribute__ ((packed))  HW_SNCP_CONFIG_T<s(0)(0)(0)>[&];(D1:HW_SNCP_CONFIG_T:1)[[TYPENAME:HW_SNCP_CONFIG_T]]
typedef struct 
{    
    UINT32<s(1)(1)(0)>[T]                      ulSncpId<s(1)(1)(0)>[&];                                                    
    SNCP_GROUP_TYPE_T<s(1)(1)(0)>[T]     GroupType<s(1)(1)(0)>[&];                          
    UINT8<s(1)(1)(0)>[T]                       ucWorkTpNum<s(1)(1)(0)>[&];                        
    UINT32<s(1)(1)(0)>[T]                      ulTpType<s(1)(1)(0)>[&];                           
    SNCP_CHANNEL_T<s(1)(1)(0)>[T]          Tp<s(1)(1)(0)>[&][1  + 1][3 ];   
    SNCP_CHANNEL_T<s(1)(1)(0)>[T]          destOrSrcTp<s(1)(1)(0)>[&][1 +1];   
    UINT8<s(1)(1)(0)>[T]                       ucSncpIntrusive<s(1)(1)(0)>[&];                    
    UINT8<s(1)(1)(0)>[T]                       ucSncpRestoreMode<s(1)(1)(0)>[&];                  
    UINT16<s(1)(1)(0)>[T]                      usHoldOffTime<s(1)(1)(0)>[&];                      
    UINT16<s(1)(1)(0)>[T]                      usSncpWTR<s(1)(1)(0)>[&];   
    
 
    UINT8<s(1)(1)(0)>[T]                       ucSncpSignalDircetion<s(1)(1)(0)>[&];              

    UINT8<s(1)(1)(0)>[T]                   ucSncpFrom<s(1)(1)(0)>[&];                           
    BOOL<s(1)(1)(0)>[T]                    SncpNeedReportGMPL<s(1)(1)(0)>[&];           
}__attribute__ ((packed))  HW_SNCP_GMPL_CONFIG_T<s(0)(0)(0)>[&];(D1:HW_SNCP_GMPL_CONFIG_T:1)[[TYPENAME:HW_SNCP_GMPL_CONFIG_T]]  
 
typedef struct 
{
    UINT32<s(1)(1)(0)>[T]     ulSncpId<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T]      ucTpSignalState<s(1)(1)(0)>[&][1  + 1][3 ];         
    UINT8<s(1)(1)(0)>[T]      ucTpTransfer<s(1)(1)(0)>[&][1  + 1];               
    UINT8<s(1)(1)(0)>[T]      ucChannelState<s(1)(1)(0)>[&];                    
    
    UINT16<s(1)(1)(0)>[T]     usTimerStart<s(1)(1)(0)>[&];                       
    UINT32<s(1)(1)(0)>[T]     ulTimerNum<s(1)(1)(0)>[&];
        
    UINT8<s(1)(1)(0)>[T]      ucSncpExternalCmd<s(1)(1)(0)>[&];                            
    UINT8<s(1)(1)(0)>[T]      ucSncpExtCmdResult<s(1)(1)(0)>[&];                           
    UINT8<s(1)(1)(0)>[T]      ucSncpCurSwitchReq<s(1)(1)(0)>[&];                           
    UINT8<s(1)(1)(0)>[T]      ucSncpSwitchReason<s(1)(1)(0)>[&];                           
}__attribute__ ((packed))  HW_SNCP_STATE_T<s(0)(0)(0)>[&];(D1:HW_SNCP_STATE_T:1)[[TYPENAME:HW_SNCP_STATE_T]]

 
typedef struct
{
    UINT32<s(1)(1)(0)>[T]                      ulSncpGroupId<s(1)(1)(0)>[&];
    SNCP_CHANNEL_T<s(1)(1)(0)>[T]              Tp<s(1)(1)(0)>[&];    
    SNCP_TP_TYPE_T<s(1)(1)(0)>[T]              TpId<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T]                        bEnable<s(1)(1)(0)>[&];
    SNCP_INTRUSIVE_T<s(1)(1)(0)>[T]            Intrusive<s(1)(1)(0)>[&];
}__attribute__ ((packed))  SW_SNCP_TP_ENABLE_STR_T<s(0)(0)(0)>[&];(D1:SW_SNCP_TP_ENABLE_STR_T:1)[[TYPENAME:SW_SNCP_TP_ENABLE_STR_T]]

 
typedef struct
{
    UINT16<s(1)(1)(0)>[T]               slot<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]               portType<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]               port<s(1)(1)(0)>[&];
    TP_INDEX_T<s(1)(1)(0)>[T]           Tp<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]               SncpIndex<s(1)(1)(0)>[&];
    SNCP_TP_TYPE_T<s(1)(1)(0)>[T]       WorkTpId<s(1)(1)(0)>[&];
    SNCP_SIGNAL_STATE_T<s(1)(1)(0)>[T]  bSet<s(1)(1)(0)>[&];
}__attribute__ ((packed))  SW_SNCP_STATE_REPORT_T<s(0)(0)(0)>[&];(D1:SW_SNCP_STATE_REPORT_T:1)[[TYPENAME:SW_SNCP_STATE_REPORT_T]]

 

 
typedef void (*SPA_DrvIntHappenFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(SPA_DrvIntHappenFunc)(UINT32<s(0)(0)(0)>[T] type<s(0)(0)(0)>[&]);(D1:type:0)

 
typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*SPA_SncpDprFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(SPA_SncpDprFunc)(INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T]* pulReportNum<s(0)(0)(0)>[&], SW_SNCP_STATE_REPORT_T<s(0)(0)(0)>[T]** ppsReportData<s(0)(0)(0)>[&]);(D1:ppsReportData:0)
typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*SPA_SncpPollFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(SPA_SncpPollFunc)(INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T]* pulReportNum<s(0)(0)(0)>[&], SW_SNCP_STATE_REPORT_T<s(0)(0)(0)>[T]** ppsReportData<s(0)(0)(0)>[&]);(D1:ppsReportData:0)

 
typedef void (*SPA_BoardStateChangeFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(SPA_BoardStateChangeFunc)(BOARD_EVENT_T<s(0)(0)(0)>[T] ulEvent<s(0)(0)(0)>[&], SLOT_NUMBER_T<s(0)(0)(0)>[T] usSlotNum<s(0)(0)(0)>[&], BOARD_STYLE_T<s(0)(0)(0)>[T] ulCardType<s(0)(0)(0)>[&]);(D1:ulCardType:0)

 
 
typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*SPA_SetProtModeFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(SPA_SetProtModeFunc)(INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&],  const SW_SNCP_TP_ENABLE_STR_T<s(0)(0)(0)>[T] *pEnableStr<s(0)(0)(0)>[&]);(D1:pEnableStr:0)

 

 
 
typedef UINT32<s(0)(0)(0)>[T] (*SPA_AddHWSncpToDrvFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(SPA_AddHWSncpToDrvFunc)(INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&],const HW_3P_SNCP_CONFIG_T<s(0)(0)(0)>[T] *pSncpGrp<s(0)(0)(0)>[&]);(D1:pSncpGrp:0)

 
typedef UINT32<s(0)(0)(0)>[T] (*SPA_DelHWSncpToDrvFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(SPA_DelHWSncpToDrvFunc)(INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulSncpGrpId<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] usDestBus<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] ucDestVc4<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] eDelMethod<s(0)(0)(0)>[&]);(D1:eDelMethod:0)

 
 
typedef UINT32<s(0)(0)(0)>[T] (*SPA_ExtSwitchCmdToDrvFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(SPA_ExtSwitchCmdToDrvFunc)(INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulSncpGrpId<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] eCmdType<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] usDestBus<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] ucDestVc4<s(0)(0)(0)>[&]);(D1:ucDestVc4:0)

 
typedef UINT32<s(0)(0)(0)>[T] (*SPA_SetSncpHoldOffTimeToDrvFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(SPA_SetSncpHoldOffTimeToDrvFunc)(INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulSncpGrpId<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] usTimeCnt<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] usDestBus<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] ucDestVc4<s(0)(0)(0)>[&]);(D1:ucDestVc4:0)

 
typedef UINT32<s(0)(0)(0)>[T] (*SPA_SetSncpWtrToDrvFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(SPA_SetSncpWtrToDrvFunc)(INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulSncpGrpId<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] usSncpWtr<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] usDestBus<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] ucDestVc4<s(0)(0)(0)>[&]);(D1:ucDestVc4:0)

 
typedef UINT32<s(0)(0)(0)>[T] (*SPA_SetSncpIntrusiveToDrvFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(SPA_SetSncpIntrusiveToDrvFunc)(INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulSncpGrpId<s(0)(0)(0)>[&], SNCP_INTRUSIVE_T<s(0)(0)(0)>[T] eNIMode<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] usDestBus<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] ucDestVc4<s(0)(0)(0)>[&]);(D1:ucDestVc4:0)

 
typedef UINT32<s(0)(0)(0)>[T] (*SPA_SetSncpRvtModeFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(SPA_SetSncpRvtModeFunc)(INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulSncpGrpId<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] eRvtMode<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] usDestBus<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] ucDestVc4<s(0)(0)(0)>[&]);(D1:ucDestVc4:0)

 
typedef UINT32<s(0)(0)(0)>[T] (*SPA_ConfigSncpEndFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(SPA_ConfigSncpEndFunc)(void);(D1:SPA_ConfigSncpEndFunc:0)

 
 
typedef UINT32<s(0)(0)(0)>[T] (*SPA_ReportSncpStateFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(SPA_ReportSncpStateFunc)(const HW_SNCP_STATE_T<s(0)(0)(0)>[T] *pSncpGrpState<s(0)(0)(0)>[&]);(D1:pSncpGrpState:0)  


 
typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*SPA_SetHapsModeFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(SPA_SetHapsModeFunc)(INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulPortType<s(0)(0)(0)>[&],UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&], TP_INDEX_T<s(0)(0)(0)>[T] tpIndex<s(0)(0)(0)>[&], SNCP_INTRUSIVE_T<s(0)(0)(0)>[T]  eNIMode<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&]);(D1:bEnable:0)
typedef UINT32<s(0)(0)(0)>[T] (*SPA_GetProtStatFromDrvFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(SPA_GetProtStatFromDrvFunc)(void);(D1:SPA_GetProtStatFromDrvFunc:0)
 
 

 
extern void SPA_RegSetProtMode<s(0)(0)(0)>[&](SPA_SetProtModeFunc<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0) 

 
extern void SPA_RegAddHWSncpToDrv<s(0)(0)(0)>[&](SPA_AddHWSncpToDrvFunc<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)
extern void SPA_RegDelHWSncpToDrv<s(0)(0)(0)>[&](SPA_DelHWSncpToDrvFunc<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)

 
extern void SPA_RegSetExCmdToDrv<s(0)(0)(0)>[&](SPA_ExtSwitchCmdToDrvFunc<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)
extern void SPA_RegSetHoldoffTimeToDrv<s(0)(0)(0)>[&](SPA_SetSncpHoldOffTimeToDrvFunc<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)
extern void SPA_RegSetWtrToDrv<s(0)(0)(0)>[&](SPA_SetSncpWtrToDrvFunc<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)
extern void SPA_RegSetIntrusiveToDrv<s(0)(0)(0)>[&](SPA_SetSncpIntrusiveToDrvFunc<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)
extern void SPA_RegSetRvtToDrv<s(0)(0)(0)>[&](SPA_SetSncpRvtModeFunc<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)

 
extern void SPA_RegConfigHWEnd<s(0)(0)(0)>[&](SPA_ConfigSncpEndFunc<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)

 
extern void SPA_RegSncpDpr<s(0)(0)(0)>[&](SPA_SncpDprFunc<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)

 
extern void SPA_RegSncpPoll<s(0)(0)(0)>[&](SPA_SncpPollFunc<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)

 
 
extern void SPA_RegSetHapsMode<s(0)(0)(0)>[&](SPA_SetHapsModeFunc<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0) 
extern void SPA_RegGetProtStatFromDrv<s(0)(0)(0)>[&](SPA_GetProtStatFromDrvFunc<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)

typedef void (*SPC_BoardStateChangeFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(SPC_BoardStateChangeFunc)(BOARD_EVENT_T<s(0)(0)(0)>[T] ulEvent<s(0)(0)(0)>[&], SLOT_NUMBER_T<s(0)(0)(0)>[T] usSlotNum<s(0)(0)(0)>[&], BOARD_STYLE_T<s(0)(0)(0)>[T] ulCardType<s(0)(0)(0)>[&]);(D1:ulCardType:0)

 
typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*SPA_SetForcRrptAlmFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(SPA_SetForcRrptAlmFunc)(INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&]);(D1:inst:0)
extern void SPA_RegSetForceRrptAlm<s(0)(0)(0)>[&](SPA_SetForcRrptAlmFunc<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)

 
typedef int (*SPA_RegGetPhyDestSncpFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(SPA_RegGetPhyDestSncpFunc)(void *pTP<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulTpNum<s(0)(0)(0)>[&]);(D1:ulTpNum:0)
extern void SPA_RegGetPhyDestSncp<s(0)(0)(0)>[&](SPA_RegGetPhyDestSncpFunc<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)

 
 
typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*SPA_SetLoSncpHoldOffTimeCommonValueToDrvFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(SPA_SetLoSncpHoldOffTimeCommonValueToDrvFunc)(INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulTimer1<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulTimer2<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulTimer3<s(0)(0)(0)>[&]);(D1:ulTimer3:0)
 
 
typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*SPA_SetLoSncpWtrCommoneValueToDrvFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(SPA_SetLoSncpWtrCommoneValueToDrvFunc)(INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulTimer1<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulTimer2<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulTimer3<s(0)(0)(0)>[&]);(D1:ulTimer3:0)
  
 
extern void SPA_RegSetLoSncpHoldOffTimeCommonValueToDrv<s(0)(0)(0)>[&] (SPA_SetLoSncpHoldOffTimeCommonValueToDrvFunc<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)
extern void SPA_RegSetLoSncpWtrCommoneValueToDrv<s(0)(0)(0)>[&] (SPA_SetLoSncpWtrCommoneValueToDrvFunc<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)
 
 
 
typedef int (*funcCCSetSncpGroupAdd<s(0)(0)(0)>[&])TYPENAME:FUNC:(funcCCSetSncpGroupAdd)(INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&], HW_3P_SNCP_CONFIG_T<s(0)(0)(0)>[T] *psSncpGrp<s(0)(0)(0)>[&]);(D1:psSncpGrp:0)

typedef int (*funcCCSetSncpExtCmd<s(0)(0)(0)>[&])TYPENAME:FUNC:(funcCCSetSncpExtCmd)(INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulSncpGrpId<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] eCmdType<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] usDestBus<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] ucDestVc4<s(0)(0)(0)>[&]);(D1:ucDestVc4:0)

typedef int (*funcCCSetSncpHoldOffTime<s(0)(0)(0)>[&])TYPENAME:FUNC:(funcCCSetSncpHoldOffTime)(INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulSncpGrpId<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] usTimeCnt<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] usDestBus<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] ucDestVc4<s(0)(0)(0)>[&]) ;(D1:ucDestVc4:0)

typedef int (*funcCCSetSncpWtr<s(0)(0)(0)>[&])TYPENAME:FUNC:(funcCCSetSncpWtr)(INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulSncpGrpId<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] usSncpWtr<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] usDestBus<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] ucDestVc4<s(0)(0)(0)>[&]) ;(D1:ucDestVc4:0)
typedef int (*funcCCSetSncpNIMode<s(0)(0)(0)>[&])TYPENAME:FUNC:(funcCCSetSncpNIMode)(INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulSncpGrpId<s(0)(0)(0)>[&], SNCP_INTRUSIVE_T<s(0)(0)(0)>[T] eNIMode<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] usDestBus<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] ucDestVc4<s(0)(0)(0)>[&]) ;(D1:ucDestVc4:0)

typedef int (*funcCCSetSncpRvtMode<s(0)(0)(0)>[&])TYPENAME:FUNC:(funcCCSetSncpRvtMode)(INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulSncpGrpId<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] eRvtMode<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] usDestBus<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] ucDestVc4<s(0)(0)(0)>[&]) ;(D1:ucDestVc4:0)
typedef int (*funcCCSetSncpDelete<s(0)(0)(0)>[&])TYPENAME:FUNC:(funcCCSetSncpDelete)(INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulSncpGrpId<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] usDestBus<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] ucDestVc4<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] eDelMethod<s(0)(0)(0)>[&]) ;(D1:eDelMethod:0)
typedef int (*funcCCSetHoSwitch<s(0)(0)(0)>[&])TYPENAME:FUNC:(funcCCSetHoSwitch)(INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] fromBus<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] fromVc4<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] toBus<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] toVc4<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bSwitch<s(0)(0)(0)>[&]);(D1:bSwitch:0)
 
typedef int (*funcCCReplaceLoSncpW<s(0)(0)(0)>[&])TYPENAME:FUNC:(funcCCReplaceLoSncpW)(INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&],UINT16<s(0)(0)(0)>[T] SncpGroupId<s(0)(0)(0)>[&], LO_MATRIX_ITEM_T<s(0)(0)(0)>[T] srcXcPoint<s(0)(0)(0)>[&],BOOL<s(0)(0)(0)>[T] bWork<s(0)(0)(0)>[&]);(D1:bWork:0)
typedef int  (*funcCCSetLoSncpGlobalWtr<s(0)(0)(0)>[&])TYPENAME:FUNC:(funcCCSetLoSncpGlobalWtr)(INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulWtrTimer1<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulWtrTimer2<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulWtrTimer3<s(0)(0)(0)>[&]);(D1:ulWtrTimer3:0)
typedef int (*funcCCSetLoSncpGloablHoldoff<s(0)(0)(0)>[&])TYPENAME:FUNC:(funcCCSetLoSncpGloablHoldoff)(INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulTimer1<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulTimer2<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulTimer3<s(0)(0)(0)>[&]);(D1:ulTimer3:0)













 




























typedef struct 
{
    command_tt<s(1)(1)(0)>[T] head<s(1)(1)(0)>[&];
    int state<s(1)(1)(0)>[&];
} PRAApplInitState_t<s(0)(0)(0)>[&];(D1:PRAApplInitState_t:1)[[TYPENAME:PRAApplInitState_t]]

typedef struct
{
    PbSlotNumberType_Tval<s(1)(1)(0)>[T] SlotNo<s(1)(1)(0)>[&];          
    UINT32<s(1)(1)(0)>[T] PortNo<s(1)(1)(0)>[&];              
    PbPortType_Tval<s(1)(1)(0)>[T]            PortType<s(1)(1)(0)>[&];            


    TruthValue_Tval<s(1)(1)(0)>[T]             PRBSEnable<s(1)(1)(0)>[&];        
    pbPRBSPattern_Tval<s(1)(1)(0)>[T]       PRBSPattern<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]                          PRBSErrorBlocks<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]                          PRBSErrorSeconds<s(1)(1)(0)>[&];
    pbPRBSStatus_Tval<s(1)(1)(0)>[T]         PRBSStatus<s(1)(1)(0)>[&];
    PbActualPortType_Tval<s(1)(1)(0)>[T]        PRBSActualPortType<s(1)(1)(0)>[&];

    prbsMode_Tval<s(1)(1)(0)>[T]   PRBSMode<s(1)(1)(0)>[&];
}PRA_PORTINFO_T<s(0)(0)(0)>[&];(D1:PRA_PORTINFO_T:1)[[TYPENAME:PRA_PORTINFO_T]]


 
PB_ERROR_CODE_T<s(0)(0)(0)>[T] PRA_SetPortStatus<s(0)(0)(0)>[&] (UINT8<s(0)(0)(0)>[T] slotNo<s(0)(0)(0)>[&],
    UINT8<s(0)(0)(0)>[T] port<s(0)(0)(0)>[&],
    UINT8<s(0)(0)(0)>[T] portType<s(0)(0)(0)>[&],
    pbPRBSStatus_Tval<s(0)(0)(0)>[T] syncStatus<s(0)(0)(0)>[&]);(D1:syncStatus:0)

typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*PRA_SetPortStatus_Func<s(0)(0)(0)>[&])TYPENAME:FUNC:(PRA_SetPortStatus_Func)
    (UINT8<s(0)(0)(0)>[T] slotNo<s(0)(0)(0)>[&],
    UINT8<s(0)(0)(0)>[T] port<s(0)(0)(0)>[&],
    UINT8<s(0)(0)(0)>[T] portType<s(0)(0)(0)>[&],
    pbPRBSStatus_Tval<s(0)(0)(0)>[T] syncStatus<s(0)(0)(0)>[&]);(D1:syncStatus:0)

 
typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*PRA_GetPortInfo_Func<s(0)(0)(0)>[&])TYPENAME:FUNC:(PRA_GetPortInfo_Func) 
    (INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&], 
    UINT32<s(0)(0)(0)>[T] ulSlot<s(0)(0)(0)>[&], 
    HW_PORT_TYPE<s(0)(0)(0)>[T] ePortType<s(0)(0)(0)>[&], 
    UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&], 
    UINT32<s(0)(0)(0)>[T] *pulPrbsCnt<s(0)(0)(0)>[&]);(D1:pulPrbsCnt:0)

 
typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*PRA_SetPortInfo_Func<s(0)(0)(0)>[&])TYPENAME:FUNC:(PRA_SetPortInfo_Func) 
    (INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&], 
    UINT32<s(0)(0)(0)>[T] ulSlot<s(0)(0)(0)>[&], 
    HW_PORT_TYPE<s(0)(0)(0)>[T] ePortType<s(0)(0)(0)>[&], 
    UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&], 
    pbPRBSPattern_Tval<s(0)(0)(0)>[T] ePrbsMode<s(0)(0)(0)>[&], 
    BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&]);(D1:bEnable:0)

void PRA_PollData<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] counter<s(0)(0)(0)>[&]);(D1:counter:0)
void PRA_RegGetPortInfo<s(0)(0)(0)>[&](PRA_GetPortInfo_Func<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)
void PRA_RegSetPortInfo<s(0)(0)(0)>[&](PRA_SetPortInfo_Func<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)




 











































 
typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*GFA_CfgAlm2DrvFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(GFA_CfgAlm2DrvFunc)(INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&]);(D1:bEnable:0)
extern void GFA_RegSetAlmCfg<s(0)(0)(0)>[&](GFA_CfgAlm2DrvFunc<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)

 

 
 
typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*GFA_RprtAlarmDetect2GmplsFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(GFA_RprtAlarmDetect2GmplsFunc)(        UINT32<s(0)(0)(0)>[T]          ulSlot<s(0)(0)(0)>[&],         HW_PORT_TYPE<s(0)(0)(0)>[T]    tPortType<s(0)(0)(0)>[&],        HW_PORT_TYPE<s(0)(0)(0)>[T]    tCurPortType<s(0)(0)(0)>[&],        UINT32<s(0)(0)(0)>[T]          ulPort<s(0)(0)(0)>[&],        SDH_TP_TYPE<s(0)(0)(0)>[T]     tpType<s(0)(0)(0)>[&],        COMPACT_TP_T<s(0)(0)(0)>[T]    tpIndex<s(0)(0)(0)>[&],        UINT32<s(0)(0)(0)>[T]          ulDefectId<s(0)(0)(0)>[&],        FMA_ALM_STATE<s(0)(0)(0)>[T]   eState<s(0)(0)(0)>[&]    );(D1:eState:0)

 
extern PB_ERROR_CODE_T<s(0)(0)(0)>[T] GFA_AlarmDetect<s(0)(0)(0)>[&](
        UINT32<s(0)(0)(0)>[T]          ulSlot<s(0)(0)(0)>[&], 
        HW_PORT_TYPE<s(0)(0)(0)>[T]    ePortType<s(0)(0)(0)>[&],
        HW_PORT_TYPE<s(0)(0)(0)>[T]    eCurPortType<s(0)(0)(0)>[&],
        UINT32<s(0)(0)(0)>[T]          ulPort<s(0)(0)(0)>[&],
        SDH_TP_TYPE<s(0)(0)(0)>[T]     tpType<s(0)(0)(0)>[&],
        COMPACT_TP_T<s(0)(0)(0)>[T]    tpIndex<s(0)(0)(0)>[&],
        UINT32<s(0)(0)(0)>[T]          ulDefectId<s(0)(0)(0)>[&],
        FMA_ALM_STATE<s(0)(0)(0)>[T]   eState<s(0)(0)(0)>[&]);(D1:eState:0)

 
extern void GFM_BoardStateChange<s(0)(0)(0)>[&](BOARD_EVENT_T<s(0)(0)(0)>[T] ulEvent<s(0)(0)(0)>[&], SLOT_NUMBER_T<s(0)(0)(0)>[T] usSlotNum<s(0)(0)(0)>[&], BOARD_STYLE_T<s(0)(0)(0)>[T] ulCardType<s(0)(0)(0)>[&]);(D1:ulCardType:0)












 
































 
typedef unsigned char       BYTE<s(0)(0)(0)>[&];(D1:BYTE:1)[[TYPENAME:BYTE]]

typedef unsigned short      WORD<s(0)(0)(0)>[&];(D1:WORD:1)[[TYPENAME:WORD]]
typedef unsigned int        DWORD<s(0)(0)(0)>[&];(D1:DWORD:1)[[TYPENAME:DWORD]]


 



















 




 






 







 










 


typedef enum 
{
     
    CTD_MODE_STM1<s(0)(0)(0)>[&]       = 0x0,
    CTD_MODE_STM1E<s(0)(0)(0)>[&]      = 0x1,
    CTD_MODE_STM4<s(0)(0)(0)>[&]       = 0x2,
    CTD_MODE_STM16<s(0)(0)(0)>[&]      = 0x3,
    CTD_MODE_STM64<s(0)(0)(0)>[&]      = 0x4,
    CTD_MODE_STM256<s(0)(0)(0)>[&]     = 0x5,

     
    CTD_MODE_E1<s(0)(0)(0)>[&]         = 0x6,
    CTD_MODE_DS1<s(0)(0)(0)>[&]        = 0x7,
    CTD_MODE_E3<s(0)(0)(0)>[&]         = 0x8,
    CTD_MODE_DS3<s(0)(0)(0)>[&]        = 0x9,

     
    CTD_MODE_OTU2<s(0)(0)(0)>[&]       = 0xa,
}CTD_MODE_TYPE_T<s(0)(0)(0)>[&];(D1:CTD_MODE_TYPE_T:1)[[TYPENAME:CTD_MODE_TYPE_T]]

 
typedef enum 
{
    CTD_FEC_MODE_RS<s(0)(0)(0)>[&]     = 0x0,
    CTD_FEC_MODE_UFEC<s(0)(0)(0)>[&]   = 0x1,
}CTD_FEC_MODE_TYPE_T<s(0)(0)(0)>[&];(D1:CTD_FEC_MODE_TYPE_T:1)[[TYPENAME:CTD_FEC_MODE_TYPE_T]]

 
typedef struct
{
    BOOL<s(1)(1)(0)>[T] los<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] lof<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] oof<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] tim<s(1)(1)(0)>[&];
}CTD_RS_ALARM_T<s(0)(0)(0)>[&];(D1:CTD_RS_ALARM_T:1)[[TYPENAME:CTD_RS_ALARM_T]]

 
typedef struct
{
    BOOL<s(1)(1)(0)>[T] ais<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] exc<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] deg<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] rdi<s(1)(1)(0)>[&];
}CTD_MS_ALARM_T<s(0)(0)(0)>[&];(D1:CTD_MS_ALARM_T:1)[[TYPENAME:CTD_MS_ALARM_T]]

 
typedef struct
{
    BOOL<s(1)(1)(0)>[T] ais<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] lop<s(1)(1)(0)>[&];
}CTD_AU_ALARM_T<s(0)(0)(0)>[&];(D1:CTD_AU_ALARM_T:1)[[TYPENAME:CTD_AU_ALARM_T]]

 
typedef struct
{
    BOOL<s(1)(1)(0)>[T] tim<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] plm<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] uneq<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] exc<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] deg<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] rdi<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] lom<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] ais<s(1)(1)(0)>[&];
}CTD_HP_ALARM_T<s(0)(0)(0)>[&];(D1:CTD_HP_ALARM_T:1)[[TYPENAME:CTD_HP_ALARM_T]]

 
typedef struct
{
    BOOL<s(1)(1)(0)>[T] ais<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] lop<s(1)(1)(0)>[&];
}CTD_TU_ALARM_T<s(0)(0)(0)>[&];(D1:CTD_TU_ALARM_T:1)[[TYPENAME:CTD_TU_ALARM_T]]

 
typedef struct
{
    BOOL<s(1)(1)(0)>[T] tim<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] plm<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] uneq<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] exc<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] deg<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] rdi<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] rfi<s(1)(1)(0)>[&];
}CTD_LP_ALARM_T<s(0)(0)(0)>[&];(D1:CTD_LP_ALARM_T:1)[[TYPENAME:CTD_LP_ALARM_T]]

 
typedef struct
{
    BOOL<s(1)(1)(0)>[T] los<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] ais<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] lof<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] lom<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] rdi<s(1)(1)(0)>[&];
}CTD_PPI_ALARM_T<s(0)(0)(0)>[&];(D1:CTD_PPI_ALARM_T:1)[[TYPENAME:CTD_PPI_ALARM_T]]

 
typedef struct
{
    BOOL<s(1)(1)(0)>[T] mcd<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] fcd<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] fma<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] osr<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] tcu<s(1)(1)(0)>[&];
}CTD_EQ_ALARM_T<s(0)(0)(0)>[&];(D1:CTD_EQ_ALARM_T:1)[[TYPENAME:CTD_EQ_ALARM_T]]

 
typedef struct
{
    BOOL<s(1)(1)(0)>[T] los<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] ldf<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] oof<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] wca<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] cim<s(1)(1)(0)>[&];
}CTD_TR_ALARM_T<s(0)(0)(0)>[&];(D1:CTD_TR_ALARM_T:1)[[TYPENAME:CTD_TR_ALARM_T]]

 
typedef struct
{
    BOOL<s(1)(1)(0)>[T] lfa<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] lma<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] tim<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] iae<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] bdi<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] ptm<s(1)(1)(0)>[&];
}CTD_OTU_ALARM_T<s(0)(0)(0)>[&];(D1:CTD_OTU_ALARM_T:1)[[TYPENAME:CTD_OTU_ALARM_T]]

 
typedef struct
{
    BOOL<s(1)(1)(0)>[T] los<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] mfo<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] dfo<s(1)(1)(0)>[&];
}CTD_E1_ALARM_T<s(0)(0)(0)>[&];(D1:CTD_E1_ALARM_T:1)[[TYPENAME:CTD_E1_ALARM_T]]


 
typedef struct
{
    BOOL<s(1)(1)(0)>[T] lof<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] tim<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] ais<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] exc<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] deg<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] rdi<s(1)(1)(0)>[&];
}CTD_MSP_ALARM_INT_T<s(0)(0)(0)>[&];(D1:CTD_MSP_ALARM_INT_T:1)[[TYPENAME:CTD_MSP_ALARM_INT_T]]

 
typedef struct
{
    BOOL<s(1)(1)(0)>[T] lof<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] tim<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] ais<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] exc<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] deg<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] rdi<s(1)(1)(0)>[&];
}CTD_MSP_ALARM_DELTA_T<s(0)(0)(0)>[&];(D1:CTD_MSP_ALARM_DELTA_T:1)[[TYPENAME:CTD_MSP_ALARM_DELTA_T]]

 
typedef struct
{
    BOOL<s(1)(1)(0)>[T] lof<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] tim<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] ais<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] exc<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] deg<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] rdi<s(1)(1)(0)>[&];
}CTD_MSP_ALARM_STATE_T<s(0)(0)(0)>[&];(D1:CTD_MSP_ALARM_STATE_T:1)[[TYPENAME:CTD_MSP_ALARM_STATE_T]]

 
typedef struct
{
    BOOL<s(1)(1)(0)>[T] ais<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] lop<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] uneq<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] tim<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] vcais<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] exc<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] deg<s(1)(1)(0)>[&];
}CTD_SNCP_ALARM_INT_T<s(0)(0)(0)>[&];(D1:CTD_SNCP_ALARM_INT_T:1)[[TYPENAME:CTD_SNCP_ALARM_INT_T]]

 
typedef struct
{
    BOOL<s(1)(1)(0)>[T] ais<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] lop<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] uneq<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] tim<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] vcais<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] exc<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] deg<s(1)(1)(0)>[&];
}CTD_SNCP_ALARM_DELTA_T<s(0)(0)(0)>[&];(D1:CTD_SNCP_ALARM_DELTA_T:1)[[TYPENAME:CTD_SNCP_ALARM_DELTA_T]]

 
typedef struct
{
    BOOL<s(1)(1)(0)>[T] ais<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] lop<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] uneq<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] tim<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] vcais<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] exc<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] deg<s(1)(1)(0)>[&];
}CTD_SNCP_ALARM_STATE_T<s(0)(0)(0)>[&];(D1:CTD_SNCP_ALARM_STATE_T:1)[[TYPENAME:CTD_SNCP_ALARM_STATE_T]]

 
typedef enum
{
    CTD_INSERT_ALM_TYPE_MSAIS<s(0)(0)(0)>[&]       =   0x0,
    CTD_INSERT_ALM_TYPE_AUAIS<s(0)(0)(0)>[&]       =   0x1,
    CTD_INSERT_ALM_TYPE_TUAIS<s(0)(0)(0)>[&]       =   0x2,
    CTD_INSERT_ALM_TYPE_AIS<s(0)(0)(0)>[&]         =   0x3,
    CTD_INSERT_ALM_TYPE_UNEQ<s(0)(0)(0)>[&]        =   0x4, 
    CTD_INSERT_ALM_TYPE_RDI<s(0)(0)(0)>[&]         =   0x5,
}CTD_INSERT_ALM_TYPE_T<s(0)(0)(0)>[&];(D1:CTD_INSERT_ALM_TYPE_T:1)[[TYPENAME:CTD_INSERT_ALM_TYPE_T]]

 
typedef enum
{
    CTD_INSERT_ALM_IN_LASER<s(0)(0)(0)>[&]         =   0x0,
    CTD_INSERT_ALM_OUT_LASER<s(0)(0)(0)>[&]        =   0x1,
}CTD_INSERT_ALM_DIR_T<s(0)(0)(0)>[&];(D1:CTD_INSERT_ALM_DIR_T:1)[[TYPENAME:CTD_INSERT_ALM_DIR_T]]

 
typedef enum
{
    CTD_LOOPBACK_TYPE_NONE<s(0)(0)(0)>[&]              =   0x0,
    CTD_LOOPBACK_TYPE_OUTWARD_NEAR<s(0)(0)(0)>[&]      =   0x1,
    CTD_LOOPBACK_TYPE_INWARD_FAR<s(0)(0)(0)>[&]        =   0x2,
    CTD_LOOPBACK_TYPE_INWARD_NEAR<s(0)(0)(0)>[&]       =   0x3,
    CTD_LOOPBACK_TYPE_OUTWARD_FAR<s(0)(0)(0)>[&]       =   0x4, 
    CTD_LOOPBACK_TYPE_OUTWARD_TSI<s(0)(0)(0)>[&]       =   0x5,
}CTD_LOOPBACK_TYPE_T<s(0)(0)(0)>[&];(D1:CTD_LOOPBACK_TYPE_T:1)[[TYPENAME:CTD_LOOPBACK_TYPE_T]]

 
typedef struct 
{
     
    WORD<s(1)(1)(0)>[T]                busNum<s(1)(1)(0)>[&];

    BYTE<s(1)(1)(0)>[T]                portNum<s(1)(1)(0)>[&];
    WORD<s(1)(1)(0)>[T]                augNum<s(1)(1)(0)>[&];
    CARDTYPE_T<s(1)(1)(0)>[T]          type<s(1)(1)(0)>[&];    
}CTD_CARD_CONFIG_T<s(0)(0)(0)>[&];(D1:CTD_CARD_CONFIG_T:1)[[TYPENAME:CTD_CARD_CONFIG_T]]

 
typedef struct 
{
    BYTE<s(1)(1)(0)>[T]  byPort<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T]  bEnable<s(1)(1)(0)>[&];
}CTD_TIMING_CONFIG_T<s(0)(0)(0)>[&];(D1:CTD_TIMING_CONFIG_T:1)[[TYPENAME:CTD_TIMING_CONFIG_T]]

 
typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*CPS_GetLatchState<s(0)(0)(0)>[&])TYPENAME:FUNC:(CPS_GetLatchState)(SLOT_NUMBER_T<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&], LATCH_STATE_T<s(0)(0)(0)>[T] eLatchState<s(0)(0)(0)>[&]);(D1:eLatchState:0)
 
typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*CAD_RprtUnitFail<s(0)(0)(0)>[&])TYPENAME:FUNC:(CAD_RprtUnitFail)(SLOT_NUMBER_T<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bUnitFail<s(0)(0)(0)>[&]);(D1:bUnitFail:0)
    
 
typedef struct
{
     
    TMA_S1ChangeCallbackFunc<s(1)(1)(0)>[T]        cRprtSsmToTMA<s(1)(1)(0)>[&];
    TMA_ModDefectFunc<s(1)(1)(0)>[T]               cRprtDefectToTMA<s(1)(1)(0)>[&];
     
    FMA_AlmModDefectFunc<s(1)(1)(0)>[T]            cRprtDefectToFMA<s(1)(1)(0)>[&];
    FMA_AlmModDefectByBusFunc<s(1)(1)(0)>[T]       cRptDefectToFmaByBus<s(1)(1)(0)>[&];
     
    PMP_GetRsOofFunc<s(1)(1)(0)>[T]                cRprtRsOofToPMA<s(1)(1)(0)>[&]; 
     
    CPS_GetLatchState<s(1)(1)(0)>[T]               cRprtLatchStateToCPA<s(1)(1)(0)>[&];
     
    CPS_GetLatchState<s(1)(1)(0)>[T]               cRprtLatchStateToCAI<s(1)(1)(0)>[&];
     
    PRA_SetPortStatus_Func<s(1)(1)(0)>[T]          cRprtPrbsStateToPRA<s(1)(1)(0)>[&];  
     
    MPA_Handle_RcvKbyte<s(1)(1)(0)>[T]             cRprtMspKByte<s(1)(1)(0)>[&];
    MPA_RcvPhyDefect<s(1)(1)(0)>[T]                cRprtMspLineCond<s(1)(1)(0)>[&];
    MPA_RprtMspStatus<s(1)(1)(0)>[T]               cRprtMspStatus<s(1)(1)(0)>[&];
     
    MST_ChangeOfKb<s(1)(1)(0)>[T]                  cRprtMsspKByte<s(1)(1)(0)>[&];
    MST_ChangeOfLineCond<s(1)(1)(0)>[T]            cRprtMsspLineCond<s(1)(1)(0)>[&];
     
    MSA_ChangeKbyteBatch<s(1)(1)(0)>[T]            cRprtMsspKByteBatch<s(1)(1)(0)>[&];
    MSA_ChangeLineCondBatch<s(1)(1)(0)>[T]         cRprtMsspLineCondBatch<s(1)(1)(0)>[&];
     
    SPA_DrvIntHappenFunc<s(1)(1)(0)>[T]            cRprtSpaDrvIntHappen<s(1)(1)(0)>[&]; 
    SPA_ReportSncpStateFunc<s(1)(1)(0)>[T]         cRprtSpaSncpState<s(1)(1)(0)>[&];
     
    TMH_InitCCFPGAFunc<s(1)(1)(0)>[T]              cRprtCcInitToTmh<s(1)(1)(0)>[&];
    TMH_SwitchHOCCFunc<s(1)(1)(0)>[T]              cRptCcStateToTmh<s(1)(1)(0)>[&];
     
    GFA_RprtAlarmDetect2GmplsFunc<s(1)(1)(0)>[T]   cRprtDefectToGmpls<s(1)(1)(0)>[&];
     
    CAD_RprtUnitFail<s(1)(1)(0)>[T]                cRprtUnitFailToCAD<s(1)(1)(0)>[&];
}CTD_CALLBACKS_T<s(0)(0)(0)>[&];(D1:CTD_CALLBACKS_T:1)[[TYPENAME:CTD_CALLBACKS_T]]

 
typedef enum
{
    CTD_MSG_TYPE_INT<s(0)(0)(0)>[&]        = 0x0,
    CTD_MSG_TYPE_POLLING<s(0)(0)(0)>[&]    = 0x1,
    CTD_MSG_TYPE_1HZINT<s(0)(0)(0)>[&]     = 0x2,
    CTD_MSG_TYPE_LATCH<s(0)(0)(0)>[&]      = 0x3,
}CTD_MSG_TYPE_T<s(0)(0)(0)>[&];(D1:CTD_MSG_TYPE_T:1)[[TYPENAME:CTD_MSG_TYPE_T]]

 
typedef struct
{
    ENTITY_T<s(1)(1)(0)>[T]            etEntity<s(1)(1)(0)>[&];
    DWORD<s(1)(1)(0)>[T]               dwPos<s(1)(1)(0)>[&];
    CTD_MSG_TYPE_T<s(1)(1)(0)>[T]      eMsgType<s(1)(1)(0)>[&];
}CTD_MSG_DATA_T<s(0)(0)(0)>[&];(D1:CTD_MSG_DATA_T:1)[[TYPENAME:CTD_MSG_DATA_T]]

 
typedef enum
{
    CTD_SNCP_SIG_DIR_UNKNOWN<s(0)(0)(0)>[&]    = 0x0,
    CTD_SNCP_SIG_DIR_SOURCE<s(0)(0)(0)>[&]     = 0x1,
    CTD_SNCP_SIG_DIR_SINK<s(0)(0)(0)>[&]       = 0x2,
    CTD_SNCP_SIG_DIR_BIDRECTION<s(0)(0)(0)>[&] = 0x3,
}CTD_SNCP_SIG_DIR_T<s(0)(0)(0)>[&];(D1:CTD_SNCP_SIG_DIR_T:1)[[TYPENAME:CTD_SNCP_SIG_DIR_T]]

 
typedef enum
{
    CTD_SNCP_CMD_UNKNOWN<s(0)(0)(0)>[&]        = 0x0,
    CTD_SNCP_CMD_CLEAR<s(0)(0)(0)>[&]          = 0x1,
    CTD_SNCP_LOCK_OUT<s(0)(0)(0)>[&]           = 0x2,
    CTD_SNCP_FORCE_SWITCH_TOP<s(0)(0)(0)>[&]   = 0x3,
    CTD_SNCP_FORCE_SWITCH_TOW<s(0)(0)(0)>[&]   = 0x4,
    CTD_SNCP_MANUAL_SWITCH_TOP<s(0)(0)(0)>[&]  = 0x5,
    CTD_SNCP_MANUAL_SWITCH_TOW<s(0)(0)(0)>[&]  = 0x6,
    CTD_SNCP_NO_COMMAND<s(0)(0)(0)>[&]         = 0x7,
}CTD_SNCP_CMD_TYPE_T<s(0)(0)(0)>[&];(D1:CTD_SNCP_CMD_TYPE_T:1)[[TYPENAME:CTD_SNCP_CMD_TYPE_T]] 

 
typedef enum 
{
    CTD_SNCP_MODE_UNKNOWN<s(0)(0)(0)>[&]       = 0x0,
    CTD_SNCP_MODE_REVERTIVE<s(0)(0)(0)>[&]     = 0x1,
    CTD_SNCP_MODE_NONREVERTIVE<s(0)(0)(0)>[&]  = 0x2,
} CTD_SNCP_MODE_T<s(0)(0)(0)>[&];(D1:CTD_SNCP_MODE_T:1)[[TYPENAME:CTD_SNCP_MODE_T]]

 
typedef enum 
{
    CTD_SNCP_REQ_CLEAR<s(0)(0)(0)>[&]              = 0x1,
    CTD_SNCP_REQ_LOCKOUT<s(0)(0)(0)>[&]            = 0x2,
    CTD_SNCP_REQ_FORCE_SWITCH_TOP<s(0)(0)(0)>[&]   = 0x3,
    CTD_SNCP_REQ_FORCE_SWITCH_TOW<s(0)(0)(0)>[&]   = 0x4,
    CTD_SNCP_REQ_SIGNAL_FAIL<s(0)(0)(0)>[&]        = 0x5,
    CTD_SNCP_REQ_MANUAL_SWITCH_TOP<s(0)(0)(0)>[&]  = 0x6,
    CTD_SNCP_REQ_MANUAL_SWITCH_TOW<s(0)(0)(0)>[&]  = 0x7,
    CTD_SNCP_REQ_WAIT_TO_RESTORE<s(0)(0)(0)>[&]    = 0x8,
    CTD_SNCP_REQ_NO_REQUEST<s(0)(0)(0)>[&]         = 0x9,
    CTD_SNCP_REQ_SIGNAL_DEG<s(0)(0)(0)>[&]         = 0xa,
} CTD_SNCP_REQ_TYPE_T<s(0)(0)(0)>[&];(D1:CTD_SNCP_REQ_TYPE_T:1)[[TYPENAME:CTD_SNCP_REQ_TYPE_T]]

 
typedef enum 
{
    CTD_SNCP_CMD_RSLT_SUCC<s(0)(0)(0)>[&]              = 0x1,
    CTD_SNCP_CMD_RSLT_LOWPRIORITY<s(0)(0)(0)>[&]       = 0x2,
    CTD_SNCP_CMD_RSLT_SWITCH_TO_ACTIVE<s(0)(0)(0)>[&]  = 0x3,
    CTD_SNCP_CMD_SWITCH_FAIL<s(0)(0)(0)>[&]            = 0x4,
    CTD_SNCP_CMD_SWITCH_TIMEOUT<s(0)(0)(0)>[&]         = 0x5,
    CTD_SNCP_CMD_WAIT_CC_RSP<s(0)(0)(0)>[&]            = 0x6,
    CTD_SNCP_BAD_COMMAND<s(0)(0)(0)>[&]                = 0x7,
} CTD_SNCP_CMD_RSLT_T<s(0)(0)(0)>[&];(D1:CTD_SNCP_CMD_RSLT_T:1)[[TYPENAME:CTD_SNCP_CMD_RSLT_T]]

 
typedef enum 
{
    CTD_SNCP_STATE_ACTIVE<s(0)(0)(0)>[&]  = 0x1,
    CTD_SNCP_STATE_STANDBY<s(0)(0)(0)>[&] = 0x2,
} CTD_SNCP_CHL_STATE_T<s(0)(0)(0)>[&];(D1:CTD_SNCP_CHL_STATE_T:1)[[TYPENAME:CTD_SNCP_CHL_STATE_T]]

 
typedef enum 
{
    CTD_SNCP_RSN_CLEAR_CMD<s(0)(0)(0)>[&]         = 0x1,
    CTD_SNCP_RSN_LP_CMD<s(0)(0)(0)>[&]            = 0x2,
    CTD_SNCP_RSN_FORCED_SWITCH<s(0)(0)(0)>[&]     = 0x3,
    CTD_SNCP_RSN_MANUAL_SWITCH<s(0)(0)(0)>[&]     = 0x4,
    CTD_SNCP_RSN_SIGNAL_FAIL<s(0)(0)(0)>[&]       = 0x5,
    CTD_SNCP_RSN_SIGNAL_FAIL_CLEAR<s(0)(0)(0)>[&] = 0x6,
    CTD_SNCP_RSN_NO_SWITCH<s(0)(0)(0)>[&]         = 0x7,
    CTD_SNCP_RSN_SIGNAL_DEG<s(0)(0)(0)>[&]        = 0x8,
    CTD_SNCP_RSN_SIGNAL_DEG_CLEAR<s(0)(0)(0)>[&]  = 0x9,
} CTD_SNCP_SWITCH_RSN_T<s(0)(0)(0)>[&];(D1:CTD_SNCP_SWITCH_RSN_T:1)[[TYPENAME:CTD_SNCP_SWITCH_RSN_T]]

 
typedef struct
{
     
    BOOL<s(1)(1)(0)>[T]                bResult<s(1)(1)(0)>[&];
     
    SNCP_SIGNAL_STATE_T<s(1)(1)(0)>[T] eWorkState<s(1)(1)(0)>[&];
    SNCP_SIGNAL_STATE_T<s(1)(1)(0)>[T] eProtState<s(1)(1)(0)>[&];
     
    CTD_SNCP_REQ_TYPE_T<s(1)(1)(0)>[T] eCmdReq<s(1)(1)(0)>[&];
}CTD_SNCP_STATE_T<s(0)(0)(0)>[&];(D1:CTD_SNCP_STATE_T:1)[[TYPENAME:CTD_SNCP_STATE_T]]




 




 

 


 

 

 

 

 

 


 


 

 


typedef enum
{
    CAH_DEBUG_LEVEL_ERROR<s(0)(0)(0)>[&]       =   0,
    CAH_DEBUG_LEVEL_CFGSET<s(0)(0)(0)>[&]      =   1,
    CAH_DEBUG_LEVEL_CFGGET<s(0)(0)(0)>[&]      =   2,
    CAH_DEBUG_LEVEL_INIT<s(0)(0)(0)>[&]        =   3,
    CAH_DEBUG_LEVEL_INT<s(0)(0)(0)>[&]         =   4,
    CAH_DEBUG_LEVEL_OP<s(0)(0)(0)>[&]          =   5,
    CAH_DEBUG_LEVEL_PMON<s(0)(0)(0)>[&]        =   6,
    CAH_DEBUG_LEVEL_CLOCK<s(0)(0)(0)>[&]       =   7,
    CAH_DEBUG_LEVEL_SNCP<s(0)(0)(0)>[&]        =   8,
    CAH_DEBUG_LEVEL_MSP<s(0)(0)(0)>[&]         =   9,
    CAH_DEBUG_LEVEL_MSSP<s(0)(0)(0)>[&]        =   10,
    CAH_DEBUG_LEVEL_ALARM<s(0)(0)(0)>[&]       =   11
}CAH_DBG_LEVEL_T<s(0)(0)(0)>[&];(D1:CAH_DBG_LEVEL_T:1)[[TYPENAME:CAH_DBG_LEVEL_T]]





 





 





 
typedef enum
{
    CAH_REG_ATTRBT_RW<s(0)(0)(0)>[&]       =   0x0,
    CAH_REG_ATTRBT_RO<s(0)(0)(0)>[&]       =   0x1,
    CAH_REG_ATTRBT_WO<s(0)(0)(0)>[&]       =   0x2,
    CAH_REG_ATTRBT_RC<s(0)(0)(0)>[&]       =   0x3,
    CAH_REG_ATTRBT_WC<s(0)(0)(0)>[&]       =   0x4,
}CAH_REG_ATTRBT_T<s(0)(0)(0)>[&];(D1:CAH_REG_ATTRBT_T:1)[[TYPENAME:CAH_REG_ATTRBT_T]]

 
typedef struct
{
    DWORD<s(1)(1)(0)>[T]             dwBaseOffset<s(1)(1)(0)>[&];
    BYTE<s(1)(1)(0)>[T]              bySimRegNum<s(1)(1)(0)>[&];
    DWORD<s(1)(1)(0)>[T]             dwSimRegInterval<s(1)(1)(0)>[&];
    WORD<s(1)(1)(0)>[T]              wValue<s(1)(1)(0)>[&];
    WORD<s(1)(1)(0)>[T]              wMask<s(1)(1)(0)>[&];
    CAH_REG_ATTRBT_T<s(1)(1)(0)>[T]  eRegAttrbt<s(1)(1)(0)>[&];
    WORD<s(1)(1)(0)>[T]              wDelayTime<s(1)(1)(0)>[&];
}CAH_INIT_TABLE_T<s(0)(0)(0)>[&];(D1:CAH_INIT_TABLE_T:1)[[TYPENAME:CAH_INIT_TABLE_T]]

 
typedef struct
{
    DWORD<s(1)(1)(0)>[T]     dwBaseOffset<s(1)(1)(0)>[&];
    BYTE<s(1)(1)(0)>[T]      bySimRegNum<s(1)(1)(0)>[&];
    DWORD<s(1)(1)(0)>[T]     dwSimRegInterval<s(1)(1)(0)>[&];
    WORD<s(1)(1)(0)>[T]      wValue<s(1)(1)(0)>[&];
    WORD<s(1)(1)(0)>[T]      wMask<s(1)(1)(0)>[&];
}CAH_STATE_CHECK_TABLE_T<s(0)(0)(0)>[&];(D1:CAH_STATE_CHECK_TABLE_T:1)[[TYPENAME:CAH_STATE_CHECK_TABLE_T]]

 
typedef struct
{
    DWORD<s(1)(1)(0)>[T]  dwPeriodMsSet<s(1)(1)(0)>[&];
    DWORD<s(1)(1)(0)>[T]  dwPeriodMsClear<s(1)(1)(0)>[&];
    WORD<s(1)(1)(0)>[T]   wThreshSet<s(1)(1)(0)>[&];
    WORD<s(1)(1)(0)>[T]   wThreshClear<s(1)(1)(0)>[&];
}CAH_B2_THRESHOLD_T<s(0)(0)(0)>[&];(D1:CAH_B2_THRESHOLD_T:1)[[TYPENAME:CAH_B2_THRESHOLD_T]]

 
typedef struct
{
    ENTITY_T<s(1)(1)(0)>[T]             dwEntityNo<s(1)(1)(0)>[&];
    DWORD<s(1)(1)(0)>[T]                dwBaseAddr<s(1)(1)(0)>[&];
    CTD_MODE_TYPE_T<s(1)(1)(0)>[T]      ePortType<s(1)(1)(0)>[&][0x7e ];
}CAH_CFG_INFO_T<s(0)(0)(0)>[&];(D1:CAH_CFG_INFO_T:1)[[TYPENAME:CAH_CFG_INFO_T]]

 
extern  WORD<s(0)(0)(0)>[T] cah_WriteRegister<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwBaseAddr<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] dwOffset<s(0)(0)(0)>[&], WORD<s(0)(0)(0)>[T] wValue<s(0)(0)(0)>[&], WORD<s(0)(0)(0)>[T] wMask<s(0)(0)(0)>[&], CAH_REG_ATTRBT_T<s(0)(0)(0)>[T] eRegAttrbt<s(0)(0)(0)>[&]);(D1:eRegAttrbt:0)
extern  WORD<s(0)(0)(0)>[T] cah_ReadRegister<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwBaseAddr<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] dwOffset<s(0)(0)(0)>[&], WORD<s(0)(0)(0)>[T]* pwValue<s(0)(0)(0)>[&], WORD<s(0)(0)(0)>[T] wMask<s(0)(0)(0)>[&], CAH_REG_ATTRBT_T<s(0)(0)(0)>[T] eRegAttrbt<s(0)(0)(0)>[&]);(D1:eRegAttrbt:0)
extern  WORD<s(0)(0)(0)>[T] cah_PollBusyBit<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwBaseAddr<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] dwOffset<s(0)(0)(0)>[&]);(D1:dwOffset:0)
extern  WORD<s(0)(0)(0)>[T] cah_IndWrite<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwBaseAddr<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] dwAddrIndAddr<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] dwAddrIndData<s(0)(0)(0)>[&], WORD<s(0)(0)(0)>[T] wAddr<s(0)(0)(0)>[&], WORD<s(0)(0)(0)>[T] wValue<s(0)(0)(0)>[&], WORD<s(0)(0)(0)>[T] wMaskval<s(0)(0)(0)>[&], WORD<s(0)(0)(0)>[T] wMaskaddr<s(0)(0)(0)>[&]);(D1:wMaskaddr:0)
extern  WORD<s(0)(0)(0)>[T] cah_IndRead<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwBaseAddr<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] dwAddrIndAddr<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] dwAddrIndData<s(0)(0)(0)>[&], WORD<s(0)(0)(0)>[T] wAddr<s(0)(0)(0)>[&], WORD<s(0)(0)(0)>[T] *pwValue<s(0)(0)(0)>[&], WORD<s(0)(0)(0)>[T] wMaskval<s(0)(0)(0)>[&], WORD<s(0)(0)(0)>[T] wMaskaddr<s(0)(0)(0)>[&]);(D1:wMaskaddr:0)
extern  WORD<s(0)(0)(0)>[T] cah_IndWriteQuick<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwBaseAddr<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] dwAddrIndAddr<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] dwAddrIndData<s(0)(0)(0)>[&], WORD<s(0)(0)(0)>[T] wAddr<s(0)(0)(0)>[&], WORD<s(0)(0)(0)>[T] wValue<s(0)(0)(0)>[&], WORD<s(0)(0)(0)>[T] wMaskval<s(0)(0)(0)>[&], WORD<s(0)(0)(0)>[T] wMaskaddr<s(0)(0)(0)>[&]);(D1:wMaskaddr:0)
extern  WORD<s(0)(0)(0)>[T] cah_IndReadQuick<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwBaseAddr<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] dwAddrIndAddr<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] dwAddrIndData<s(0)(0)(0)>[&], WORD<s(0)(0)(0)>[T] wAddr<s(0)(0)(0)>[&], WORD<s(0)(0)(0)>[T] *pwValue<s(0)(0)(0)>[&], WORD<s(0)(0)(0)>[T] wMaskval<s(0)(0)(0)>[&], WORD<s(0)(0)(0)>[T] wMaskaddr<s(0)(0)(0)>[&]);(D1:wMaskaddr:0)
extern  WORD<s(0)(0)(0)>[T] cah_Write8Reg<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwBaseAddr<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] dwOffset<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byValue<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byMask<s(0)(0)(0)>[&], CAH_REG_ATTRBT_T<s(0)(0)(0)>[T] eRegAttrbt<s(0)(0)(0)>[&]);(D1:eRegAttrbt:0)
extern  WORD<s(0)(0)(0)>[T] cah_Read8Reg<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwBaseAddr<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] dwOffset<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] *pbyValue<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byMask<s(0)(0)(0)>[&], CAH_REG_ATTRBT_T<s(0)(0)(0)>[T] eRegAttrbt<s(0)(0)(0)>[&]);(D1:eRegAttrbt:0)
extern  WORD<s(0)(0)(0)>[T] cah_Write32Reg<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwBaseAddr<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] dwOffset<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] dwValue<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] dwMask<s(0)(0)(0)>[&], CAH_REG_ATTRBT_T<s(0)(0)(0)>[T] eRegAttrbt<s(0)(0)(0)>[&]);(D1:eRegAttrbt:0)
extern  WORD<s(0)(0)(0)>[T] cah_Read32Reg<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwBaseAddr<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] dwOffset<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] *pdwValue<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] dwMask<s(0)(0)(0)>[&], CAH_REG_ATTRBT_T<s(0)(0)(0)>[T] eRegAttrbt<s(0)(0)(0)>[&]);(D1:eRegAttrbt:0)
extern  WORD<s(0)(0)(0)>[T] cah_Stm4TpConvert<s(0)(0)(0)>[&](CTD_MODE_TYPE_T<s(0)(0)(0)>[T] ePortType<s(0)(0)(0)>[&], COMPACT_TP_T<s(0)(0)(0)>[T] tpId<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] *byAug1No<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] *byAu3No<s(0)(0)(0)>[&]);(D1:byAu3No:0)
extern  WORD<s(0)(0)(0)>[T] cah_Stm16TpConvert<s(0)(0)(0)>[&](CTD_MODE_TYPE_T<s(0)(0)(0)>[T] ePortType<s(0)(0)(0)>[&], COMPACT_TP_T<s(0)(0)(0)>[T] tpId<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] *byAug4No<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] *byAug1No<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] *byAu3No<s(0)(0)(0)>[&]);(D1:byAu3No:0)
extern  WORD<s(0)(0)(0)>[T] cah_Stm64TpConvert<s(0)(0)(0)>[&](CTD_MODE_TYPE_T<s(0)(0)(0)>[T] ePortType<s(0)(0)(0)>[&], COMPACT_TP_T<s(0)(0)(0)>[T] tpId<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] *byAug16No<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] *byAug4No<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] *byAug1No<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] *byAu3No<s(0)(0)(0)>[&]);(D1:byAu3No:0)
extern  WORD<s(0)(0)(0)>[T] cah_Stm256TpConvert<s(0)(0)(0)>[&](CTD_MODE_TYPE_T<s(0)(0)(0)>[T] ePortType<s(0)(0)(0)>[&], COMPACT_TP_T<s(0)(0)(0)>[T] tpId<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] *byAug64No<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] *byAug16No<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] *byAug4No<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] *byAug1No<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] *byAu3No<s(0)(0)(0)>[&]);(D1:byAu3No:0)
extern  DWORD<s(0)(0)(0)>[T] CAH_GetCardBaseAddr<s(0)(0)(0)>[&](CARDTYPE_T<s(0)(0)(0)>[T] eCardType<s(0)(0)(0)>[&]);(D1:eCardType:0)

 
extern  DBG_MODULE_T<s(0)(0)(0)>[T]       gCahDbgModuleNo<s(0)(0)(0)>[&];(D1:gCahDbgModuleNo:0)
extern  CAH_B2_THRESHOLD_T<s(0)(0)(0)>[T] gCahStm1B2Threshold<s(0)(0)(0)>[&][0x9  - 0x3  + 1];(D1:gCahStm1B2Threshold:0)
extern  CAH_B2_THRESHOLD_T<s(0)(0)(0)>[T] gCahStm4B2Threshold<s(0)(0)(0)>[&][0x9  - 0x3  + 1];(D1:gCahStm4B2Threshold:0)
extern  CAH_B2_THRESHOLD_T<s(0)(0)(0)>[T] gCahStm16B2Threshold<s(0)(0)(0)>[&][0x9  - 0x3  + 1];(D1:gCahStm16B2Threshold:0)
extern  CAH_B2_THRESHOLD_T<s(0)(0)(0)>[T] gCahStm64B2Threshold<s(0)(0)(0)>[&][0x9  - 0x3  + 1];(D1:gCahStm64B2Threshold:0)
extern  CAH_B2_THRESHOLD_T<s(0)(0)(0)>[T] gCahStm256B2Threshold<s(0)(0)(0)>[&][0x9  - 0x3  + 1];(D1:gCahStm256B2Threshold:0)

 
extern  int sysClkRateGet<s(0)(0)(0)>[&](void);(D1:sysClkRateGet:0)
extern  STATUS<s(0)(0)(0)>[T] taskDelay<s(0)(0)(0)>[&](int ticks<s(0)(0)(0)>[&]);(D1:ticks:0)
extern  UINT32<s(0)(0)(0)>[T] sysTimestampFreq<s(0)(0)(0)>[&](void);(D1:sysTimestampFreq:0)




 






















 





















 
 

 

 

 


























 

 

 
















union sigval<s(1)(0)(1)>[&]
    {
    int			sival_int<s(1)(1)(0)>[&];
    void		*sival_ptr<s(1)(1)(0)>[&];
    };

struct sigevent<s(1)(0)(1)>[&]
    {
    int			sigev_signo<s(1)(1)(0)>[&];
    union sigval<s(2)(1)(1)>[&]	sigev_value<s(2)(1)(1)>[&];
    int			sigev_notify<s(1)(1)(0)>[&];
    };













typedef struct __timer<s(1)(0)(1)>[&] *timer_t<s(0)(0)(0)>[&] ;(D1:timer_t:1)[[TYPENAME:timer_t]]




typedef unsigned int clock_t<s(0)(0)(0)>[&] ;(D1:clock_t:1)[[TYPENAME:clock_t]]








typedef int clockid_t<s(0)(0)(0)>[&];(D1:clockid_t:1)[[TYPENAME:clockid_t]]





struct tm<s(1)(0)(1)>[&]
	{
	int tm_sec<s(1)(1)(0)>[&];	 
	int tm_min<s(1)(1)(0)>[&];	 
	int tm_hour<s(1)(1)(0)>[&];	 
	int tm_mday<s(1)(1)(0)>[&];	 
	int tm_mon<s(1)(1)(0)>[&];	 
	int tm_year<s(1)(1)(0)>[&];	 
	int tm_wday<s(1)(1)(0)>[&];	 
	int tm_yday<s(1)(1)(0)>[&];	 
	int tm_isdst<s(1)(1)(0)>[&];	 
	};

struct timespec<s(1)(0)(1)>[&]
    {
    					 
    time_t<s(1)(1)(0)>[T] tv_sec<s(1)(1)(0)>[&];			 
    long tv_nsec<s(1)(1)(0)>[&];			 
    };

struct itimerspec<s(1)(0)(1)>[&]
    {
    struct timespec<s(2)(1)(1)>[&] it_interval<s(2)(1)(1)>[&];	 
    struct timespec<s(2)(1)(1)>[&] it_value<s(2)(1)(1)>[&];		 
    };






 



extern uint_t<s(0)(0)(0)>[T]      _clocks_per_sec<s(0)(0)(0)>[&](void);(D1:_clocks_per_sec:0)
extern char *	   asctime<s(0)(0)(0)>[&] (const struct tm<s(1)(0)(1)>[&] *_tptr<s(0)(0)(0)>[&]);(D1:_tptr:0)
extern clock_t<s(0)(0)(0)>[T]	   clock<s(0)(0)(0)>[&] (void);(D1:clock:0)
extern char *	   ctime<s(0)(0)(0)>[&] (const time_t<s(0)(0)(0)>[T] *_cal<s(0)(0)(0)>[&]);(D1:_cal:0)
extern double	   difftime<s(0)(0)(0)>[&] (time_t<s(0)(0)(0)>[T] _t1<s(0)(0)(0)>[&], time_t<s(0)(0)(0)>[T] _t0<s(0)(0)(0)>[&]);(D1:_t0:0)
extern struct tm<s(1)(0)(1)>[&] * gmtime<s(0)(0)(0)>[&] (const time_t<s(0)(0)(0)>[T] *_tod<s(0)(0)(0)>[&]);(D1:_tod:0)
extern struct tm<s(1)(0)(1)>[&] * localtime<s(0)(0)(0)>[&] (const time_t<s(0)(0)(0)>[T] *_tod<s(0)(0)(0)>[&]);(D1:_tod:0)
extern time_t<s(0)(0)(0)>[T]	   mktime<s(0)(0)(0)>[&] (struct tm<s(1)(0)(1)>[&] *_tptr<s(0)(0)(0)>[&]);(D1:_tptr:0)
extern size_t<s(0)(0)(0)>[T]	   strftime<s(0)(0)(0)>[&] (char *_s<s(0)(0)(0)>[&], size_t<s(0)(0)(0)>[T] _n<s(0)(0)(0)>[&], const char *_format<s(0)(0)(0)>[&],
		   	      const struct tm<s(1)(0)(1)>[&] *_tptr<s(0)(0)(0)>[&]);(D1:_tptr:0)
extern time_t<s(0)(0)(0)>[T]	   time<s(0)(0)(0)>[&] (time_t<s(0)(0)(0)>[T] *_tod<s(0)(0)(0)>[&]);(D1:_tod:0)

extern int 	clock_gettime<s(0)(0)(0)>[&] (clockid_t<s(0)(0)(0)>[T] clock_id<s(0)(0)(0)>[&], struct timespec<s(1)(0)(1)>[&] *tp<s(0)(0)(0)>[&]);(D1:tp:0)
extern int 	clock_settime<s(0)(0)(0)>[&] (clockid_t<s(0)(0)(0)>[T] clock_id<s(0)(0)(0)>[&], const struct timespec<s(1)(0)(1)>[&] *tp<s(0)(0)(0)>[&]);(D1:tp:0)
extern int 	clock_getres<s(0)(0)(0)>[&] (clockid_t<s(0)(0)(0)>[T] clock_id<s(0)(0)(0)>[&], struct timespec<s(1)(0)(1)>[&] *res<s(0)(0)(0)>[&]);(D1:res:0)

extern int 	timer_create<s(0)(0)(0)>[&] (clockid_t<s(0)(0)(0)>[T] clock_id<s(0)(0)(0)>[&], struct sigevent<s(1)(0)(1)>[&] *evp<s(0)(0)(0)>[&],
			      timer_t<s(0)(0)(0)>[T] *ptimer<s(0)(0)(0)>[&]);(D1:ptimer:0)
extern int 	timer_delete<s(0)(0)(0)>[&] (timer_t<s(0)(0)(0)>[T] timerid<s(0)(0)(0)>[&]);(D1:timerid:0)
extern int 	timer_gettime<s(0)(0)(0)>[&] (timer_t<s(0)(0)(0)>[T] timerid<s(0)(0)(0)>[&], struct itimerspec<s(1)(0)(1)>[&] *value<s(0)(0)(0)>[&]);(D1:value:0)
extern int 	timer_settime<s(0)(0)(0)>[&] (timer_t<s(0)(0)(0)>[T] timerid<s(0)(0)(0)>[&], int flags<s(0)(0)(0)>[&],
		               const struct itimerspec<s(1)(0)(1)>[&] *value<s(0)(0)(0)>[&],
			       struct itimerspec<s(1)(0)(1)>[&] *ovalue<s(0)(0)(0)>[&]);(D1:ovalue:0)
extern int 	timer_getoverrun<s(0)(0)(0)>[&] (timer_t<s(0)(0)(0)>[T] timerid<s(0)(0)(0)>[&]);(D1:timerid:0)

extern int      timer_connect<s(0)(0)(0)>[&] (timer_t<s(0)(0)(0)>[T] timerid<s(0)(0)(0)>[&], VOIDFUNCPTR<s(0)(0)(0)>[T] routine<s(0)(0)(0)>[&], int arg<s(0)(0)(0)>[&]);(D1:arg:0)
extern int      timer_cancel<s(0)(0)(0)>[&] (timer_t<s(0)(0)(0)>[T] timerid<s(0)(0)(0)>[&]);(D1:timerid:0)
extern int      timer_show<s(0)(0)(0)>[&] (timer_t<s(0)(0)(0)>[T] timerid<s(0)(0)(0)>[&]);(D1:timerid:0)

extern int 	nanosleep<s(0)(0)(0)>[&] (const struct timespec<s(1)(0)(1)>[&] *rqtp<s(0)(0)(0)>[&], struct timespec<s(1)(0)(1)>[&] *rmtp<s(0)(0)(0)>[&]);(D1:rmtp:0)




extern int	   asctime_r<s(0)(0)(0)>[&](const struct tm<s(1)(0)(1)>[&] *_tm<s(0)(0)(0)>[&], char *_buffer<s(0)(0)(0)>[&],
			     size_t<s(0)(0)(0)>[T] *_buflen<s(0)(0)(0)>[&]);(D1:_buflen:0)
extern char *	   ctime_r<s(0)(0)(0)>[&] (const time_t<s(0)(0)(0)>[T] *_cal<s(0)(0)(0)>[&], char *_buffer<s(0)(0)(0)>[&], size_t<s(0)(0)(0)>[T] *_buflen<s(0)(0)(0)>[&]);(D1:_buflen:0)
extern int	   gmtime_r<s(0)(0)(0)>[&] (const time_t<s(0)(0)(0)>[T] *_tod<s(0)(0)(0)>[&], struct tm<s(1)(0)(1)>[&] *_result<s(0)(0)(0)>[&]);(D1:_result:0)
extern int	   localtime_r<s(0)(0)(0)>[&] (const time_t<s(0)(0)(0)>[T] *_tod<s(0)(0)(0)>[&], struct tm<s(1)(0)(1)>[&] *_result<s(0)(0)(0)>[&]);(D1:_result:0)





























 














 





 




































 






 









 







 









 



 









                                

























 














































 















































 

















































































                                    






































































































































 


extern int i2c_debug<s(0)(0)(0)>[&];(D1:i2c_debug:0)





	
 







typedef struct {
    int addr<s(1)(1)(0)>[&];
	int maxChannelNum<s(1)(1)(0)>[&];
} I2C_MUX_ADDR_TBL_T<s(0)(0)(0)>[&];(D1:I2C_MUX_ADDR_TBL_T:1)[[TYPENAME:I2C_MUX_ADDR_TBL_T]]



typedef enum {
	I2C_ACCESS_OK<s(0)(0)(0)>[&]    = 0,
	I2C_BUS_ERROR<s(0)(0)(0)>[&]    = 0x1000,      
	I2C_BUS_TIMEOUT<s(0)(0)(0)>[&]  = 0x2000,    
	I2C_ERROR_UNKNOWN<s(0)(0)(0)>[&]= 0x4000
} I2C_ERROR_TYPE<s(0)(0)(0)>[&];(D1:I2C_ERROR_TYPE:1)[[TYPENAME:I2C_ERROR_TYPE]]     

typedef struct {
    int          valid<s(1)(1)(0)>[&];        
	int          taskId<s(1)(1)(0)>[&];       
	const char * pTaskName<s(1)(1)(0)>[&];    
    const char * pCaller<s(1)(1)(0)>[&];      
    const char * pCallerFile<s(1)(1)(0)>[&]; 
    int          callerLine<s(1)(1)(0)>[&];  
    int          muxAddr<s(1)(1)(0)>[&];      
    int          channel<s(1)(1)(0)>[&];      
} I2C_BUS_CHANNEL_STATUS<s(0)(0)(0)>[&];(D1:I2C_BUS_CHANNEL_STATUS:1)[[TYPENAME:I2C_BUS_CHANNEL_STATUS]]

typedef struct {
    int               valid<s(1)(1)(0)>[&];              
    int               taskId<s(1)(1)(0)>[&];             
    const char *      pTaskName<s(1)(1)(0)>[&];          
    int               devAddr<s(1)(1)(0)>[&];            
    const char *      pCaller<s(1)(1)(0)>[&];            
    const char *      pCallerFile<s(1)(1)(0)>[&];        
    int               callerLine<s(1)(1)(0)>[&];         
    struct tm<s(2)(1)(1)>[&]        currTime<s(2)(1)(1)>[&];           
    I2C_ERROR_TYPE<s(1)(1)(0)>[T]    reason<s(1)(1)(0)>[&];             
	                                       
	                                       
										  
    int               times<s(1)(1)(0)>[&];              
} I2C_BUS_ERR_RECORD<s(0)(0)(0)>[&];(D1:I2C_BUS_ERR_RECORD:1)[[TYPENAME:I2C_BUS_ERR_RECORD]]  

typedef struct {
    int               isSemInUse<s(1)(1)(0)>[&];          
    SEM_ID<s(1)(1)(0)>[T]            selfID<s(1)(1)(0)>[&];              
    int               taskId<s(1)(1)(0)>[&];              
    const char *      pTaskName<s(1)(1)(0)>[&];           
    const char *      pSemOwner<s(1)(1)(0)>[&];           
    const char *      pSemOwnerFile<s(1)(1)(0)>[&];      
    int               semOwnerLine<s(1)(1)(0)>[&];       
    int               semForMuxAddr<s(1)(1)(0)>[&];      
    int               semTimeOut<s(1)(1)(0)>[&];          
    int               semCounter<s(1)(1)(0)>[&];          
} I2C_SEM_RECORD<s(0)(0)(0)>[&];(D1:I2C_SEM_RECORD:1)[[TYPENAME:I2C_SEM_RECORD]]        





typedef struct {
    int          valid<s(1)(1)(0)>[&];            
	int          taskId<s(1)(1)(0)>[&];           
	const char * pTaskName<s(1)(1)(0)>[&];       
} I2C_SEM_OVERTIME_RECORD_ITEM<s(0)(0)(0)>[&];(D1:I2C_SEM_OVERTIME_RECORD_ITEM:1)[[TYPENAME:I2C_SEM_OVERTIME_RECORD_ITEM]]   

typedef struct {
	int          nextItem<s(1)(1)(0)>[&];           
	I2C_SEM_OVERTIME_RECORD_ITEM<s(1)(1)(0)>[T] item<s(1)(1)(0)>[&][10 ];    
} I2C_SEM_OVERTIME_RECORD<s(0)(0)(0)>[&];(D1:I2C_SEM_OVERTIME_RECORD:1)[[TYPENAME:I2C_SEM_OVERTIME_RECORD]]   



typedef enum {
	I2C_RAW<s(0)(0)(0)>[&],
	I2C_RAW_BASE<s(0)(0)(0)>[&],
	I2C_BASE<s(0)(0)(0)>[&],
} I2C_OPTION<s(0)(0)(0)>[&];(D1:I2C_OPTION:1)[[TYPENAME:I2C_OPTION]]        

typedef struct {
    void *tlvDataPtr<s(1)(1)(0)>[&];
    char deviceName<s(1)(1)(0)>[&][32];
} TLV_data_t<s(0)(0)(0)>[&];(D1:TLV_data_t:1)[[TYPENAME:TLV_data_t]]


















	



 









        
 
 







       
 






















 
int i2cDrvSemTake<s(0)(0)(0)>[&](const char*pCaller<s(0)(0)(0)>[&], const char* pCallerFile<s(0)(0)(0)>[&], 
        const int callerLine<s(0)(0)(0)>[&], int muxAddr<s(0)(0)(0)>[&], int wait<s(0)(0)(0)>[&]);(D1:wait:0)
int i2cDrvSemGive<s(0)(0)(0)>[&](void);(D1:i2cDrvSemGive:0)

int tlvDrvSemTake<s(0)(0)(0)>[&](const char*pCaller<s(0)(0)(0)>[&], const char* pCallerFile<s(0)(0)(0)>[&], 
        const int callerLine<s(0)(0)(0)>[&], int wait<s(0)(0)(0)>[&]);(D1:wait:0)
int tlvDrvSemGive<s(0)(0)(0)>[&](void);(D1:tlvDrvSemGive:0)

int i2cGeneralRead<s(0)(0)(0)>[&](const char* pCaller<s(0)(0)(0)>[&], const char* pCallerFile<s(0)(0)(0)>[&],
        int callerLine<s(0)(0)(0)>[&], int fd<s(0)(0)(0)>[&], int offset<s(0)(0)(0)>[&], int address<s(0)(0)(0)>[&], char *buffer<s(0)(0)(0)>[&], int numbytes<s(0)(0)(0)>[&], int *status<s(0)(0)(0)>[&], I2C_OPTION<s(0)(0)(0)>[T] option<s(0)(0)(0)>[&]);(D1:option:0)

int i2cGeneralWrite<s(0)(0)(0)>[&](const char* pCaller<s(0)(0)(0)>[&], const char* pCallerFile<s(0)(0)(0)>[&],
        int callerLine<s(0)(0)(0)>[&], int fd<s(0)(0)(0)>[&], int offset<s(0)(0)(0)>[&], int address<s(0)(0)(0)>[&], char *buffer<s(0)(0)(0)>[&], int numbytes<s(0)(0)(0)>[&], int *status<s(0)(0)(0)>[&], I2C_OPTION<s(0)(0)(0)>[T] option<s(0)(0)(0)>[&]);(D1:option:0)

void i2cBusChannelStatusClear<s(0)(0)(0)>[&](void);(D1:i2cBusChannelStatusClear:0)
void i2cBusChannelStatusSet<s(0)(0)(0)>[&](const char* pCaller<s(0)(0)(0)>[&], const char* pCallerFile<s(0)(0)(0)>[&], int callerLine<s(0)(0)(0)>[&], 
	int muxAddr<s(0)(0)(0)>[&], int channel<s(0)(0)(0)>[&]);(D1:channel:0)

void i2cTrace<s(0)(0)(0)>[&](int level<s(0)(0)(0)>[&], char* mname<s(0)(0)(0)>[&], int line<s(0)(0)(0)>[&], char*fname<s(0)(0)(0)>[&], char* fmt<s(0)(0)(0)>[&], ...);(D1:fmt:0)

void i2cCloseDrv<s(0)(0)(0)>[&](int value<s(0)(0)(0)>[&]);(D1:value:0)  

int i2cCreate<s(0)(0)(0)>[&](char *name<s(0)(0)(0)>[&]);(D1:name:0)
int i2cDrv<s(0)(0)(0)>[&](void);(D1:i2cDrv:0)
void i2cFDClose<s(0)(0)(0)>[&](int fd<s(0)(0)(0)>[&]);(D1:fd:0)






 















 















































 


 





 


 



 


 














 
 


 






 


































































 


























extern UINT32<s(0)(0)(0)>[T] CRC32<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] LastBufCRC<s(0)(0)(0)>[&],const UINT8<s(0)(0)(0)>[T] * pBuf<s(0)(0)(0)>[&],UINT32<s(0)(0)(0)>[T] BufLength<s(0)(0)(0)>[&]);(D1:BufLength:0)


 


 

typedef enum
{
    FM_DEFECT_BIT_TYPE_UNKNOW<s(0)(0)(0)>[&]       = 0,
        
    FM_DEFECT_BIT_TYPE_STM1_LC<s(0)(0)(0)>[&]      = 1,
    FM_DEFECT_BIT_TYPE_STM1_PM<s(0)(0)(0)>[&]      = 2,
    FM_DEFECT_BIT_TYPE_STM1_LOCC<s(0)(0)(0)>[&]    = 3,
    FM_DEFECT_BIT_TYPE_STM4_LC<s(0)(0)(0)>[&]      = 4,
    FM_DEFECT_BIT_TYPE_STM4_PM<s(0)(0)(0)>[&]      = 5,
    FM_DEFECT_BIT_TYPE_STM4_LOCC<s(0)(0)(0)>[&]    = 6,
    FM_DEFECT_BIT_TYPE_STM16_LC<s(0)(0)(0)>[&]     = 7,
    FM_DEFECT_BIT_TYPE_STM16_PM<s(0)(0)(0)>[&]     = 8,
    FM_DEFECT_BIT_TYPE_STM16_LOCC<s(0)(0)(0)>[&]   = 9,
    FM_DEFECT_BIT_TYPE_STM64_LC<s(0)(0)(0)>[&]     = 10,
    FM_DEFECT_BIT_TYPE_STM64_PM<s(0)(0)(0)>[&]     = 11,
    FM_DEFECT_BIT_TYPE_STM64_LOCC<s(0)(0)(0)>[&]   = 12,
    FM_DEFECT_BIT_TYPE_STM256_LC<s(0)(0)(0)>[&]    = 13,
    FM_DEFECT_BIT_TYPE_STM256_PM<s(0)(0)(0)>[&]    = 14,
    FM_DEFECT_BIT_TYPE_STM256_LOCC<s(0)(0)(0)>[&]  = 15,
    
    FM_DEFECT_BIT_TYPE_E1<s(0)(0)(0)>[&]           = 16,
    FM_DEFECT_BIT_TYPE_E1_PM<s(0)(0)(0)>[&]        = 17,
    FM_DEFECT_BIT_TYPE_E3DS3<s(0)(0)(0)>[&]        = 18,
    FM_DEFECT_BIT_TYPE_E3DS3_PM<s(0)(0)(0)>[&]     = 19,
    
    FM_DEFECT_BIT_TYPE_LAN<s(0)(0)(0)>[&]          = 20,
    FM_DEFECT_BIT_TYPE_VWAN<s(0)(0)(0)>[&]         = 21,
    FM_DEFECT_BIT_TYPE_RPR<s(0)(0)(0)>[&]          = 22,
    FM_DEFECT_BIT_TYPE_VSTM1<s(0)(0)(0)>[&]        = 23,
    FM_DEFECT_BIT_TYPE_VSTM1_PM<s(0)(0)(0)>[&]     = 24,
    FM_DEFECT_BIT_TYPE_VSTM4<s(0)(0)(0)>[&]        = 25,
    FM_DEFECT_BIT_TYPE_VSTM4_PM<s(0)(0)(0)>[&]     = 26,
    FM_DEFECT_BIT_TYPE_VSTM16<s(0)(0)(0)>[&]       = 27,
    FM_DEFECT_BIT_TYPE_VSTM16_PM<s(0)(0)(0)>[&]    = 28,
    FM_DEFECT_BIT_TYPE_VSTM64<s(0)(0)(0)>[&]       = 29,
    FM_DEFECT_BIT_TYPE_VSTM64_PM<s(0)(0)(0)>[&]    = 30,
    
    FM_DEFECT_BIT_TYPE_OA<s(0)(0)(0)>[&]           = 31,
    
    FM_DEFECT_BIT_TYPE_SLOT<s(0)(0)(0)>[&]         = 32,
    FM_DEFECT_BIT_TYPE_NE<s(0)(0)(0)>[&]           = 33,

    FM_DEFECT_BIT_TYPE_OTU2<s(0)(0)(0)>[&]         = 34
}FM_DEFECT_BIT_TYPE_T<s(0)(0)(0)>[&];(D1:FM_DEFECT_BIT_TYPE_T:1)[[TYPENAME:FM_DEFECT_BIT_TYPE_T]]


typedef struct 
{
    BOOL<s(1)(1)(0)>[T] empty<s(1)(1)(0)>[&];
    FM_DEFECT_BIT_TYPE_T<s(1)(1)(0)>[T]  defectType<s(1)(1)(0)>[&];
    unsigned int  entity<s(1)(1)(0)>[&];
    unsigned int  instance<s(1)(1)(0)>[&];
    unsigned int  bitPos<s(1)(1)(0)>[&];
    unsigned int  index<s(1)(1)(0)>[&];
    unsigned char  state<s(1)(1)(0)>[&];            
} __attribute__ ((packed))  FMA_DEFECT_BIT_UNIT_T<s(0)(0)(0)>[&];(D1:FMA_DEFECT_BIT_UNIT_T:1)[[TYPENAME:FMA_DEFECT_BIT_UNIT_T]]


typedef struct
{
    unsigned int index<s(1)(1)(0)>[&];
    FMA_DEFECT_BIT_UNIT_T<s(1)(1)(0)>[T] *pBitUnits<s(1)(1)(0)>[&];
    int number<s(1)(1)(0)>[&];
    void *pNext<s(1)(1)(0)>[&];
} __attribute__ ((packed))  FMA_SENT_BIT_MSG<s(0)(0)(0)>[&];(D1:FMA_SENT_BIT_MSG:1)[[TYPENAME:FMA_SENT_BIT_MSG]]

typedef struct
{
   int length<s(1)(1)(0)>[&];
   void *pNext<s(1)(1)(0)>[&];
}__attribute__ ((packed))  FMA_SENT_BIT_MSG_HEAD<s(0)(0)(0)>[&];(D1:FMA_SENT_BIT_MSG_HEAD:1)[[TYPENAME:FMA_SENT_BIT_MSG_HEAD]]

typedef struct 
{
    command_tt<s(1)(1)(0)>[T] head<s(1)(1)(0)>[&];
    unsigned int index<s(1)(1)(0)>[&];
    unsigned int defectBitNumber<s(1)(1)(0)>[&];

    unsigned int crc32<s(1)(1)(0)>[&];

    FMA_DEFECT_BIT_UNIT_T<s(1)(1)(0)>[T] *pDefectTable<s(1)(1)(0)>[&];    
} FMA_FMC_DEFECT_BIT_REPORT_CMD_T<s(0)(0)(0)>[&];(D1:FMA_FMC_DEFECT_BIT_REPORT_CMD_T:1)[[TYPENAME:FMA_FMC_DEFECT_BIT_REPORT_CMD_T]]










 

  




typedef enum
{
    FM_GENERAL_TYPE_UNKOWN<s(0)(0)(0)>[&]  = 0,
    FM_GENERAL_TYPE_SDH_LC<s(0)(0)(0)>[&]  = 1,
    FM_GENERAL_TYPE_PDH<s(0)(0)(0)>[&]     = 2,
    FM_GENERAL_TYPE_DATA<s(0)(0)(0)>[&]    = 3,
    FM_GENERAL_TYPE_CC<s(0)(0)(0)>[&]      = 4,
    FM_GENERAL_TYPE_SC<s(0)(0)(0)>[&]      = 5,
    FM_GENERAL_TYPE_OA<s(0)(0)(0)>[&]      = 6,
} FM_GENERAL_TYPE_T<s(0)(0)(0)>[&];(D1:FM_GENERAL_TYPE_T:1)[[TYPENAME:FM_GENERAL_TYPE_T]]


 








typedef enum
{
    FMA_LOCATION_UNKNOW<s(0)(0)(0)>[&]    = 0,
    FMA_LOCATION_LC<s(0)(0)(0)>[&]        = 1,
    FMA_LOCATION_CC<s(0)(0)(0)>[&]        = 2,
    FMA_LOCATION_SC<s(0)(0)(0)>[&]        = 3,
    FMA_LOCATION_SI<s(0)(0)(0)>[&]        = 4,   
} FMA_CPU_LOCATION_T<s(0)(0)(0)>[&];(D1:FMA_CPU_LOCATION_T:1)[[TYPENAME:FMA_CPU_LOCATION_T]]


typedef enum
{
    FMA_START_UP_UNKNOW<s(0)(0)(0)>[&]            = 0,
    FMA_START_UP_AGENT_BOOT_UP<s(0)(0)(0)>[&]     = 1,
    FMA_START_UP_SC_BOOT_UP<s(0)(0)(0)>[&]        = 2,
} FMA_START_UP_INFO_T<s(0)(0)(0)>[&];(D1:FMA_START_UP_INFO_T:1)[[TYPENAME:FMA_START_UP_INFO_T]]

typedef struct
{
    command_tt<s(1)(1)(0)>[T] head<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T] slot<s(1)(1)(0)>[&];                   
    UINT32<s(1)(1)(0)>[T] cardStyle<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T] cardOption<s(1)(1)(0)>[&];
    FMA_START_UP_INFO_T<s(1)(1)(0)>[T] agentInform<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T] cpuLocation<s(1)(1)(0)>[&];         
    UINT8<s(1)(1)(0)>[T] type<s(1)(1)(0)>[&];                     
} FMA_FMC_AGENT_START_UP_CMD_T<s(0)(0)(0)>[&];(D1:FMA_FMC_AGENT_START_UP_CMD_T:1)[[TYPENAME:FMA_FMC_AGENT_START_UP_CMD_T]]

 
typedef struct
{
    command_tt<s(1)(1)(0)>[T] head<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T] agentSlotId<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T] option<s(1)(1)(0)>[&];
} FMA_FMC_QUERY_ALARM_PERSISENT_TIME_CMD_T<s(0)(0)(0)>[&];(D1:FMA_FMC_QUERY_ALARM_PERSISENT_TIME_CMD_T:1)[[TYPENAME:FMA_FMC_QUERY_ALARM_PERSISENT_TIME_CMD_T]]

 
typedef struct
{
    command_tt<s(1)(1)(0)>[T] head<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T] slotNo<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T] portNo<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T] portType<s(1)(1)(0)>[&];
} FMA_FMC_LOS_STATE_CHANGE_CMD_T<s(0)(0)(0)>[&];(D1:FMA_FMC_LOS_STATE_CHANGE_CMD_T:1)[[TYPENAME:FMA_FMC_LOS_STATE_CHANGE_CMD_T]]

 
typedef struct
{
    command_tt<s(1)(1)(0)>[T] head<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T] queryId<s(1)(1)(0)>[&];    
} FMA_FMC_QUERY_STATE_CMD_T<s(0)(0)(0)>[&];(D1:FMA_FMC_QUERY_STATE_CMD_T:1)[[TYPENAME:FMA_FMC_QUERY_STATE_CMD_T]]

 
typedef FMA_FMC_QUERY_STATE_CMD_T<s(0)(0)(0)>[T] FMC_FMA_QUERY_STATE_ACK_CMD_T<s(0)(0)(0)>[&];(D1:FMC_FMA_QUERY_STATE_ACK_CMD_T:1)[[TYPENAME:FMC_FMA_QUERY_STATE_ACK_CMD_T]]


 
typedef struct
{
    command_tt<s(1)(1)(0)>[T] head<s(1)(1)(0)>[&];
     
} FMA_FMM_CUTOFF_STATE_FROM_BUTTON_CMD_T<s(0)(0)(0)>[&];(D1:FMA_FMM_CUTOFF_STATE_FROM_BUTTON_CMD_T:1)[[TYPENAME:FMA_FMM_CUTOFF_STATE_FROM_BUTTON_CMD_T]]

 
typedef struct
{
    command_tt<s(1)(1)(0)>[T] head<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T] state<s(1)(1)(0)>[&];
} FMA_FMM_SUPPRESS_STATE_FROM_BUTTON_CMD_T<s(0)(0)(0)>[&];(D1:FMA_FMM_SUPPRESS_STATE_FROM_BUTTON_CMD_T:1)[[TYPENAME:FMA_FMM_SUPPRESS_STATE_FROM_BUTTON_CMD_T]]

 
typedef struct
{
    command_tt<s(1)(1)(0)>[T] head<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T] slotId<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T] portNo<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T] defectId<s(1)(1)(0)>[&];
    FMA_ALM_STATE<s(1)(1)(0)>[T] state<s(1)(1)(0)>[&];
} PMA_FMA_LAN_DEFECT_REPORT_CMD_T<s(0)(0)(0)>[&];(D1:PMA_FMA_LAN_DEFECT_REPORT_CMD_T:1)[[TYPENAME:PMA_FMA_LAN_DEFECT_REPORT_CMD_T]]

 
typedef struct
{
	command_tt<s(1)(1)(0)>[T] head<s(1)(1)(0)>[&];
	UINT32<s(1)(1)(0)>[T] slotID<s(1)(1)(0)>[&];
}FMA_FMC_LOCC_CHANGE_CMD_T<s(0)(0)(0)>[&];(D1:FMA_FMC_LOCC_CHANGE_CMD_T:1)[[TYPENAME:FMA_FMC_LOCC_CHANGE_CMD_T]]


 
typedef struct
{
    command_tt<s(1)(1)(0)>[T] head<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T] slotId<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T] portNo<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T] defectId<s(1)(1)(0)>[&];
    FMA_ALM_STATE<s(1)(1)(0)>[T] state<s(1)(1)(0)>[&];
} FMA_FMA_FAN_DEFECT_REPORT_CMD_T<s(0)(0)(0)>[&];(D1:FMA_FMA_FAN_DEFECT_REPORT_CMD_T:1)[[TYPENAME:FMA_FMA_FAN_DEFECT_REPORT_CMD_T]]





 





























typedef struct
{
    UINT32<s(1)(1)(0)>[T] slotNo<s(1)(1)(0)>[&];                
    
    INSTANCE_T<s(1)(1)(0)>[T] instance<s(1)(1)(0)>[&];          
                               
    UINT32<s(1)(1)(0)>[T] portNo<s(1)(1)(0)>[&];                
                                  
    HW_PORT_TYPE<s(1)(1)(0)>[T] portType<s(1)(1)(0)>[&];        
  
    SDH_TP_TYPE<s(1)(1)(0)>[T] tpType<s(1)(1)(0)>[&];           

    COMPACT_TP_T<s(1)(1)(0)>[T] tpIndex<s(1)(1)(0)>[&];         


    UINT32<s(1)(1)(0)>[T] defectId<s(1)(1)(0)>[&];              

    FMA_ALM_STATE<s(1)(1)(0)>[T] state<s(1)(1)(0)>[&];          

    UINT8<s(1)(1)(0)>[T] deep<s(1)(1)(0)>[&];                   
    
} FM_SET_DEFECT_INFRMATION_T<s(0)(0)(0)>[&];(D1:FM_SET_DEFECT_INFRMATION_T:1)[[TYPENAME:FM_SET_DEFECT_INFRMATION_T]]

 







typedef enum
{
    FM_DEFECT_TYPE_NONE<s(0)(0)(0)>[&]    = 0, 
    FM_DEFECT_TYPE_LC<s(0)(0)(0)>[&]      = 1,
    FM_DEFECT_TYPE_LOCC<s(0)(0)(0)>[&]    = 2,
    FM_DEFECT_TYPE_DATA<s(0)(0)(0)>[&]    = 3,
    FM_DEFECT_TYPE_PM<s(0)(0)(0)>[&]      = 4,         
} FM_DEFECT_GROUP_TYPE_T<s(0)(0)(0)>[&];(D1:FM_DEFECT_GROUP_TYPE_T:1)[[TYPENAME:FM_DEFECT_GROUP_TYPE_T]]

extern  PB_ERROR_CODE_T<s(0)(0)(0)>[T] FMA_SetDefectByBus_Callback<s(0)(0)(0)>[&](UINT16<s(0)(0)(0)>[T] busNo<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] vc4No<s(0)(0)(0)>[&], TU_TP_T<s(0)(0)(0)>[T] tpIndex<s(0)(0)(0)>[&], SDH_TP_TYPE<s(0)(0)(0)>[T] tpType<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] defectId<s(0)(0)(0)>[&], FMA_ALM_STATE<s(0)(0)(0)>[T] state<s(0)(0)(0)>[&]);(D1:state:0)
extern  PB_ERROR_CODE_T<s(0)(0)(0)>[T] FMA_AddBoardEntity<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] exist<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] style<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] option<s(0)(0)(0)>[&]);(D1:option:0)
extern  PB_ERROR_CODE_T<s(0)(0)(0)>[T] FMA_SetDefect_Callback<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] SlotId<s(0)(0)(0)>[&], INSTANCE_T<s(0)(0)(0)>[T] Instance<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] PortId<s(0)(0)(0)>[&], HW_PORT_TYPE<s(0)(0)(0)>[T] PortType<s(0)(0)(0)>[&], SDH_TP_TYPE<s(0)(0)(0)>[T] TpType<s(0)(0)(0)>[&], COMPACT_TP_T<s(0)(0)(0)>[T] TpIndex<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] DefectId<s(0)(0)(0)>[&], FMA_ALM_STATE<s(0)(0)(0)>[T] state<s(0)(0)(0)>[&]);(D1:state:0)
extern void FMA_HandleButtonEvent<s(0)(0)(0)>[&](SDD_BUTTON_EVENT_TYPE<s(0)(0)(0)>[T] buttonType<s(0)(0)(0)>[&], BUTTON_STATE_T<s(0)(0)(0)>[T] oldState<s(0)(0)(0)>[&], BUTTON_STATE_T<s(0)(0)(0)>[T] newState<s(0)(0)(0)>[&]);(D1:newState:0)
extern void FMA_TCL_CreateCommand<s(0)(0)(0)>[&](Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&]);(D1:interp:0)











 




















 
 
 
 
 
 
 
 
 
 





















 
 
 
 
 






 



 
 
 
 
 
 
 
 












 
 
 
 
 
typedef enum 
{   
    non_GMPLS<s(0)(0)(0)>[&]   = 0x0,
    I_NNI<s(0)(0)(0)>[&]       = 0x1,
    E_NNI<s(0)(0)(0)>[&]       = 0x2,
    UNI10<s(0)(0)(0)>[&]       = 0x3,
    UNI20<s(0)(0)(0)>[&]       = 0x4,
}PB_GMPLS_PORT_CLASSIFIER<s(0)(0)(0)>[&];(D1:PB_GMPLS_PORT_CLASSIFIER:1)[[TYPENAME:PB_GMPLS_PORT_CLASSIFIER]]


typedef enum 
{   
    unreserved<s(0)(0)(0)>[&]  = 0x0,
    migrating<s(0)(0)(0)>[&]   = 0x1,
    reserved<s(0)(0)(0)>[&]    = 0x2,
} PB_TP_RESERVATION<s(0)(0)(0)>[&];(D1:PB_TP_RESERVATION:1)[[TYPENAME:PB_TP_RESERVATION]]


typedef struct 
{
    UINT16<s(1)(1)(0)>[T]      slotNo<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]      portType<s(1)(1)(0)>[&];        
    							                            
    UINT16<s(1)(1)(0)>[T]      portNo<s(1)(1)(0)>[&];
    TP_INDEX_T<s(1)(1)(0)>[T]  tpIndex<s(1)(1)(0)>[&];         
}PB_GMPLS_TP_T<s(0)(0)(0)>[&];(D1:PB_GMPLS_TP_T:1)[[TYPENAME:PB_GMPLS_TP_T]]


typedef struct 
{
    UINT16<s(1)(1)(0)>[T]       vcgXVType<s(1)(1)(0)>[&];      
                                 
                                 
                                 
    UINT16<s(1)(1)(0)>[T]       vcgLCASSupport<s(1)(1)(0)>[&]; 
                                 
    UINT16<s(1)(1)(0)>[T]       vcgGfpType<s(1)(1)(0)>[&];     
                                                                 
    char         vcgChannelId<s(1)(1)(0)>[&][50];   
 } PB_GMPLS_VCG_CONFIG_T<s(0)(0)(0)>[&];(D1:PB_GMPLS_VCG_CONFIG_T:1)[[TYPENAME:PB_GMPLS_VCG_CONFIG_T]]


typedef struct 
{
    PB_GMPLS_TP_T<s(1)(1)(0)>[T]       fromTP<s(1)(1)(0)>[&];
    PB_GMPLS_TP_T<s(1)(1)(0)>[T]       toTP<s(1)(1)(0)>[&];
	int		GmplsVcNumber<s(1)(1)(0)>[&];   
	char	GmplsCallName<s(1)(1)(0)>[&][255];    
    PbGmplsCcDirection_Tval<s(1)(1)(0)>[T] GmplsCcDirection<s(1)(1)(0)>[&]; 
} PB_GMPLS_XC_T<s(0)(0)(0)>[&];(D1:PB_GMPLS_XC_T:1)[[TYPENAME:PB_GMPLS_XC_T]]

typedef enum 
{
	PB_GMPLS_XC_CREATION<s(0)(0)(0)>[&] = 0x1,
	PB_GMPLS_XC_DELETION<s(0)(0)(0)>[&] = 0x2,
}PB_GMPLS_XC_OPERATION<s(0)(0)(0)>[&];(D1:PB_GMPLS_XC_OPERATION:1)[[TYPENAME:PB_GMPLS_XC_OPERATION]]

typedef enum 
{
	PB_GMPLS_XC_NORMAL_CONFIG<s(0)(0)(0)>[&] = 0x1,
	PB_GMPLS_XC_FAST_CONFIG<s(0)(0)(0)>[&] = 0x2,
}PB_GMPLS_XC_CONFIG_MODE<s(0)(0)(0)>[&];(D1:PB_GMPLS_XC_CONFIG_MODE:1)[[TYPENAME:PB_GMPLS_XC_CONFIG_MODE]]

 typedef struct 
{
    PB_GMPLS_TP_T<s(1)(1)(0)>[T]       workingTP<s(1)(1)(0)>[&];
    PB_GMPLS_TP_T<s(1)(1)(0)>[T]       protectingTP<s(1)(1)(0)>[&];
    PB_GMPLS_TP_T<s(1)(1)(0)>[T]       srcOrDestTP<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]              direction<s(1)(1)(0)>[&];    
                                      
} PB_GMPLS_SNCP_T<s(0)(0)(0)>[&];(D1:PB_GMPLS_SNCP_T:1)[[TYPENAME:PB_GMPLS_SNCP_T]]

typedef enum 
{
	PB_GMPLS_SNCP_CREATION_OR_CC_TO_SNCP_CONVERTION<s(0)(0)(0)>[&] = 0x1,
	PB_GMPLS_SNCP_DELETION<s(0)(0)(0)>[&] = 0x2,
	PB_GMPLS_SNCP_TO_CC<s(0)(0)(0)>[&] = 0x3,
	PB_GMPLS_SNCP_EXTERNAL_SWITCHING<s(0)(0)(0)>[&] = 0x4,
}PB_GMPLS_SNCP_OPERATION<s(0)(0)(0)>[&];(D1:PB_GMPLS_SNCP_OPERATION:1)[[TYPENAME:PB_GMPLS_SNCP_OPERATION]]	

typedef enum 
{
	PB_GMPLS_SNCP_WORKING_TO_CC<s(0)(0)(0)>[&] = 0x1,
	PB_GMPLS_SNCP_PROTECTION_TO_CC<s(0)(0)(0)>[&] = 0x2,
}PB_GMPLS_SNCP_TO_CC_CONVERTION<s(0)(0)(0)>[&];(D1:PB_GMPLS_SNCP_TO_CC_CONVERTION:1)[[TYPENAME:PB_GMPLS_SNCP_TO_CC_CONVERTION]]	

typedef enum 
{
    PB_GMPLS_SNCP_CLEAR<s(0)(0)(0)>[&] = 0x1,
    PB_GMPLS_SNCP_MANUAL_TO_PROTECTING<s(0)(0)(0)>[&] =0x2,
    PB_GMPLS_SNCP_MANUAL_TO_WORKING<s(0)(0)(0)>[&] = 0x3,
    PB_GMPLS_SNCP_FORCED_TO_PROTECTING<s(0)(0)(0)>[&] = 0x4,
    PB_GMPLS_SNCP_LOCKOUT<s(0)(0)(0)>[&] = 0x5,
} PB_GMPLS_SNCP_SWITCHING_COMMAND<s(0)(0)(0)>[&];(D1:PB_GMPLS_SNCP_SWITCHING_COMMAND:1)[[TYPENAME:PB_GMPLS_SNCP_SWITCHING_COMMAND]]
	
typedef enum 
{
    PB_GMPLS_SNCP_ACTIVE<s(0)(0)(0)>[&] = 0x1,
    PB_GMPLS_SNCP_STANDBY<s(0)(0)(0)>[&] = 0x2,
} PB_GMPLS_SNCP_STATUS<s(0)(0)(0)>[&];(D1:PB_GMPLS_SNCP_STATUS:1)[[TYPENAME:PB_GMPLS_SNCP_STATUS]]

 typedef struct 
{
    UINT16<s(1)(1)(0)>[T]      slotNo<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]      portNo<s(1)(1)(0)>[&];
} PB_GMPLS_MSP_PORT_T<s(0)(0)(0)>[&];(D1:PB_GMPLS_MSP_PORT_T:1)[[TYPENAME:PB_GMPLS_MSP_PORT_T]]


typedef enum 
{
    PB_GMPLS_LOF<s(0)(0)(0)>[&]         = 0x1,
    PB_GMPLS_TIM<s(0)(0)(0)>[&]         = 0x2,
    PB_GMPLS_RSEXE<s(0)(0)(0)>[&]      = 0x3,
    PB_GMPLS_RSDEG<s(0)(0)(0)>[&]      = 0x4,
    PB_GMPLS_MSAIS<s(0)(0)(0)>[&]      = 0x5,
    PB_GMPLS_MSEXE<s(0)(0)(0)>[&]      = 0x6,
    PB_GMPLS_MSDEG<s(0)(0)(0)>[&]      = 0x7,
    PB_GMPLS_MSRDI<s(0)(0)(0)>[&]      = 0x8,
} PB_GMPLS_ALARM<s(0)(0)(0)>[&];(D1:PB_GMPLS_ALARM:1)[[TYPENAME:PB_GMPLS_ALARM]]

 
 
 
 
 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
PB_ERROR_CODE_T<s(0)(0)(0)>[T] CBM_SDH_PORT_CLASSIFIER_CHANGE_CHECK<s(0)(0)(0)>[&](UINT16<s(0)(0)(0)>[T]       slotNo<s(0)(0)(0)>[&],
                                           UINT16<s(0)(0)(0)>[T]       portType<s(0)(0)(0)>[&],
                                           UINT16<s(0)(0)(0)>[T]       portNo<s(0)(0)(0)>[&],
                                           PB_GMPLS_PORT_CLASSIFIER<s(0)(0)(0)>[T] newPortClassifier<s(0)(0)(0)>[&]);(D1:newPortClassifier:0)


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
PB_ERROR_CODE_T<s(0)(0)(0)>[T] CBM_TP_RESERVATION_CHANGE_CHECK<s(0)(0)(0)>[&]( UINT16<s(0)(0)(0)>[T]   slotNo<s(0)(0)(0)>[&],
                                       UINT16<s(0)(0)(0)>[T]   portType<s(0)(0)(0)>[&],
                                       UINT16<s(0)(0)(0)>[T]   portNo<s(0)(0)(0)>[&],
                                       UINT16<s(0)(0)(0)>[T]   action<s(0)(0)(0)>[&],
                                       UINT16<s(0)(0)(0)>[T]   tpNum<s(0)(0)(0)>[&],
                                       UINT16<s(0)(0)(0)>[T]   *tp<s(0)(0)(0)>[&]);(D1:tp:0)


 
 
 
 
 
 
gmplsLicenseStatus_Tval<s(0)(0)(0)>[T] CBM_CheckGmplsStatus<s(0)(0)(0)>[&]();(D1:CBM_CheckGmplsStatus:0)


 
 
 
 
 
 
 
 
 
 
 
 
 
typedef struct 
{
    command_tt<s(1)(1)(0)>[T]    head<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]        slotNo<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]        portType<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]        realPortType<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]        portNo<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]        mapString_len<s(1)(1)(0)>[&];
    char          portMappingString<s(1)(1)(0)>[&][384];
}CMND_IFM_CBM_PORT_MAPPING_CHANGE_IND_T<s(0)(0)(0)>[&];(D1:CMND_IFM_CBM_PORT_MAPPING_CHANGE_IND_T:1)[[TYPENAME:CMND_IFM_CBM_PORT_MAPPING_CHANGE_IND_T]]


 
 
 
 
 


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
PB_ERROR_CODE_T<s(0)(0)(0)>[T] CBM_ETH_PORT_CLASSIFIER_CHANGE_CHECK<s(0)(0)(0)>[&]( UINT16<s(0)(0)(0)>[T]      slotNo<s(0)(0)(0)>[&],
                                            UINT16<s(0)(0)(0)>[T]      portType<s(0)(0)(0)>[&],
                                            UINT16<s(0)(0)(0)>[T]      portNo<s(0)(0)(0)>[&],
                                            PB_GMPLS_PORT_CLASSIFIER<s(0)(0)(0)>[T]    newPortClassifier<s(0)(0)(0)>[&]);(D1:newPortClassifier:0)


 
 
 
 
 
 
                                                                             
 
 
 
 
 
 
 

PB_ERROR_CODE_T<s(0)(0)(0)>[T] CBM_VCG_CONFIGURATION_CHANGE_CHECK<s(0)(0)(0)>[&]( UINT16<s(0)(0)(0)>[T]        slotNo<s(0)(0)(0)>[&],
                                          UINT16<s(0)(0)(0)>[T]        vcgNo<s(0)(0)(0)>[&],
                                          PB_GMPLS_VCG_CONFIG_T<s(0)(0)(0)>[T]         vcgConfiguration<s(0)(0)(0)>[&]);(D1:vcgConfiguration:0)

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

PB_ERROR_CODE_T<s(0)(0)(0)>[T] CBM_VCG_CAPACITY_CHANGE_CHECK<s(0)(0)(0)>[&]( UINT16<s(0)(0)(0)>[T]             slotNo<s(0)(0)(0)>[&],
                                     PB_GMPLS_TP_T<s(0)(0)(0)>[T]      tp<s(0)(0)(0)>[&],
                                     UINT16<s(0)(0)(0)>[T]             vcgNo<s(0)(0)(0)>[&],
                                     UINT16<s(0)(0)(0)>[T]             direction<s(0)(0)(0)>[&],
                                     UINT16<s(0)(0)(0)>[T]             action<s(0)(0)(0)>[&]);(D1:action:0)



 
 
 
 
 


 
 
 
 
 
 
 
 
 
 
 
 
 
 

PB_ERROR_CODE_T<s(0)(0)(0)>[T] CBM_XC_CHANGE_CHECK<s(0)(0)(0)>[&]( PB_GMPLS_XC_OPERATION<s(0)(0)(0)>[T]        action<s(0)(0)(0)>[&],
                           PB_GMPLS_XC_T<s(0)(0)(0)>[T]                xc<s(0)(0)(0)>[&]);(D1:xc:0)


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
typedef struct 
{
    command_tt<s(1)(1)(0)>[T]    head<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]        correlator<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]        configMode<s(1)(1)(0)>[&];   
    UINT16<s(1)(1)(0)>[T]        deletedXcNum<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]        createdXcNum<s(1)(1)(0)>[&];
    PB_GMPLS_XC_T<s(1)(1)(0)>[T] modifiedXc<s(1)(1)(0)>[&][1];
} CMND_CBM_CCS_MODIFY_XC_REQ_T<s(0)(0)(0)>[&];(D1:CMND_CBM_CCS_MODIFY_XC_REQ_T:1)[[TYPENAME:CMND_CBM_CCS_MODIFY_XC_REQ_T]]

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
typedef struct 
{
    command_tt<s(1)(1)(0)>[T]    head<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]        correlator<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]        deletedXcNum<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]        createdXcNum<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]        result<s(1)(1)(0)>[&][1];   
} CMND_CCS_CBM_MODIFY_XC_ACK_T<s(0)(0)(0)>[&];(D1:CMND_CCS_CBM_MODIFY_XC_ACK_T:1)[[TYPENAME:CMND_CCS_CBM_MODIFY_XC_ACK_T]]

 
 
 
 
 
 
 
 
 
 
 
typedef struct 
{
    command_tt<s(1)(1)(0)>[T]      head<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]          action<s(1)(1)(0)>[&];  
    UINT16<s(1)(1)(0)>[T]          result<s(1)(1)(0)>[&];  
    PB_GMPLS_XC_T<s(1)(1)(0)>[T]   xc<s(1)(1)(0)>[&];
}CMND_CCS_CBM_XC_CHANGE_IND_T<s(0)(0)(0)>[&];(D1:CMND_CCS_CBM_XC_CHANGE_IND_T:1)[[TYPENAME:CMND_CCS_CBM_XC_CHANGE_IND_T]]


 
 
 
 
 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

PB_ERROR_CODE_T<s(0)(0)(0)>[T] CBM_SNCP_CHANGE_CHECK<s(0)(0)(0)>[&](PB_GMPLS_SNCP_OPERATION<s(0)(0)(0)>[T]        action<s(0)(0)(0)>[&],
                            PB_GMPLS_SNCP_TO_CC_CONVERTION<s(0)(0)(0)>[T] workOrProtToCc<s(0)(0)(0)>[&],
                            PB_GMPLS_SNCP_T<s(0)(0)(0)>[T]                sncp<s(0)(0)(0)>[&]);(D1:sncp:0)

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
typedef struct 
{
    command_tt<s(1)(1)(0)>[T]                       head<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]                           correlator<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]                           action<s(1)(1)(0)>[&];          
    UINT16<s(1)(1)(0)>[T]                           workOrProtToCc<s(1)(1)(0)>[&];  
    UINT16<s(1)(1)(0)>[T]                           sncpNum<s(1)(1)(0)>[&];
    PB_GMPLS_SNCP_T<s(1)(1)(0)>[T]                  modifiedSncp<s(1)(1)(0)>[&][1];
} CMND_CBM_SPM_MODIFY_SNCP_REQ_T<s(0)(0)(0)>[&];(D1:CMND_CBM_SPM_MODIFY_SNCP_REQ_T:1)[[TYPENAME:CMND_CBM_SPM_MODIFY_SNCP_REQ_T]]

 
 
 
 
 
 
 
 
 
 
 
 
 
 
typedef struct 
{
    command_tt<s(1)(1)(0)>[T]    head<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]        correlator<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]        sncpNum<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]        result<s(1)(1)(0)>[&][1];  
} CMND_SPM_CBM_MODIFY_SNCP_ACK_T<s(0)(0)(0)>[&];(D1:CMND_SPM_CBM_MODIFY_SNCP_ACK_T:1)[[TYPENAME:CMND_SPM_CBM_MODIFY_SNCP_ACK_T]]

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
typedef struct 
{
    command_tt<s(1)(1)(0)>[T]                       head<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]                           correlator<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]                           action<s(1)(1)(0)>[&];     
    UINT16<s(1)(1)(0)>[T]                           sncpNum<s(1)(1)(0)>[&];
    PB_GMPLS_SNCP_T<s(1)(1)(0)>[T]                  switchedSncp<s(1)(1)(0)>[&][1];
} CMND_CBM_SPM_SWITCH_SNCP_REQ_T<s(0)(0)(0)>[&];(D1:CMND_CBM_SPM_SWITCH_SNCP_REQ_T:1)[[TYPENAME:CMND_CBM_SPM_SWITCH_SNCP_REQ_T]]


 
 
 
 
 
 
 
 
 
 
 
 
 
 
typedef struct 
{
    command_tt<s(1)(1)(0)>[T]    head<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]        correlator<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]        sncpNum<s(1)(1)(0)>[&]; 
    UINT16<s(1)(1)(0)>[T]        result<s(1)(1)(0)>[&][1];  
} CMND_SPM_CBM_SWITCH_SNCP_ACK_T<s(0)(0)(0)>[&];(D1:CMND_SPM_CBM_SWITCH_SNCP_ACK_T:1)[[TYPENAME:CMND_SPM_CBM_SWITCH_SNCP_ACK_T]]

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
typedef struct 
{
        command_tt<s(1)(1)(0)>[T]              head<s(1)(1)(0)>[&];
        UINT16<s(1)(1)(0)>[T]                  action<s(1)(1)(0)>[&];  
        UINT16<s(1)(1)(0)>[T]                  workOrProtToCc<s(1)(1)(0)>[&];  
        PB_GMPLS_SNCP_T<s(1)(1)(0)>[T]         sncp<s(1)(1)(0)>[&];
        UINT16<s(1)(1)(0)>[T]                  result<s(1)(1)(0)>[&];  
}CMND_SPM_CBM_SNCP_CHANGE_IND_T<s(0)(0)(0)>[&];(D1:CMND_SPM_CBM_SNCP_CHANGE_IND_T:1)[[TYPENAME:CMND_SPM_CBM_SNCP_CHANGE_IND_T]]

 
 
 
 
 
 
 
 
 
 
 
 
typedef struct 
{
    command_tt<s(1)(1)(0)>[T]            head<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]                           action<s(1)(1)(0)>[&];    
     
    UINT16<s(1)(1)(0)>[T]                result<s(1)(1)(0)>[&]; 
     
    PB_GMPLS_SNCP_T<s(1)(1)(0)>[T]       sncp<s(1)(1)(0)>[&];
} CMND_SPM_CBM_SNCP_SWITCH_IND_T<s(0)(0)(0)>[&];(D1:CMND_SPM_CBM_SNCP_SWITCH_IND_T:1)[[TYPENAME:CMND_SPM_CBM_SNCP_SWITCH_IND_T]]

 
 
 
 
 
 
 
 
 
 
 
typedef struct 
{
    command_tt<s(1)(1)(0)>[T]            head<s(1)(1)(0)>[&];
    PB_GMPLS_SNCP_T<s(1)(1)(0)>[T]       sncp<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]                currentStatus<s(1)(1)(0)>[&];  
} CMND_SPA_CBM_SNCP_SWITCHING_IND_T<s(0)(0)(0)>[&];(D1:CMND_SPA_CBM_SNCP_SWITCHING_IND_T:1)[[TYPENAME:CMND_SPA_CBM_SNCP_SWITCHING_IND_T]]


 
 
 
 
 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

PB_ERROR_CODE_T<s(0)(0)(0)>[T] CBM_MSP_CREATION_CHECK<s(0)(0)(0)>[&](UINT16<s(0)(0)(0)>[T]                     mspScheme<s(0)(0)(0)>[&],
                             UINT16<s(0)(0)(0)>[T]                     portType<s(0)(0)(0)>[&],
                             PB_GMPLS_MSP_PORT_T<s(0)(0)(0)>[T]        port<s(0)(0)(0)>[&]);(D1:port:0)

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
typedef struct 
{
    command_tt<s(1)(1)(0)>[T]          head<s(1)(1)(0)>[&]; 
    UINT16<s(1)(1)(0)>[T]              action<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]              mspScheme<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]              portType<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]              workingPortNum<s(1)(1)(0)>[&];
    PB_GMPLS_MSP_PORT_T<s(1)(1)(0)>[T] protectingPort<s(1)(1)(0)>[&];
    PB_GMPLS_MSP_PORT_T<s(1)(1)(0)>[T] workingPort<s(1)(1)(0)>[&][14];
} CMND_MPM_CBM_MSP_CHANGE_IND_T<s(0)(0)(0)>[&];(D1:CMND_MPM_CBM_MSP_CHANGE_IND_T:1)[[TYPENAME:CMND_MPM_CBM_MSP_CHANGE_IND_T]]


 
 
 
 
 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
PB_ERROR_CODE_T<s(0)(0)(0)>[T] CBM_MSSPRING_CREATION_CHECK<s(0)(0)(0)>[&](UINT16<s(0)(0)(0)>[T]                protectionScheme<s(0)(0)(0)>[&],
                                  UINT16<s(0)(0)(0)>[T]                portType<s(0)(0)(0)>[&],
                                  PB_GMPLS_MSP_PORT_T<s(0)(0)(0)>[T]   port<s(0)(0)(0)>[&]);(D1:port:0)

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
typedef struct 
{
    command_tt<s(1)(1)(0)>[T]          head<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]              action<s(1)(1)(0)>[&]; 
    UINT16<s(1)(1)(0)>[T]              protectionScheme<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]              portType<s(1)(1)(0)>[&];
    PB_GMPLS_MSP_PORT_T<s(1)(1)(0)>[T] eastPort<s(1)(1)(0)>[&];
    PB_GMPLS_MSP_PORT_T<s(1)(1)(0)>[T] eastProtectionPort<s(1)(1)(0)>[&];
    PB_GMPLS_MSP_PORT_T<s(1)(1)(0)>[T] westPort<s(1)(1)(0)>[&];
    PB_GMPLS_MSP_PORT_T<s(1)(1)(0)>[T] westProtectingPort<s(1)(1)(0)>[&];
}CMND_MSM_CBM_MSSPRING_CHANGE_IND_T<s(0)(0)(0)>[&];(D1:CMND_MSM_CBM_MSSPRING_CHANGE_IND_T:1)[[TYPENAME:CMND_MSM_CBM_MSSPRING_CHANGE_IND_T]]


 
 
 
 
 


 
 
 
 
 

 
 
 
 
 
 
 
 
 
 
typedef struct 
{
    command_tt<s(1)(1)(0)>[T]    head<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]        action<s(1)(1)(0)>[&];
} CMND_MFM_CBM_MIB_SAVING_ADMISSION_IND_T<s(0)(0)(0)>[&];(D1:CMND_MFM_CBM_MIB_SAVING_ADMISSION_IND_T:1)[[TYPENAME:CMND_MFM_CBM_MIB_SAVING_ADMISSION_IND_T]]
 
 
 
 
 

 
 
 
 
 
 
 
 
typedef struct 
{
    command_tt<s(1)(1)(0)>[T]    head<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]        gmplsStatus<s(1)(1)(0)>[&];
} CMND_CBM_SNMPAGENT_GMPLS_ACTIVE_IND_T<s(0)(0)(0)>[&];(D1:CMND_CBM_SNMPAGENT_GMPLS_ACTIVE_IND_T:1)[[TYPENAME:CMND_CBM_SNMPAGENT_GMPLS_ACTIVE_IND_T]]


 
 
 
 
 

 
 
 
 
 
 
 
 
 
typedef struct 
{
    command_tt<s(1)(1)(0)>[T]   head<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]       slotNo<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]       trigger<s(1)(1)(0)>[&];
} CMND_CBM_GFA_ALARM_IND_TRIGGER_T<s(0)(0)(0)>[&];(D1:CMND_CBM_GFA_ALARM_IND_TRIGGER_T:1)[[TYPENAME:CMND_CBM_GFA_ALARM_IND_TRIGGER_T]]


 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
void CBM_SEND_ALARM_IND_TO_GMPLS<s(0)(0)(0)>[&](UINT16<s(0)(0)(0)>[T]              slotNo<s(0)(0)(0)>[&],
                                 UINT16<s(0)(0)(0)>[T]              portType<s(0)(0)(0)>[&],
                                 UINT16<s(0)(0)(0)>[T]              portNo<s(0)(0)(0)>[&],
                                 UINT16<s(0)(0)(0)>[T]              cardType<s(0)(0)(0)>[&],
                                 PB_GMPLS_ALARM<s(0)(0)(0)>[T]      alarmType<s(0)(0)(0)>[&],
                                 UINT16<s(0)(0)(0)>[T]              alarmStatus<s(0)(0)(0)>[&]);(D1:alarmStatus:0)
                                 
                                 

 
 
 
 
 

 
 
 
 
 
 
typedef struct 
{
   command_tt<s(1)(1)(0)>[T]    head<s(1)(1)(0)>[&];
} CMND_PSM_CBM_MANUAL_SC_SWITCHING_IND_T<s(0)(0)(0)>[&];(D1:CMND_PSM_CBM_MANUAL_SC_SWITCHING_IND_T:1)[[TYPENAME:CMND_PSM_CBM_MANUAL_SC_SWITCHING_IND_T]]



 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
typedef struct 
{
    command_tt<s(1)(1)(0)>[T]    head<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]        slotNo<s(1)(1)(0)>[&];
    UINT16<s(1)(1)(0)>[T]        reserved<s(1)(1)(0)>[&];
}CMND_UDM_MIB_RESTORE_READY_NOTIFY_T<s(0)(0)(0)>[&];(D1:CMND_UDM_MIB_RESTORE_READY_NOTIFY_T:1)[[TYPENAME:CMND_UDM_MIB_RESTORE_READY_NOTIFY_T]]

 
 
 
 
 
 
 
 
 
PB_ERROR_CODE_T<s(0)(0)(0)>[T] 
	     CBM_IFM_OTU_PORT_PATH_MAPPING_CHANGE_CHECK<s(0)(0)(0)>[&](
	                                               UINT16<s(0)(0)(0)>[T]       slotNo<s(0)(0)(0)>[&],                                        
                                                   UINT16<s(0)(0)(0)>[T]       portNo<s(0)(0)(0)>[&],
                                                   UINT8<s(0)(0)(0)>[T]        newPathMapping<s(0)(0)(0)>[&]);(D1:newPathMapping:0)


 
 
 
typedef unsigned int (*CHK_TP_RESERVE_CALLBACK<s(0)(0)(0)>[&])TYPENAME:FUNC:(CHK_TP_RESERVE_CALLBACK)(const PB_GMPLS_TP_T<s(0)(0)(0)>[T]* , UINT32<s(0)(0)(0)>[T] );(D1:UINT32:0)
extern void grm_register_ccs_check_tp_reserve<s(0)(0)(0)>[&](CHK_TP_RESERVE_CALLBACK<s(0)(0)(0)>[T] );(D1:CHK_TP_RESERVE_CALLBACK:0)
extern void grm_register_spm_check_tp_reserve<s(0)(0)(0)>[&](CHK_TP_RESERVE_CALLBACK<s(0)(0)(0)>[T] );(D1:CHK_TP_RESERVE_CALLBACK:0)
























 













typedef enum{
    SDD_EC_P2W<s(0)(0)(0)>[&],
    SDD_EC_W2P<s(0)(0)(0)>[&],
}SDD_EC_SWITCH_T<s(0)(0)(0)>[&];(D1:SDD_EC_SWITCH_T:1)[[TYPENAME:SDD_EC_SWITCH_T]]

 
typedef enum{
    NO_TP_MAP<s(0)(0)(0)>[&] =0,        
    PDH_TP_MAP<s(0)(0)(0)>[&],              
    SDH_TP_MAP<s(0)(0)(0)>[&],                 
    GMPLS_TP_MAP<s(0)(0)(0)>[&]             
}MAPPER_TYPE_T<s(0)(0)(0)>[&];(D1:MAPPER_TYPE_T:1)[[TYPENAME:MAPPER_TYPE_T]]

typedef enum{
    LO_MAPPING_TU12<s(0)(0)(0)>[&] = 0,
    LO_MAPPING_TU3<s(0)(0)(0)>[&],
    LO_MAPPING_TU11<s(0)(0)(0)>[&],
    LO_MAPPING_TU2<s(0)(0)(0)>[&]
}LO_MAPPING_TYPE_T<s(0)(0)(0)>[&];(D1:LO_MAPPING_TYPE_T:1)[[TYPENAME:LO_MAPPING_TYPE_T]]

typedef struct LoTPMapperItem_s<s(1)(0)(1)>[&]
{
    MAPPER_TYPE_T<s(1)(1)(0)>[T] TpType<s(1)(1)(0)>[&];     
    UINT8<s(1)(1)(0)>[T] bGmplsReserve<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T] LoBus<s(1)(1)(0)>[&];     
    UINT8<s(1)(1)(0)>[T] LoVC4<s(1)(1)(0)>[&];     
    UINT8<s(1)(1)(0)>[T]  HoSlot<s(1)(1)(0)>[&];     
    UINT8<s(1)(1)(0)>[T]  HoPortType<s(1)(1)(0)>[&];  
    UINT8<s(1)(1)(0)>[T]  HoPort<s(1)(1)(0)>[&];     
    UINT8<s(1)(1)(0)>[T]  HoE<s(1)(1)(0)>[&];          
    UINT8<s(1)(1)(0)>[T]  HoD<s(1)(1)(0)>[&];         
    UINT8<s(1)(1)(0)>[T]  HoC<s(1)(1)(0)>[&];         
    UINT8<s(1)(1)(0)>[T]  HoB<s(1)(1)(0)>[&];         
} __attribute__ ((packed))  LO_TP_MAPPER_ITEM_T<s(0)(0)(0)>[&];(D1:LO_TP_MAPPER_ITEM_T:1)[[TYPENAME:LO_TP_MAPPER_ITEM_T]]

 
typedef struct CrossConnectionItem_s<s(1)(0)(1)>[&]
{    
    UINT8<s(1)(1)(0)>[T] fromBus<s(1)(1)(0)>[&];       
    UINT8<s(1)(1)(0)>[T] fromVC4<s(1)(1)(0)>[&];       
    UINT8<s(1)(1)(0)>[T] type<s(1)(1)(0)>[&] : 5;     
    UINT8<s(1)(1)(0)>[T] k<s(1)(1)(0)>[&] : 3;         
    UINT8<s(1)(1)(0)>[T] l<s(1)(1)(0)>[&] : 4;         
    UINT8<s(1)(1)(0)>[T] m<s(1)(1)(0)>[&] : 3;         
    UINT8<s(1)(1)(0)>[T] bChanged<s(1)(1)(0)>[&] : 1;  
} __attribute__ ((packed))  CROSS_CONNECT_ITEM_T<s(0)(0)(0)>[&];(D1:CROSS_CONNECT_ITEM_T:1)[[TYPENAME:CROSS_CONNECT_ITEM_T]]

 
typedef struct CrossConnectionHCCMatrix_s<s(1)(0)(1)>[&]
{
    CROSS_CONNECT_ITEM_T<s(1)(1)(0)>[T]    VC4List<s(1)(1)(0)>[&][136 ][16 ];     



} __attribute__ ((packed))  CROSS_CONNECT_HCC_MATRIX_T<s(0)(0)(0)>[&];(D1:CROSS_CONNECT_HCC_MATRIX_T:1)[[TYPENAME:CROSS_CONNECT_HCC_MATRIX_T]]
 
typedef struct CrossConnectionLCCMatrix_s<s(1)(0)(1)>[&]
{
    CROSS_CONNECT_ITEM_T<s(1)(1)(0)>[T]    VC3List<s(1)(1)(0)>[&][9 ][16 ][3 ];     
    CROSS_CONNECT_ITEM_T<s(1)(1)(0)>[T]    VC12List<s(1)(1)(0)>[&][9 ][16 ][3 ][7 ][3 ];     
} __attribute__ ((packed))  CROSS_CONNECT_LCC_MATRIX_T<s(0)(0)(0)>[&];(D1:CROSS_CONNECT_LCC_MATRIX_T:1)[[TYPENAME:CROSS_CONNECT_LCC_MATRIX_T]]

 
typedef struct CrossConnectionHLCMatrix_s<s(1)(0)(1)>[&]
{
    CROSS_CONNECT_ITEM_T<s(1)(1)(0)>[T]    VC4List<s(1)(1)(0)>[&][18 ][16 ];     
    CROSS_CONNECT_ITEM_T<s(1)(1)(0)>[T]    VC3List<s(1)(1)(0)>[&][18 ][16 ][3 ];     
    CROSS_CONNECT_ITEM_T<s(1)(1)(0)>[T]    VC12List<s(1)(1)(0)>[&][18 ][16 ][3 ][7 ][3 ];     
} __attribute__ ((packed))  CrossConnectionHLCMatrix<s(0)(0)(0)>[&];(D1:CrossConnectionHLCMatrix:1)[[TYPENAME:CrossConnectionHLCMatrix]]

 
 
typedef int (*funcPBCCHCCAllCXC<s(0)(0)(0)>[&])TYPENAME:FUNC:(funcPBCCHCCAllCXC)(INSTANCE_T<s(0)(0)(0)>[T] instance<s(0)(0)(0)>[&], CROSS_CONNECT_HCC_MATRIX_T<s(0)(0)(0)>[T] *pMatrix<s(0)(0)(0)>[&]);(D1:pMatrix:0)
typedef int (*funcPBCCLCCAllCXC<s(0)(0)(0)>[&])TYPENAME:FUNC:(funcPBCCLCCAllCXC)(INSTANCE_T<s(0)(0)(0)>[T] instance<s(0)(0)(0)>[&], CROSS_CONNECT_LCC_MATRIX_T<s(0)(0)(0)>[T] *pMatrix<s(0)(0)(0)>[&]);(D1:pMatrix:0)
typedef int (*funcPBCCHLCAllCXC<s(0)(0)(0)>[&])TYPENAME:FUNC:(funcPBCCHLCAllCXC)(INSTANCE_T<s(0)(0)(0)>[T] instance<s(0)(0)(0)>[&], CrossConnectionHLCMatrix<s(0)(0)(0)>[T] *pMatrix<s(0)(0)(0)>[&]);(D1:pMatrix:0)

 
 
typedef int (*funcPBCCSetVC4XC<s(0)(0)(0)>[&])TYPENAME:FUNC:(funcPBCCSetVC4XC) (INSTANCE_T<s(0)(0)(0)>[T] instance<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] FromBus<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] FromVC4<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] ToBus<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] ToVC4<s(0)(0)(0)>[&]);(D1:ToVC4:0)
typedef int (*funcPBCCSetVC3XC<s(0)(0)(0)>[&])TYPENAME:FUNC:(funcPBCCSetVC3XC) (INSTANCE_T<s(0)(0)(0)>[T] instance<s(0)(0)(0)>[&],UINT16<s(0)(0)(0)>[T] FromBus<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] FromVC4<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] FromVC3<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] ToBus<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] ToVC4<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] ToVC3<s(0)(0)(0)>[&]);(D1:ToVC3:0)
typedef int (*funcPBCCSetVC12XC<s(0)(0)(0)>[&])TYPENAME:FUNC:(funcPBCCSetVC12XC) (INSTANCE_T<s(0)(0)(0)>[T] instance<s(0)(0)(0)>[&],UINT16<s(0)(0)(0)>[T] FromBus<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] FromVC4<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] FromVC3<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] FromVC2<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] FromVC1<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] ToBus<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] ToVC4<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] ToVC3<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] ToVC2<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] ToVC1<s(0)(0)(0)>[&]);(D1:ToVC1:0)

 
 
typedef int (*funcPBCCTpMapper<s(0)(0)(0)>[&])TYPENAME:FUNC:(funcPBCCTpMapper)(INSTANCE_T<s(0)(0)(0)>[T] instance<s(0)(0)(0)>[&], LO_TP_MAPPER_ITEM_T<s(0)(0)(0)>[T] *pMapper<s(0)(0)(0)>[&]);(D1:pMapper:0)
 
typedef int (*funcPBCCLoMapping<s(0)(0)(0)>[&])TYPENAME:FUNC:(funcPBCCLoMapping)(INSTANCE_T<s(0)(0)(0)>[T] instance<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] LoBus<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] LoVC4<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] LoK<s(0)(0)(0)>[&], LO_MAPPING_TYPE_T<s(0)(0)(0)>[T] type<s(0)(0)(0)>[&]);(D1:type:0)

 
typedef int (*funcPBCCSetHOCCCardState<s(0)(0)(0)>[&])TYPENAME:FUNC:(funcPBCCSetHOCCCardState) (INSTANCE_T<s(0)(0)(0)>[T] instance<s(0)(0)(0)>[&],BOOL<s(0)(0)(0)>[T] bState<s(0)(0)(0)>[&]);(D1:bState:0)
typedef int (*funcPBCCFreezeAllSNCP<s(0)(0)(0)>[&])TYPENAME:FUNC:(funcPBCCFreezeAllSNCP) (INSTANCE_T<s(0)(0)(0)>[T] instance<s(0)(0)(0)>[&],BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&]);(D1:bEnable:0)
typedef int (*funcPBCCFreezeAllHardWareMSP<s(0)(0)(0)>[&])TYPENAME:FUNC:(funcPBCCFreezeAllHardWareMSP) (INSTANCE_T<s(0)(0)(0)>[T] instance<s(0)(0)(0)>[&],BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&]);(D1:bEnable:0)

 
typedef int (*funcPBCCSetLOCCMode<s(0)(0)(0)>[&])TYPENAME:FUNC:(funcPBCCSetLOCCMode) (INSTANCE_T<s(0)(0)(0)>[T] instance<s(0)(0)(0)>[&],BOOL<s(0)(0)(0)>[T] bState<s(0)(0)(0)>[&]);(D1:bState:0)

 
 
typedef int (*funcPBCCSetEPGSwitch<s(0)(0)(0)>[&])TYPENAME:FUNC:(funcPBCCSetEPGSwitch) (INSTANCE_T<s(0)(0)(0)>[T] instance<s(0)(0)(0)>[&],UINT32<s(0)(0)(0)>[T] WorkSlot<s(0)(0)(0)>[&],UINT32<s(0)(0)(0)>[T] ProtSlot<s(0)(0)(0)>[&],BOOL<s(0)(0)(0)>[T] bState<s(0)(0)(0)>[&]);(D1:bState:0)
typedef int (*funcPBCCSetMSPSwitch<s(0)(0)(0)>[&])TYPENAME:FUNC:(funcPBCCSetMSPSwitch) (INSTANCE_T<s(0)(0)(0)>[T] instance<s(0)(0)(0)>[&],UINT32<s(0)(0)(0)>[T] WorkSlot<s(0)(0)(0)>[&],HW_PORT_TYPE<s(0)(0)(0)>[T] eWorkPortType<s(0)(0)(0)>[&],UINT32<s(0)(0)(0)>[T] WorkPort<s(0)(0)(0)>[&],
											UINT32<s(0)(0)(0)>[T] ProtSlot<s(0)(0)(0)>[&],HW_PORT_TYPE<s(0)(0)(0)>[T] eProtPortType<s(0)(0)(0)>[&],UINT32<s(0)(0)(0)>[T] ProtPort<s(0)(0)(0)>[&],BOOL<s(0)(0)(0)>[T] bState<s(0)(0)(0)>[&]);(D1:bState:0)
typedef int (*funcPBCCSetDRISwitch<s(0)(0)(0)>[&])TYPENAME:FUNC:(funcPBCCSetDRISwitch) (INSTANCE_T<s(0)(0)(0)>[T] instance<s(0)(0)(0)>[&],UINT32<s(0)(0)(0)>[T] WorkSlot<s(0)(0)(0)>[&],HW_PORT_TYPE<s(0)(0)(0)>[T] eWorkPortType<s(0)(0)(0)>[&],UINT32<s(0)(0)(0)>[T] WorkPort<s(0)(0)(0)>[&],TP_INDEX_T<s(0)(0)(0)>[T] WorkTp<s(0)(0)(0)>[&],
											UINT32<s(0)(0)(0)>[T] ProtSlot<s(0)(0)(0)>[&],HW_PORT_TYPE<s(0)(0)(0)>[T] eProtPortType<s(0)(0)(0)>[&],UINT32<s(0)(0)(0)>[T] ProtPort<s(0)(0)(0)>[&],TP_INDEX_T<s(0)(0)(0)>[T] ProtTp<s(0)(0)(0)>[&],BOOL<s(0)(0)(0)>[T] bState<s(0)(0)(0)>[&]);(D1:bState:0)

 
 
typedef int (*funcPBCCSetAis<s(0)(0)(0)>[&])TYPENAME:FUNC:(funcPBCCSetAis)(INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&],HW_PORT_TYPE<s(0)(0)(0)>[T] ePortType<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&], TP_INDEX_T<s(0)(0)(0)>[T] eTp<s(0)(0)(0)>[&], ALARM_DIRECTION_T<s(0)(0)(0)>[T] eDir<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&]);(D1:bEnable:0)
typedef int (*funcPBCCSetCardAis<s(0)(0)(0)>[&])TYPENAME:FUNC:(funcPBCCSetCardAis)(INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&],UINT32<s(0)(0)(0)>[T] Slot<s(0)(0)(0)>[&],BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&]);(D1:bEnable:0)

typedef int (*funcGetLoccSlotFromLCTP<s(0)(0)(0)>[&])TYPENAME:FUNC:(funcGetLoccSlotFromLCTP)(UINT8<s(0)(0)(0)>[T] ucTpType<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] ucSlot<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] ucPortType<s(0)(0)(0)>[&]
    , UINT8<s(0)(0)(0)>[T] ucPort<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulTp<s(0)(0)(0)>[&]);(D1:ulTp:0)    

typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (* funcPBCCSetLOCCSwitch<s(0)(0)(0)>[&])TYPENAME:FUNC:(funcPBCCSetLOCCSwitch)(ENTITY_T<s(0)(0)(0)>[T] etEntity<s(0)(0)(0)>[&], CTD_LOCC_MODE_T<s(0)(0)(0)>[T] eLccMode<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bWorkState<s(0)(0)(0)>[&]);(D1:bWorkState:0)

typedef int (*funcPBCCSetCardType<s(0)(0)(0)>[&])TYPENAME:FUNC:(funcPBCCSetCardType) (INSTANCE_T<s(0)(0)(0)>[T] inst<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulSlot<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulStyle<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulOption<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bWarm<s(0)(0)(0)>[&]);(D1:bWarm:0)
typedef int (*funcCCSetPortType<s(0)(0)(0)>[&])TYPENAME:FUNC:(funcCCSetPortType)(INSTANCE_T<s(0)(0)(0)>[T] instance<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulSlotNo<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulPortType<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T]  usPortId<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulActualPortType<s(0)(0)(0)>[&]);(D1:ulActualPortType:0)
typedef unsigned int (*funcCCGetNofreeCapacityslot<s(0)(0)(0)>[&])TYPENAME:FUNC:(funcCCGetNofreeCapacityslot)(UINT32<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&]);(D1:slot:0)

typedef  int (*funcCCGetGcbCheck<s(0)(0)(0)>[&])TYPENAME:FUNC:(funcCCGetGcbCheck)(PB_GMPLS_XC_OPERATION<s(0)(0)(0)>[T] action<s(0)(0)(0)>[&], PB_GMPLS_XC_T<s(0)(0)(0)>[T] xc<s(0)(0)(0)>[&]);(D1:xc:0)



















 


















 



 






















 


 

typedef struct 
{
    command_tt<s(1)(1)(0)>[T]          head<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T]                enable<s(1)(1)(0)>[&];             
} FMM_HANDLE_SUPPRESS_CMND_T<s(0)(0)(0)>[&];(D1:FMM_HANDLE_SUPPRESS_CMND_T:1)[[TYPENAME:FMM_HANDLE_SUPPRESS_CMND_T]]

 
typedef struct
{
    command_tt<s(1)(1)(0)>[T]          head<s(1)(1)(0)>[&];
    MIBpbActiveAlarmTable_t<s(1)(1)(0)>[T]  data<s(1)(1)(0)>[&];
} FMM_AEL_NEW_ALARM_RAISED_CMND_T<s(0)(0)(0)>[&];(D1:FMM_AEL_NEW_ALARM_RAISED_CMND_T:1)[[TYPENAME:FMM_AEL_NEW_ALARM_RAISED_CMND_T]]

 
typedef enum
{
    LOG_COMMAND_NONE<s(0)(0)(0)>[&] = 0,
    LOG_COMMAND_CLEAR_ALARMLOG<s(0)(0)(0)>[&]  = 1,
    LOG_COMMAND_CLEAR_EVENTLOG<s(0)(0)(0)>[&]  = 2,    
} LOG_COMMAND_T<s(0)(0)(0)>[&];(D1:LOG_COMMAND_T:1)[[TYPENAME:LOG_COMMAND_T]]

typedef struct
{
    command_tt<s(1)(1)(0)>[T]         head<s(1)(1)(0)>[&];
    LOG_COMMAND_T<s(1)(1)(0)>[T]      logCmd<s(1)(1)(0)>[&];    
} FMM_AEL_LOG_STATUS_CMND_T<s(0)(0)(0)>[&];(D1:FMM_AEL_LOG_STATUS_CMND_T:1)[[TYPENAME:FMM_AEL_LOG_STATUS_CMND_T]]


 





typedef struct
{
    command_tt<s(1)(1)(0)>[T]         head<s(1)(1)(0)>[&];
    int                DetectTime<s(1)(1)(0)>[&];
    int                ClearTime<s(1)(1)(0)>[&];   
} FMM_FMC_ALM_PERSISTENT_TIME_CFG_CMND_T<s(0)(0)(0)>[&];(D1:FMM_FMC_ALM_PERSISTENT_TIME_CFG_CMND_T:1)[[TYPENAME:FMM_FMC_ALM_PERSISTENT_TIME_CFG_CMND_T]]


 
typedef struct
{
    command_tt<s(1)(1)(0)>[T]         head<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T]               enable<s(1)(1)(0)>[&];
} FMM_FMC_ENABLE_CORRELATION_CMND_T<s(0)(0)(0)>[&];(D1:FMM_FMC_ENABLE_CORRELATION_CMND_T:1)[[TYPENAME:FMM_FMC_ENABLE_CORRELATION_CMND_T]]


 
typedef struct
{
    command_tt<s(1)(1)(0)>[T]          head<s(1)(1)(0)>[&];    
    BOOL<s(1)(1)(0)>[T]                enable<s(1)(1)(0)>[&];
} FMM_FMC_NE_LEVEL_ALARM_INHIBIT_CMND_T<s(0)(0)(0)>[&];(D1:FMM_FMC_NE_LEVEL_ALARM_INHIBIT_CMND_T:1)[[TYPENAME:FMM_FMC_NE_LEVEL_ALARM_INHIBIT_CMND_T]]

 
typedef struct
{
    command_tt<s(1)(1)(0)>[T]          head<s(1)(1)(0)>[&];    
    BOOL<s(1)(1)(0)>[T]                aisEnable<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T]                rdiEnable<s(1)(1)(0)>[&];
} FMM_FMC_NE_LEVEL_AIS_RDI_INHIBIT_CMND_T<s(0)(0)(0)>[&];(D1:FMM_FMC_NE_LEVEL_AIS_RDI_INHIBIT_CMND_T:1)[[TYPENAME:FMM_FMC_NE_LEVEL_AIS_RDI_INHIBIT_CMND_T]]

 
typedef struct
{
	command_tt<s(1)(1)(0)>[T]          head<s(1)(1)(0)>[&];
	BOOL<s(1)(1)(0)>[T]                alarmEnable<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T]                aisEnable<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T]                rdiEnable<s(1)(1)(0)>[&];
	BOOL<s(1)(1)(0)>[T]                sefEnable<s(1)(1)(0)>[&];
	unsigned int        changeMsgBit<s(1)(1)(0)>[&];
}FMM_FMC_NE_LEVEL_CFG_CMND_T<s(0)(0)(0)>[&];(D1:FMM_FMC_NE_LEVEL_CFG_CMND_T:1)[[TYPENAME:FMM_FMC_NE_LEVEL_CFG_CMND_T]]

 
typedef struct
{
	PbEnableDisable_Tval<s(1)(1)(0)>[T] pbNodeAlarmEnabling<s(1)(1)(0)>[&];
	TruthValue_Tval<s(1)(1)(0)>[T] pbAISEnabled<s(1)(1)(0)>[&];
	TruthValue_Tval<s(1)(1)(0)>[T] pbRDIEnabled<s(1)(1)(0)>[&];
	TruthValue_Tval<s(1)(1)(0)>[T] pbSEFEnabled<s(1)(1)(0)>[&];
	unsigned int    changeMsgBit<s(1)(1)(0)>[&]; 
}FMM_NE_LEVEL_CFG_CHANGE_T<s(0)(0)(0)>[&];(D1:FMM_NE_LEVEL_CFG_CHANGE_T:1)[[TYPENAME:FMM_NE_LEVEL_CFG_CHANGE_T]]

 

typedef enum
{
	FMM_ALARM_ENABLE<s(0)(0)(0)>[&] = 0,
	FMM_AIS_ENABLE<s(0)(0)(0)>[&]   = 1,
	FMM_RDI_ENABLE<s(0)(0)(0)>[&]   = 2,
	FMM_SEF_ENABLE<s(0)(0)(0)>[&]   = 3
}FMM_NE_CFG_NUM<s(0)(0)(0)>[&];(D1:FMM_NE_CFG_NUM:1)[[TYPENAME:FMM_NE_CFG_NUM]]

 
typedef struct
{
    command_tt<s(1)(1)(0)>[T]          head<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]              ledId<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T]                ledOn<s(1)(1)(0)>[&];
} FMM_FMA_ALARM_OUT_STATE_CMND_T<s(0)(0)(0)>[&];(D1:FMM_FMA_ALARM_OUT_STATE_CMND_T:1)[[TYPENAME:FMM_FMA_ALARM_OUT_STATE_CMND_T]]

 
typedef struct
{
    command_tt<s(1)(1)(0)>[T]          head<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]              ledId<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T]                ledOn<s(1)(1)(0)>[&];
} FMM_FMA_MDO_STATE_CMND_T<s(0)(0)(0)>[&];(D1:FMM_FMA_MDO_STATE_CMND_T:1)[[TYPENAME:FMM_FMA_MDO_STATE_CMND_T]]


 
 

































typedef struct
{
    command_tt<s(1)(1)(0)>[T]          head<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]              ioaIndex<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T]                enable<s(1)(1)(0)>[&];
} FMM_FMC_MDI_ENABLE_CFG_CMND_T<s(0)(0)(0)>[&];(D1:FMM_FMC_MDI_ENABLE_CFG_CMND_T:1)[[TYPENAME:FMM_FMC_MDI_ENABLE_CFG_CMND_T]]


 
typedef struct
{
    command_tt<s(1)(1)(0)>[T]          head<s(1)(1)(0)>[&];
    UINT32<s(1)(1)(0)>[T]              alarmId<s(1)(1)(0)>[&];
    BOOL<s(1)(1)(0)>[T]                inhibit<s(1)(1)(0)>[&];
} FMM_FMC_ALARM_TYPE_INHIBIT_CFG_CMND_T<s(0)(0)(0)>[&];(D1:FMM_FMC_ALARM_TYPE_INHIBIT_CFG_CMND_T:1)[[TYPENAME:FMM_FMC_ALARM_TYPE_INHIBIT_CFG_CMND_T]]

 
typedef enum
{
    FM_ALARM_RULE_NO_CHANGE<s(0)(0)(0)>[&] = 0,           
    FM_ALARM_RULE_ENABLE<s(0)(0)(0)>[&] = 1,               
    FM_ALARM_RULE_DISABLE<s(0)(0)(0)>[&] = 2,              
} FM_ALARM_RULE_T<s(0)(0)(0)>[&];(D1:FM_ALARM_RULE_T:1)[[TYPENAME:FM_ALARM_RULE_T]]

typedef struct
{
    command_tt<s(1)(1)(0)>[T]          head<s(1)(1)(0)>[&];
    FM_ALARM_RULE_T<s(1)(1)(0)>[T]     lof<s(1)(1)(0)>[&];
    FM_ALARM_RULE_T<s(1)(1)(0)>[T]     lom<s(1)(1)(0)>[&];
    FM_ALARM_RULE_T<s(1)(1)(0)>[T]     lop<s(1)(1)(0)>[&];
} FMM_FMC_ALARM_RULE_CFG_CMND_T<s(0)(0)(0)>[&];(D1:FMM_FMC_ALARM_RULE_CFG_CMND_T:1)[[TYPENAME:FMM_FMC_ALARM_RULE_CFG_CMND_T]]

extern int FMM_TclCmdShowProc<s(0)(0)(0)>[&](ClientData<s(0)(0)(0)>[T] clientData<s(0)(0)(0)>[&], Tcl_Interp<s(0)(0)(0)>[T] *interp<s(0)(0)(0)>[&], int argc<s(0)(0)(0)>[&], char *argv<s(0)(0)(0)>[&][]);(D1:argv:0)








 
































































 






















 







typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*CAI_LoadCard<s(0)(0)(0)>[&])TYPENAME:FUNC:(CAI_LoadCard)(UINT32<s(0)(0)(0)>[T] instance<s(0)(0)(0)>[&],
                                        UINT32<s(0)(0)(0)>[T] style<s(0)(0)(0)>[&],
                                        UINT32<s(0)(0)(0)>[T] option<s(0)(0)(0)>[&]);(D1:option:0)

 





PB_ERROR_CODE_T<s(0)(0)(0)>[T] CAI_RegisterLoad<s(0)(0)(0)>[&](CAI_LoadCard<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)

 









 





 
 


 






 

 





 

 





 

 





 

 





 

 





 

 







typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*CAI_BoardStateChangeFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(CAI_BoardStateChangeFunc)(BOARD_EVENT_T<s(0)(0)(0)>[T] event<s(0)(0)(0)>[&], SLOT_NUMBER_T<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&], BOARD_STYLE_T<s(0)(0)(0)>[T] style<s(0)(0)(0)>[&]);(D1:style:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] CAI_BoardStateChange<s(0)(0)(0)>[&](BOARD_EVENT_T<s(0)(0)(0)>[T] event<s(0)(0)(0)>[&], SLOT_NUMBER_T<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&], BOARD_STYLE_T<s(0)(0)(0)>[T] style<s(0)(0)(0)>[&]);(D1:style:0)


 






 


 





 

 






typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*CAI_ReportCardFailureFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(CAI_ReportCardFailureFunc)(INT16<s(0)(0)(0)>[T] entityNum<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] failure<s(0)(0)(0)>[&]);(D1:failure:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] CAI_ReportCardFailure<s(0)(0)(0)>[&](INT16<s(0)(0)(0)>[T] entityNum<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] failure<s(0)(0)(0)>[&]);(D1:failure:0)



 






typedef struct _CM_CARDPRESENCE_T<s(1)(0)(1)>[&]
{
    BOARD_PRESENCE_T<s(1)(1)(0)>[T]  IsPresent<s(1)(1)(0)>[&][16  + 1];   
                                          
} CM_CARDPRESENCE_T<s(0)(0)(0)>[&];(D1:CM_CARDPRESENCE_T:1)[[TYPENAME:CM_CARDPRESENCE_T]]

typedef void (*CAI_ReportCardPresenceFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(CAI_ReportCardPresenceFunc)(INT16<s(0)(0)(0)>[T] entityNum<s(0)(0)(0)>[&],
                                       ENTITY_INFO_T<s(0)(0)(0)>[T] *pInfo<s(0)(0)(0)>[&]);(D1:pInfo:0)
void CAI_ReportCardPresence<s(0)(0)(0)>[&](INT16<s(0)(0)(0)>[T] entityNum<s(0)(0)(0)>[&],
                                       ENTITY_INFO_T<s(0)(0)(0)>[T] *pInfo<s(0)(0)(0)>[&]);(D1:pInfo:0)

 





 



 

 
 











 




















void Cad_PrintTask<s(0)(0)(0)>[&](void);(D1:Cad_PrintTask:0)
 







typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*CAD_InitCard<s(0)(0)(0)>[&])TYPENAME:FUNC:(CAD_InitCard)(UINT32<s(0)(0)(0)>[T] instance<s(0)(0)(0)>[&],
                                        UINT32<s(0)(0)(0)>[T] style<s(0)(0)(0)>[&],
                                        UINT32<s(0)(0)(0)>[T] option<s(0)(0)(0)>[&]);(D1:option:0)

 





PB_ERROR_CODE_T<s(0)(0)(0)>[T] CAD_RegisterInit<s(0)(0)(0)>[&](CAD_InitCard<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)


 






typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*CAD_ActivateCard<s(0)(0)(0)>[&])TYPENAME:FUNC:(CAD_ActivateCard)(UINT32<s(0)(0)(0)>[T] instance<s(0)(0)(0)>[&],BOOL<s(0)(0)(0)>[T] bWarmFlag<s(0)(0)(0)>[&]);(D1:bWarmFlag:0)

 





PB_ERROR_CODE_T<s(0)(0)(0)>[T] CAD_RegisterActive<s(0)(0)(0)>[&](CAD_ActivateCard<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)

 





typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*CAD_DeinitCard<s(0)(0)(0)>[&])TYPENAME:FUNC:(CAD_DeinitCard)(UINT32<s(0)(0)(0)>[T] instance<s(0)(0)(0)>[&]);(D1:instance:0)

 





PB_ERROR_CODE_T<s(0)(0)(0)>[T] CAD_RegisterDeinit<s(0)(0)(0)>[&](CAD_DeinitCard<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)

 





typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*CAD_DeactiveCard<s(0)(0)(0)>[&])TYPENAME:FUNC:(CAD_DeactiveCard)(UINT32<s(0)(0)(0)>[T] instance<s(0)(0)(0)>[&]);(D1:instance:0)

 





PB_ERROR_CODE_T<s(0)(0)(0)>[T] CAD_RegisterDeactive<s(0)(0)(0)>[&](CAD_DeactiveCard<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)

 







 
 


 






typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*CAD_Detecter<s(0)(0)(0)>[&])TYPENAME:FUNC:(CAD_Detecter)(INSTANCE_T<s(0)(0)(0)>[T] instance<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] *pState<s(0)(0)(0)>[&]);(D1:pState:0)


 





PB_ERROR_CODE_T<s(0)(0)(0)>[T] CAD_RegisterDetecter<s(0)(0)(0)>[&](CAD_Detecter<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)

 








 
 
 
 



 





 









 
 

 
                                       

 






typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*CAD_ColdRebootFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(CAD_ColdRebootFunc)(void);(D1:CAD_ColdRebootFunc:0)
extern PB_ERROR_CODE_T<s(0)(0)(0)>[T] CAD_RegisterColdReboot<s(0)(0)(0)>[&](CAD_ColdRebootFunc<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)

 






typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*CAD_ReportCardFailureFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(CAD_ReportCardFailureFunc)(UINT32<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] failure<s(0)(0)(0)>[&]);(D1:failure:0)
extern PB_ERROR_CODE_T<s(0)(0)(0)>[T] CAD_ReportCardFailure<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] failure<s(0)(0)(0)>[&]);(D1:failure:0)

 






typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*CAD_ReportFanFailureFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(CAD_ReportFanFailureFunc)(UINT32<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] failure<s(0)(0)(0)>[&]);(D1:failure:0)
extern PB_ERROR_CODE_T<s(0)(0)(0)>[T] CAD_ReportFanFailure<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] failure<s(0)(0)(0)>[&]);(D1:failure:0)

 






typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*CAD_FpgaVersion<s(0)(0)(0)>[&])TYPENAME:FUNC:(CAD_FpgaVersion)(INSTANCE_T<s(0)(0)(0)>[T]    inst<s(0)(0)(0)>[&], char *pFpgaVer<s(0)(0)(0)>[&]);(D1:pFpgaVer:0)

PB_ERROR_CODE_T<s(0)(0)(0)>[T] CAD_RegisterFpgaVersion<s(0)(0)(0)>[&](CAD_FpgaVersion<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)

 





typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*CAD_RebootL2Card<s(0)(0)(0)>[&])TYPENAME:FUNC:(CAD_RebootL2Card)(UINT32<s(0)(0)(0)>[T] instance<s(0)(0)(0)>[&]);(D1:instance:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] CAD_RegisterRebootL2Card<s(0)(0)(0)>[&](CAD_RebootL2Card<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)

typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*CAD_SetLOCCCardState<s(0)(0)(0)>[&])TYPENAME:FUNC:(CAD_SetLOCCCardState)(UINT32<s(0)(0)(0)>[T] instance<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bState<s(0)(0)(0)>[&]);(D1:bState:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] CAD_RegSetLOCCCardState<s(0)(0)(0)>[&](CAD_SetLOCCCardState<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)

typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*CAD_SetLcAIS<s(0)(0)(0)>[&])TYPENAME:FUNC:(CAD_SetLcAIS)(UINT32<s(0)(0)(0)>[T] instance<s(0)(0)(0)>[&],UINT32<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bSet<s(0)(0)(0)>[&]);(D1:bSet:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] CAD_RegSetLcAIS<s(0)(0)(0)>[&](CAD_SetLcAIS<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)

 

extern PB_ERROR_CODE_T<s(0)(0)(0)>[T] CMC_RegisterECCActive<s(0)(0)(0)>[&](CAD_ActivateCard<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)
extern PB_ERROR_CODE_T<s(0)(0)(0)>[T] CMC_RegisterECCDeactive<s(0)(0)(0)>[&](CAD_DeactiveCard<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)

















 

typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*SDD_TEMP_EVENT_CBACK<s(0)(0)(0)>[&])TYPENAME:FUNC:(SDD_TEMP_EVENT_CBACK)(ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&],
                                     SDD_BOARD_TYPE_T<s(0)(0)(0)>[T] boardtype<s(0)(0)(0)>[&],
                                     BOOL<s(0)(0)(0)>[T] bOverheat<s(0)(0)(0)>[&]);(D1:bOverheat:0)
 
typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T] (*SDD_TEMP_LEM_EVENT_CBACK<s(0)(0)(0)>[&])TYPENAME:FUNC:(SDD_TEMP_LEM_EVENT_CBACK)(ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&],
                                     SDD_BOARD_TYPE_T<s(0)(0)(0)>[T] boardtype<s(0)(0)(0)>[&],
                                     BOOL<s(0)(0)(0)>[T] bOverheat<s(0)(0)(0)>[&]);(D1:bOverheat:0)
 
typedef void (*HII_PTInitGESFPFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(HII_PTInitGESFPFunc)(int instance<s(0)(0)(0)>[&], int portId<s(0)(0)(0)>[&], int SFPType<s(0)(0)(0)>[&]);(D1:SFPType:0)

 
typedef PB_ERROR_CODE_T<s(0)(0)(0)>[T](*SDD_NotifyIfmSfpChange<s(0)(0)(0)>[&])TYPENAME:FUNC:(SDD_NotifyIfmSfpChange)(UINT32<s(0)(0)(0)>[T] ulSlotNo<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulPortType<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulPortNo<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulConnectorType<s(0)(0)(0)>[&]);(D1:ulConnectorType:0) 

 
SDD_RESET_REASON<s(0)(0)(0)>[T] SDD_GetResetReason<s(0)(0)(0)>[&]();(D1:SDD_GetResetReason:0)
void SDD_LoadModule<s(0)(0)(0)>[&]();(D1:SDD_LoadModule:0)
void SDD_SetModuleState<s(0)(0)(0)>[&](BOOL<s(0)(0)(0)>[T] enable<s(0)(0)(0)>[&]);(D1:enable:0)
BOOL<s(0)(0)(0)>[T] SDD_GetModuleState<s(0)(0)(0)>[&]();(D1:SDD_GetModuleState:0)
BOOL<s(0)(0)(0)>[T] SDD_JudgeIfMaincard<s(0)(0)(0)>[&]();(D1:SDD_JudgeIfMaincard:0)
PbBoardStyle_Tval<s(0)(0)(0)>[T] SDD_GetLocalBoardStyle<s(0)(0)(0)>[&]();(D1:SDD_GetLocalBoardStyle:0)


 
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_InitCard<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], CARDTYPE_T<s(0)(0)(0)>[T] cardType<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulOption<s(0)(0)(0)>[&]);(D1:ulOption:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_ActivateCard<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bWarm<s(0)(0)(0)>[&]);(D1:bWarm:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_DeactivateCard<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&]);(D1:entity:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_DeinitCard<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&]);(D1:entity:0)

BOARD_PRESENCE_T<s(0)(0)(0)>[T] SDD_GetBoardPresence<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&]);(D1:entity:0)
PbBoardFunction_Tval<s(0)(0)(0)>[T] SDD_GetBoardFunction<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&]);(D1:entity:0)
PbBoardStyle_Tval<s(0)(0)(0)>[T] SDD_GetBoardStyle<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&]);(D1:entity:0)
UINT<s(0)(0)(0)>[T] SDD_GetSlotBoardRev<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&]);(D1:entity:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_ResetBoard<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&]);(D1:entity:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_SetLedState<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], LED_TYPE_T<s(0)(0)(0)>[T] ledType<s(0)(0)(0)>[&],UINT16<s(0)(0)(0)>[T] usLedId<s(0)(0)(0)>[&], LED_STATE_T<s(0)(0)(0)>[T] ledState<s(0)(0)(0)>[&]);(D1:ledState:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_GetLedState<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], LED_TYPE_T<s(0)(0)(0)>[T] ledType<s(0)(0)(0)>[&],UINT16<s(0)(0)(0)>[T] usLedId<s(0)(0)(0)>[&], LED_STATE_T<s(0)(0)(0)>[T] *pLedState<s(0)(0)(0)>[&]);(D1:pLedState:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_GetMdiPort<s(0)(0)(0)>[&](UINT16<s(0)(0)(0)>[T] portId<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] *pbState<s(0)(0)(0)>[&]);(D1:pbState:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_SetMdoPort<s(0)(0)(0)>[&](UINT16<s(0)(0)(0)>[T] portId<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&]);(D1:bEnable:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_SetAlarmOut<s(0)(0)(0)>[&](UINT16<s(0)(0)(0)>[T] portId<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&]);(D1:bEnable:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_SetGlobalOutSignalStatus<s(0)(0)(0)>[&](BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&]);(D1:bEnable:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_SetCardOutSignalStatus<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&]);(D1:bEnable:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_SetCardManageSignalStatus<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] portId<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&]);(D1:bEnable:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_SetPortAdminStatus<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], HW_PORT_TYPE<s(0)(0)(0)>[T] portType<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] portId<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&]);(D1:bEnable:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_EnablePortAls<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], HW_PORT_TYPE<s(0)(0)(0)>[T] portType<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] portId<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&]);(D1:bEnable:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_GetInSignalPowerStatus<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], HW_PORT_TYPE<s(0)(0)(0)>[T] portType<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] portId<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] *pNip<s(0)(0)(0)>[&]);(D1:pNip:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_NotifyLos<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], HW_PORT_TYPE<s(0)(0)(0)>[T] portType<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] portId<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bLos<s(0)(0)(0)>[&]);(D1:bLos:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_GetOutSignalStatus<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], HW_PORT_TYPE<s(0)(0)(0)>[T] portType<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] portId<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] *pStatus<s(0)(0)(0)>[&]);(D1:pStatus:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_SetSTMMode<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], HW_PORT_TYPE<s(0)(0)(0)>[T] ePortType<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&], HW_ACT_PORT_TYPE<s(0)(0)(0)>[T] Mode<s(0)(0)(0)>[&]);(D1:Mode:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_GetSfpPresence<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], HW_PORT_TYPE<s(0)(0)(0)>[T] portType<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] portId<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] *pState<s(0)(0)(0)>[&]);(D1:pState:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_GetLaserParameters<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], HW_PORT_TYPE<s(0)(0)(0)>[T] portType<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] portId<s(0)(0)(0)>[&], LASER_PARAMETER_T<s(0)(0)(0)>[T] *pParam<s(0)(0)(0)>[&]);(D1:pParam:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_GetRtcTime<s(0)(0)(0)>[&](struct tm<s(1)(0)(1)>[&] *pMyTime<s(0)(0)(0)>[&]);(D1:pMyTime:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_SetRtcTime<s(0)(0)(0)>[&](struct tm<s(1)(0)(1)>[&] *myTime<s(0)(0)(0)>[&]);(D1:myTime:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_GetTemperature<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] id<s(0)(0)(0)>[&], INT16<s(0)(0)(0)>[T] *pTemp<s(0)(0)(0)>[&]);(D1:pTemp:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_SetTempThreshold<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], TEMPERATURE_T<s(0)(0)(0)>[T] high<s(0)(0)(0)>[&], TEMPERATURE_T<s(0)(0)(0)>[T] low<s(0)(0)(0)>[&]);(D1:low:0)
 
void SDD_Enable1HzInterrupt<s(0)(0)(0)>[&](BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&]);(D1:bEnable:0)
void SDD_RegisterReportDefect<s(0)(0)(0)>[&](FMA_AlmModDefectFunc<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)         
void SDD_RegisterBoardsPresence<s(0)(0)(0)>[&](CAI_ReportCardPresenceFunc<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0) 
void SDD_RegisterReportCardFail<s(0)(0)(0)>[&](CAI_ReportCardFailureFunc<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)  
void SDD_RegisterNotifyIfmSfpChange<s(0)(0)(0)>[&](SDD_NotifyIfmSfpChange<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)  

PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_RegisterLatchEvent<s(0)(0)(0)>[&](SDD_LATCH_EVENT_CBACK<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)   
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_NotifyLatchEvent<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&],CARDTYPE_T<s(0)(0)(0)>[T] cardType<s(0)(0)(0)>[&],BOARD_EVENT_T<s(0)(0)(0)>[T] latchEvent<s(0)(0)(0)>[&]);(D1:latchEvent:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_RegisterBoardEvent<s(0)(0)(0)>[&](SDD_BOARD_EVENT_CBACK<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)   
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_RegisterEntityUpdate<s(0)(0)(0)>[&](SDD_ENTITY_UPDATE_CBACK<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)   
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_RegisterOneSecTimer<s(0)(0)(0)>[&](SDD_ONE_SECOND_TIMER_CBACK<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_RegisterButtonEvent<s(0)(0)(0)>[&](SDD_BUTTON_EVENT_CBACK<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_RegisterTempEvent<s(0)(0)(0)>[&](SDD_TEMP_EVENT_CBACK<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)         
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_RegisterTempLemEvent<s(0)(0)(0)>[&](SDD_TEMP_LEM_EVENT_CBACK<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)         
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_SetNotifyTempEvent<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&]);(D1:entity:0)

 


void SDD_RegisterReportFanFail<s(0)(0)(0)>[&](CAD_ReportFanFailureFunc<s(0)(0)(0)>[T] pFunc<s(0)(0)(0)>[&]);(D1:pFunc:0)


PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_ECCardSwitch<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], SDD_EC_SWITCH_T<s(0)(0)(0)>[T] switchStatus<s(0)(0)(0)>[&]);(D1:switchStatus:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_TimingRefSel<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], TIMING_REF_T<s(0)(0)(0)>[T] refSet<s(0)(0)(0)>[&]);(D1:refSet:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_DetectFanFailure<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&]);(D1:entity:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_DetectPwrFailure<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&]);(D1:entity:0)
void SDD_EnableLedTest<s(0)(0)(0)>[&](BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&]);(D1:bEnable:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_GetFanState<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], FAN_STATUS_T<s(0)(0)(0)>[T] *pState<s(0)(0)(0)>[&]);(D1:pState:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_GetPowerState<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] id<s(0)(0)(0)>[&], POWER_STATUS_T<s(0)(0)(0)>[T] *pState<s(0)(0)(0)>[&]);(D1:pState:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_GetLocalSlot<s(0)(0)(0)>[&](SLOT_NUMBER_T<s(0)(0)(0)>[T] *pSlot<s(0)(0)(0)>[&]);(D1:pSlot:0)

 
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_SET_OAReset<s(0)(0)(0)>[&] (BOOL<s(0)(0)(0)>[T] bActive<s(0)(0)(0)>[&]);(D1:bActive:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_SET_OADisable<s(0)(0)(0)>[&] (BOOL<s(0)(0)(0)>[T] bActive<s(0)(0)(0)>[&]);(D1:bActive:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_SET_OAOutputMute<s(0)(0)(0)>[&] (BOOL<s(0)(0)(0)>[T] bActive<s(0)(0)(0)>[&]);(D1:bActive:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_SET_OALinkLED<s(0)(0)(0)>[&] (BOOL<s(0)(0)(0)>[T] bActive<s(0)(0)(0)>[&]);(D1:bActive:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_GET_OAPin<s(0)(0)(0)>[&] (UINT16<s(0)(0)(0)>[T] *wStatus<s(0)(0)(0)>[&]);(D1:wStatus:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_ResetAsic<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&]);(D1:entity:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_InitSi5319Sedres<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&]);(D1:entity:0)

 
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_SetGeElLaserParameters<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&],HW_PORT_TYPE<s(0)(0)(0)>[T] portType<s(0)(0)(0)>[&],
                                UINT16<s(0)(0)(0)>[T] port<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] offset<s(0)(0)(0)>[&],UINT16<s(0)(0)(0)>[T] val<s(0)(0)(0)>[&]);(D1:val:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_GetGeElLaserParameters<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&],HW_PORT_TYPE<s(0)(0)(0)>[T] portType<s(0)(0)(0)>[&],
                                UINT16<s(0)(0)(0)>[T] port<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] offset<s(0)(0)(0)>[&],UINT16<s(0)(0)(0)>[T] * val<s(0)(0)(0)>[&]);(D1:val:0)
void SDD_RegHIIInitGeSfp<s(0)(0)(0)>[&](HII_PTInitGESFPFunc<s(0)(0)(0)>[T] fun<s(0)(0)(0)>[&]);(D1:fun:0)
 
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_SetAlsMode<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], HW_PORT_TYPE<s(0)(0)(0)>[T] portType<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T]  usPortId<s(0)(0)(0)>[&], ALS_MODE_STATUS_T<s(0)(0)(0)>[T] aMode<s(0)(0)(0)>[&]);(D1:aMode:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDDSetPCA9555<s(0)(0)(0)>[&](UINT8<s(0)(0)(0)>[T] addr<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] states<s(0)(0)(0)>[&]);(D1:states:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_SetImpedanceMode<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], HW_PORT_TYPE<s(0)(0)(0)>[T] ePortType<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&], PDH_OHM_TYPE_T<s(0)(0)(0)>[T] eOhmType<s(0)(0)(0)>[&]);(D1:eOhmType:0)
void SDD_NotifyNERebootFinished<s(0)(0)(0)>[&]();(D1:SDD_NotifyNERebootFinished:0)
void SDD_NotifyNERebootStarted<s(0)(0)(0)>[&]();(D1:SDD_NotifyNERebootStarted:0)

 
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_SetPortAdminStatus<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], HW_PORT_TYPE<s(0)(0)(0)>[T] portType<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] portId<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&]);(D1:bEnable:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_SetWavelength<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] etEntity<s(0)(0)(0)>[&], HW_PORT_TYPE<s(0)(0)(0)>[T] portType<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] portId<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] wWaveLengthId<s(0)(0)(0)>[&]);(D1:wWaveLengthId:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_SetDecisionThreshold<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] etEntity<s(0)(0)(0)>[&], HW_PORT_TYPE<s(0)(0)(0)>[T] portType<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] portId<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] wDecesionThreshold<s(0)(0)(0)>[&]);(D1:wDecesionThreshold:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_GetOsrAbnormalStatus<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] etEntity<s(0)(0)(0)>[&], HW_PORT_TYPE<s(0)(0)(0)>[T] portType<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] portId<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] *pbState<s(0)(0)(0)>[&]);(D1:pbState:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_GetDecisionThreshold<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] etEntity<s(0)(0)(0)>[&], HW_PORT_TYPE<s(0)(0)(0)>[T] portType<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] portId<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] *wDecesionThreshold<s(0)(0)(0)>[&]);(D1:wDecesionThreshold:0)

PB_ERROR_CODE_T<s(0)(0)(0)>[T] SDD_ISELECSFP<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], HW_PORT_TYPE<s(0)(0)(0)>[T] portType<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] portId<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] *wIsElecSfp<s(0)(0)(0)>[&]);(D1:wIsElecSfp:0)

extern int sdd_get_ioN_port<s(0)(0)(0)>[&] (int io<s(0)(0)(0)>[&], int * pFirst<s(0)(0)(0)>[&], int * pLast<s(0)(0)(0)>[&]);(D1:pLast:0)
extern int SDD_126xE1IOPortConvert<s(0)(0)(0)>[&] (int port<s(0)(0)(0)>[&]);(D1:port:0)












 

























 

 

 























































 





 

extern  int intCnt<s(0)(0)(0)>[&];(D1:intCnt:0)		 


 



 














 



extern STATUS<s(0)(0)(0)>[T] 	intConnect<s(0)(0)(0)>[&] (VOIDFUNCPTR<s(0)(0)(0)>[T] *vector<s(0)(0)(0)>[&], VOIDFUNCPTR<s(0)(0)(0)>[T] routine<s(0)(0)(0)>[&],
	       	    	    int parameter<s(0)(0)(0)>[&]);(D1:parameter:0)
extern FUNCPTR<s(0)(0)(0)>[T] 	intHandlerCreate<s(0)(0)(0)>[&] (FUNCPTR<s(0)(0)(0)>[T] routine<s(0)(0)(0)>[&], int parameter<s(0)(0)(0)>[&]);(D1:parameter:0)
extern void 	intLockLevelSet<s(0)(0)(0)>[&] (int newLevel<s(0)(0)(0)>[&]);(D1:newLevel:0)
extern int 	intLockLevelGet<s(0)(0)(0)>[&] (void);(D1:intLockLevelGet:0)
extern BOOL<s(0)(0)(0)>[T] 	intContext<s(0)(0)(0)>[&] (void);(D1:intContext:0)
extern int 	intCount<s(0)(0)(0)>[&] (void);(D1:intCount:0)
extern void 	intVecBaseSet<s(0)(0)(0)>[&] (FUNCPTR<s(0)(0)(0)>[T] *baseAddr<s(0)(0)(0)>[&]);(D1:baseAddr:0)
extern FUNCPTR<s(0)(0)(0)>[T] *intVecBaseGet<s(0)(0)(0)>[&] (void);(D1:intVecBaseGet:0)
extern void 	intVecSet<s(0)(0)(0)>[&] (FUNCPTR<s(0)(0)(0)>[T] *vector<s(0)(0)(0)>[&], FUNCPTR<s(0)(0)(0)>[T] function<s(0)(0)(0)>[&]);(D1:function:0)
extern FUNCPTR<s(0)(0)(0)>[T] 	intVecGet<s(0)(0)(0)>[&] (FUNCPTR<s(0)(0)(0)>[T] *vector<s(0)(0)(0)>[&]);(D1:vector:0)
extern int 	intLevelSet<s(0)(0)(0)>[&] (int level<s(0)(0)(0)>[&]);(D1:level:0)
extern int 	intLock<s(0)(0)(0)>[&] (void);(D1:intLock:0)
extern int 	intUnlock<s(0)(0)(0)>[&] (int oldSR<s(0)(0)(0)>[&]);(D1:oldSR:0)
extern int 	intRegsLock<s(0)(0)(0)>[&] (REG_SET<s(0)(0)(0)>[T] *pRegs<s(0)(0)(0)>[&]);(D1:pRegs:0)
extern void 	intRegsUnlock<s(0)(0)(0)>[&] (REG_SET<s(0)(0)(0)>[T] *pRegs<s(0)(0)(0)>[&], int lockKey<s(0)(0)(0)>[&]);(D1:lockKey:0)
extern STATUS<s(0)(0)(0)>[T]   intVecTableWriteProtect<s(0)(0)(0)>[&] (void);(D1:intVecTableWriteProtect:0)

























extern int	intDisable<s(0)(0)(0)>[&] (int);(D1:intDisable:0)
extern int	intEnable<s(0)(0)(0)>[&] (int);(D1:intEnable:0)






























 

 
 

 





 


















































     






















    typedef struct _FPGA_REGADDR_T<s(1)(0)(1)>[&]
    {
        UINT32<s(1)(1)(0)>[T] mask1<s(1)(1)(0)>[&];
        UINT32<s(1)(1)(0)>[T] mask2<s(1)(1)(0)>[&];
        UINT32<s(1)(1)(0)>[T] mask3<s(1)(1)(0)>[&];
        UINT32<s(1)(1)(0)>[T] status1<s(1)(1)(0)>[&];
        UINT32<s(1)(1)(0)>[T] status2<s(1)(1)(0)>[&];
        UINT32<s(1)(1)(0)>[T] status3<s(1)(1)(0)>[&];
    }
    FPGA_REGADDR_T<s(0)(0)(0)>[&];(D1:FPGA_REGADDR_T:1)[[TYPENAME:FPGA_REGADDR_T]]




     

 
     





     































    typedef struct _FPGA_SIG_PIN_T<s(1)(0)(1)>[&]
    {
        UINT32<s(1)(1)(0)>[T] port<s(1)(1)(0)>[&];                   
        UINT32<s(1)(1)(0)>[T] pin<s(1)(1)(0)>[&];                    
    }
    FPGA_SIG_PIN_T<s(0)(0)(0)>[&];(D1:FPGA_SIG_PIN_T:1)[[TYPENAME:FPGA_SIG_PIN_T]]






























    typedef struct _FPGA_PIN_XILINX_T<s(1)(0)(1)>[&]
    {
        FPGA_SIG_PIN_T<s(1)(1)(0)>[T] BitInit<s(1)(1)(0)>[&];             
        FPGA_SIG_PIN_T<s(1)(1)(0)>[T] BitProgram<s(1)(1)(0)>[&];          
        FPGA_SIG_PIN_T<s(1)(1)(0)>[T] BitDone<s(1)(1)(0)>[&];             
 
        FPGA_SIG_PIN_T<s(1)(1)(0)>[T] BitFpgaDln<s(1)(1)(0)>[&];          
    }
    FPGA_PIN_XILINX_T<s(0)(0)(0)>[&];(D1:FPGA_PIN_XILINX_T:1)[[TYPENAME:FPGA_PIN_XILINX_T]]

    typedef struct _FPGA_PIN_ALTERA_T<s(1)(0)(1)>[&]
    {
        FPGA_SIG_PIN_T<s(1)(1)(0)>[T] BitDClk<s(1)(1)(0)>[&];             
        FPGA_SIG_PIN_T<s(1)(1)(0)>[T] BitData0<s(1)(1)(0)>[&];            
        FPGA_SIG_PIN_T<s(1)(1)(0)>[T] BitnConfig<s(1)(1)(0)>[&];          
        FPGA_SIG_PIN_T<s(1)(1)(0)>[T] BitnStatus<s(1)(1)(0)>[&];          
        FPGA_SIG_PIN_T<s(1)(1)(0)>[T] BitCfgDone<s(1)(1)(0)>[&];          
 
        FPGA_SIG_PIN_T<s(1)(1)(0)>[T] BitFpgaDln<s(1)(1)(0)>[&];          
    }
    FPGA_PIN_ALTERA_T<s(0)(0)(0)>[&];(D1:FPGA_PIN_ALTERA_T:1)[[TYPENAME:FPGA_PIN_ALTERA_T]]

    typedef union _FPGA_PINCFG_T<s(1)(0)(1)>[&]
    {
        FPGA_PIN_ALTERA_T<s(1)(1)(0)>[T] PinAltera<s(1)(1)(0)>[&];        
        FPGA_PIN_XILINX_T<s(1)(1)(0)>[T] PinXilinx<s(1)(1)(0)>[&];        
    } FPGA_PINCFG_T<s(0)(0)(0)>[&];(D1:FPGA_PINCFG_T:1)[[TYPENAME:FPGA_PINCFG_T]]

     









     





























     


    typedef enum
    {
        FPGA_STATUS_INACTIVE<s(0)(0)(0)>[&],
        FPGA_STATUS_ACTIVE<s(0)(0)(0)>[&],
    } FPGA_STATUS_T<s(0)(0)(0)>[&];(D1:FPGA_STATUS_T:1)[[TYPENAME:FPGA_STATUS_T]]

    typedef int FPGA_HANDLE<s(0)(0)(0)>[&];(D1:FPGA_HANDLE:1)[[TYPENAME:FPGA_HANDLE]]







    typedef unsigned int FPGA_HOOK_ARG<s(0)(0)(0)>[&];(D1:FPGA_HOOK_ARG:1)[[TYPENAME:FPGA_HOOK_ARG]]
    typedef void ( * FPGA_HOOK_FUNC<s(0)(0)(0)>[&] )TYPENAME:FUNC:(FPGA_HOOK_FUNC) ( FPGA_HANDLE<s(0)(0)(0)>[T] handle<s(0)(0)(0)>[&], FPGA_HOOK_ARG<s(0)(0)(0)>[T] usrHookArg<s(0)(0)(0)>[&] );(D1:usrHookArg:0)

    typedef struct _FPGA_INTHOOK_T<s(1)(0)(1)>[&]
    {
        FPGA_HOOK_FUNC<s(1)(1)(0)>[T] UsrHookFunc<s(1)(1)(0)>[&];         
        FPGA_HOOK_ARG<s(1)(1)(0)>[T] UsrHookArg<s(1)(1)(0)>[&];          
        UINT32<s(1)(1)(0)>[T] Interrupts<s(1)(1)(0)>[&];          
        UINT32<s(1)(1)(0)>[T] Missed<s(1)(1)(0)>[&];              
    }
    FPGA_INTHOOK_T<s(0)(0)(0)>[&];(D1:FPGA_INTHOOK_T:1)[[TYPENAME:FPGA_INTHOOK_T]]

    typedef struct _FPGA_ERR_STATS_T<s(1)(0)(1)>[&]
    {
        UINT32<s(1)(1)(0)>[T] Interrupts<s(1)(1)(0)>[&];                  
        UINT32<s(1)(1)(0)>[T] WriteViolate<s(1)(1)(0)>[&];                
        UINT32<s(1)(1)(0)>[T] AddressViolate<s(1)(1)(0)>[&];              
        UINT32<s(1)(1)(0)>[T] SizeViolate<s(1)(1)(0)>[&];                 
        UINT32<s(1)(1)(0)>[T] PortViolate<s(1)(1)(0)>[&];                 
        UINT32<s(1)(1)(0)>[T] BoundaryViolate<s(1)(1)(0)>[&];             
    }
    FPGA_ERRSTATS_T<s(0)(0)(0)>[&];(D1:FPGA_ERRSTATS_T:1)[[TYPENAME:FPGA_ERRSTATS_T]]


     


    typedef struct _FPGA_CHIP_DATA_T<s(1)(0)(1)>[&]
    {
        UINT8<s(1)(1)(0)>[T] Chip<s(1)(1)(0)>[&];                
        UCHAR<s(1)(1)(0)>[T] CS<s(1)(1)(0)>[&];                  
        UINT16<s(1)(1)(0)>[T] IntNum<s(1)(1)(0)>[&];              
        UINT32<s(1)(1)(0)>[T] MemBase<s(1)(1)(0)>[&];             
        FPGA_PINCFG_T<s(1)(1)(0)>[T] PinCfg<s(1)(1)(0)>[&];              
        UCHAR<s(1)(1)(0)>[T] * FileName<s(1)(1)(0)>[&];            
        void ( *RegInit<s(1)(1)(0)>[&] ) ( struct _FPGA_CHIP_DATA_T<s(2)(1)(1)>[&] * );
         
        UINT32<s(1)(1)(0)>[T] SubFunction<s(1)(1)(0)>[&];         
        UCHAR<s(1)(1)(0)>[T] * SubSlot<s(1)(1)(0)>[&];             

        FPGA_INTHOOK_T<s(1)(1)(0)>[T] IntHook<s(1)(1)(0)>[&][ 64  ];
         
        FPGA_ERRSTATS_T<s(1)(1)(0)>[T] ErrStats<s(1)(1)(0)>[&];            
        UINT32<s(1)(1)(0)>[T] Version<s(1)(1)(0)>[&];             
        UINT32<s(1)(1)(0)>[T] Status<s(1)(1)(0)>[&];
    }
    FPGA_CHIP_DATA_T<s(0)(0)(0)>[&];(D1:FPGA_CHIP_DATA_T:1)[[TYPENAME:FPGA_CHIP_DATA_T]]





    typedef struct
    {
        UCHAR<s(1)(1)(0)>[T] fileName<s(1)(1)(0)>[&][ 13  ];
        UINT32<s(1)(1)(0)>[T] fileLength<s(1)(1)(0)>[&];
    }
    FPGA_MEM_DATA_T<s(0)(0)(0)>[&];(D1:FPGA_MEM_DATA_T:1)[[TYPENAME:FPGA_MEM_DATA_T]]

    extern FPGA_CHIP_DATA_T<s(0)(0)(0)>[T] *fpgaChips<s(0)(0)(0)>[&];(D1:fpgaChips:0)



     



    extern int pbFpgaInit<s(0)(0)(0)>[&]( void );(D1:pbFpgaInit:0)

    extern FPGA_STATUS_T<s(0)(0)(0)>[T] pbFpgaGetStatus<s(0)(0)(0)>[&]( void );(D1:pbFpgaGetStatus:0)

     



    extern FPGA_HANDLE<s(0)(0)(0)>[T] pbFpgaIsrHookAdd<s(0)(0)(0)>[&]
        (
            int chip<s(0)(0)(0)>[&],
            int asic<s(0)(0)(0)>[&],
            int bank<s(0)(0)(0)>[&],
            FPGA_HOOK_FUNC<s(0)(0)(0)>[T] usrHookFunc<s(0)(0)(0)>[&],
            FPGA_HOOK_ARG<s(0)(0)(0)>[T] usrHookArg<s(0)(0)(0)>[&]
        );(D1:usrHookArg:0)
    extern FPGA_HANDLE<s(0)(0)(0)>[T] pbFpgaIsrHookSlotAdd<s(0)(0)(0)>[&]
        (
            PbSlotNumberType_Tval<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&],
            FPGA_HOOK_FUNC<s(0)(0)(0)>[T] usrHookFunc<s(0)(0)(0)>[&],
            FPGA_HOOK_ARG<s(0)(0)(0)>[T] usrHookArg<s(0)(0)(0)>[&]
        );(D1:usrHookArg:0)

     



    extern int pbFpgaIsrHookDel<s(0)(0)(0)>[&]( FPGA_HANDLE<s(0)(0)(0)>[T] handle<s(0)(0)(0)>[&] );(D1:handle:0)

     



    extern int pbFpgaIntrEnable<s(0)(0)(0)>[&]( FPGA_HANDLE<s(0)(0)(0)>[T] handle<s(0)(0)(0)>[&] );(D1:handle:0)
    extern int pbFpgaIntrSlotEnable<s(0)(0)(0)>[&]( PbSlotNumberType_Tval<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&] );(D1:slot:0)

     



    extern int pbFpgaIntrDisable<s(0)(0)(0)>[&]( FPGA_HANDLE<s(0)(0)(0)>[T] handle<s(0)(0)(0)>[&] );(D1:handle:0)
    extern int pbFpgaIntrSlotDisable<s(0)(0)(0)>[&]( PbSlotNumberType_Tval<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&] );(D1:slot:0)

    extern int pbFpgaIsrEnable<s(0)(0)(0)>[&]( int chip<s(0)(0)(0)>[&] );(D1:chip:0)
    extern int pbFpgaIsrDisable<s(0)(0)(0)>[&]( int chip<s(0)(0)(0)>[&] );(D1:chip:0)
    extern int pbFpgaDownloadCS<s(0)(0)(0)>[&]( UINT<s(0)(0)(0)>[T] cs<s(0)(0)(0)>[&], char * fileName<s(0)(0)(0)>[&], UCHAR<s(0)(0)(0)>[T] * data<s(0)(0)(0)>[&], UINT<s(0)(0)(0)>[T] length<s(0)(0)(0)>[&] );(D1:length:0)










    typedef void ( * FPGA_WRITE_FUNC<s(0)(0)(0)>[&] )TYPENAME:FUNC:(FPGA_WRITE_FUNC) ( UINT32<s(0)(0)(0)>[T] addr<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] var<s(0)(0)(0)>[&] );(D1:var:0)
    typedef UINT32<s(0)(0)(0)>[T] ( * FPGA_READ_FUNC<s(0)(0)(0)>[&] )TYPENAME:FUNC:(FPGA_READ_FUNC) ( UINT32<s(0)(0)(0)>[T] addr<s(0)(0)(0)>[&] );(D1:addr:0)

    STATUS<s(0)(0)(0)>[T] pbFpgaDownloadSlot<s(0)(0)(0)>[&]( PbSlotNumberType_Tval<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&], char * fileName<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] memBase<s(0)(0)(0)>[&] );(D1:memBase:0)
    STATUS<s(0)(0)(0)>[T] pbFpgaInitSlot<s(0)(0)(0)>[&]( PbSlotNumberType_Tval<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&], char * fileName<s(0)(0)(0)>[&] );(D1:fileName:0)








 



















































































 







































 









 



 






 



 


 










 


 


 


 

 

 

 


 

 

 

 


 


 


 





 
 
 

 



 
 
 

 

 
 
 

 




 
 
 

 


 


 


 


 


 


 


 

 

 


 
 
 

 


 
 
 

 


 


 


 


 




 



 


 


 
 
 

 



 
 
 

 



 

















 








 


















 
























 

























 

















 









     




 
 





 
 











    
 
 



 
 


 
 


 
 

















 
 




 
 









 
 













 
 













 




 


















 






























 





























 
















































































typedef enum
{
        eEm4EntEmp<s(0)(0)(0)>[&] = 0,
        eEm4EntInit<s(0)(0)(0)>[&],
        eEm4EntAct<s(0)(0)(0)>[&]  
}
EM4_ENTITY_STATE_T<s(0)(0)(0)>[&];(D1:EM4_ENTITY_STATE_T:1)[[TYPENAME:EM4_ENTITY_STATE_T]]


typedef void (*CPA_LATCHSTATE_CHANGE_FUNC<s(0)(0)(0)>[&])TYPENAME:FUNC:(CPA_LATCHSTATE_CHANGE_FUNC)(BOARD_EVENT_T<s(0)(0)(0)>[T] ulEvent<s(0)(0)(0)>[&], SLOT_NUMBER_T<s(0)(0)(0)>[T] usSlotNum<s(0)(0)(0)>[&], BOARD_STYLE_T<s(0)(0)(0)>[T] ulCardType<s(0)(0)(0)>[&]);(D1:ulCardType:0)
typedef struct
{
    FMA_AlmModDefectFunc<s(1)(1)(0)>[T] pFuncReportAlm<s(1)(1)(0)>[&];  
    CPA_LATCHSTATE_CHANGE_FUNC<s(1)(1)(0)>[T] pFuncReportLatch<s(1)(1)(0)>[&];  
    PRA_SetPortStatus_Func<s(1)(1)(0)>[T] pFuncReportPrbs<s(1)(1)(0)>[&];  
    CAI_BoardStateChangeFunc<s(1)(1)(0)>[T] pFuncReportFault<s(1)(1)(0)>[&];
} CAH_EM4_CALLBACKS_T<s(0)(0)(0)>[&];(D1:CAH_EM4_CALLBACKS_T:1)[[TYPENAME:CAH_EM4_CALLBACKS_T]]

typedef struct {
    UINT32<s(1)(1)(0)>[T] address<s(1)(1)(0)>[&];
    UINT8<s(1)(1)(0)>[T] value<s(1)(1)(0)>[&];
}EM4_REG_CONF<s(0)(0)(0)>[&];(D1:EM4_REG_CONF:1)[[TYPENAME:EM4_REG_CONF]]

typedef struct 
{
    UINT32<s(1)(1)(0)>[T] baseAddr<s(1)(1)(0)>[&];

     


    UINT32<s(1)(1)(0)>[T] portMask<s(1)(1)(0)>[&][(63 )  + 1];    
}CAH_EM4_CHIP_CONFIG_T<s(0)(0)(0)>[&];(D1:CAH_EM4_CHIP_CONFIG_T:1)[[TYPENAME:CAH_EM4_CHIP_CONFIG_T]]



typedef struct
{
        PbTIModeType_Tval<s(1)(1)(0)>[T] J2Mode<s(1)(1)(0)>[&];
        UINT8<s(1)(1)(0)>[T] J2Data<s(1)(1)(0)>[&][64  + 1];
}
EM4_J2_BYTES_T<s(0)(0)(0)>[&];(D1:EM4_J2_BYTES_T:1)[[TYPENAME:EM4_J2_BYTES_T]]
typedef struct
{
        PRBS_MODE_T<s(1)(1)(0)>[T] prbsMode<s(1)(1)(0)>[&];
        PRBS_STATUS_T<s(1)(1)(0)>[T] prbsStatus<s(1)(1)(0)>[&];
         


        UINT32<s(1)(1)(0)>[T] prbsErrCnt<s(1)(1)(0)>[&];
        BOOL<s(1)(1)(0)>[T] bForceRpt<s(1)(1)(0)>[&];
}
EM4_PRBS_CONFIG_T<s(0)(0)(0)>[&];(D1:EM4_PRBS_CONFIG_T:1)[[TYPENAME:EM4_PRBS_CONFIG_T]]

typedef enum
{
    EM4_NONE_FORCE<s(0)(0)(0)>[&]  = 0,
    EM4_DOWN_FORCE<s(0)(0)(0)>[&]  = 1<<1,
    EM4_UP_FORCE<s(0)(0)(0)>[&]    = 1<<2
}EM4_FORCE_MODE_T<s(0)(0)(0)>[&];(D1:EM4_FORCE_MODE_T:1)[[TYPENAME:EM4_FORCE_MODE_T]]



 


typedef struct
{
        UINT16<s(1)(1)(0)>[T] almID<s(1)(1)(0)>[&][14  + 2];

 

























        UINT16<s(1)(1)(0)>[T] state<s(1)(1)(0)>[&][14  + 2];
        UINT16<s(1)(1)(0)>[T] e1state<s(1)(1)(0)>[&][14  + 2];

 
















        UINT16<s(1)(1)(0)>[T] ssf<s(1)(1)(0)>[&];
        UINT16<s(1)(1)(0)>[T] ssfFc<s(1)(1)(0)>[&];
         


        UINT16<s(1)(1)(0)>[T] rdi<s(1)(1)(0)>[&];
        UINT16<s(1)(1)(0)>[T] rfi<s(1)(1)(0)>[&];
        UINT16<s(1)(1)(0)>[T] rdiFc<s(1)(1)(0)>[&];
        UINT16<s(1)(1)(0)>[T] rfiFc<s(1)(1)(0)>[&];

         


        UINT16<s(1)(1)(0)>[T] temp<s(1)(1)(0)>[&];     
        UINT16<s(1)(1)(0)>[T] e1ssf<s(1)(1)(0)>[&];
        UINT16<s(1)(1)(0)>[T] e1ssfFc<s(1)(1)(0)>[&];
        UINT16<s(1)(1)(0)>[T] e1rdi<s(1)(1)(0)>[&];
        UINT16<s(1)(1)(0)>[T] e1rdiFc<s(1)(1)(0)>[&];
}
EM4_POH_ALM_T<s(0)(0)(0)>[&];(D1:EM4_POH_ALM_T:1)[[TYPENAME:EM4_POH_ALM_T]]




 


typedef struct
{
         


        CAH_EM4_CHIP_CONFIG_T<s(1)(1)(0)>[T] cfg<s(1)(1)(0)>[&];

         


        UINT32<s(1)(1)(0)>[T] su_id<s(1)(1)(0)>[&];

         


        BOOL<s(1)(1)(0)>[T] bPlmEnable<s(1)(1)(0)>[&][(63 )  + 1];
        BOOL<s(1)(1)(0)>[T] bTimEnable<s(1)(1)(0)>[&][(63 )  + 1];
        PORT_STATE_T<s(1)(1)(0)>[T] adminState<s(1)(1)(0)>[&][(63 )  + 1];
        UINT8<s(1)(1)(0)>[T] ExpPSL<s(1)(1)(0)>[&][(63 )  + 1];
        UINT8<s(1)(1)(0)>[T] RcvPSL<s(1)(1)(0)>[&][(63 )  + 1];
        UINT8<s(1)(1)(0)>[T] TranPSL<s(1)(1)(0)>[&][(63 )  + 1];

        EM4_J2_BYTES_T<s(1)(1)(0)>[T] strExpJ2<s(1)(1)(0)>[&][(63 )  + 1];
        EM4_J2_BYTES_T<s(1)(1)(0)>[T] strTranJ2<s(1)(1)(0)>[&][(63 )  + 1];
        EM4_J2_BYTES_T<s(1)(1)(0)>[T] strRcvJ2<s(1)(1)(0)>[&][(63 )  + 1];

         



        PDH_PORT_MODE_T<s(1)(1)(0)>[T] portType<s(1)(1)(0)>[&][(63 )  + 1];

         


        EM4_PRBS_CONFIG_T<s(1)(1)(0)>[T] prbsCfg<s(1)(1)(0)>[&][(63 )  + 1];

         


         unsigned int faisMode<s(1)(1)(0)>[&][(63 )  + 1];
        EM4_FORCE_MODE_T<s(1)(1)(0)>[T] frdiMode<s(1)(1)(0)>[&][(63 )  + 1];

         


        PORT_LOOPBACK_T<s(1)(1)(0)>[T] loopMode<s(1)(1)(0)>[&][(63 )  + 1];

         


        EM4_POH_ALM_T<s(1)(1)(0)>[T] pohAlm<s(1)(1)(0)>[&][(63 )  + 1];
        int farcrc<s(1)(1)(0)>[&][(63 )  + 1];
        int crc<s(1)(1)(0)>[&][(63 )  + 1];
        int nslip<s(1)(1)(0)>[&][(63 )  + 1];
        int pslip<s(1)(1)(0)>[&][(63 )  + 1];

         



        BOOL<s(1)(1)(0)>[T] forceRptAlm<s(1)(1)(0)>[&][(63 )  + 1];

         


        UINT32<s(1)(1)(0)>[T] nPrbsDelayCount<s(1)(1)(0)>[&][(63 )  + 1];

         


        BOOL<s(1)(1)(0)>[T] bRestrainRDI<s(1)(1)(0)>[&][(63 )  + 1];
        BOOL<s(1)(1)(0)>[T] bBlockAis<s(1)(1)(0)>[&][(63 )  + 1];
        int isFrcais<s(1)(1)(0)>[&] [(63 )  + 1];
        int isFrcrdi<s(1)(1)(0)>[&] [(63 )  + 1];

         


        int isRptLOM<s(1)(1)(0)>[&] [(63 )  + 1];
        PDH_FRAME_MODE_T<s(1)(1)(0)>[T] isFrame<s(1)(1)(0)>[&] [(63 )  + 1];

        
}
EM4_CHIP_VAR_T<s(0)(0)(0)>[&];(D1:EM4_CHIP_VAR_T:1)[[TYPENAME:EM4_CHIP_VAR_T]]


 
 

typedef enum
{ 
    EM4_ENTITY_UNKNOWN<s(0)(0)(0)>[&] = 0,
    EM4_ENTITY_LATCH<s(0)(0)(0)>[&],
    EM4_ENTITY_DELATCH<s(0)(0)(0)>[&]
}CAH_EM4_ENTITY_LATCH_T<s(0)(0)(0)>[&];(D1:CAH_EM4_ENTITY_LATCH_T:1)[[TYPENAME:CAH_EM4_ENTITY_LATCH_T]]




typedef enum{
    eEM4_DISABLE<s(0)(0)(0)>[&] = 0,
    eEM4_ENABLE<s(0)(0)(0)>[&]  = 1
}eEM4SWITCH<s(0)(0)(0)>[&];(D1:eEM4SWITCH:1)[[TYPENAME:eEM4SWITCH]]





typedef struct
{
         






        ENTITY_T<s(1)(1)(0)>[T] entity<s(1)(1)(0)>[&];

         






        DWORD<s(1)(1)(0)>[T] dwPos<s(1)(1)(0)>[&];

         




        UINT32<s(1)(1)(0)>[T] chipNum<s(1)(1)(0)>[&];

         


        EM4_ENTITY_STATE_T<s(1)(1)(0)>[T] state<s(1)(1)(0)>[&];

         


        EM4_CHIP_VAR_T<s(1)(1)(0)>[T] chip_var<s(1)(1)(0)>[&][(5) ];
}
CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[&];(D1:CAH_EM4_ENTITY_DATA_T:1)[[TYPENAME:CAH_EM4_ENTITY_DATA_T]]







 




typedef union _ARG32<s(1)(0)(1)>[&]
{
    int arg<s(1)(1)(0)>[&];
    char tti<s(1)(1)(0)>[&][32 + 3];
}ARG32<s(0)(0)(0)>[&];(D1:ARG32:1)[[TYPENAME:ARG32]]
typedef void (*PMyFun<s(0)(0)(0)>[&])TYPENAME:FUNC:(PMyFun)( );(D1:PMyFun:0)


typedef struct __E1_CALL<s(1)(0)(1)>[&]
{
     
    PMyFun<s(1)(1)(0)>[T] p<s(1)(1)(0)>[&];
    int arg1<s(1)(1)(0)>[&];
    int arg2<s(1)(1)(0)>[&];
    int arg3<s(1)(1)(0)>[&];
 







    ARG32<s(1)(1)(0)>[T] arg4<s(1)(1)(0)>[&];
    int arg5<s(1)(1)(0)>[&];
    int arg6<s(1)(1)(0)>[&];
    int sn<s(1)(1)(0)>[&];
    int id<s(1)(1)(0)>[&];
    struct __E1_CALL<s(2)(1)(1)>[&] *pNext<s(1)(1)(0)>[&];
    struct __E1_CALL<s(2)(1)(1)>[&] *pHashNext<s(1)(1)(0)>[&][11];
    char fname<s(1)(1)(0)>[&][64];
}
E1_CALL<s(0)(0)(0)>[&];(D1:E1_CALL:1)[[TYPENAME:E1_CALL]]








 














 
 
typedef union _sexar_framer_cfgctrl<s(1)(0)(1)>[&]
{
	struct _cfgCtrlBit<s(2)(1)(1)>[&]
	{
   		unsigned    loopback<s(2)(1)(0)>[&]:1;     
		unsigned	IsDS3<s(2)(1)(0)>[&]:1;	    
		unsigned	losEnable<s(2)(1)(0)>[&]:1;    
		unsigned	reset<s(2)(1)(0)>[&]:1;        
		unsigned	Unused<s(2)(1)(0)>[&]:1;	    
        unsigned	format<s(2)(1)(0)>[&]:1;	    
        unsigned	TimeRefSel<s(2)(1)(0)>[&]:2;   
	} cfgCtrlBit<s(1)(0)(0)>[&];
	UINT1<s(1)(0)(0)>[T] cfgCtrl<s(1)(0)(0)>[&];
}EXAR_FRAMER_CTRL_T<s(0)(0)(0)>[&];(D1:EXAR_FRAMER_CTRL_T:1)[[TYPENAME:EXAR_FRAMER_CTRL_T]]


typedef union _sexar_rxj1_cfgctrl_x<s(1)(0)(1)>[&]
{
	struct _rxj1CtrlBit_x<s(2)(1)(1)>[&]
	{
   		unsigned    reserved<s(2)(1)(0)>[&] :3;   
		unsigned	bufMode<s(2)(1)(0)>[&]:1;	   
		unsigned	threshold<s(2)(1)(0)>[&]:1;   
		unsigned	alignment<s(2)(1)(0)>[&]:1;   
		unsigned	length<s(2)(1)(0)>[&]:2;	   
	} rxj1CtrlBit<s(1)(0)(0)>[&];
	UINT1<s(1)(0)(0)>[T] rxj1Ctrl<s(1)(0)(0)>[&];
}EXAR_RXJ2_CTRL_T<s(0)(0)(0)>[&];(D1:EXAR_RXJ2_CTRL_T:1)[[TYPENAME:EXAR_RXJ2_CTRL_T]]





typedef enum
{
        eEm4J2Tx<s(0)(0)(0)>[&] = 0,
        eEm4J2Rx<s(0)(0)(0)>[&],
        eEm4J2Exp<s(0)(0)(0)>[&]
}
EM4_J2_DIRECTION_T<s(0)(0)(0)>[&];(D1:EM4_J2_DIRECTION_T:1)[[TYPENAME:EM4_J2_DIRECTION_T]]

typedef enum
{
        eEm4J2Rd<s(0)(0)(0)>[&] = 0,
        eEm4J2Wr<s(0)(0)(0)>[&],
}
EM4_J2_OPERATION_T<s(0)(0)(0)>[&];(D1:EM4_J2_OPERATION_T:1)[[TYPENAME:EM4_J2_OPERATION_T]]


typedef enum 
{
    EEM_LB_GL_TOH_IN<s(0)(0)(0)>[&] = 5 ,         
    EEM_LB_GL_POH_IN<s(0)(0)(0)>[&],         
    EEM_LB_LC_FRM_IN<s(0)(0)(0)>[&],         
    EEM_LB_LC_FRM_OUT<s(0)(0)(0)>[&],      

}EEM_LOOPBACK_T<s(0)(0)(0)>[&];(D1:EEM_LOOPBACK_T:1)[[TYPENAME:EEM_LOOPBACK_T]]

typedef enum 
{
    EEM_LB_CLEAR<s(0)(0)(0)>[&] , 
    EEM_LB_SET<s(0)(0)(0)>[&],

}EEM_LB_ACC_T<s(0)(0)(0)>[&];(D1:EEM_LB_ACC_T:1)[[TYPENAME:EEM_LB_ACC_T]]



 


typedef union __sexar_alarm_dect<s(1)(0)(1)>[&]
{
    struct __alarmCtrlBit<s(2)(1)(1)>[&]
    {

         


        int rfi<s(2)(1)(0)>[&]:1;
        int ppi_tlct<s(2)(1)(0)>[&]:1;  
        int ppi_crc<s(2)(1)(0)>[&]:1;
        int ppi_oof<s(2)(1)(0)>[&]:1;   
        int ppi_lof<s(2)(1)(0)>[&]:1;
        int ppi_lom<s(2)(1)(0)>[&]:1;
        int ppi_rdi<s(2)(1)(0)>[&]:1;
        int other1<s(2)(1)(0)>[&]:1;          

         


        int tim<s(2)(1)(0)>[&]:1;             
        int unstablePSL<s(2)(1)(0)>[&]:1;     
        int uneq<s(2)(1)(0)>[&]:1;            
        int plm<s(2)(1)(0)>[&]:1;             

        int rdi<s(2)(1)(0)>[&]:1;             
        int unstableRDI<s(2)(1)(0)>[&]:1;     
        int lop<s(2)(1)(0)>[&]:1;             
        int ais<s(2)(1)(0)>[&]:1;             
    }
    alarmCtrlBit<s(1)(0)(0)>[&];
    UINT16<s(1)(0)(0)>[T] alarmCtrl<s(1)(0)(0)>[&];
}
ALARM_REGISTER_T<s(0)(0)(0)>[&];(D1:ALARM_REGISTER_T:1)[[TYPENAME:ALARM_REGISTER_T]]



typedef struct
{
        SEM_ID<s(1)(1)(0)>[T] semInst<s(1)(1)(0)>[&][((1) )  + 1];
        SEM_ID<s(1)(1)(0)>[T] semData<s(1)(1)(0)>[&];
        SEM_ID<s(1)(1)(0)>[T] semLink<s(1)(1)(0)>[&];
        SEM_ID<s(1)(1)(0)>[T] semFind<s(1)(1)(0)>[&];

         


        SEM_ID<s(1)(1)(0)>[T] semLatchIsr<s(1)(1)(0)>[&];
        SEM_ID<s(1)(1)(0)>[T] semisr<s(1)(1)(0)>[&];

        SEM_ID<s(1)(1)(0)>[T] semLatchIsrClose<s(1)(1)(0)>[&];
        SEM_ID<s(1)(1)(0)>[T] semisrclose<s(1)(1)(0)>[&];

        int latchent<s(1)(1)(0)>[&];
        int fpgaHanle<s(1)(1)(0)>[&][((1) )  + 1];
        BOOL<s(1)(1)(0)>[T] bEM4Running<s(1)(1)(0)>[&];
        MSG_Q_ID<s(1)(1)(0)>[T] EM4MsgQId<s(1)(1)(0)>[&];
        CAH_EM4_ENTITY_LATCH_T<s(1)(1)(0)>[T] EM4LatchStatus<s(1)(1)(0)>[&][((1) )  + 1];
        BOOL<s(1)(1)(0)>[T] EM4LatchForceRpt<s(1)(1)(0)>[&][((1) )  + 1];
        UINT16<s(1)(1)(0)>[T] IntCount<s(1)(1)(0)>[&][((1) )  + 1];
}
CAH_EM4_ENTITY_TRIB_T<s(0)(0)(0)>[&];(D1:CAH_EM4_ENTITY_TRIB_T:1)[[TYPENAME:CAH_EM4_ENTITY_TRIB_T]]



typedef union sexar_prbs_cfgctrl<s(1)(0)(1)>[&]
{
	struct __prbsCtrlBit<s(2)(1)(1)>[&]
	{
   		UINT1<s(2)(1)(0)>[T]   TxOHSrc<s(2)(1)(0)>[&]:1;    
		UINT1<s(2)(1)(0)>[T]	Unused<s(2)(1)(0)>[&]:2;	  
		UINT1<s(2)(1)(0)>[T]	lock<s(2)(1)(0)>[&]:1;       
		UINT1<s(2)(1)(0)>[T]	RxPRBS<s(2)(1)(0)>[&]:1;     
		UINT1<s(2)(1)(0)>[T]	TxPRBS<s(2)(1)(0)>[&]:1;	  
        UINT1<s(2)(1)(0)>[T]	reserved<s(2)(1)(0)>[&]:2;	  
	} prbsCtrlBit<s(1)(0)(0)>[&];
	UINT1<s(1)(0)(0)>[T] prbsCtrl<s(1)(0)(0)>[&];
}__EXAR_PRBS_CTRL_T<s(0)(0)(0)>[&];(D1:__EXAR_PRBS_CTRL_T:1)[[TYPENAME:__EXAR_PRBS_CTRL_T]]

typedef union sexar_ais_cfgctrl<s(1)(0)(1)>[&]
{
	struct __aisCtrlBit<s(2)(1)(1)>[&]
	{
   		UINT1<s(2)(1)(0)>[T]   reserved<s(2)(1)(0)>[&]:1;       
		UINT1<s(2)(1)(0)>[T]   unstableC2<s(2)(1)(0)>[&]:1;	  
		UINT1<s(2)(1)(0)>[T]	uneq<s(2)(1)(0)>[&]:1;           
		UINT1<s(2)(1)(0)>[T]	plm<s(2)(1)(0)>[&]:1;            
		UINT1<s(2)(1)(0)>[T]	unstableJ1<s(2)(1)(0)>[&]:1;	  
		UINT1<s(2)(1)(0)>[T]	tim<s(2)(1)(0)>[&]:1;	          
                                  
		UINT1<s(2)(1)(0)>[T]	lop<s(2)(1)(0)>[&]:1;	          
        UINT1<s(2)(1)(0)>[T]	enable<s(2)(1)(0)>[&]:1;	      
	} aisCtrlBit<s(1)(0)(0)>[&];
	UINT1<s(1)(0)(0)>[T] aisCtrl<s(1)(0)(0)>[&];
}__EXAR_AIS_CTRL_T<s(0)(0)(0)>[&];(D1:__EXAR_AIS_CTRL_T:1)[[TYPENAME:__EXAR_AIS_CTRL_T]]


typedef union sexar_insert_cfgctrl<s(1)(0)(1)>[&]
{
	struct __insertCtrlBit<s(2)(1)(1)>[&]
	{
   		UINT1<s(2)(1)(0)>[T]   F2<s(2)(1)(0)>[&]:1;              
		UINT1<s(2)(1)(0)>[T]   rei<s(2)(1)(0)>[&]:2;	           
		UINT1<s(2)(1)(0)>[T]	rdi<s(2)(1)(0)>[&]:2;             
		UINT1<s(2)(1)(0)>[T]	c2<s(2)(1)(0)>[&]:1;              
		UINT1<s(2)(1)(0)>[T]	pdi<s(2)(1)(0)>[&]:1;             
		UINT1<s(2)(1)(0)>[T]	ais<s(2)(1)(0)>[&]:1;             
	} insertCtrlBit<s(1)(0)(0)>[&];
	UINT1<s(1)(0)(0)>[T] insertCtrl<s(1)(0)(0)>[&];
}__EXAR_INSERT_CTRL_T<s(0)(0)(0)>[&];(D1:__EXAR_INSERT_CTRL_T:1)[[TYPENAME:__EXAR_INSERT_CTRL_T]]


            
typedef union sexar_alarm_dect_2<s(1)(0)(1)>[&]
{
	struct _alarmCtrlBit_2<s(2)(1)(1)>[&]
	{
   		UINT1<s(2)(1)(0)>[T]   tim<s(2)(1)(0)>[&]:1;            
		UINT1<s(2)(1)(0)>[T]   unstableC2<s(2)(1)(0)>[&]:1;	  
		UINT1<s(2)(1)(0)>[T]	uneq<s(2)(1)(0)>[&]:1;           
		UINT1<s(2)(1)(0)>[T]	plm<s(2)(1)(0)>[&]:1;            
		UINT1<s(2)(1)(0)>[T]	rdi<s(2)(1)(0)>[&]:1;	          
		UINT1<s(2)(1)(0)>[T]	unstableRDI<s(2)(1)(0)>[&]:1;	  
		UINT1<s(2)(1)(0)>[T]	lop<s(2)(1)(0)>[&]:1;	          
        UINT1<s(2)(1)(0)>[T]	ais<s(2)(1)(0)>[&]:1;	          
	} alarmCtrlBit<s(1)(0)(0)>[&];
	UINT1<s(1)(0)(0)>[T] alarmCtrl<s(1)(0)(0)>[&];
}__EXAR_ALARM_DECT_T<s(0)(0)(0)>[&];(D1:__EXAR_ALARM_DECT_T:1)[[TYPENAME:__EXAR_ALARM_DECT_T]]


 



 
WORD<s(0)(0)(0)>[T] CAH_EM4_SetPortLoopback<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], CTD_LOOPBACK_TYPE_T<s(0)(0)(0)>[T] eLpbckMd<s(0)(0)(0)>[&]);(D1:eLpbckMd:0)

 
WORD<s(0)(0)(0)>[T] CAH_EM4_SetInsertAlm<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], CTD_INSERT_ALM_TYPE_T<s(0)(0)(0)>[T] eAlmType<s(0)(0)(0)>[&], CTD_INSERT_ALM_DIR_T<s(0)(0)(0)>[T] eInsAlmDir<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&]);(D1:bEnable:0)
 
 
WORD<s(0)(0)(0)>[T] CAH_EM4_GetPrbsState<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] *bPrbsSucc<s(0)(0)(0)>[&]);(D1:bPrbsSucc:0)
WORD<s(0)(0)(0)>[T] CAH_EM4_EnablePrbs<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&]) ;(D1:bEnable:0)
WORD<s(0)(0)(0)>[T] CAH_EM4_GetPrbsErrCount<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] *dwPrbsCnt<s(0)(0)(0)>[&]);(D1:dwPrbsCnt:0)

 
UINT32<s(0)(0)(0)>[T] sysTimestamp<s(0)(0)(0)>[&](void);(D1:sysTimestamp:0)
UINT32<s(0)(0)(0)>[T] sysTimestampFreq<s(0)(0)(0)>[&](void);(D1:sysTimestampFreq:0)
 
WORD<s(0)(0)(0)>[T] CAH_EM4_GetTimingRef<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T]   byClockNum<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T]    *byPort<s(0)(0)(0)>[&],  BOOL<s(0)(0)(0)>[T]  *bEnable<s(0)(0)(0)>[&]);(D1:bEnable:0)
WORD<s(0)(0)(0)>[T] CAH_EM4_SetTimingRef<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T]    byPort<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T]   byClockNum<s(0)(0)(0)>[&],  BOOL<s(0)(0)(0)>[T]  bEnable<s(0)(0)(0)>[&]);(D1:bEnable:0)

 
WORD<s(0)(0)(0)>[T] CAH_EM4_GetFpgaVersion<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], char *pucFpgaVer<s(0)(0)(0)>[&]);(D1:pucFpgaVer:0)
WORD<s(0)(0)(0)>[T] CAH_EM4_GetPpiAlmState<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], CTD_PPI_ALARM_T<s(0)(0)(0)>[T] *psPpiAlarm<s(0)(0)(0)>[&]);(D1:psPpiAlarm:0)
WORD<s(0)(0)(0)>[T] CAH_EM4_GetLpAlmState<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], CTD_LP_ALARM_T<s(0)(0)(0)>[T] *psLpAlarm<s(0)(0)(0)>[&]);(D1:psLpAlarm:0)
WORD<s(0)(0)(0)>[T] CAH_EM4_GetTuAlmState<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], CTD_TU_ALARM_T<s(0)(0)(0)>[T] *psTuAlarm<s(0)(0)(0)>[&]);(D1:psTuAlarm:0)

 
WORD<s(0)(0)(0)>[T] CAH_EM4_getLatchStatus<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&]);(D1:dwPos:0)

 
WORD<s(0)(0)(0)>[T] CAH_EM4_EnableReTiming<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&],BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&]);(D1:bEnable:0)

 
WORD<s(0)(0)(0)>[T] CAH_EM4_GetLpBipCount<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] * pLpBip<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] * pLpRei<s(0)(0)(0)>[&]);(D1:pLpRei:0)
WORD<s(0)(0)(0)>[T] CAH_EM4_GetPpiBipCount<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] *pPpiBip<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] *pPpiFebe<s(0)(0)(0)>[&]);(D1:pPpiFebe:0)
WORD<s(0)(0)(0)>[T] CAH_EM4_GetSlip<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&] ,DWORD<s(0)(0)(0)>[T] *pdwPSlip<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] *pdwNSlip<s(0)(0)(0)>[&]);(D1:pdwNSlip:0)

 
WORD<s(0)(0)(0)>[T] CAH_EM4_SetRxLpTtiMode<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], TTI_LEN_T<s(0)(0)(0)>[T] eTtiMode<s(0)(0)(0)>[&]);(D1:eTtiMode:0)
WORD<s(0)(0)(0)>[T] CAH_EM4_SetTxLpTtiMode<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], TTI_LEN_T<s(0)(0)(0)>[T] eTtiMode<s(0)(0)(0)>[&]);(D1:eTtiMode:0)
WORD<s(0)(0)(0)>[T] CAH_EM4_SetRxLpTtiAisEnable<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&]);(D1:bEnable:0)
WORD<s(0)(0)(0)>[T] CAH_EM4_SetRxLpTtiAlmEnable<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&]);(D1:bEnable:0)
WORD<s(0)(0)(0)>[T] CAH_EM4_SetRxExpLpTti<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], TTI_LEN_T<s(0)(0)(0)>[T] eTtiMode<s(0)(0)(0)>[&], const BYTE<s(0)(0)(0)>[T] *pbyTtiValue<s(0)(0)(0)>[&]);(D1:pbyTtiValue:0)
WORD<s(0)(0)(0)>[T] CAH_EM4_SetTxLpTti<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], TTI_LEN_T<s(0)(0)(0)>[T] eTtiMode<s(0)(0)(0)>[&], const BYTE<s(0)(0)(0)>[T] *pbyTtiValue<s(0)(0)(0)>[&]);(D1:pbyTtiValue:0)
WORD<s(0)(0)(0)>[T] CAH_EM4_GetTxLpTti<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], TTI_LEN_T<s(0)(0)(0)>[T] eTtiMode<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] *pbyTtiValue<s(0)(0)(0)>[&]);(D1:pbyTtiValue:0)
WORD<s(0)(0)(0)>[T] CAH_EM4_GetRxRcvLpTti<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], TTI_LEN_T<s(0)(0)(0)>[T] eTtiMode<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] *pbyTtiValue<s(0)(0)(0)>[&]);(D1:pbyTtiValue:0)
WORD<s(0)(0)(0)>[T] CAH_EM4_GetRxExpLpTti<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], TTI_LEN_T<s(0)(0)(0)>[T] eTtiMode<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] *pbyTtiValue<s(0)(0)(0)>[&]);(D1:pbyTtiValue:0)

 
WORD<s(0)(0)(0)>[T] CAH_EM4_SetRxLpPslEnable<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&]);(D1:bEnable:0)
WORD<s(0)(0)(0)>[T] CAH_EM4_SetRxTxLpPsl<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&],  BYTE<s(0)(0)(0)>[T] byC2Value<s(0)(0)(0)>[&]);(D1:byC2Value:0)
WORD<s(0)(0)(0)>[T] CAH_EM4_SetRxExpLpPsl<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&],  BYTE<s(0)(0)(0)>[T] byC2Value<s(0)(0)(0)>[&]);(D1:byC2Value:0)
WORD<s(0)(0)(0)>[T] CAH_EM4_SetTxLpPsl<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&],  BYTE<s(0)(0)(0)>[T] byC2Value<s(0)(0)(0)>[&]);(D1:byC2Value:0)
WORD<s(0)(0)(0)>[T] CAH_EM4_GetRxRcvLpPsl<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] *pbyC2Value<s(0)(0)(0)>[&]);(D1:pbyC2Value:0)
WORD<s(0)(0)(0)>[T] CAH_EM4_GetRxExpLpPsl<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&],  BYTE<s(0)(0)(0)>[T] *byC2Value<s(0)(0)(0)>[&]);(D1:byC2Value:0)

 
WORD<s(0)(0)(0)>[T] CAH_EM4_DetectCardState<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] * pbActive<s(0)(0)(0)>[&]);(D1:pbActive:0)
WORD<s(0)(0)(0)>[T] CAH_EM4_GetInnerB1Err<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] *pdwB1Err<s(0)(0)(0)>[&]);(D1:pdwB1Err:0)
WORD<s(0)(0)(0)>[T] CAH_EM4_GetTdmLinkErr<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] *pdwTdmErr<s(0)(0)(0)>[&]);(D1:pdwTdmErr:0)
WORD<s(0)(0)(0)>[T] CAH_EM4_Get8KClkState<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] *pbActive<s(0)(0)(0)>[&]);(D1:pbActive:0)
WORD<s(0)(0)(0)>[T] CAH_EM4_Get19MClkState<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] *pbActive<s(0)(0)(0)>[&]);(D1:pbActive:0)
WORD<s(0)(0)(0)>[T] CAH_EM4_GetPllState<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] *pbPllLock<s(0)(0)(0)>[&]);(D1:pbPllLock:0)

  
PB_ERROR_CODE_T<s(0)(0)(0)>[T] CAH_EM4_loadModule<s(0)(0)(0)>[&] ();(D1:CAH_EM4_loadModule:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] CAH_EM4_activateEntity<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] b_warm<s(0)(0)(0)>[&]) ;(D1:b_warm:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T] CAH_EM4_deActEntity<s(0)(0)(0)>[&](ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&]);(D1:entity:0)
WORD<s(0)(0)(0)>[T] CAH_EM4_InitEntity<s(0)(0)(0)>[&] (ENTITY_T<s(0)(0)(0)>[T] etEntity<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], CTD_MODE_TYPE_T<s(0)(0)(0)>[T] eporttype<s(0)(0)(0)>[&]);(D1:eporttype:0)
WORD<s(0)(0)(0)>[T] CAH_EM4_DeInitEntity<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&]);(D1:dwPos:0)
WORD<s(0)(0)(0)>[T] CAH_EM4_Initialize<s(0)(0)(0)>[&](DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&]);(D1:dwPos:0)


























 


 


 



 


typedef int (*CahEm4pTransFunc<s(0)(0)(0)>[&])TYPENAME:FUNC:(CahEm4pTransFunc) (ENTITY_T<s(0)(0)(0)>[T]);(D1:ENTITY_T:0)
 














typedef struct
{
    INT32<s(1)(1)(0)>[T] id<s(1)(1)(0)>[&];
    INT8<s(1)(1)(0)>[T] *pName<s(1)(1)(0)>[&];
    INT32<s(1)(1)(0)>[T] pri<s(1)(1)(0)>[&];
    INT32<s(1)(1)(0)>[T] opt<s(1)(1)(0)>[&];
    INT32<s(1)(1)(0)>[T] stckSz<s(1)(1)(0)>[&];
    FUNCPTR<s(1)(1)(0)>[T] pEntryPtr<s(1)(1)(0)>[&];
}
CAH_EM4_TSK_CTL_BLK_T<s(0)(0)(0)>[&];(D1:CAH_EM4_TSK_CTL_BLK_T:1)[[TYPENAME:CAH_EM4_TSK_CTL_BLK_T]]


int buffer_reset<s(0)(0)(0)>[&] (void);(D1:buffer_reset:0)



extern int sysClkRateGet<s(0)(0)(0)>[&] (void);(D1:sysClkRateGet:0)
extern unsigned long GetSystemTime<s(0)(0)(0)>[&] (void);(D1:GetSystemTime:0)

unsigned short em4_bpc_rd<s(0)(0)(0)>[&] (int page<s(0)(0)(0)>[&], int off<s(0)(0)(0)>[&]);(D1:off:0)
unsigned short em4Map2Wr<s(0)(0)(0)>[&] (int page<s(0)(0)(0)>[&], int off<s(0)(0)(0)>[&], unsigned short val<s(0)(0)(0)>[&]);(D1:val:0)
unsigned short em4Map1Wr<s(0)(0)(0)>[&] (int page<s(0)(0)(0)>[&], int off<s(0)(0)(0)>[&], unsigned short val<s(0)(0)(0)>[&]);(D1:val:0)
unsigned short em4MapRd<s(0)(0)(0)>[&] (int page<s(0)(0)(0)>[&], int off<s(0)(0)(0)>[&], unsigned short *pU1<s(0)(0)(0)>[&], unsigned short *pU2<s(0)(0)(0)>[&]);(D1:pU2:0)
unsigned short em4Map2Rd<s(0)(0)(0)>[&] (int page<s(0)(0)(0)>[&], int off<s(0)(0)(0)>[&]);(D1:off:0)
unsigned short em4Map1Rd<s(0)(0)(0)>[&] (int page<s(0)(0)(0)>[&], int off<s(0)(0)(0)>[&]);(D1:off:0)
 


int cah_em4_hash<s(0)(0)(0)>[&] (int sn<s(0)(0)(0)>[&]);(D1:sn:0)
void cah_em4_isrFunc<s(0)(0)(0)>[&] (FPGA_HANDLE<s(0)(0)(0)>[T] handle<s(0)(0)(0)>[&], FPGA_HOOK_ARG<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&]);(D1:entity:0)
void cah_em4_EnableLatchInt<s(0)(0)(0)>[&] (UINT32<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] Enable<s(0)(0)(0)>[&]);(D1:Enable:0)
void cah_em4_latch<s(0)(0)(0)>[&] ();(D1:cah_em4_latch:0)
void cah_em4_Dpr<s(0)(0)(0)>[&] ();(D1:cah_em4_Dpr:0)
void cah_em4_readAlarm<s(0)(0)(0)>[&] (CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] * pEntity<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&]);(D1:ulPort:0)
E1_CALL<s(0)(0)(0)>[T] *cah_em4_findCall2<s(0)(0)(0)>[&] (ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], void *pfun<s(0)(0)(0)>[&], int arg1<s(0)(0)(0)>[&]   ,
                                   int arg2<s(0)(0)(0)>[&]   , int arg3<s(0)(0)(0)>[&]   , int sn<s(0)(0)(0)>[&]);(D1:sn:0)
CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *cah_em4_fd2entptr<s(0)(0)(0)>[&] (int fd<s(0)(0)(0)>[&]);(D1:fd:0)
int cah_em4_trace<s(0)(0)(0)>[&] (int level<s(0)(0)(0)>[&], char *msg<s(0)(0)(0)>[&], ...);(D1:msg:0)
int cah_em4_ent2fd<s(0)(0)(0)>[&] (ENTITY_T<s(0)(0)(0)>[T] ent<s(0)(0)(0)>[&]);(D1:ent:0)
int cah_em4_pohWrite<s(0)(0)(0)>[&] (void *base<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&], unsigned short reg<s(0)(0)(0)>[&], unsigned short val<s(0)(0)(0)>[&]);(D1:val:0)
CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *cah_em4_getEntityPtr<s(0)(0)(0)>[&] (ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&]);(D1:entity:0)
int cah_em4_registerCall<s(0)(0)(0)>[&] (PMyFun<s(0)(0)(0)>[T] pFun<s(0)(0)(0)>[&], int arg3<s(0)(0)(0)>[&], int arg4<s(0)(0)(0)>[&], int arg5<s(0)(0)(0)>[&], int sn<s(0)(0)(0)>[&], char *fname<s(0)(0)(0)>[&]);(D1:fname:0)
unsigned short cah_em4_pohRead<s(0)(0)(0)>[&] (void *base<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&], unsigned short reg<s(0)(0)(0)>[&]);(D1:reg:0)
void *cah_em4_getEntityBase<s(0)(0)(0)>[&] (ENTITY_T<s(0)(0)(0)>[T] ent<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&]);(D1:port:0)
void cah_em4_forceAis<s(0)(0)(0)>[&] (void *baseaddr<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&], eEM4SWITCH<s(0)(0)(0)>[T] ais<s(0)(0)(0)>[&]);(D1:ais:0)
CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *cah_em4_getEntity<s(0)(0)(0)>[&] (ENTITY_T<s(0)(0)(0)>[T] ent<s(0)(0)(0)>[&]);(D1:ent:0)
void em4_PollBit<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] addrOffset<s(0)(0)(0)>[&], int byPortNo<s(0)(0)(0)>[&]);(D1:byPortNo:0)

void cah_em4_getprbsname<s(0)(0)(0)>[&] (int, char *);(D1:cah_em4_getprbsname:0)

DBG_MODULE_T<s(0)(0)(0)>[T] gCahEm4DbgModNum<s(0)(0)(0)>[&];(D1:gCahEm4DbgModNum:0)   
DBG_INFO_T<s(0)(0)(0)>[T] gCahEm4DbgInfo<s(0)(0)(0)>[&] =(D2) {    
    "EM4",                       
    {
      
      
      
     {"ERROR", 1, "error occurs."},
     {"INIT", 0, "Init info."},
     {"CFGGET", 0, "Get config information."},
     {"CFGSET", 0, "Set config information."},
     {"ALM", 0, "Alarm report information."},
     {"PMON", 0, "Performance information. "},
     {"INTR", 0, "Interrupt information. "},
     {"EGP", 0, "Egp information. "},
     {"OP", 0, "Operation information. "},
     }
};

 


CAH_EM4_ENTITY_TRIB_T<s(0)(0)(0)>[T] gCahEm4TribVar<s(0)(0)(0)>[&];(D1:gCahEm4TribVar:0)




CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *gppCahEm4CfgVar<s(0)(0)(0)>[&][((1) )  + 1];(D1:gppCahEm4CfgVar:0)
CAH_CFG_INFO_T<s(0)(0)(0)>[T] gCahEm4CfgData<s(0)(0)(0)>[&][((1) )  + 1];(D1:gCahEm4CfgData:0)

 



unsigned int g_cah_em4entity<s(0)(0)(0)>[&] =(D2) 0;

 


unsigned int g_isrcount<s(0)(0)(0)>[&] =(D2) 0;

 


CahEm4pTransFunc<s(0)(0)(0)>[T] g_pTransFunc<s(0)(0)(0)>[&];(D1:g_pTransFunc:0)

 


E1_CALL<s(0)(0)(0)>[T] *gpCahEm4HashHead<s(0)(0)(0)>[&][((1) )  + 1][11 + 1] =(D2) { {0} };
E1_CALL<s(0)(0)(0)>[T] gCahEm4Head<s(0)(0)(0)>[&][((1) )  + 1] =(D2) { {((void *)0) , 0, 0, 0, {0}, 0, 0, 0} };
E1_CALL<s(0)(0)(0)>[T] *pCahEm4Head<s(0)(0)(0)>[&][((1) )  + 1];(D1:pCahEm4Head:0)
int gCahEm4LinkFlag<s(0)(0)(0)>[&] =(D2) 0;

 
static char g_aname<s(0)(0)(0)>[&][32];(D1:g_aname:0)

 
int g_fflag<s(0)(0)(0)>[&] =(D2) 1;

 


int gCahEm4SelectEnt<s(0)(0)(0)>[&] =(D2) 5;
int gCahEm4SelectPort<s(0)(0)(0)>[&] =(D2) 0;

  int g_UseInt<s(0)(0)(0)>[&] =(D2) 1;

 
int g_waste<s(0)(0)(0)>[&] =(D2) 0, g_wasetCnt<s(0)(0)(0)>[&] =(D2) 10;


 





int g_crccnt<s(0)(0)(0)>[&] =(D2) 8;
 


int gggg_cnt<s(0)(0)(0)>[&] =(D2) 0;
UINT32<s(0)(0)(0)>[T] g_StampStart<s(0)(0)(0)>[&] =(D2) 0, g_StampStop<s(0)(0)(0)>[&] =(D2) 0;

 


int g_cnt<s(0)(0)(0)>[&] =(D2) 14;
int g_flaggg<s(0)(0)(0)>[&] =(D2) 0;

int nnn<s(0)(0)(0)>[&] =(D2) 1;
int g_delay<s(0)(0)(0)>[&] =(D2) 0;
int g_port<s(0)(0)(0)>[&] =(D2) 0;

 



int g_testcrc<s(0)(0)(0)>[&] =(D2) 0;
int cah_em4_blockupais<s(0)(0)(0)>[&] =(D2) 0;
BOOL<s(0)(0)(0)>[T] gbCahEm4RunPollingTask<s(0)(0)(0)>[&][3 + 1] =(D2) { 1 , 1 , 1 , 1  };
FMA_AlmModDefectFunc<s(0)(0)(0)>[T] cah_em4_gpFunRptAlm<s(0)(0)(0)>[&] =(D2) ((void *)0) ;
CPA_LATCHSTATE_CHANGE_FUNC<s(0)(0)(0)>[T] cah_em4_gpFunRptLatch<s(0)(0)(0)>[&] =(D2) ((void *)0) ;
PRA_SetPortStatus_Func<s(0)(0)(0)>[T] cah_em4_gpFunRptPRBS<s(0)(0)(0)>[&] =(D2) ((void *)0) ;

int gCahEm4Flag<s(0)(0)(0)>[&][((1) )  + 2] =(D2) { 0 };

 
char g_CahEm4Des<s(0)(0)(0)>[&][] =(D2) "  gCahEm4DebugLevel ::= {        1:      ,         2: how cah_em4_AlmPollingTask () is running now ?         3: how cah_em4_set_global_register () is running now ?                 how cah_em4_StopPolling ... ?                 what's the EM4_GetFarCRCErrCount () result ?                 what's the EM4_GetCRCErrCount () result ?         4: what's the cah_em4_ReportAlarm () result ?         5: none,         6: none,         7: none,         8: none,         9: 10: 11: how cah_em4_AlmPollingTask () is polling in detail ?         12: none,         13: how cah_em4_ClearAlarm ()/cah_em4_RiseAlarm () is running now ?         14: what's the indirect register's content in cah_em4_read_hardware_alarm () ?         15: watch EM4_EnablePlm ()         16: watch how is cah_em4_ReadPrbsStatus () running ?         17: watch EM4_SetTransTti ()         18: HOW EM4_GetLpPmPara () IS RUNNING NOW?         19: how are EM4_PrbsEnable ()/EM4_SetPrbsMode ()/cah_em4_getprbsstatus ()              running now ?         20: how is cah_em4_Dpr () running now ?         21: how is EM4_GetSlip () running now ?         22: how is cah_em4_latch () running now ?         23: how is EM4_GetPDHPM () running now ?         24: is there any PDH-NOTHING/SDH-NOTHING ?         33: ReadAlarm and ReportAlamr debug info.                                    // operated by polling g_testcrc(0) // control for test crc-error-counter g_UseInt=0; // if(g_UseInt == 1) the use polling to collect data,                // or use 1hz-interrupt only. int g_waste=0, g_wasetCnt=10; int g_pollcnt=0, g_hdcnt=0, }        " ;

const char *cah_em4_fmsg<s(0)(0)(0)>[&][] =(D2) {
    "__________________________________________________________________",
    "unsigned short\tem4Map1Wr\t(int page, int off, unsigned short val)",
    "unsigned short\tem4MapRd\t(int page, int off)",
    "unsigned short\tem4_bpc_rd\t(int page, int off)", 
    "unsigned short\tem4_bpc_wr\t(int page, int off)", 
    " ",    
    "void\tem4help\t\t(void)",
    "int\tem4BpcShow\t(void)",
    "int\tem4MapShow\t(void)",
    "int\tem4ShowCons\t(int port)",
    "int\tem4ShowEnable\t(int port)",
    "int\tem4AllInLoop\t(int flag) //backplane inloop",
    " ",
    "int\tem4ShowIntMask\t(int port)",
    "int\tem4ShowPageAddr\t(void)",
    "int\tem4ShowAlarms\t(int port)",
    "int\tem4ShowPortMap\t(void)",
    "int\tem4TtiRxTest\t(int port)",
    "int\tem4TtiTxTest\t(int port)",
    "int\tem4SetExpPslTest\t(int port, int c2)", 
    "int\tem4GetExpPslTest\t(int port)",
    "int\tem4GetExpTtiTest\t(int port)",
    "int\tem4SetExpTtiTest\t(int port)", 
    " ",
    "__________________________________________________________________",
    "",
    ((void *)0) 
};

 
static int g_phyportmap<s(0)(0)(0)>[&] [130];(D1:g_phyportmap:0)
int em4ShowPortMap<s(0)(0)(0)>[&] (void)
{
    int i<s(0)(0)(0)>[&] =(D2) 0;

    for (i<s(0)(0)(0)>[&] = 0; i<s(0)(0)(0)>[&] < 130; i<s(0)(0)(0)>[&] ++) {
        if (g_phyportmap<s(0)(0)(0)>[&][i<s(0)(0)(0)>[&]] != i<s(0)(0)(0)>[&]) {
            printf<s(0)(0)(0)>[&] ("\r\ng_phyportmap[%3d]\t=\t[%3d]", i<s(0)(0)(0)>[&], g_phyportmap<s(0)(0)(0)>[&][i<s(0)(0)(0)>[&]]);
        }
    }

    printf<s(0)(0)(0)>[&] ("\r\n");
    return 0;
}


int
em4showsample<s(0)(0)(0)>[&] (void)
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0;

    cah_ReadRegister<s(0)(0)(0)>[&] (0x50000000, ((0x00 << 10) | 0x00) , &u<s(0)(0)(0)>[&], 0xffff, CAH_REG_ATTRBT_RO<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\n%s(): devid(%x)", __FUNCTION__<s(0)(0)(0)>[&], u<s(0)(0)(0)>[&]);

    cah_ReadRegister<s(0)(0)(0)>[&] (0x50000000, (((0x00 << 10) | 0x01)) , &u<s(0)(0)(0)>[&], 0xffff, CAH_REG_ATTRBT_RO<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\n%s(): PAGE0(%x)", __FUNCTION__<s(0)(0)(0)>[&], u<s(0)(0)(0)>[&]);

    cah_ReadRegister<s(0)(0)(0)>[&] (0x50000000, ((0x00 << 10) | 0x05) , &u<s(0)(0)(0)>[&], 0xffff, CAH_REG_ATTRBT_RO<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\n%s(): EM4_IRQ_IN(%x)", __FUNCTION__<s(0)(0)(0)>[&], u<s(0)(0)(0)>[&]);

    cah_ReadRegister<s(0)(0)(0)>[&] (0x50000000, ((0x00 << 10) | 0x0a) , &u<s(0)(0)(0)>[&], 0xffff, CAH_REG_ATTRBT_RO<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\n%s(): EM4_MON_INTER(%x)", __FUNCTION__<s(0)(0)(0)>[&], u<s(0)(0)(0)>[&]);

    cah_ReadRegister<s(0)(0)(0)>[&] (0x50000000, ((0x00 << 10) | 0x0b) , &u<s(0)(0)(0)>[&], 0xffff, CAH_REG_ATTRBT_RO<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\n%s(): EM4_TIMING_SEL(%x)", __FUNCTION__<s(0)(0)(0)>[&], u<s(0)(0)(0)>[&]);

    cah_ReadRegister<s(0)(0)(0)>[&] (0x50000000, ((0x00 << 10) | 0x10) , &u<s(0)(0)(0)>[&], 0xffff, CAH_REG_ATTRBT_RO<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\n%s(): EM4_TEST(%x)", __FUNCTION__<s(0)(0)(0)>[&], u<s(0)(0)(0)>[&]);

    printf<s(0)(0)(0)>[&] ("\r\n");
    return 0;
}



int g_cahem4version<s(0)(0)(0)>[&] =(D2) 30;
int g_CahEm4Delay<s(0)(0)(0)>[&] =(D2) 2;


CAH_EM4_TSK_CTL_BLK_T<s(0)(0)(0)>[T] cah_em4_PollingTask<s(0)(0)(0)>[&] =(D2) {
    0x00,                        
    "cahem4Poll",                
    231 ,   
    0x00,                        
    20480,                       
    (FUNCPTR<s(0)(0)(0)>[T]) ((void *)0) 
};

CAH_EM4_TSK_CTL_BLK_T<s(0)(0)(0)>[T] cah_em4_EpgTask<s(0)(0)(0)>[&] =(D2) {
    0x00,                        
      "cahem4Epg",
     
    230 ,   
    0x00,                        
    20480,                       
    (FUNCPTR<s(0)(0)(0)>[T]) cah_em4_latch<s(0)(0)(0)>[&]
};


CAH_EM4_TSK_CTL_BLK_T<s(0)(0)(0)>[T] cah_em4_DprTsk<s(0)(0)(0)>[&] =(D2) {
    0x00,                        
      "cahem4Dpr",
     
    230 ,   
    0x00,                        
    20480,                       
    (FUNCPTR<s(0)(0)(0)>[T]) cah_em4_Dpr<s(0)(0)(0)>[&]
};


 



int gCahEm4PrbsPort<s(0)(0)(0)>[&] =(D2) 0;

 
int g_wait<s(0)(0)(0)>[&] =(D2) 0;

 

int gHardSlot<s(0)(0)(0)>[&] =(D2) 0;
int gHardPort<s(0)(0)(0)>[&] =(D2) 0;


int gCahEm4DebugLevel<s(0)(0)(0)>[&] =(D2) 0;


 






WORD<s(0)(0)(0)>[T]
cah_em4_deInitEntity<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&])
{
    WORD<s(0)(0)(0)>[T] wRtn<s(0)(0)(0)>[&] =(D2) ((WORD<s(0)(0)(0)>[T])0x0) ;

     
    memset<s(0)(0)(0)>[&] (&gCahEm4CfgData<s(0)(0)(0)>[&][0], 0, sizeof (gCahEm4CfgData<s(0)(0)(0)>[&]));
    CAH_EM4_DeInitEntity<s(0)(0)(0)>[&] (0);

     
    return wRtn<s(0)(0)(0)>[&];
}



 




int
cah_em4_mapPort<s(0)(0)(0)>[&] (int port<s(0)(0)(0)>[&])
{
    return ((port<s(0)(0)(0)>[&] > 62) ? ((port<s(0)(0)(0)>[&] + 1) - 63) : (port<s(0)(0)(0)>[&] + 1));
}


int g_logbackn<s(0)(0)(0)>[&] =(D2) 0;
 




int
cah_em4_port2chip<s(0)(0)(0)>[&] (int port<s(0)(0)(0)>[&])
{
    if (0 > port<s(0)(0)(0)>[&] || 125 < port<s(0)(0)(0)>[&])
    {
        printf<s(0)(0)(0)>[&] ("\r\n%s: port(%d) overflow!!!", __FUNCTION__<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&]);
        if (g_logbackn<s(0)(0)(0)>[&] == 1)
        {
            logBackN<s(0)(0)(0)>[&] ("cah_em4_port2chip ", 5);
        }
    }

    return (0 <= port<s(0)(0)(0)>[&] && 62 >= port<s(0)(0)(0)>[&]) ? 1 : 2;
}


int
cah_em4_dwPos2id<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&])
{
    int id<s(0)(0)(0)>[&] =(D2) 0;

    return (id<s(0)(0)(0)>[&]);
}

 


int
cah_em4_dwPos2ent<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&])
{
    return (cah_em4_dwPos2id<s(0)(0)(0)>[&] (dwPos<s(0)(0)(0)>[&]));
}

 




PB_ERROR_CODE_T<s(0)(0)(0)>[T]
cah_em4_initModule<s(0)(0)(0)>[&] ()
{
    static int flag<s(0)(0)(0)>[&] =(D2) 1;
    UINT8<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&];(D1:slot:0)

    if (0 == flag<s(0)(0)(0)>[&])
    {
        return ((WORD<s(0)(0)(0)>[T])0x0) ;
    }
    flag<s(0)(0)(0)>[&] = 0;

    gCahEm4DbgModNum<s(0)(0)(0)>[&] = DBG_RegisterModule<s(0)(0)(0)>[&] (&gCahEm4DbgInfo<s(0)(0)(0)>[&]);

    for (slot<s(0)(0)(0)>[&] = 0; slot<s(0)(0)(0)>[&] < ((1) ) ; slot<s(0)(0)(0)>[&]++)
    {
        gCahEm4TribVar<s(0)(0)(0)>[&].EM4LatchForceRpt<s(0)(0)(0)>[&][slot<s(0)(0)(0)>[&]] = 1 ;
		 


        gppCahEm4CfgVar<s(0)(0)(0)>[&][slot<s(0)(0)(0)>[&]] = ((void *)0) ;
        printf<s(0)(0)(0)>[&] ("\r\n%s(): set gppCahEm4CfgVar[%d] to 0", __FUNCTION__<s(0)(0)(0)>[&], slot<s(0)(0)(0)>[&]);
    }

    return ((WORD<s(0)(0)(0)>[T])0x0) ;
}




 






PB_ERROR_CODE_T<s(0)(0)(0)>[T]
cah_em4_loadModule<s(0)(0)(0)>[&] ()
{
    PB_ERROR_CODE_T<s(0)(0)(0)>[T] pbRtn<s(0)(0)(0)>[&] =(D2) ((WORD<s(0)(0)(0)>[T])0x0) ;

    memset<s(0)(0)(0)>[&] (&gCahEm4CfgData<s(0)(0)(0)>[&], 0, sizeof (gCahEm4CfgData<s(0)(0)(0)>[&]));
    cah_em4_initModule<s(0)(0)(0)>[&] ();

    return pbRtn<s(0)(0)(0)>[&];
}

int
cah_em4_getChipBase<s(0)(0)(0)>[&] (int slot<s(0)(0)(0)>[&], int chipno<s(0)(0)(0)>[&])
{
    int base<s(0)(0)(0)>[&] =(D2) 0;

    base<s(0)(0)(0)>[&] = 0;

    return (base<s(0)(0)(0)>[&]);
}

 






void
cah_em4_Info<s(0)(0)(0)>[&] ()
{
    DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&];(D1:dwPos:0)

    for (dwPos<s(0)(0)(0)>[&] = 0; dwPos<s(0)(0)(0)>[&] < ((1) ) ; dwPos<s(0)(0)(0)>[&]++)
    {
        if (CTD_MODE_E1<s(0)(0)(0)>[&] == gCahEm4CfgData<s(0)(0)(0)>[&][dwPos<s(0)(0)(0)>[&]].ePortType<s(0)(0)(0)>[&][0]
            || CTD_MODE_DS1<s(0)(0)(0)>[&] == gCahEm4CfgData<s(0)(0)(0)>[&][dwPos<s(0)(0)(0)>[&]].ePortType<s(0)(0)(0)>[&][0])
        {
            printf<s(0)(0)(0)>[&] ("EntityNo[%d],portType[%d],dwBaseAddr[0x%x].\r\n",
                    gCahEm4CfgData<s(0)(0)(0)>[&][dwPos<s(0)(0)(0)>[&]].dwEntityNo<s(0)(0)(0)>[&], gCahEm4CfgData<s(0)(0)(0)>[&][dwPos<s(0)(0)(0)>[&]].ePortType<s(0)(0)(0)>[&][0],
                    gCahEm4CfgData<s(0)(0)(0)>[&][dwPos<s(0)(0)(0)>[&]].dwBaseAddr<s(0)(0)(0)>[&]);
        }
    }
}

 


unsigned short
cah_em4_rd<s(0)(0)(0)>[&] (void *base<s(0)(0)(0)>[&], int offset<s(0)(0)(0)>[&])
{
    unsigned short ud<s(0)(0)(0)>[&] =(D2) 0xcc;

    ud<s(0)(0)(0)>[&] = *((volatile unsigned short *) (base<s(0)(0)(0)>[&]) + offset<s(0)(0)(0)>[&]);

    return (ud<s(0)(0)(0)>[&]);
}


 


int
cah_em4_wr<s(0)(0)(0)>[&] (void *base<s(0)(0)(0)>[&], int offset<s(0)(0)(0)>[&], unsigned short data<s(0)(0)(0)>[&])
{
    *((volatile unsigned short *) (base<s(0)(0)(0)>[&]) + offset<s(0)(0)(0)>[&]) = data<s(0)(0)(0)>[&];

    return 0;
}

 



int
cah_em4_enableLatchIntr<s(0)(0)(0)>[&] (void *baseaddr<s(0)(0)(0)>[&], int flag<s(0)(0)(0)>[&])
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0;

    if (flag<s(0)(0)(0)>[&])
    {
        u<s(0)(0)(0)>[&] = 0x0001;              
    }
    else
    {
        u<s(0)(0)(0)>[&] = 0x0000;
    }

    cah_WriteRegister<s(0)(0)(0)>[&] ((DWORD<s(0)(0)(0)>[T]) baseaddr<s(0)(0)(0)>[&], ((0x00 << 10) | 0X09) , u<s(0)(0)(0)>[&], 0x00ff, CAH_REG_ATTRBT_RW<s(0)(0)(0)>[&]);



    return (((WORD<s(0)(0)(0)>[T])0x0) );
}


 


void
cah_em4_pollBitDmapper<s(0)(0)(0)>[&] (unsigned short *baseaddr<s(0)(0)(0)>[&], int offset<s(0)(0)(0)>[&])
{
    int i<s(0)(0)(0)>[&] =(D2) 0;
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0x0000;

    for (;;)
    {
        u<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], offset<s(0)(0)(0)>[&]);
        if ((u<s(0)(0)(0)>[&] & 0x8000))
        {
            i<s(0)(0)(0)>[&] = i<s(0)(0)(0)>[&] + 1;
            if (i<s(0)(0)(0)>[&] >= 100)
            {
                printf<s(0)(0)(0)>[&] ("\r\n%s(): FATAL ERROR ON INDRECT REG ACCESS", __FUNCTION__<s(0)(0)(0)>[&]);
                break;
            }
        }
        else
        {
            break;
        }
    }
}


 


void
cah_em4_pollBit<s(0)(0)(0)>[&] (unsigned short *baseaddr<s(0)(0)(0)>[&], int offset<s(0)(0)(0)>[&])
{
    int i<s(0)(0)(0)>[&] =(D2) 0;
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0x0000;

    for (;;)
    {
        u<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], offset<s(0)(0)(0)>[&]);
        if ((u<s(0)(0)(0)>[&] & 0x8000))
        {
            i<s(0)(0)(0)>[&] = i<s(0)(0)(0)>[&] + 1;
            if (i<s(0)(0)(0)>[&] >= 100)
			{
				printf<s(0)(0)(0)>[&] ("\r\n%s():\t register unstable forever!!!", __FUNCTION__<s(0)(0)(0)>[&]);
                break;
			}
        } else {
            break;
        }
    }
}


 


void
cah_em4_enablePlm<s(0)(0)(0)>[&] (void *baseaddr<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&], int mode<s(0)(0)(0)>[&])
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0x0000;

     


    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 ,          0x8000 + (ulPort<s(0)(0)(0)>[&] << 8) + 0x00 );
    cah_em4_pollBit<s(0)(0)(0)>[&] ((unsigned short *) baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 );
    u<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x03 );

    u<s(0)(0)(0)>[&] &= ~0x0004;
    u<s(0)(0)(0)>[&] |= (mode<s(0)(0)(0)>[&] ? 1 : 0) << 2;

    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x02 , u<s(0)(0)(0)>[&]);

    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 , 0xc000 + (ulPort<s(0)(0)(0)>[&] << 8) + 0x00 );
    cah_em4_pollBit<s(0)(0)(0)>[&] ((unsigned short *) baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 );

     


    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 ,   0x8000 + (ulPort<s(0)(0)(0)>[&] << 8) + 0x01 );
    cah_em4_pollBit<s(0)(0)(0)>[&] ((unsigned short *) baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 );
    u<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x03 );

    if (1 == mode<s(0)(0)(0)>[&])
    {
         
        u<s(0)(0)(0)>[&] &= ~0x0040;
        u<s(0)(0)(0)>[&] |= 0x0010;
    }
    else
    {
        u<s(0)(0)(0)>[&] &= ~0x0040;
        u<s(0)(0)(0)>[&] &= ~0x0010;
    }
    u<s(0)(0)(0)>[&] |= (0x0020 | 0x0080);
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x02 , u<s(0)(0)(0)>[&]);
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 , 0xc000 + (ulPort<s(0)(0)(0)>[&] << 8) + 0x01 );
    cah_em4_pollBit<s(0)(0)(0)>[&] ((unsigned short *) baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 );
}

 


int
cah_em4_setPrbs<s(0)(0)(0)>[&] (void *baseaddr<s(0)(0)(0)>[&], eEM4SWITCH<s(0)(0)(0)>[T] flag<s(0)(0)(0)>[&])
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0;

    if (eEM4_ENABLE<s(0)(0)(0)>[&] == flag<s(0)(0)(0)>[&])
    {
        u<s(0)(0)(0)>[&] |= 0x0001;
    }
    else
    {
        u<s(0)(0)(0)>[&] &= ~0x0001;
    }
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x04 << 10) | 0x47 , u<s(0)(0)(0)>[&]);
    return (((WORD<s(0)(0)(0)>[T])0x0) );
}

 



void
cah_em4_enableTim<s(0)(0)(0)>[&] (void *baseaddr<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&], int mode<s(0)(0)(0)>[&])
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0x0000;

     


    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 ,         
                0x8000 + (ulPort<s(0)(0)(0)>[&] << 8) + 0x00 );
    cah_em4_pollBit<s(0)(0)(0)>[&] ((unsigned short *) baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 );
    u<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x03 );

    u<s(0)(0)(0)>[&] &= ~(0x0001 + 0x0080);
    u<s(0)(0)(0)>[&] |= (mode<s(0)(0)(0)>[&] ? (1 + 0x0080) : 0);

    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x02 , u<s(0)(0)(0)>[&]);
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 , 0xc000 + (ulPort<s(0)(0)(0)>[&] << 8) + 0x00 );
    cah_em4_pollBit<s(0)(0)(0)>[&] ((unsigned short *) baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 );

     


    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 ,   0x8000 + (ulPort<s(0)(0)(0)>[&] << 8) + 0x01 );
    cah_em4_pollBit<s(0)(0)(0)>[&] ((unsigned short *) baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 );
    u<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x03 );

    if (1 == mode<s(0)(0)(0)>[&])
    {
        u<s(0)(0)(0)>[&] |= 0x0008;
        u<s(0)(0)(0)>[&] |= 0x0004;
    }
    else
    {
        u<s(0)(0)(0)>[&] &= ~0x0008;
        u<s(0)(0)(0)>[&] &= ~0x0004;
    }

    u<s(0)(0)(0)>[&] |= (0x0020 | 0x0080);
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x02 , u<s(0)(0)(0)>[&]);
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 , 0xc000 + (ulPort<s(0)(0)(0)>[&] << 8) + 0x01 );
    cah_em4_pollBit<s(0)(0)(0)>[&] ((unsigned short *) baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 );
}
 



void
cah_em4_enableTimRdi<s(0)(0)(0)>[&] (void *baseaddr<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&], int mode<s(0)(0)(0)>[&])
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0x0000;

     


    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 ,         
                0x8000 + (ulPort<s(0)(0)(0)>[&] << 8) + 0x00 );
    cah_em4_pollBit<s(0)(0)(0)>[&] ((unsigned short *) baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 );
    u<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x03 );

    u<s(0)(0)(0)>[&] &= ~(0x0001 + 0x0080);
    u<s(0)(0)(0)>[&] |= (mode<s(0)(0)(0)>[&] ? (1 + 0x0080) : 0);

    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x02 , u<s(0)(0)(0)>[&]);
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 , 0xc000 + (ulPort<s(0)(0)(0)>[&] << 8) + 0x00 );
    cah_em4_pollBit<s(0)(0)(0)>[&] ((unsigned short *) baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 );

     


    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 ,   0x8000 + (ulPort<s(0)(0)(0)>[&] << 8) + 0x01 );
    cah_em4_pollBit<s(0)(0)(0)>[&] ((unsigned short *) baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 );
    u<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x03 );

    if (1 == mode<s(0)(0)(0)>[&])
    {
        u<s(0)(0)(0)>[&] |= 0x0008;
         
    }
    else
    {
        u<s(0)(0)(0)>[&] &= ~0x0008;
         
    }

    u<s(0)(0)(0)>[&] |= (0x0020 | 0x0080);
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x02 , u<s(0)(0)(0)>[&]);
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 , 0xc000 + (ulPort<s(0)(0)(0)>[&] << 8) + 0x01 );
    cah_em4_pollBit<s(0)(0)(0)>[&] ((unsigned short *) baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 );
}

 



void
cah_em4_enableTimAis<s(0)(0)(0)>[&] (void *baseaddr<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&], int mode<s(0)(0)(0)>[&])
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0x0000;

     


    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 ,         
                0x8000 + (ulPort<s(0)(0)(0)>[&] << 8) + 0x00 );
    cah_em4_pollBit<s(0)(0)(0)>[&] ((unsigned short *) baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 );
    u<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x03 );

    u<s(0)(0)(0)>[&] &= ~(0x0001 + 0x0080);
    u<s(0)(0)(0)>[&] |= (mode<s(0)(0)(0)>[&] ? (1 + 0x0080) : 0);

    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x02 , u<s(0)(0)(0)>[&]);
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 , 0xc000 + (ulPort<s(0)(0)(0)>[&] << 8) + 0x00 );
    cah_em4_pollBit<s(0)(0)(0)>[&] ((unsigned short *) baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 );

     


    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 ,   0x8000 + (ulPort<s(0)(0)(0)>[&] << 8) + 0x01 );
    cah_em4_pollBit<s(0)(0)(0)>[&] ((unsigned short *) baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 );
    u<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x03 );

    if (1 == mode<s(0)(0)(0)>[&])
    {
         
        u<s(0)(0)(0)>[&] |= 0x0004;
    }
    else
    {
         
        u<s(0)(0)(0)>[&] &= ~0x0004;
    }

    u<s(0)(0)(0)>[&] |= (0x0020 | 0x0080);
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x02 , u<s(0)(0)(0)>[&]);
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 , 0xc000 + (ulPort<s(0)(0)(0)>[&] << 8) + 0x01 );
    cah_em4_pollBit<s(0)(0)(0)>[&] ((unsigned short *) baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 );
}


 


void
cah_em4_setTtiMode<s(0)(0)(0)>[&] (void *baseaddr<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&], int mode<s(0)(0)(0)>[&])
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0x0000;

    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 ,   0x8000 + (ulPort<s(0)(0)(0)>[&] << 8) + 0x01 );
    cah_em4_pollBit<s(0)(0)(0)>[&] ((unsigned short *) baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 );
    u<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x03 );

    u<s(0)(0)(0)>[&] &= ~0x0001;
    u<s(0)(0)(0)>[&] |= mode<s(0)(0)(0)>[&];

    u<s(0)(0)(0)>[&] |= (0x0020 | 0x0080);
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x02 , u<s(0)(0)(0)>[&]);
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 , 0xc000 + (ulPort<s(0)(0)(0)>[&] << 8) + 0x01 );
    cah_em4_pollBit<s(0)(0)(0)>[&] ((unsigned short *) baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 );
}


 



void
cah_em4_setPrbs2<s(0)(0)(0)>[&] (void *baseaddr<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&], eEM4SWITCH<s(0)(0)(0)>[T] flag<s(0)(0)(0)>[&])
{
     


    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x04 << 10) | 0x30 , port<s(0)(0)(0)>[&]);
    cah_em4_setPrbs<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], flag<s(0)(0)(0)>[&]);
}


 


void
cah_em4_initERdi<s(0)(0)(0)>[&] (void *baseaddr<s(0)(0)(0)>[&], eEM4SWITCH<s(0)(0)(0)>[T] flag<s(0)(0)(0)>[&])
{
     


    unsigned short u<s(0)(0)(0)>[&] =(D2) 0;


    cah_ReadRegister<s(0)(0)(0)>[&] ((DWORD<s(0)(0)(0)>[T]) baseaddr<s(0)(0)(0)>[&], (0x04 << 10) | 0x42 , &u<s(0)(0)(0)>[&], 0xffff, CAH_REG_ATTRBT_RO<s(0)(0)(0)>[&]);



    if (eEM4_ENABLE<s(0)(0)(0)>[&] == flag<s(0)(0)(0)>[&])
    {
        u<s(0)(0)(0)>[&] |= 0x0001;
    }
    else
    {
        u<s(0)(0)(0)>[&] &= ~0x0001;
    }


    cah_WriteRegister<s(0)(0)(0)>[&] ((DWORD<s(0)(0)(0)>[T]) baseaddr<s(0)(0)(0)>[&], (0x04 << 10) | 0x42 , u<s(0)(0)(0)>[&], 0xffff, CAH_REG_ATTRBT_RW<s(0)(0)(0)>[&]);



}


 




void
cah_em4_forceAis<s(0)(0)(0)>[&] (void *baseaddr<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&], eEM4SWITCH<s(0)(0)(0)>[T] ais<s(0)(0)(0)>[&])
{
    unsigned short u1<s(0)(0)(0)>[&] =(D2) 0;

    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x04 << 10) | 0x30 , port<s(0)(0)(0)>[&]);
    u1<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (   (0x04 << 10) | 0x40 ));
    if (gCahEm4SelectPort<s(0)(0)(0)>[&] == port<s(0)(0)(0)>[&])
        cah_em4_trace<s(0)(0)(0)>[&] (40 , "%s: base(%x), offset(%x), port(%d), u1(%x)",
                       __FUNCTION__<s(0)(0)(0)>[&], baseaddr<s(0)(0)(0)>[&], (0x04 << 10) | 0x40 , port<s(0)(0)(0)>[&], u1<s(0)(0)(0)>[&]);

    if (eEM4_ENABLE<s(0)(0)(0)>[&] == ais<s(0)(0)(0)>[&])
    {
        if (u1<s(0)(0)(0)>[&] & 0x8000)
        {
            if (gCahEm4SelectPort<s(0)(0)(0)>[&] == port<s(0)(0)(0)>[&])
                cah_em4_trace<s(0)(0)(0)>[&] (40 , "already set, skip");
            goto endfrcais<s(0)(0)(0)>[&];
        }
        else
        {
            if (gCahEm4SelectPort<s(0)(0)(0)>[&] == port<s(0)(0)(0)>[&])
                cah_em4_trace<s(0)(0)(0)>[&] (40 , "set tu-asi insertion");
            u1<s(0)(0)(0)>[&] |= 0x8000;
        }
    }
    else
    {
        if (u1<s(0)(0)(0)>[&] & 0x8000)
        {
            if (gCahEm4SelectPort<s(0)(0)(0)>[&] == port<s(0)(0)(0)>[&])
                cah_em4_trace<s(0)(0)(0)>[&] (40 , "clear tu-asi insertion");
            u1<s(0)(0)(0)>[&] &= ~0x8000;
        }
        else
        {
            if (gCahEm4SelectPort<s(0)(0)(0)>[&] == port<s(0)(0)(0)>[&])
                cah_em4_trace<s(0)(0)(0)>[&] (40 , "already cleared, skip");
            goto endfrcais<s(0)(0)(0)>[&];
        }
    }
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (   (0x04 << 10) | 0x40 ), u1<s(0)(0)(0)>[&]);
  endfrcais<s(0)(0)(0)>[&]:

  return;
}

void
cah_em4_forceRdi<s(0)(0)(0)>[&] (void *baseaddr<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&], eEM4SWITCH<s(0)(0)(0)>[T] rdi<s(0)(0)(0)>[&])
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0;

    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x04 << 10) | 0x30 , port<s(0)(0)(0)>[&]);
    u<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x04 << 10) | 0x40 );

    if (eEM4_ENABLE<s(0)(0)(0)>[&] == rdi<s(0)(0)(0)>[&])
    {
        if ((u<s(0)(0)(0)>[&] & 0x0001) && !(u<s(0)(0)(0)>[&] & 0x0002))
        {
            goto endFrcrdi<s(0)(0)(0)>[&];
        }
        else
        {
            u<s(0)(0)(0)>[&] |= 0x0001;
            u<s(0)(0)(0)>[&] &= ~0x0002;
        }
    }
    else
    {
        if ((u<s(0)(0)(0)>[&] & 0x0002) && !(u<s(0)(0)(0)>[&] & 0x0001))
        {
            goto endFrcrdi<s(0)(0)(0)>[&];
        }
        else
        {
            u<s(0)(0)(0)>[&] |= 0x0002;
            u<s(0)(0)(0)>[&] &= (~0x0001);
        }
    }
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x04 << 10) | 0x40 , u<s(0)(0)(0)>[&]);
  endFrcrdi<s(0)(0)(0)>[&]:

  return;
}

int
cah_em4_initReiRdiRfi<s(0)(0)(0)>[&] (void *baseaddr<s(0)(0)(0)>[&], eEM4SWITCH<s(0)(0)(0)>[T] rei<s(0)(0)(0)>[&], eEM4SWITCH<s(0)(0)(0)>[T] rdi<s(0)(0)(0)>[&], eEM4SWITCH<s(0)(0)(0)>[T] rfi<s(0)(0)(0)>[&])
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0;

    u<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x04 << 10) | 0x40 );

    if (eEM4_ENABLE<s(0)(0)(0)>[&] == rei<s(0)(0)(0)>[&])
    {
        u<s(0)(0)(0)>[&] |= 0x0080;
    }
    else
    {
        u<s(0)(0)(0)>[&] &= (~0x0080);
    }


    if (eEM4_ENABLE<s(0)(0)(0)>[&] == rdi<s(0)(0)(0)>[&])
    {
        u<s(0)(0)(0)>[&] |= 0x0002;
    }
    else
    {
        u<s(0)(0)(0)>[&] &= (~0x0002);
    }

    if (eEM4_ENABLE<s(0)(0)(0)>[&] == rfi<s(0)(0)(0)>[&])
    {
        u<s(0)(0)(0)>[&] |= 0x0020;
    }
    else
    {
        u<s(0)(0)(0)>[&] &= (~0x0020);
    }

    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x04 << 10) | 0x40 , u<s(0)(0)(0)>[&]);
    return (((WORD<s(0)(0)(0)>[T])0x0) );

}


int
cah_em4_initPsl<s(0)(0)(0)>[&] (void *baseaddr<s(0)(0)(0)>[&], unsigned short psl<s(0)(0)(0)>[&])
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0;

    u<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x04 << 10) | 0x40 );
    u<s(0)(0)(0)>[&] &= 0xffe3;
    u<s(0)(0)(0)>[&] &= ~0x0020;                
    u<s(0)(0)(0)>[&] |= ((psl<s(0)(0)(0)>[&] & 0x0007) << 2);
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x04 << 10) | 0x40 , u<s(0)(0)(0)>[&]);
    return (((WORD<s(0)(0)(0)>[T])0x0) );
}

void
em4SetPsl2<s(0)(0)(0)>[&] (void *baseaddr<s(0)(0)(0)>[&], unsigned short port<s(0)(0)(0)>[&], unsigned short psl<s(0)(0)(0)>[&])
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0;

    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x04 << 10) | 0x30 , port<s(0)(0)(0)>[&]);
    u<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x04 << 10) | 0x40 );
    u<s(0)(0)(0)>[&] &= 0xffe3;                 
    u<s(0)(0)(0)>[&] &= ~0x0020;
    u<s(0)(0)(0)>[&] |= ((psl<s(0)(0)(0)>[&] & 0x0007) << 2);
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x04 << 10) | 0x40 , u<s(0)(0)(0)>[&]);
}


void
em4SetPsl<s(0)(0)(0)>[&] (int ent<s(0)(0)(0)>[&], unsigned short port<s(0)(0)(0)>[&], unsigned short psl<s(0)(0)(0)>[&])
{
    void *baseaddr<s(0)(0)(0)>[&] =(D2) ((void *)0) ;

    if (((void *)0)  == cah_em4_getEntity<s(0)(0)(0)>[&] (ent<s(0)(0)(0)>[&]))
    {
        printf<s(0)(0)(0)>[&] ("\r\nent(%d) NOT active", ent<s(0)(0)(0)>[&]);
        return;
    }

    baseaddr<s(0)(0)(0)>[&] = cah_em4_getEntityBase<s(0)(0)(0)>[&] (ent<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&]);

    em4SetPsl2<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&], psl<s(0)(0)(0)>[&]);
}



int
cah_em4_setTxj2<s(0)(0)(0)>[&] (void *baseaddr<s(0)(0)(0)>[&], const unsigned char *j2<s(0)(0)(0)>[&])
{
    int r<s(0)(0)(0)>[&] =(D2) 0;

    if (((void *)0)  == j2<s(0)(0)(0)>[&])
    {
        printf<s(0)(0)(0)>[&] ("\r\nem4_set_j2: j2 NULL");
        return (r<s(0)(0)(0)>[&] = -1);
    }

    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (((0x04 << 10) | 0x50 ) + 0), (unsigned short) j2<s(0)(0)(0)>[&][0] | (j2<s(0)(0)(0)>[&][1] << 8));
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (((0x04 << 10) | 0x50 ) + 1), (unsigned short) j2<s(0)(0)(0)>[&][2] | (j2<s(0)(0)(0)>[&][3] << 8));
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (((0x04 << 10) | 0x50 ) + 2), (unsigned short) j2<s(0)(0)(0)>[&][4] | (j2<s(0)(0)(0)>[&][5] << 8));
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (((0x04 << 10) | 0x50 ) + 3), (unsigned short) j2<s(0)(0)(0)>[&][6] | (j2<s(0)(0)(0)>[&][7] << 8));
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (((0x04 << 10) | 0x50 ) + 4), (unsigned short) j2<s(0)(0)(0)>[&][8] | (j2<s(0)(0)(0)>[&][9] << 8));
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (((0x04 << 10) | 0x50 ) + 5), (unsigned short) j2<s(0)(0)(0)>[&][10] | (j2<s(0)(0)(0)>[&][11] << 8));
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (((0x04 << 10) | 0x50 ) + 6), (unsigned short) j2<s(0)(0)(0)>[&][12] | (j2<s(0)(0)(0)>[&][13] << 8));
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (((0x04 << 10) | 0x50 ) + 7), (unsigned short) j2<s(0)(0)(0)>[&][14] | (j2<s(0)(0)(0)>[&][15] << 8));

    return (((WORD<s(0)(0)(0)>[T])0x0) );
}

void
cahem4setTxj2_2<s(0)(0)(0)>[&] (void *baseaddr<s(0)(0)(0)>[&], unsigned short port<s(0)(0)(0)>[&], const unsigned char *j2<s(0)(0)(0)>[&])
{
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x04 << 10) | 0x30 , port<s(0)(0)(0)>[&]);
    cah_em4_setTxj2<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], j2<s(0)(0)(0)>[&]);
}


int
cah_em4_setConsequentAction<s(0)(0)(0)>[&] (void *baseaddr<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&], eEM4SWITCH<s(0)(0)(0)>[T] uneqrdi<s(0)(0)(0)>[&], eEM4SWITCH<s(0)(0)(0)>[T] plmrdi<s(0)(0)(0)>[&],
                             eEM4SWITCH<s(0)(0)(0)>[T] uneqais<s(0)(0)(0)>[&], eEM4SWITCH<s(0)(0)(0)>[T] plmais<s(0)(0)(0)>[&], eEM4SWITCH<s(0)(0)(0)>[T] timrdi<s(0)(0)(0)>[&],
                             eEM4SWITCH<s(0)(0)(0)>[T] timais<s(0)(0)(0)>[&], int ttimode<s(0)(0)(0)>[&])
{
     



    unsigned short u<s(0)(0)(0)>[&] =(D2) 0;

    if (eEM4_ENABLE<s(0)(0)(0)>[&] == uneqrdi<s(0)(0)(0)>[&])
    {
        u<s(0)(0)(0)>[&] |= 0x0080;
    }
    else
    {
        u<s(0)(0)(0)>[&] &= ~0x0080;
    }

    if (eEM4_ENABLE<s(0)(0)(0)>[&] == plmrdi<s(0)(0)(0)>[&])
    {
        u<s(0)(0)(0)>[&] |= 0x0040;
    }
    else
    {
        u<s(0)(0)(0)>[&] &= ~0x0040;
    }

    if (eEM4_ENABLE<s(0)(0)(0)>[&] == uneqais<s(0)(0)(0)>[&])
    {
        u<s(0)(0)(0)>[&] &= ~0x0020;
    }
    else
    {
        u<s(0)(0)(0)>[&] |= 0x0020;
    }

    if (eEM4_ENABLE<s(0)(0)(0)>[&] == plmais<s(0)(0)(0)>[&])
    {
        u<s(0)(0)(0)>[&] &= ~0x0010;
    }
    else
    {
        u<s(0)(0)(0)>[&] |= 0x0010;
    }


    if (eEM4_ENABLE<s(0)(0)(0)>[&] == timrdi<s(0)(0)(0)>[&])
    {
        u<s(0)(0)(0)>[&] |= 0x0008;
    }
    else
    {
        u<s(0)(0)(0)>[&] &= ~0x0008;
    }

    if (eEM4_ENABLE<s(0)(0)(0)>[&] == timais<s(0)(0)(0)>[&])
    {
        u<s(0)(0)(0)>[&] &= ~0x0004;
    }
    else
    {
        u<s(0)(0)(0)>[&] |= 0x0004;
    }

    if (eEM4_ENABLE<s(0)(0)(0)>[&] == ttimode<s(0)(0)(0)>[&])
    {
        u<s(0)(0)(0)>[&] &= ~0x0001;
    }
    else
    {
        u<s(0)(0)(0)>[&] |= 0x0001;
    }

    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x02 , u<s(0)(0)(0)>[&]);
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 , 0xc000 + (port<s(0)(0)(0)>[&] << 8) + 0x01 );
    cah_em4_pollBit<s(0)(0)(0)>[&] ((unsigned short *) baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 );

    return (((WORD<s(0)(0)(0)>[T])0x0) );
}


int
cah_em4_setDegThreshold<s(0)(0)(0)>[&] (void *baseaddr<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&], unsigned short threshold<s(0)(0)(0)>[&])
{
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x02 , threshold<s(0)(0)(0)>[&]);
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 , 0xc000 + (port<s(0)(0)(0)>[&] << 8) + ((0x02 << 10) | 0x20 ));
    cah_em4_pollBit<s(0)(0)(0)>[&] ((unsigned short *) baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 );
    return (((WORD<s(0)(0)(0)>[T])0x0) );
}



void
cah_em4_getTslNow<s(0)(0)(0)>[&] (void *baseaddr<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&], unsigned short *tslexp<s(0)(0)(0)>[&])
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0;

    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 ,   0x8000 + (port<s(0)(0)(0)>[&] << 8) + 0x0d );
    cah_em4_pollBit<s(0)(0)(0)>[&] ((unsigned short *) baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 );
    u<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x03 );
    *tslexp<s(0)(0)(0)>[&] = ((u<s(0)(0)(0)>[&] & 0x7000) >> 12);
}

void
em4GetTslAcc<s(0)(0)(0)>[&] (int ent<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&])
{
    unsigned short tsl<s(0)(0)(0)>[&];(D1:tsl:0)
    void *baseaddr<s(0)(0)(0)>[&] =(D2) ((void *)0) ;

    if (((void *)0)  == cah_em4_getEntity<s(0)(0)(0)>[&] (ent<s(0)(0)(0)>[&]))
    {
        printf<s(0)(0)(0)>[&] ("\r\nent(%d) NOT active", ent<s(0)(0)(0)>[&]);
        return;
    }

    baseaddr<s(0)(0)(0)>[&] = cah_em4_getEntityBase<s(0)(0)(0)>[&] (ent<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&]);

    cah_em4_getTslNow<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&], &tsl<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\nent(%d), port(%d), accepted psl(0x%x)", ent<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&], tsl<s(0)(0)(0)>[&] & 0x0007);
    printf<s(0)(0)(0)>[&] ("\r\n");
}

void
cah_em4_get_j2exp<s(0)(0)(0)>[&] (void *baseaddr<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&], unsigned char *j2exp<s(0)(0)(0)>[&])
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0;
    int i<s(0)(0)(0)>[&] =(D2) 0;

	printf<s(0)(0)(0)>[&] ("\r\n%s(): base(%p), port(%d)", __FUNCTION__<s(0)(0)(0)>[&], baseaddr<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&]);
    for (i<s(0)(0)(0)>[&] = 0; i<s(0)(0)(0)>[&] < 8; i<s(0)(0)(0)>[&]++)
    {
        cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 , 0x8000 + (port<s(0)(0)(0)>[&] << 8) + (0X20  + i<s(0)(0)(0)>[&]));
        cah_em4_pollBit<s(0)(0)(0)>[&] ((unsigned short *) baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 );
        u<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x03 );
		j2exp<s(0)(0)(0)>[&][i<s(0)(0)(0)>[&] * 2] = u<s(0)(0)(0)>[&] & 0x00ff;
		j2exp<s(0)(0)(0)>[&][i<s(0)(0)(0)>[&] * 2 + 1] = (u<s(0)(0)(0)>[&] >> 8) & 0x00ff;
    }
}



void
cah_em4_set_j2exp<s(0)(0)(0)>[&] (void *baseaddr<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&], const unsigned char *j2exp<s(0)(0)(0)>[&])
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0;
    int i<s(0)(0)(0)>[&] =(D2) 0;

    for (i<s(0)(0)(0)>[&] = 0; i<s(0)(0)(0)>[&] < 8; i<s(0)(0)(0)>[&]++)
    {
        u<s(0)(0)(0)>[&] = j2exp<s(0)(0)(0)>[&][i<s(0)(0)(0)>[&] * 2] + (j2exp<s(0)(0)(0)>[&][i<s(0)(0)(0)>[&] * 2 + 1] << 8);
        cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x02 , u<s(0)(0)(0)>[&]);
        cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 , 0xc000 + (port<s(0)(0)(0)>[&] << 8) + (0X20  + i<s(0)(0)(0)>[&]));
        cah_em4_pollBit<s(0)(0)(0)>[&] ((unsigned short *) baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 );
    }
}

 


int
em4ShowJ2Exp<s(0)(0)(0)>[&] (int entity<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&])
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0;
    int i<s(0)(0)(0)>[&] =(D2) 0;
    void *baseaddr<s(0)(0)(0)>[&] =(D2) (void *) 0;

    baseaddr<s(0)(0)(0)>[&] = cah_em4_getEntityBase<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&]);

    if ((void *) 0 == baseaddr<s(0)(0)(0)>[&])
    {
        printf<s(0)(0)(0)>[&] ("\r\nentity(%d) not active", entity<s(0)(0)(0)>[&]);
        return (0);
    }
    for (i<s(0)(0)(0)>[&] = 0; i<s(0)(0)(0)>[&] < 8; i<s(0)(0)(0)>[&]++)
    {

        cah_WriteRegister<s(0)(0)(0)>[&] ((DWORD<s(0)(0)(0)>[T]) baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 ,      
                           0x8000 + (port<s(0)(0)(0)>[&] << 8) + (0X20  + i<s(0)(0)(0)>[&]), 0x7f3f,
                           CAH_REG_ATTRBT_RW<s(0)(0)(0)>[&]);




        cah_em4_pollBit<s(0)(0)(0)>[&] ((unsigned short *) baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 );

        cah_ReadRegister<s(0)(0)(0)>[&] ((DWORD<s(0)(0)(0)>[T]) baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x03 , &u<s(0)(0)(0)>[&], 0xffff, CAH_REG_ATTRBT_RO<s(0)(0)(0)>[&]);



        printf<s(0)(0)(0)>[&] ("\r\nj2exp[%2d]=[%x]", i<s(0)(0)(0)>[&] * 2, u<s(0)(0)(0)>[&] & 0x00ff);
        printf<s(0)(0)(0)>[&] ("\r\nj2exp[%2d]=[%x]", i<s(0)(0)(0)>[&] * 2 + 1, (u<s(0)(0)(0)>[&] & 0xff00) >> 8);
    }
    printf<s(0)(0)(0)>[&] ("\r\n");

    return (0);
}


void
cah_em4_getJ2Acc<s(0)(0)(0)>[&] (void *baseaddr<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&], unsigned char *j2exp<s(0)(0)(0)>[&])
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0;
    int i<s(0)(0)(0)>[&] =(D2) 0;

    for (i<s(0)(0)(0)>[&] = 0; i<s(0)(0)(0)>[&] < 16; i<s(0)(0)(0)>[&]++)
    {
        cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 ,     
                    0x8000 + (port<s(0)(0)(0)>[&] << 8) + (0x10  + i<s(0)(0)(0)>[&]));
        cah_em4_pollBit<s(0)(0)(0)>[&] ((unsigned short *) baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 );
        u<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x03 );
        *(j2exp<s(0)(0)(0)>[&] + i<s(0)(0)(0)>[&]) = u<s(0)(0)(0)>[&] & (0x00ff);
         
    }
}


int
cah_em4_setIntMask<s(0)(0)(0)>[&] (void *baseaddr<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&], eEM4SWITCH<s(0)(0)(0)>[T] tsl<s(0)(0)(0)>[&], eEM4SWITCH<s(0)(0)(0)>[T] rdi<s(0)(0)(0)>[&], eEM4SWITCH<s(0)(0)(0)>[T] uneq<s(0)(0)(0)>[&],
                    eEM4SWITCH<s(0)(0)(0)>[T] plm<s(0)(0)(0)>[&], eEM4SWITCH<s(0)(0)(0)>[T] tim<s(0)(0)(0)>[&], eEM4SWITCH<s(0)(0)(0)>[T] erdi<s(0)(0)(0)>[&], unsigned short tslexp<s(0)(0)(0)>[&])
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0;


    if (eEM4_ENABLE<s(0)(0)(0)>[&] == tsl<s(0)(0)(0)>[&])
    {
        u<s(0)(0)(0)>[&] |= 0x0100;
    }
    else
    {
        u<s(0)(0)(0)>[&] &= ~0x0100;
    }

    if (eEM4_ENABLE<s(0)(0)(0)>[&] == rdi<s(0)(0)(0)>[&])
    {
        u<s(0)(0)(0)>[&] |= 0x0010;
    }
    else
    {
        u<s(0)(0)(0)>[&] &= ~0x0010;
    }
    if (eEM4_ENABLE<s(0)(0)(0)>[&] == uneq<s(0)(0)(0)>[&])
    {
        u<s(0)(0)(0)>[&] |= 0x0008;
    }
    else
    {
        u<s(0)(0)(0)>[&] &= ~0x0008;
    }
    if (eEM4_ENABLE<s(0)(0)(0)>[&] == plm<s(0)(0)(0)>[&])
    {
        u<s(0)(0)(0)>[&] |= 0x0004;
    }
    else
    {
        u<s(0)(0)(0)>[&] &= ~0x0004;
    }
    if (eEM4_ENABLE<s(0)(0)(0)>[&] == tim<s(0)(0)(0)>[&])
    {
        u<s(0)(0)(0)>[&] |= 0x0001;
    }
    else
    {
        u<s(0)(0)(0)>[&] &= ~0x0001;
    }
    if (eEM4_ENABLE<s(0)(0)(0)>[&] == erdi<s(0)(0)(0)>[&])
    {
        u<s(0)(0)(0)>[&] |= 0x0200;
    }
    else
    {
        u<s(0)(0)(0)>[&] &= ~0x0200;
    }

    u<s(0)(0)(0)>[&] &= ~0x3800;
    u<s(0)(0)(0)>[&] |= ((tslexp<s(0)(0)(0)>[&] & 0x0007) << 11);

    u<s(0)(0)(0)>[&] |= 0xc000;                 

    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x02 , u<s(0)(0)(0)>[&]);
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 , 0xc000 + (port<s(0)(0)(0)>[&] << 8) + 0x00 );
    cah_em4_pollBit<s(0)(0)(0)>[&] ((unsigned short *) baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 );
    return (((WORD<s(0)(0)(0)>[T])0x0) );
}

void
em4SetPslexp<s(0)(0)(0)>[&] (void *baseaddr<s(0)(0)(0)>[&], unsigned short port<s(0)(0)(0)>[&], unsigned short pslexp<s(0)(0)(0)>[&])
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0x0000;

    u<s(0)(0)(0)>[&] = cah_em4_pohRead<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&], 0x00 );
    u<s(0)(0)(0)>[&] &= (~0x3800);
    u<s(0)(0)(0)>[&] |= ((pslexp<s(0)(0)(0)>[&] & 0x0007) << 11);

    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x02 , u<s(0)(0)(0)>[&]);
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 , 0xc000 + (port<s(0)(0)(0)>[&] << 8) + 0x00 );
    cah_em4_pollBit<s(0)(0)(0)>[&] ((unsigned short *) baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 );
}



int
cah_em4_set_inloopretiming<s(0)(0)(0)>[&] (void *baseaddr<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&], eEM4SWITCH<s(0)(0)(0)>[T] inloop<s(0)(0)(0)>[&], eEM4SWITCH<s(0)(0)(0)>[T] retiming<s(0)(0)(0)>[&])
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0;

    u<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], ((0x05 << 10) | 0x100 ) + port<s(0)(0)(0)>[&]);


    if (eEM4_ENABLE<s(0)(0)(0)>[&] == retiming<s(0)(0)(0)>[&])
    {
        u<s(0)(0)(0)>[&] |= 0x0001;
    }
    else
    {
        u<s(0)(0)(0)>[&] &= ~0x0001;
    }

    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], ((0x05 << 10) | 0x100 ) + port<s(0)(0)(0)>[&], u<s(0)(0)(0)>[&]);

    return (((WORD<s(0)(0)(0)>[T])0x0) );
}




UINT16<s(0)(0)(0)>[T] cah_em4_PollBusyBit<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] dwBaseAddr<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] dwOffset<s(0)(0)(0)>[&])
{
    UINT16<s(0)(0)(0)>[T]    wcnt<s(0)(0)(0)>[&]     =(D2) 0x0;
    UINT16<s(0)(0)(0)>[T]    wdelay<s(0)(0)(0)>[&]   =(D2) 0x0;
    UINT16<s(0)(0)(0)>[T]    wdummy<s(0)(0)(0)>[&]   =(D2) 0x0;
    
    while (((UINT16<s(0)(0)(0)>[T])(*(volatile UINT16<s(0)(0)(0)>[T]*)( (UINT32<s(0)(0)(0)>[T])(dwBaseAddr<s(0)(0)(0)>[&] + (dwOffset<s(0)(0)(0)>[&] * 2)) )))  & 0x8000 )
    {
        if (wcnt<s(0)(0)(0)>[&]++ > 50 )
        {
            return ((UINT16<s(0)(0)(0)>[T])0x4) ;
        }
        
        for (wdelay<s(0)(0)(0)>[&] = 0; wdelay<s(0)(0)(0)>[&] < 100 ; wdelay<s(0)(0)(0)>[&]++)
        {
            wdummy<s(0)(0)(0)>[&] = wdummy<s(0)(0)(0)>[&] + wdelay<s(0)(0)(0)>[&];
        }
    }
    
    return ((WORD<s(0)(0)(0)>[T])0x0) ;
}

 
typedef enum
{
    EM4_REG_ATTRBT_RW<s(0)(0)(0)>[&]   = 0x0,
    EM4_REG_ATTRBT_RO<s(0)(0)(0)>[&]   = 0x1,
    EM4_REG_ATTRBT_WO<s(0)(0)(0)>[&]   = 0x2,
    EM4_REG_ATTRBT_RC<s(0)(0)(0)>[&]   = 0x3,
    EM4_REG_ATTRBT_WC<s(0)(0)(0)>[&]   = 0x4,
}EM4_REG_ATTRBT_T<s(0)(0)(0)>[&];(D1:EM4_REG_ATTRBT_T:1)[[TYPENAME:EM4_REG_ATTRBT_T]]

UINT16<s(0)(0)(0)>[T] cah_em4_WriteRegister<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] dwBaseAddr<s(0)(0)(0)>[&],         UINT32<s(0)(0)(0)>[T] dwOffset<s(0)(0)(0)>[&],         UINT16<s(0)(0)(0)>[T] wValue<s(0)(0)(0)>[&],         UINT16<s(0)(0)(0)>[T] wMask<s(0)(0)(0)>[&],         EM4_REG_ATTRBT_T<s(0)(0)(0)>[T] eRegAttrbt<s(0)(0)(0)>[&])




{
    UINT32<s(0)(0)(0)>[T]   dwAbsAddr<s(0)(0)(0)>[&]          =(D2) 0x0;
    UINT16<s(0)(0)(0)>[T]   wCurRegValue<s(0)(0)(0)>[&]       =(D2) 0x0;
    UINT16<s(0)(0)(0)>[T]   wShouldWrtValue<s(0)(0)(0)>[&]    =(D2) 0x0;
    UINT16<s(0)(0)(0)>[T]   wRtn<s(0)(0)(0)>[&]               =(D2) ((WORD<s(0)(0)(0)>[T])0x0) ;

     
    dwAbsAddr<s(0)(0)(0)>[&] = (UINT32<s(0)(0)(0)>[T])(dwBaseAddr<s(0)(0)(0)>[&] + (dwOffset<s(0)(0)(0)>[&] * 2));
     
    wCurRegValue<s(0)(0)(0)>[&] = ((UINT16<s(0)(0)(0)>[T])(*(volatile UINT16<s(0)(0)(0)>[T]*)( dwAbsAddr<s(0)(0)(0)>[&] ))) ;
     
    wShouldWrtValue<s(0)(0)(0)>[&] = (UINT16<s(0)(0)(0)>[T])((wValue<s(0)(0)(0)>[&] & wMask<s(0)(0)(0)>[&]) | (wCurRegValue<s(0)(0)(0)>[&] & (~wMask<s(0)(0)(0)>[&])));
     
    ((UINT16<s(0)(0)(0)>[T])(*(volatile UINT16<s(0)(0)(0)>[T]*)( dwAbsAddr<s(0)(0)(0)>[&] )))  = wShouldWrtValue<s(0)(0)(0)>[&];

     
    


     
    return wRtn<s(0)(0)(0)>[&];
}



UINT16<s(0)(0)(0)>[T] cah_em4_ReadRegister<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] dwBaseAddr<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] dwOffset<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] *pwValue<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] wMask<s(0)(0)(0)>[&], EM4_REG_ATTRBT_T<s(0)(0)(0)>[T] eRegAttrbt<s(0)(0)(0)>[&])
{
    UINT32<s(0)(0)(0)>[T]   dwAbsAddr<s(0)(0)(0)>[&]       =(D2) 0x0;
    UINT16<s(0)(0)(0)>[T]   wCurRegValue<s(0)(0)(0)>[&]    =(D2) 0x0;
    UINT16<s(0)(0)(0)>[T]   wRtn<s(0)(0)(0)>[&]            =(D2) ((WORD<s(0)(0)(0)>[T])0x0) ;

    if (((void *)0)  != pwValue<s(0)(0)(0)>[&])
    {
         
        dwAbsAddr<s(0)(0)(0)>[&] = (UINT32<s(0)(0)(0)>[T])(dwBaseAddr<s(0)(0)(0)>[&] + (dwOffset<s(0)(0)(0)>[&] * 2));
         
        wCurRegValue<s(0)(0)(0)>[&] = ((UINT16<s(0)(0)(0)>[T])(*(volatile UINT16<s(0)(0)(0)>[T]*)( dwAbsAddr<s(0)(0)(0)>[&] ))) ;
         
        *pwValue<s(0)(0)(0)>[&] = (UINT16<s(0)(0)(0)>[T])(wCurRegValue<s(0)(0)(0)>[&] & wMask<s(0)(0)(0)>[&]);

         
        if (EM4_REG_ATTRBT_WC<s(0)(0)(0)>[&] == eRegAttrbt<s(0)(0)(0)>[&])
        {
             
            ((UINT16<s(0)(0)(0)>[T])(*(volatile UINT16<s(0)(0)(0)>[T]*)( dwAbsAddr<s(0)(0)(0)>[&] )))  = wMask<s(0)(0)(0)>[&];
        }
        
         
        if (EM4_REG_ATTRBT_RW<s(0)(0)(0)>[&] == eRegAttrbt<s(0)(0)(0)>[&])
        {          
            if (0xcccc!= ((UINT16<s(0)(0)(0)>[T])(*(volatile UINT16<s(0)(0)(0)>[T]*)( ((0x00 << 10) | 0x10)  ))) )
            {
                wRtn<s(0)(0)(0)>[&] = ((UINT16<s(0)(0)(0)>[T])0x2) ;
            }
        }
    }
    else
    {
        wRtn<s(0)(0)(0)>[&] = ((UINT16<s(0)(0)(0)>[T])0x1) ;
    }
    
     
    return wRtn<s(0)(0)(0)>[&];
}



UINT16<s(0)(0)(0)>[T] cah_em4_IndRead<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] dwbaseAddr<s(0)(0)(0)>[&] ,     UINT32<s(0)(0)(0)>[T] dwaddrIndAddr<s(0)(0)(0)>[&] ,     UINT32<s(0)(0)(0)>[T] addrIndData<s(0)(0)(0)>[&] ,     UINT16<s(0)(0)(0)>[T] waddr<s(0)(0)(0)>[&] ,     UINT16<s(0)(0)(0)>[T] *pwvalue<s(0)(0)(0)>[&],     UINT16<s(0)(0)(0)>[T] wMaskval<s(0)(0)(0)>[&],     UINT16<s(0)(0)(0)>[T] wMaskaddr<s(0)(0)(0)>[&])






{
    UINT16<s(0)(0)(0)>[T] wRtn<s(0)(0)(0)>[&]    =(D2) ((WORD<s(0)(0)(0)>[T])0x0) ;

     
    wRtn<s(0)(0)(0)>[&] |= cah_em4_PollBusyBit<s(0)(0)(0)>[&](dwbaseAddr<s(0)(0)(0)>[&], dwaddrIndAddr<s(0)(0)(0)>[&]);
    if (((WORD<s(0)(0)(0)>[T])0x0)  != wRtn<s(0)(0)(0)>[&])
    {
        return ((UINT16<s(0)(0)(0)>[T])0x8) ;
    }

     
    wRtn<s(0)(0)(0)>[&] |= cah_em4_WriteRegister<s(0)(0)(0)>[&](dwbaseAddr<s(0)(0)(0)>[&], dwaddrIndAddr<s(0)(0)(0)>[&], ((waddr<s(0)(0)(0)>[&] & (~0x4000 )) | 0x8000 ), wMaskaddr<s(0)(0)(0)>[&], EM4_REG_ATTRBT_WO<s(0)(0)(0)>[&]);
	
     
    wRtn<s(0)(0)(0)>[&] |= cah_em4_PollBusyBit<s(0)(0)(0)>[&](dwbaseAddr<s(0)(0)(0)>[&], dwaddrIndAddr<s(0)(0)(0)>[&]);
    if (((WORD<s(0)(0)(0)>[T])0x0)  != wRtn<s(0)(0)(0)>[&])
    {
        return ((UINT16<s(0)(0)(0)>[T])0x8) ;
    }

     
    wRtn<s(0)(0)(0)>[&] |= cah_em4_ReadRegister<s(0)(0)(0)>[&](dwbaseAddr<s(0)(0)(0)>[&], addrIndData<s(0)(0)(0)>[&] , pwvalue<s(0)(0)(0)>[&], wMaskval<s(0)(0)(0)>[&], EM4_REG_ATTRBT_RO<s(0)(0)(0)>[&]);

    return ((WORD<s(0)(0)(0)>[T])0x0) ;
}



 



PB_ERROR_CODE_T<s(0)(0)(0)>[T]
cah_em4_setPdhPortMode<s(0)(0)(0)>[&] (ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&], PDH_PORT_MODE_T<s(0)(0)(0)>[T] type<s(0)(0)(0)>[&])
{
    void *base<s(0)(0)(0)>[&] =(D2) 0x0000;
    int port<s(0)(0)(0)>[&] =(D2) 0;
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0x0000;
    CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *pEntity<s(0)(0)(0)>[&] =(D2) ((void *)0) ;

    pEntity<s(0)(0)(0)>[&] = cah_em4_getEntityPtr<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&]);
    cah_em4_registerCall<s(0)(0)(0)>[&] ((PMyFun<s(0)(0)(0)>[T]) cah_em4_setPdhPortMode<s(0)(0)(0)>[&], (int) ulPort<s(0)(0)(0)>[&], (int) type<s(0)(0)(0)>[&], 0, 11, __FUNCTION__<s(0)(0)(0)>[&]);

    if (pEntity<s(0)(0)(0)>[&]->state<s(0)(0)(0)>[&] != eEm4EntAct<s(0)(0)(0)>[&])
    {
        return PB_ERR_STATE<s(0)(0)(0)>[&];
    }
    base<s(0)(0)(0)>[&] = (void *) cah_em4_getEntityBase<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&], ulPort<s(0)(0)(0)>[&]);
    u<s(0)(0)(0)>[&] = cah_em4_pohRead<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&] = ulPort<s(0)(0)(0)>[&], 0x00 );
    u<s(0)(0)(0)>[&] &= ~0x000c;                
    cah_em4_pohWrite<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&], 0x00 , u<s(0)(0)(0)>[&]);

    return ((WORD<s(0)(0)(0)>[T])0x0) ;
}

int cah_em4_gete1outloop<s(0)(0)(0)>[&] (void * base<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&])
{
	unsigned short loop<s(0)(0)(0)>[&] =(D2) 0;
	int byte<s(0)(0)(0)>[&] =(D2) 0;
	int bit<s(0)(0)(0)>[&] =(D2) 0;

	byte<s(0)(0)(0)>[&] = (port<s(0)(0)(0)>[&] / 16);
	bit<s(0)(0)(0)>[&] = (port<s(0)(0)(0)>[&] % 16);
	
	loop<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (((0x04 << 10) | 0x10 ) + byte<s(0)(0)(0)>[&]));

    return (loop<s(0)(0)(0)>[&] & (0x0001 << bit<s(0)(0)(0)>[&])) ? 1:0;
}


int cah_em4_e1outloop<s(0)(0)(0)>[&] (void * base<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&], int enable<s(0)(0)(0)>[&])
{
	unsigned short loop<s(0)(0)(0)>[&] =(D2) 0;
	int byte<s(0)(0)(0)>[&] =(D2) 0;
	int bit<s(0)(0)(0)>[&] =(D2) 0;

	byte<s(0)(0)(0)>[&] = (port<s(0)(0)(0)>[&] / 16);
	bit<s(0)(0)(0)>[&] = (port<s(0)(0)(0)>[&] % 16);
	
	loop<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (((0x04 << 10) | 0x10 ) + byte<s(0)(0)(0)>[&]));
	if (enable<s(0)(0)(0)>[&])
	{
		loop<s(0)(0)(0)>[&] |= (0x0001 << bit<s(0)(0)(0)>[&]);
	} else {
		loop<s(0)(0)(0)>[&] &= ~(0x0001 << bit<s(0)(0)(0)>[&]);
	}

	cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (((0x04 << 10) | 0x10 ) + byte<s(0)(0)(0)>[&]), loop<s(0)(0)(0)>[&]);

	return ((WORD<s(0)(0)(0)>[T])0x0) ;
}

int cah_em4_e1inloop<s(0)(0)(0)>[&] (void * base<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&], int enable<s(0)(0)(0)>[&])
{
	unsigned short loop<s(0)(0)(0)>[&] =(D2) 0;
	
	loop<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (((0x05 << 10) | 0x100 ) + port<s(0)(0)(0)>[&]));
	if (enable<s(0)(0)(0)>[&])
	{
		loop<s(0)(0)(0)>[&] |= (0x0002);
	} else {
		loop<s(0)(0)(0)>[&] &= ~(0x0002);
	}

	cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (((0x05 << 10) | 0x100 ) + port<s(0)(0)(0)>[&]), loop<s(0)(0)(0)>[&]);

	return ((WORD<s(0)(0)(0)>[T])0x0) ;
}
 


WORD<s(0)(0)(0)>[T]
CAH_EM4_SetPortLoopback<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], CTD_LOOPBACK_TYPE_T<s(0)(0)(0)>[T] eLpbckMd<s(0)(0)(0)>[&])
{
    WORD<s(0)(0)(0)>[T] wRtn<s(0)(0)(0)>[&] =(D2) ((WORD<s(0)(0)(0)>[T])0x0) ;
	int port<s(0)(0)(0)>[&] =(D2) 0;
	void * base<s(0)(0)(0)>[&] =(D2) 0;

	{if (125 <  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;
    cah_em4_registerCall<s(0)(0)(0)>[&] ((PMyFun<s(0)(0)(0)>[T]) CAH_EM4_SetPortLoopback<s(0)(0)(0)>[&], (int) SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]), (int) eLpbckMd<s(0)(0)(0)>[&], 0, 16, __FUNCTION__<s(0)(0)(0)>[&]);
	port<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&])) - 1;
	base<s(0)(0)(0)>[&] = cah_em4_getEntityBase<s(0)(0)(0)>[&] (0, SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]));

    switch (eLpbckMd<s(0)(0)(0)>[&])
    {
    case CTD_LOOPBACK_TYPE_NONE<s(0)(0)(0)>[&]:
		cah_em4_e1inloop<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&], CTD_LOOPBACK_TYPE_NONE<s(0)(0)(0)>[&]);
		cah_em4_e1outloop<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&], CTD_LOOPBACK_TYPE_NONE<s(0)(0)(0)>[&]);
        break;

    case CTD_LOOPBACK_TYPE_INWARD_NEAR<s(0)(0)(0)>[&]:
        break;

    case CTD_LOOPBACK_TYPE_OUTWARD_FAR<s(0)(0)(0)>[&]:
        break;

    case CTD_LOOPBACK_TYPE_OUTWARD_NEAR<s(0)(0)(0)>[&]:
         
         

		cah_em4_e1inloop<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&], eLpbckMd<s(0)(0)(0)>[&]);
        break;

    case CTD_LOOPBACK_TYPE_INWARD_FAR<s(0)(0)(0)>[&]:
         
         

		cah_em4_e1outloop<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&], eLpbckMd<s(0)(0)(0)>[&]);
		return ((WORD<s(0)(0)(0)>[T])0x0) ;
        break;

    default:
        wRtn<s(0)(0)(0)>[&] = ((WORD<s(0)(0)(0)>[T])0x1) ;
		return wRtn<s(0)(0)(0)>[&];
    }

    return wRtn<s(0)(0)(0)>[&];
}

 


PB_ERROR_CODE_T<s(0)(0)(0)>[T]
cah_em4_prbsEnable<s(0)(0)(0)>[&] (ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&])
{
    CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *pEntity<s(0)(0)(0)>[&];(D1:pEntity:0)
    PB_ERROR_CODE_T<s(0)(0)(0)>[T] ret<s(0)(0)(0)>[&] =(D2) ((WORD<s(0)(0)(0)>[T])0x0) ;
    void *base<s(0)(0)(0)>[&] =(D2) 0x0000;
     
     


    if ((((  entity<s(0)(0)(0)>[&]   >= ((1) ) )) || ((   ulChip<s(0)(0)(0)>[&]  )  >=  (1) ) || ((   ulPort<s(0)(0)(0)>[&]  ) >= (63 ) ) ) )
    {
        printf<s(0)(0)(0)>[&] ("\r\n%s!  Entity= %d; File=%s; Line=%d  \r\n", __FUNCTION__<s(0)(0)(0)>[&], entity<s(0)(0)(0)>[&], "cah_126e1.c",
                1758);
        return PB_ERR_PARAM<s(0)(0)(0)>[&];
    }

    pEntity<s(0)(0)(0)>[&] = cah_em4_getEntityPtr<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&]);
    cah_em4_registerCall<s(0)(0)(0)>[&] ((PMyFun<s(0)(0)(0)>[T]) cah_em4_prbsEnable<s(0)(0)(0)>[&], (int) ulPort<s(0)(0)(0)>[&], (int) bEnable<s(0)(0)(0)>[&], 0, 16, __FUNCTION__<s(0)(0)(0)>[&]);

    if (pEntity<s(0)(0)(0)>[&]->state<s(0)(0)(0)>[&] != eEm4EntAct<s(0)(0)(0)>[&])
    {
        return PB_ERR_STATE<s(0)(0)(0)>[&];
    }

    if (bEnable<s(0)(0)(0)>[&])
    {
         


        base<s(0)(0)(0)>[&] = (void *) cah_em4_getEntityBase<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&], ulPort<s(0)(0)(0)>[&]);
        cah_em4_setPrbs2<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], ulPort<s(0)(0)(0)>[&], eEM4_ENABLE<s(0)(0)(0)>[&]);

        ret<s(0)(0)(0)>[&] = ((WORD<s(0)(0)(0)>[T])0x0) ;
        if (((WORD<s(0)(0)(0)>[T])0x0)  == ret<s(0)(0)(0)>[&])
        {
            pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].prbsCfg<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].prbsMode<s(0)(0)(0)>[&] = PRBS_MODE_POWER15<s(0)(0)(0)>[&];
            pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].prbsCfg<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].prbsStatus<s(0)(0)(0)>[&] = PRBS_STATUS_SYNCING<s(0)(0)(0)>[&];
            pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].prbsCfg<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].prbsErrCnt<s(0)(0)(0)>[&] = 0;
        }
    }
    else
    {
        base<s(0)(0)(0)>[&] = (void *) cah_em4_getEntityBase<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&], ulPort<s(0)(0)(0)>[&]);
        cah_em4_setPrbs2<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], ulPort<s(0)(0)(0)>[&], eEM4_DISABLE<s(0)(0)(0)>[&]);
        ret<s(0)(0)(0)>[&] = ((WORD<s(0)(0)(0)>[T])0x0) ;
        if (((WORD<s(0)(0)(0)>[T])0x0)  == ret<s(0)(0)(0)>[&])
        {
            pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].prbsCfg<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].prbsMode<s(0)(0)(0)>[&] = PRBS_MODE_NA<s(0)(0)(0)>[&];
            pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].prbsCfg<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].prbsStatus<s(0)(0)(0)>[&] = PRBS_STATUS_NA<s(0)(0)(0)>[&];
            pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].prbsCfg<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].prbsErrCnt<s(0)(0)(0)>[&] = 0;
        }
    }

    if (((WORD<s(0)(0)(0)>[T])0x0)  != ret<s(0)(0)(0)>[&])
    {
        printf<s(0)(0)(0)>[&] ("\r\n%s!  Entity= %d; File=%s; Line=%d  \r\n", __FUNCTION__<s(0)(0)(0)>[&], entity<s(0)(0)(0)>[&], "cah_126e1.c",
                1802);
        return ((WORD<s(0)(0)(0)>[T])0x1) ;
    }

    pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].prbsCfg<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].bForceRpt<s(0)(0)(0)>[&] = 1 ;
    cah_em4_trace<s(0)(0)(0)>[&] (19, "%s: entity(%d), port(%d), flag(%d)", __FUNCTION__<s(0)(0)(0)>[&], entity<s(0)(0)(0)>[&], ulPort<s(0)(0)(0)>[&], bEnable<s(0)(0)(0)>[&]);

    return ((WORD<s(0)(0)(0)>[T])0x0) ;
}

double cah_em4_wasteOfTime<s(0)(0)(0)>[&] (void);(D1:cah_em4_wasteOfTime:0)


int g_ulport<s(0)(0)(0)>[&] =(D2) 200;


UINT16<s(0)(0)(0)>[T]
cah_em4_readPdhAlarm<s(0)(0)(0)>[&](void *base<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&])
{
    unsigned short val<s(0)(0)(0)>[&] =(D2) 0, val1<s(0)(0)(0)>[&] =(D2) 0;

    int i<s(0)(0)(0)>[&] =(D2) 0   ;

    g_waste<s(0)(0)(0)>[&] = 1 + cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x04 << 10) | 0x17 , port<s(0)(0)(0)>[&] | 0x8000);   
    for (;;)
    {
if (0) taskDelay<s(0)(0)(0)>[&] (1);            
else cah_em4_wasteOfTime<s(0)(0)(0)>[&] ();
        val<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x04 << 10) | 0x17 );
        if (0 == (val<s(0)(0)(0)>[&] & 0x8000))
        {
            break;
        }
        else
        {
            i<s(0)(0)(0)>[&] = i<s(0)(0)(0)>[&] + 1;
            if (i<s(0)(0)(0)>[&] >= 100)
            {
                printf<s(0)(0)(0)>[&] ("\r\n%s():\tbase(%p), port(%d), FATAL ERROR INDIRECT REG ACCESS ERROR !!!", __FUNCTION__<s(0)(0)(0)>[&], base<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&]);
                { { if (DBG_GetLevel<s(0)(0)(0)>[&](  gCahDbgModuleNo<s(0)(0)(0)>[&] ,     CAH_DEBUG_LEVEL_ERROR<s(0)(0)(0)>[&]  )) {printf<s(0)(0)(0)>[&]("[%s] %d: ", "cah_126e1.c", 1852); printf<s(0)(0)(0)>[&]   ("\r\ncah_em4_readPdhAlarm():\tbase(%p), port(%d), FATAL ERROR INDIRECT REG ACCESS ERROR !!!\r\n", base<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&])  ;} if (DBG_NvGetLevel<s(0)(0)(0)>[&](  gCahDbgModuleNo<s(0)(0)(0)>[&] ,     CAH_DEBUG_LEVEL_ERROR<s(0)(0)(0)>[&]  ))    ; } ; } ;
                break;
            }
        }
    }

    val<s(0)(0)(0)>[&] 	= cah_em4_rd<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x04 << 10) | 0x1b ) & 0x0007;
    val1<s(0)(0)(0)>[&] 	= cah_em4_rd<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x04 << 10) | 0x1c ) & 0x0001;
    if (port<s(0)(0)(0)>[&] == g_ulport<s(0)(0)(0)>[&])
    {
        printf<s(0)(0)(0)>[&] ("\r\ncah_em4_readPdhAlarm:port(%d), val(%x), val1(%x)", port<s(0)(0)(0)>[&], val<s(0)(0)(0)>[&], val1<s(0)(0)(0)>[&]);
    }

    val<s(0)(0)(0)>[&]     = val<s(0)(0)(0)>[&] & 0x0007;
    val1<s(0)(0)(0)>[&]    = val1<s(0)(0)(0)>[&] & 0x0001;
	val<s(0)(0)(0)>[&] 	= val<s(0)(0)(0)>[&] | ((val1<s(0)(0)(0)>[&] & 0x0001) ? 0x0008 : 0x0000);

    return (val<s(0)(0)(0)>[&]);
}


static double gCahEm4Time<s(0)(0)(0)>[&] =(D2) 0;

double cah_em4_wasteOfTime<s(0)(0)(0)>[&] ()
{
    static double ary<s(0)(0)(0)>[&] [16];(D1:ary:0)
    double r<s(0)(0)(0)>[&] =(D2) 0.0;
    int i<s(0)(0)(0)>[&] =(D2) 0;

    for (i<s(0)(0)(0)>[&] = 0; i<s(0)(0)(0)>[&] < 5; i<s(0)(0)(0)>[&] ++)
    {
        r<s(0)(0)(0)>[&] = ary<s(0)(0)(0)>[&][i<s(0)(0)(0)>[&]] = ary<s(0)(0)(0)>[&][i<s(0)(0)(0)>[&]+1] * ary<s(0)(0)(0)>[&][i<s(0)(0)(0)>[&]+2] / ary<s(0)(0)(0)>[&][i<s(0)(0)(0)>[&]+3];
    }

    gCahEm4Time<s(0)(0)(0)>[&] = r<s(0)(0)(0)>[&];

    return r<s(0)(0)(0)>[&];
}

int g_inderr<s(0)(0)(0)>[&] =(D2) 1;


UINT32<s(0)(0)(0)>[T]
cah_em4_readCrc4RemoteReg<s(0)(0)(0)>[&] (void *base<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] *pNear<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] *pRemote<s(0)(0)(0)>[&])
{
    UINT16<s(0)(0)(0)>[T] val<s(0)(0)(0)>[&];(D1:val:0)
    
    int i<s(0)(0)(0)>[&] =(D2) 0   ;
    g_waste<s(0)(0)(0)>[&] = 1 + cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x04 << 10) | 0x18 , port<s(0)(0)(0)>[&] | 0x8000);   
    for (;;)
    {
        val<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x04 << 10) | 0x18 );
        if (0 == (val<s(0)(0)(0)>[&] & 0x8000))
        {
            break;
        }
        else
        {
            i<s(0)(0)(0)>[&] = i<s(0)(0)(0)>[&] + 1;
if (0) taskDelay<s(0)(0)(0)>[&] (1);            
else cah_em4_wasteOfTime<s(0)(0)(0)>[&] ();
            if (i<s(0)(0)(0)>[&] >= 100)
            {
                if (g_inderr<s(0)(0)(0)>[&])
                printf<s(0)(0)(0)>[&] ("\r\n%s():\tbase(%p), port(%d), FATAL ERROR ON INDIRECT REG ACCESS", __FUNCTION__<s(0)(0)(0)>[&], base<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&]);
                break;
            }
        }
    }
    val<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x04 << 10) | 0x1a );
    *pNear<s(0)(0)(0)>[&] = val<s(0)(0)(0)>[&];

    val<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x04 << 10) | 0x19 );
    val<s(0)(0)(0)>[&] &= ~0xfc00;                
    *pRemote<s(0)(0)(0)>[&] = val<s(0)(0)(0)>[&];

    return val<s(0)(0)(0)>[&];
}



UINT32<s(0)(0)(0)>[T]
cah_em4_readCrc4Reg<s(0)(0)(0)>[&] (void *base<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&])
{
    UINT16<s(0)(0)(0)>[T] val<s(0)(0)(0)>[&];(D1:val:0)
    








    int i<s(0)(0)(0)>[&] =(D2) 0   ;
    g_waste<s(0)(0)(0)>[&] = 1 + cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x04 << 10) | 0x18 , port<s(0)(0)(0)>[&] | 0x8000);   
    for (;;)
    {
        val<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x04 << 10) | 0x18 );
        if (0 == (val<s(0)(0)(0)>[&] & 0x8000))
        {
            break;
        }
        else
        {
            i<s(0)(0)(0)>[&] = i<s(0)(0)(0)>[&] + 1;
if (0) taskDelay<s(0)(0)(0)>[&] (1);            
else cah_em4_wasteOfTime<s(0)(0)(0)>[&] ();
            if (i<s(0)(0)(0)>[&] >= 100)
            {
                if (g_inderr<s(0)(0)(0)>[&])
                printf<s(0)(0)(0)>[&] ("\r\n%s():\tbase(%p), port(%d), FATAL ERROR ON INDIRECT REG ACCESS", __FUNCTION__<s(0)(0)(0)>[&], base<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&]);
                break;
            }
        }
    }
    val<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x04 << 10) | 0x1a );

    return val<s(0)(0)(0)>[&];
}






unsigned short
cah_em4_getFarCrcErrCount<s(0)(0)(0)>[&] (void *base<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&])
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0;








    int i<s(0)(0)(0)>[&] =(D2) 0;
    cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x04 << 10) | 0x18 , port<s(0)(0)(0)>[&] | 0x8000);         
    for (;;)
    {
        u<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x04 << 10) | 0x18 );
        if (0 == (u<s(0)(0)(0)>[&] & 0x8000))
        {
            break;
        }
        else
        {
            i<s(0)(0)(0)>[&] = i<s(0)(0)(0)>[&] + 1;
if (0) taskDelay<s(0)(0)(0)>[&] (1);            
else cah_em4_wasteOfTime<s(0)(0)(0)>[&] ();
            if (i<s(0)(0)(0)>[&] >= 100)
            {
if (g_inderr<s(0)(0)(0)>[&])
                printf<s(0)(0)(0)>[&] ("\r\n%s():\tbase(%p), port(%d), FATAL ERROR ON INDRECT REG ACCESS", __FUNCTION__<s(0)(0)(0)>[&], base<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&]);
                break;
            }
        }
    }
    u<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x04 << 10) | 0x19 );
    u<s(0)(0)(0)>[&] &= ~0xfc00;                



    return u<s(0)(0)(0)>[&];
}






inline int
cah_em4_ent2chipno<s(0)(0)(0)>[&] (ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&])
{
    return cah_em4_ent2fd<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&]);
}



 


PB_ERROR_CODE_T<s(0)(0)(0)>[T]
cah_em4_insertUpAis<s(0)(0)(0)>[&] (ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&])
{
    CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *pEntity<s(0)(0)(0)>[&];(D1:pEntity:0)
     


    if (cah_em4_blockupais<s(0)(0)(0)>[&] && bEnable<s(0)(0)(0)>[&])
    {
        printf<s(0)(0)(0)>[&] ("\r\n%s, has been blocked! entity%d ulChip%d ulPort%d \r\n", __FUNCTION__<s(0)(0)(0)>[&], entity<s(0)(0)(0)>[&],
                ulChip<s(0)(0)(0)>[&], ulChip<s(0)(0)(0)>[&]);
        bEnable<s(0)(0)(0)>[&] = 0 ;
    }

    if ((((  entity<s(0)(0)(0)>[&]   >= ((1) ) )) || ((   ulChip<s(0)(0)(0)>[&]  )  >=  (1) ) || ((   ulPort<s(0)(0)(0)>[&]  ) >= (63 ) ) ) )
    {
        printf<s(0)(0)(0)>[&] ("\r\n%s!  Entity= %d; File=%s; Line=%d  \r\n", __FUNCTION__<s(0)(0)(0)>[&], entity<s(0)(0)(0)>[&], "cah_126e1.c",
                2247);
        return PB_ERR_PARAM<s(0)(0)(0)>[&];
    }

    pEntity<s(0)(0)(0)>[&] = cah_em4_getEntityPtr<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&]);

    if (pEntity<s(0)(0)(0)>[&]->state<s(0)(0)(0)>[&] != eEm4EntAct<s(0)(0)(0)>[&])
    {
        printf<s(0)(0)(0)>[&] ("\r\n%s!  Entity= %d; File=%s; Line=%d  \r\n", __FUNCTION__<s(0)(0)(0)>[&], entity<s(0)(0)(0)>[&], "cah_126e1.c",
                2256);
        return PB_ERR_STATE<s(0)(0)(0)>[&];
    }

    return ((WORD<s(0)(0)(0)>[T])0x0) ;
}

extern STATUS<s(0)(0)(0)>[T] vxMemProbe<s(0)(0)(0)>[&](char * adrs<s(0)(0)(0)>[&], int mode<s(0)(0)(0)>[&], int length<s(0)(0)(0)>[&], char * pVal<s(0)(0)(0)>[&]);(D1:pVal:0)

 



PB_ERROR_CODE_T<s(0)(0)(0)>[T]
cah_em4_detectCardStateEx<s(0)(0)(0)>[&] (CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] * pEntity<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] * pbActive<s(0)(0)(0)>[&])
{
    void *base<s(0)(0)(0)>[&] =(D2) (void *) 0;
    unsigned short val<s(0)(0)(0)>[&] =(D2) 0;
    static int flag<s(0)(0)(0)>[&] =(D2) 1;
    volatile unsigned short *p<s(0)(0)(0)>[&] =(D2) ((void *)0) ;

    *pbActive<s(0)(0)(0)>[&] = 0 ;
     


	base<s(0)(0)(0)>[&] = cah_em4_getEntityBase<s(0)(0)(0)>[&](0, 3);
    p<s(0)(0)(0)>[&] = (unsigned short *)0x50000020;
    if (-1 == vxMemProbe<s(0)(0)(0)>[&]((char *)p<s(0)(0)(0)>[&], 0 , 2, (char *)&val<s(0)(0)(0)>[&]))
    {
 
        *pbActive<s(0)(0)(0)>[&] = 0 ;
        return ((WORD<s(0)(0)(0)>[T])0x0) ;
    } else {
   
    }

    p<s(0)(0)(0)>[&] = (unsigned short *)0x60000020;
    if (-1 == vxMemProbe<s(0)(0)(0)>[&]((char *)p<s(0)(0)(0)>[&], 0 , 2, (char *)&val<s(0)(0)(0)>[&]))
    {
    
        *pbActive<s(0)(0)(0)>[&] = 0 ;
        return ((WORD<s(0)(0)(0)>[T])0x0) ;
    } else {
     
    }

     
    val<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (((0x00 << 10) | 0x01)) );
    if (0x28 == (val<s(0)(0)(0)>[&]&0xff))
    {
        if (flag<s(0)(0)(0)>[&])
            printf<s(0)(0)(0)>[&] ("\r\ndetect(TRUE), base(%x), val(%x)", (int) base<s(0)(0)(0)>[&], val<s(0)(0)(0)>[&]);
        *pbActive<s(0)(0)(0)>[&] = 1 ;
    }
    else
    {
        printf<s(0)(0)(0)>[&] ("\r\ndetect(FALSE), base(%x), val(%x)", (int) base<s(0)(0)(0)>[&], val<s(0)(0)(0)>[&]);
        *pbActive<s(0)(0)(0)>[&] = 0 ;
    }

	base<s(0)(0)(0)>[&] = cah_em4_getEntityBase<s(0)(0)(0)>[&](0, 77);
     
    val<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (((0x00 << 10) | 0x01)) );
    if (0x28 == (val<s(0)(0)(0)>[&]&0xff))
    {
        if (flag<s(0)(0)(0)>[&])
            printf<s(0)(0)(0)>[&] ("\r\ndetect(TRUE), base(%x), val(%x)", (int) base<s(0)(0)(0)>[&], val<s(0)(0)(0)>[&]);
        *pbActive<s(0)(0)(0)>[&] = 1 ;
    }
    else
    {
        printf<s(0)(0)(0)>[&] ("\r\ndetect(FALSE), base(%x), val(%x)", (int) base<s(0)(0)(0)>[&], val<s(0)(0)(0)>[&]);
        *pbActive<s(0)(0)(0)>[&] = 0 ;
    }
 
    flag<s(0)(0)(0)>[&] = 0;

    return ((WORD<s(0)(0)(0)>[T])0x0) ;
}







 





















 




void
cah_em4_showbuild<s(0)(0)(0)>[&] (void)
{
    printf<s(0)(0)(0)>[&] ("\r\n>>>>> EM4: this load is build at (%s):(%s)(%s) <<<<<\r\n", "Apr 13 2009", "15:08:05",
            __FUNCTION__<s(0)(0)(0)>[&]);
}

 



int
cah_em4_show<s(0)(0)(0)>[&] (char *fmt<s(0)(0)(0)>[&], ...)
{
    va_list<s(0)(0)(0)>[T] argptr<s(0)(0)(0)>[&];(D1:argptr:0)
    int cnt<s(0)(0)(0)>[&];(D1:cnt:0)

    printf<s(0)(0)(0)>[&] ("\r\n");
    (__builtin_next_arg<s(0)(0)(0)>[&] (  fmt<s(0)(0)(0)>[&] ), __builtin_memcpy<s(0)(0)(0)>[&] ((  argptr<s(0)(0)(0)>[&]  ), __builtin_saveregs<s(0)(0)(0)>[&] (), sizeof(__gnuc_va_list<s(0)(0)(0)>[T])) ) ;
    cnt<s(0)(0)(0)>[&] = vprintf<s(0)(0)(0)>[&] (fmt<s(0)(0)(0)>[&], argptr<s(0)(0)(0)>[&]);
    ((void)0) ;

    return (cnt<s(0)(0)(0)>[&]);
}

 






int
em4help<s(0)(0)(0)>[&] (void)
{
    int i<s(0)(0)(0)>[&] =(D2) 0;

    printf<s(0)(0)(0)>[&] ("\r\nEM4 version(%d)", g_cahem4version<s(0)(0)(0)>[&]);

    while (cah_em4_fmsg<s(0)(0)(0)>[&][i<s(0)(0)(0)>[&]] != ((void *)0) )
    {
        cah_em4_show<s(0)(0)(0)>[&] ("%s", cah_em4_fmsg<s(0)(0)(0)>[&][i<s(0)(0)(0)>[&]]);
        i<s(0)(0)(0)>[&]++;
    }

    return 0;

}



 


int
cah_em4_portCfg2<s(0)(0)(0)>[&] (void *baseaddr<s(0)(0)(0)>[&])
{
    int port<s(0)(0)(0)>[&] =(D2) 0;
    char *j2<s(0)(0)(0)>[&] =(D2) "FPGA_BENCH_T";
    int j<s(0)(0)(0)>[&] =(D2) 0, i<s(0)(0)(0)>[&] =(D2) 0;
    int r<s(0)(0)(0)>[&] =(D2) 0;
    
    cah_em4_wr<s(0)(0)(0)>[&](baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x00 , 0x8000);
    taskDelay<s(0)(0)(0)>[&] (10);
    cah_em4_wr<s(0)(0)(0)>[&](baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x00 , 0x0001);
    
    for (port<s(0)(0)(0)>[&] = 0; port<s(0)(0)(0)>[&] < (63 ) ; port<s(0)(0)(0)>[&]++)
    {
         



		cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x02 , 0xd3ff);
         

		cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 , 0xc000+(port<s(0)(0)(0)>[&] << 8) + 0);
         

        taskDelay<s(0)(0)(0)>[&] (2);
		cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x02 , 0x01c8);
         

		cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 , 0xc000+(port<s(0)(0)(0)>[&] << 8) + 1);
         
        taskDelay<s(0)(0)(0)>[&] (2);

        if ((port<s(0)(0)(0)>[&] << 10))
        {
            for (i<s(0)(0)(0)>[&] = 0; i<s(0)(0)(0)>[&] < 16; i<s(0)(0)(0)>[&]++)
            {
                if (((WORD<s(0)(0)(0)>[T])0x0)  !=
                    (r<s(0)(0)(0)>[&] = cah_em4_setDegThreshold<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&], (j2<s(0)(0)(0)>[&][1] << 8) + 0x80 + j2<s(0)(0)(0)>[&][0])))
                {
                    printf<s(0)(0)(0)>[&] ("\r\ncah_em4_setDegThreshold () failed");
                    return (r<s(0)(0)(0)>[&]);
                }
                for (j<s(0)(0)(0)>[&] = 1; j<s(0)(0)(0)>[&] < 8; j<s(0)(0)(0)>[&]++)
                {
                    if (((WORD<s(0)(0)(0)>[T])0x0)  !=
                        (r<s(0)(0)(0)>[&] =
                         cah_em4_setDegThreshold<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&],
                                                  (j2<s(0)(0)(0)>[&][j<s(0)(0)(0)>[&] * 2 + 1] << 8) + j2<s(0)(0)(0)>[&][j<s(0)(0)(0)>[&] * 2])))
                    {
                        printf<s(0)(0)(0)>[&] ("\r\ncah_em4_setDegThreshold() failed");
                        return (r<s(0)(0)(0)>[&]);
                    }
                }
            }
        }
        else
        {
            for (i<s(0)(0)(0)>[&] = 0; i<s(0)(0)(0)>[&] < 16; i<s(0)(0)(0)>[&]++)
            {
                if (((WORD<s(0)(0)(0)>[T])0x0)  !=
                    (r<s(0)(0)(0)>[&] = cah_em4_setDegThreshold<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&], (j2<s(0)(0)(0)>[&][1] << 8) + 0x80 + j2<s(0)(0)(0)>[&][0])))
                {
                    printf<s(0)(0)(0)>[&] ("\r\ncah_em4_setDegThreshold () failed");
                    return (r<s(0)(0)(0)>[&]);
                }

                for (j<s(0)(0)(0)>[&] = 1; j<s(0)(0)(0)>[&] < 8; j<s(0)(0)(0)>[&]++)
                {
                    if (((WORD<s(0)(0)(0)>[T])0x0)  !=
                        (r<s(0)(0)(0)>[&] =
                         cah_em4_setDegThreshold<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&],
                                                  (j2<s(0)(0)(0)>[&][j<s(0)(0)(0)>[&] * 2 + 1] << 8) + j2<s(0)(0)(0)>[&][j<s(0)(0)(0)>[&] * 2])))
                    {
                        printf<s(0)(0)(0)>[&] ("\r\ncah_em4_setDegThreshold () failed");
                        return (r<s(0)(0)(0)>[&]);
                    }
                }
            }
        }
    }

    return 0;
}

int
cah_em4_portCfg1<s(0)(0)(0)>[&] (void *baseaddr<s(0)(0)(0)>[&])
{
    char buffer<s(0)(0)(0)>[&][256];(D1:buffer:0)
    int port<s(0)(0)(0)>[&] =(D2) 0;
    char *j2<s(0)(0)(0)>[&] =(D2) "FPGA_BENCH_T";
    int r<s(0)(0)(0)>[&] =(D2) 0;
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0;


     


    for (port<s(0)(0)(0)>[&] = 0; port<s(0)(0)(0)>[&] < (63 ) ; port<s(0)(0)(0)>[&]++)
    {
         



        cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x04 << 10) | 0x30 , port<s(0)(0)(0)>[&]);       
        cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x04 << 10) | 0x40 , 0x8a);
        cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x04 << 10) | 0x47 , 0);
        cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x04 << 10) | 0x41 , 0);

         
        u<s(0)(0)(0)>[&] = 0;





  

 
         sprintf<s(0)(0)(0)>[&] (buffer<s(0)(0)(0)>[&], "%s%d", j2<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&]);
        if (((WORD<s(0)(0)(0)>[T])0x0)  != (r<s(0)(0)(0)>[&] = cah_em4_setTxj2<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (const unsigned char *) buffer<s(0)(0)(0)>[&])))
        {
            printf<s(0)(0)(0)>[&] ("\r\n%s(): cah_em4_setTxj2() failed", __FUNCTION__<s(0)(0)(0)>[&]);
            return (r<s(0)(0)(0)>[&]);
        }
    }
    return (((WORD<s(0)(0)(0)>[T])0x0) );
}



void
e1_init<s(0)(0)(0)>[&] (void)
{
    printf<s(0)(0)(0)>[&] ("\r\nInitialize 63-E1 Mapper (%x) : version (%x)(%x)", (0x50000000) , em4Map1Rd<s(0)(0)(0)>[&] (0, 0),
            em4Map2Rd<s(0)(0)(0)>[&] (0, 0));
    em4Map1Wr<s(0)(0)(0)>[&] (0, 1, 0x29);
    taskDelay<s(0)(0)(0)>[&] (sysClkRateGet<s(0)(0)(0)>[&] () / 4);
    em4Map1Wr<s(0)(0)(0)>[&] (0, 1, 0x28);

    taskDelay<s(0)(0)(0)>[&] (sysClkRateGet<s(0)(0)(0)>[&] () / 2);

    printf<s(0)(0)(0)>[&] ("\r\nInitialize DCM monitor interval to 15ms ");
    em4Map1Wr<s(0)(0)(0)>[&] (0, 0x0a, 0x3200);
}

int gCahEm4Print<s(0)(0)(0)>[&] =(D2) 0;
int
cah_em4_printf<s(0)(0)(0)>[&] (char *msg<s(0)(0)(0)>[&], ...)
{
    va_list<s(0)(0)(0)>[T] argptr<s(0)(0)(0)>[&];(D1:argptr:0)
    int cnt<s(0)(0)(0)>[&] =(D2) 0;

    if (0 == gCahEm4Print<s(0)(0)(0)>[&]) 
    {
        taskDelay<s(0)(0)(0)>[&] (3);
        return 0;
    }

    if (1 == gCahEm4Print<s(0)(0)(0)>[&])
    {
        printf<s(0)(0)(0)>[&] ("\r\n");
        (__builtin_next_arg<s(0)(0)(0)>[&] (  msg<s(0)(0)(0)>[&] ), __builtin_memcpy<s(0)(0)(0)>[&] ((  argptr<s(0)(0)(0)>[&]  ), __builtin_saveregs<s(0)(0)(0)>[&] (), sizeof(__gnuc_va_list<s(0)(0)(0)>[T])) ) ;
        cnt<s(0)(0)(0)>[&] = vprintf<s(0)(0)(0)>[&] (msg<s(0)(0)(0)>[&], argptr<s(0)(0)(0)>[&]);
        ((void)0) ;
    }

    return (cnt<s(0)(0)(0)>[&]);
}



void
e1_dcm_state<s(0)(0)(0)>[&] (void *baseaddr<s(0)(0)(0)>[&])
{
    unsigned short v<s(0)(0)(0)>[&] =(D2) 0;

    v<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], ((0x00 << 10) | 0x0a) );
    if (v<s(0)(0)(0)>[&] & 0x80)
    {
        printf<s(0)(0)(0)>[&] ("\r\nDCM: locked");
    }
    else
    {
        printf<s(0)(0)(0)>[&] ("\r\nDCM: UNlocked!");
    }
    printf<s(0)(0)(0)>[&] ("\r\n monitored at interval 15 ms, resetted ");
}

 




















































extern UINT8<s(0)(0)(0)>[T] GetSlotNumber<s(0)(0)(0)>[&](void);(D1:GetSlotNumber:0)



 





































































































































void cah_em4_e1desync_default<s(0)(0)(0)>[&](void *baseaddr<s(0)(0)(0)>[&])
{
    int i<s(0)(0)(0)>[&]=(D2)0;   
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0;
    cah_em4_printf<s(0)(0)(0)>[&]("\r\nDesync: set to 32-byte fifo with center 12");
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x05 << 10) | 0x00 , 0x30c);
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], ((0x05 << 10) | 0x00 ) | 0x0c, 0);
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], ((0x05 << 10) | 0x00 ) | 0x0d, 0);
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], ((0x05 << 10) | 0x00 ) | 0x0e, 0);
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], ((0x05 << 10) | 0x00 ) | 0x0f, 0);
    
    cah_em4_printf<s(0)(0)(0)>[&] ("\r\nInitial desynchronizer (macro): ");
    for (i<s(0)(0)(0)>[&] = 0; i<s(0)(0)(0)>[&] < (63 ) ; i<s(0)(0)(0)>[&]++)
    {      
        u<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x05 << 10) |( 0x100+ i<s(0)(0)(0)>[&]));
        u<s(0)(0)(0)>[&] &= ~0x0007;
        cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x05 << 10) |( 0x100+ i<s(0)(0)(0)>[&]), u<s(0)(0)(0)>[&] );        
    }

}
void cah_em4_e1sync_default<s(0)(0)(0)>[&](void *baseaddr<s(0)(0)(0)>[&])
{
      cah_em4_printf<s(0)(0)(0)>[&]("\r\nsync: set LIU fall edge");
       
     cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x04 << 10) | 0x00 , 0x0010);
     cah_em4_printf<s(0)(0)(0)>[&]("\r\nall ports are set E1");
     cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x04 << 10) | 0x0c, 0);
     cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x04 << 10) | 0x0d, 0);
     cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x04 << 10) | 0x0e, 0);
     cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x04 << 10) | 0x0f, 0);
}
void  cah_em4_e1_tb_outloop_disable<s(0)(0)(0)>[&](void *baseaddr<s(0)(0)(0)>[&])
{    
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0;
    u<s(0)(0)(0)>[&]=cah_em4_rd<s(0)(0)(0)>[&](baseaddr<s(0)(0)(0)>[&],(((0x00 << 10) | 0x01)) );
    u<s(0)(0)(0)>[&]=u<s(0)(0)(0)>[&]& 0xfffd;
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (((0x00 << 10) | 0x01)) ,u<s(0)(0)(0)>[&]);
     
    u<s(0)(0)(0)>[&]=cah_em4_rd<s(0)(0)(0)>[&](baseaddr<s(0)(0)(0)>[&],(0x04 << 10) | 0x00 );
    u<s(0)(0)(0)>[&]=u<s(0)(0)(0)>[&]|0x0010;
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x04 << 10) | 0x00 ,u<s(0)(0)(0)>[&]);
    
}
void cah_em4_e1_poh_rx_mask_int<s(0)(0)(0)>[&](void *baseaddr<s(0)(0)(0)>[&])
{
    int i<s(0)(0)(0)>[&]=(D2)0;
    cah_em4_printf<s(0)(0)(0)>[&] ("\r\ndisable plmais and timais");
    for (i<s(0)(0)(0)>[&] = 0; i<s(0)(0)(0)>[&] < (63 ) ; i<s(0)(0)(0)>[&]++)
    {                     
        cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x02 , 0x1000);
        cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 , 0xc000 + (i<s(0)(0)(0)>[&] << 8) + 0x00 );
        cah_em4_pollBit<s(0)(0)(0)>[&] ((unsigned short *) baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 );
    }
}


void cah_em4_e1_poh_set_degrade<s(0)(0)(0)>[&] (void *baseaddr<s(0)(0)(0)>[&],int level<s(0)(0)(0)>[&],int thr<s(0)(0)(0)>[&],int period<s(0)(0)(0)>[&])
{

    cah_em4_printf<s(0)(0)(0)>[&] ("\r\nSet poh rx degrade ...");
    cah_em4_wr<s(0)(0)(0)>[&](baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | (0x020+2*(level<s(0)(0)(0)>[&]&0x07)), (thr<s(0)(0)(0)>[&]&0x7f)+((period<s(0)(0)(0)>[&]&0xff)<<8)  );
    cah_em4_wr<s(0)(0)(0)>[&](baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | (0x021+2*(level<s(0)(0)(0)>[&]&0x07)), ((period<s(0)(0)(0)>[&]&0xffff00)>>8)  );
}

void cah_em4_e1_poh_clr_degrade<s(0)(0)(0)>[&] (void *baseaddr<s(0)(0)(0)>[&],int level<s(0)(0)(0)>[&],int thr<s(0)(0)(0)>[&],int period<s(0)(0)(0)>[&])
{

    cah_em4_printf<s(0)(0)(0)>[&] ("\r\nSet poh rx degrade ...");
    cah_em4_wr<s(0)(0)(0)>[&](baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | (0x030+2*(level<s(0)(0)(0)>[&]&0x07)), (thr<s(0)(0)(0)>[&]&0x7f)+((period<s(0)(0)(0)>[&]&0xff)<<8)  );
    cah_em4_wr<s(0)(0)(0)>[&](baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | (0x031+2*(level<s(0)(0)(0)>[&]&0x07)), ((period<s(0)(0)(0)>[&]&0xffff00)>>8)  );
}

int
cah_em4_setGlobalRegister<s(0)(0)(0)>[&] (void *baseaddr<s(0)(0)(0)>[&])
{
    int r<s(0)(0)(0)>[&] =(D2) 0;
    int j1_locked<s(0)(0)(0)>[&] =(D2) 0;
    int i<s(0)(0)(0)>[&] =(D2) 0;
     
     

    cah_em4_printf<s(0)(0)(0)>[&] ("\r\n%s(): base(%p)", __FUNCTION__<s(0)(0)(0)>[&], baseaddr<s(0)(0)(0)>[&]);
    
    
 
    cah_em4_printf<s(0)(0)(0)>[&] ("\r\nInitialize 63-E1 Mapper (%p) : version (%x)", baseaddr<s(0)(0)(0)>[&], em4Map1Rd<s(0)(0)(0)>[&] (0, 0));
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (((0x00 << 10) | 0x01)) , 0x29);
     
    taskDelay<s(0)(0)(0)>[&] (10);
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (((0x00 << 10) | 0x01)) , 0x28);
     
    taskDelay<s(0)(0)(0)>[&] (40);
    
     












    cah_em4_printf<s(0)(0)(0)>[&] ("\r\nInitialize DCM monitor interval to 15ms ");
    cah_em4_wr<s(0)(0)(0)>[&](baseaddr<s(0)(0)(0)>[&], ((0x00 << 10) | 0x0a) , 0x3200);
    
    if ((((WORD<s(0)(0)(0)>[T])0x0)  != (r<s(0)(0)(0)>[&] = cah_em4_portCfg1<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&]))))
    {
        cah_em4_printf<s(0)(0)(0)>[&] ("\r\n%s(): cah_em4_portCfg1() failed", __FUNCTION__<s(0)(0)(0)>[&]);
        return (r<s(0)(0)(0)>[&]);
    }



      
    
    cah_em4_trace<s(0)(0)(0)>[&] (3, "e1j2 set");

    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x00 , 0x8000);
     
   taskDelay<s(0)(0)(0)>[&] (sysClkRateGet<s(0)(0)(0)>[&] () / 2);
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x00 , 0x0001);
    taskDelay<s(0)(0)(0)>[&] (sysClkRateGet<s(0)(0)(0)>[&] () / 2);
    

    

    
    cah_em4_trace<s(0)(0)(0)>[&] (3, "e1ram reset");
    if (((WORD<s(0)(0)(0)>[T])0x0)  != (r<s(0)(0)(0)>[&] = cah_em4_portCfg2<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&])))
    {
        cah_em4_printf<s(0)(0)(0)>[&] ("\r\ncah_em4_portCfg2 () failed");
        return (r<s(0)(0)(0)>[&]);
    }



    cah_em4_trace<s(0)(0)(0)>[&] (3, "e1rx&tx set");
    cah_em4_printf<s(0)(0)(0)>[&] ("\r\nResetting mapper ...");
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x04 << 10) | 0x00 , 0x0119);
     
    taskDelay<s(0)(0)(0)>[&] (40);
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x04 << 10) | 0x00 , 0x0118);
    
    cah_em4_printf<s(0)(0)(0)>[&] ("\r\nwait for telecom bus stable ...");
    
     
    j1_locked<s(0)(0)(0)>[&] = 0;
    while (j1_locked<s(0)(0)(0)>[&] == 0)
    {
        j1_locked<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x05 << 10) | 0x00 ) & 0x80;
    }
     

    
    cah_em4_printf<s(0)(0)(0)>[&] ("\r\nResetting demapper ...");
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x05 << 10) | 0x00 , 0x8004);
     
     
    taskDelay<s(0)(0)(0)>[&] (50);
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x05 << 10) | 0x00 , 0x0004);
    cah_em4_printf<s(0)(0)(0)>[&] ("\r\nResetting poh ...");
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x00 , 0x8000);
      
    taskDelay<s(0)(0)(0)>[&] (50);
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x00 , 0x0000);
    e1_dcm_state<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&]);
    cah_em4_printf<s(0)(0)(0)>[&] ("\r\nWaiting DCM stablized ...");
     
    taskDelay<s(0)(0)(0)>[&] (50);
    e1_dcm_state<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&]);
     
    
     
    cah_em4_e1desync_default<s(0)(0)(0)>[&](baseaddr<s(0)(0)(0)>[&]);
    cah_em4_e1sync_default<s(0)(0)(0)>[&](baseaddr<s(0)(0)(0)>[&]);
    
    cah_em4_printf<s(0)(0)(0)>[&] ("\r\ndisable plmais and timais");
    for (i<s(0)(0)(0)>[&] = 0; i<s(0)(0)(0)>[&] < (63 ) ; i<s(0)(0)(0)>[&]++)
    {                     
        cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x02 , 0x01c8);
        cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 , 0xc000 + (i<s(0)(0)(0)>[&] << 8) + 0x01 );
        cah_em4_pollBit<s(0)(0)(0)>[&] ((unsigned short *) baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 );
    }


     cah_em4_e1_tb_outloop_disable<s(0)(0)(0)>[&](baseaddr<s(0)(0)(0)>[&]);
     cah_em4_e1_poh_rx_mask_int<s(0)(0)(0)>[&](baseaddr<s(0)(0)(0)>[&]);

     cah_em4_e1_poh_set_degrade<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&],0,40,16000);
     cah_em4_e1_poh_clr_degrade<s(0)(0)(0)>[&](baseaddr<s(0)(0)(0)>[&],0,6,16000);
     	
     cah_em4_e1_poh_set_degrade<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&],1,80,16000);     
     cah_em4_e1_poh_clr_degrade<s(0)(0)(0)>[&](baseaddr<s(0)(0)(0)>[&],1,8,16000);
     
     
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x05 << 10) | 0x200 , (0x3f)  | ((0x3f)  << 8));
    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x05 << 10) | 0x201 , (0x3f)  | ((0x3f)  << 8));


    
    cah_Write8Reg<s(0)(0)(0)>[&] (0x70000000 ,  
                    0x1b  + 0, 
                    0x07,  
                    0x07,  
                    CAH_REG_ATTRBT_RW<s(0)(0)(0)>[&]);
    cah_Write8Reg<s(0)(0)(0)>[&] (0x70000000 ,  
                    0x1b  + 1,  
                    0x07,  
                    0x07,  
                    CAH_REG_ATTRBT_RW<s(0)(0)(0)>[&]);
    cah_Write8Reg<s(0)(0)(0)>[&] (0x70000000 ,  
                    0x1b  + 2,  
                    0x07,  
                    0x07,  
                    CAH_REG_ATTRBT_RW<s(0)(0)(0)>[&]);
    cah_Write8Reg<s(0)(0)(0)>[&] (0x70000000 ,  
                    0x1b  + 3, 
                    0x07,  
                    0x07,  
                    CAH_REG_ATTRBT_RW<s(0)(0)(0)>[&]);
    return ((WORD<s(0)(0)(0)>[T])0x0) ;
}




 


PB_ERROR_CODE_T<s(0)(0)(0)>[T]
cah_em4_initChip<s(0)(0)(0)>[&] (ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&])
{

    cah_em4_printf<s(0)(0)(0)>[&] ("\r\n%s: ent(%d), base address(0x%x)", __FUNCTION__<s(0)(0)(0)>[&], entity<s(0)(0)(0)>[&], (int) (0x50000000) );
    cah_em4_printf<s(0)(0)(0)>[&] ("\r\n%s: setGlobalRegister-1", __FUNCTION__<s(0)(0)(0)>[&]);
    if (((WORD<s(0)(0)(0)>[T])0x0)  != cah_em4_setGlobalRegister<s(0)(0)(0)>[&] ((void *) (0x50000000) ))
    {
        cah_em4_printf<s(0)(0)(0)>[&] ("\r\n%s(): set map1 failed", __FUNCTION__<s(0)(0)(0)>[&]);
        return ((WORD<s(0)(0)(0)>[T])0x1) ;
    }

    cah_em4_printf<s(0)(0)(0)>[&] ("\r\n%s: ent(%d), base address(0x%x)", __FUNCTION__<s(0)(0)(0)>[&], entity<s(0)(0)(0)>[&], (int) (0x60000000) );
    cah_em4_printf<s(0)(0)(0)>[&] ("\r\n%s: setGlobalRegister-2", __FUNCTION__<s(0)(0)(0)>[&]);
    if (((WORD<s(0)(0)(0)>[T])0x0)  != cah_em4_setGlobalRegister<s(0)(0)(0)>[&] ((void *) (0x60000000) ))
    {
        cah_em4_printf<s(0)(0)(0)>[&] ("\r\n%s(): set map2 failed", __FUNCTION__<s(0)(0)(0)>[&]);
        return ((WORD<s(0)(0)(0)>[T])0x1) ;
    }
    
    return ((WORD<s(0)(0)(0)>[T])0x0) ;
}





 



void
cah_em4_InitAlmID<s(0)(0)(0)>[&] (CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] * pEntity<s(0)(0)(0)>[&], int ulChip<s(0)(0)(0)>[&], int ulPort<s(0)(0)(0)>[&])
{
    pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].almID<s(0)(0)(0)>[&][0] = 34 ;
    pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].almID<s(0)(0)(0)>[&][1] = 32 ;
    pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].almID<s(0)(0)(0)>[&][2] = 36 ;
    pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].almID<s(0)(0)(0)>[&][3] = 39 ;
    pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].almID<s(0)(0)(0)>[&][4] = 37 ;
    pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].almID<s(0)(0)(0)>[&][5] = 38 ;
    pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].almID<s(0)(0)(0)>[&][6] = 91 ;
    pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].almID<s(0)(0)(0)>[&][7] = 92 ;
    pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].almID<s(0)(0)(0)>[&][8] = 42 ;
     


    pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].almID<s(0)(0)(0)>[&][9] = 232 ;
    pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].almID<s(0)(0)(0)>[&][10] = 233 ;
    pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].almID<s(0)(0)(0)>[&][11] = 235 ;
    pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].almID<s(0)(0)(0)>[&][12] = 230 ;
    pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].almID<s(0)(0)(0)>[&][13] = 231 ;




}

void
cah_em4_initVars<s(0)(0)(0)>[&] (CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] * pEntity<s(0)(0)(0)>[&], int chipNum<s(0)(0)(0)>[&])
{
    UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&],(D1:ulChip:0) ulPort<s(0)(0)(0)>[&];(D1:ulPort:0)

    for (ulChip<s(0)(0)(0)>[&] = 0; (int)ulChip<s(0)(0)(0)>[&] < chipNum<s(0)(0)(0)>[&]; ulChip<s(0)(0)(0)>[&]++)
    {
        for (ulPort<s(0)(0)(0)>[&] = 0; ulPort<s(0)(0)(0)>[&] < (63 ) ; ulPort<s(0)(0)(0)>[&]++)
        {
             


            pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].bPlmEnable<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]] = 0 ;
            pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].bTimEnable<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]] = 0 ;
            pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].bRestrainRDI<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]] = 0 ;
            pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].bBlockAis<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]] = 0 ;
            pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].adminState<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]] = PORT_STATE_UP<s(0)(0)(0)>[&];
            pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].faisMode<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]] =   0;
            pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].frdiMode<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]] = EM4_NONE_FORCE<s(0)(0)(0)>[&];
            pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].loopMode<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]] = PORT_LOOP_NONE<s(0)(0)(0)>[&];
            pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].portType<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]] = PDH_MODE_E1<s(0)(0)(0)>[&];
            memset<s(0)(0)(0)>[&]((INT1<s(0)(0)(0)>[T] *)( &pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].prbsCfg<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]] ), (  0 ), (  sizeof (EM4_PRBS_CONFIG_T<s(0)(0)(0)>[T]) )) ;
            pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].prbsCfg<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].prbsMode<s(0)(0)(0)>[&] = PRBS_MODE_NA<s(0)(0)(0)>[&];

             


            pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].strExpJ2<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].J2Mode<s(0)(0)(0)>[&] = PbTIModeType_modeFixedOneByte<s(0)(0)(0)>[&];
            pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].strTranJ2<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].J2Mode<s(0)(0)(0)>[&] = PbTIModeType_modeFixedOneByte<s(0)(0)(0)>[&];
            pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].strRcvJ2<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].J2Mode<s(0)(0)(0)>[&] = PbTIModeType_modeFixedOneByte<s(0)(0)(0)>[&];
            memset<s(0)(0)(0)>[&]((INT1<s(0)(0)(0)>[T] *)( pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].strExpJ2<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].J2Data<s(0)(0)(0)>[&] ), (  0 ), (  64  + 1 )) ;
            memset<s(0)(0)(0)>[&]((INT1<s(0)(0)(0)>[T] *)( pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].strTranJ2<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].J2Data<s(0)(0)(0)>[&] ), (  0 ), (  64  + 1 )) ;
            memset<s(0)(0)(0)>[&]((INT1<s(0)(0)(0)>[T] *)( pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].strRcvJ2<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].J2Data<s(0)(0)(0)>[&] ), (  0 ), (  64  + 1 )) ;

             


            pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].ExpPSL<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]] = 0;
            pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].RcvPSL<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]] = 0;
            pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].TranPSL<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]] = 0;

             


            pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].forceRptAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]] = 1 ;
            pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].ssf<s(0)(0)(0)>[&] = 0;
            pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].ssfFc<s(0)(0)(0)>[&] = 0;
            pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].rdi<s(0)(0)(0)>[&] = 0;
            pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].rfi<s(0)(0)(0)>[&] = 0;
            pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].rdiFc<s(0)(0)(0)>[&] = 0;
            pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].rfiFc<s(0)(0)(0)>[&] = 0;
            pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].e1rdiFc<s(0)(0)(0)>[&] = 0;

            cah_em4_InitAlmID<s(0)(0)(0)>[&] (pEntity<s(0)(0)(0)>[&], ulChip<s(0)(0)(0)>[&], ulPort<s(0)(0)(0)>[&]);
        }
    }
}

int
cah_em4_chkdwPos<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&])
{
    return 0;
}

int
cah_em4_chkId<s(0)(0)(0)>[&] (ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&])
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0x0000;

    u<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (cah_em4_getEntityBase<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&]), ((0x00 << 10) | 0x00) );
    if (0x8915  != u<s(0)(0)(0)>[&])
    {
        return 0;
    }
    else
    {
        return 1;
    }
}

 






















int
cah_em4_revise<s(0)(0)(0)>[&] (int isCall<s(0)(0)(0)>[&])
{
    E1_CALL<s(0)(0)(0)>[T] *ppp<s(0)(0)(0)>[&] =(D2) ((void *)0) , *ppp1<s(0)(0)(0)>[&] =(D2) ((void *)0) ;
	ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&] =(D2) 0;
    int fd<s(0)(0)(0)>[&] =(D2) 0;
    int j<s(0)(0)(0)>[&] =(D2) 0;

    fd<s(0)(0)(0)>[&] = cah_em4_ent2fd<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\n%s: entity(%d), fd(%d), isCall(%s)", __FUNCTION__<s(0)(0)(0)>[&], entity<s(0)(0)(0)>[&], fd<s(0)(0)(0)>[&],
            isCall<s(0)(0)(0)>[&] ? "CALL" : "CLEAR");
    if (((void *)0)  == pCahEm4Head<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]])
    {
        printf<s(0)(0)(0)>[&] ("\r\n%s, pointer NULL entity(%d)", __FUNCTION__<s(0)(0)(0)>[&], entity<s(0)(0)(0)>[&]);
        return (0);
    }

    ppp1<s(0)(0)(0)>[&] = pCahEm4Head<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]];

    for (;;)
    {
        ppp<s(0)(0)(0)>[&] = ppp1<s(0)(0)(0)>[&];
        if (1 == isCall<s(0)(0)(0)>[&])
        {
            if (((void *)0)  == ppp<s(0)(0)(0)>[&]->p<s(0)(0)(0)>[&])
            {
                printf<s(0)(0)(0)>[&] ("\r\npCahEm4Head[%d]->p NULL", fd<s(0)(0)(0)>[&]);
                break;
            }
            else
            {
                 
                if (5 == ppp<s(0)(0)(0)>[&]->sn<s(0)(0)(0)>[&] || 6 == ppp<s(0)(0)(0)>[&]->sn<s(0)(0)(0)>[&])
                {
                    (*(ppp<s(0)(0)(0)>[&]->p<s(0)(0)(0)>[&])) (ppp<s(0)(0)(0)>[&]->arg1<s(0)(0)(0)>[&], ppp<s(0)(0)(0)>[&]->arg3<s(0)(0)(0)>[&], ppp<s(0)(0)(0)>[&]->arg4<s(0)(0)(0)>[&].tti<s(0)(0)(0)>[&], ppp<s(0)(0)(0)>[&]->arg5<s(0)(0)(0)>[&], ppp<s(0)(0)(0)>[&]->arg6<s(0)(0)(0)>[&], ppp<s(0)(0)(0)>[&]->arg2<s(0)(0)(0)>[&]);
                }
                else
                {
                    (*(ppp<s(0)(0)(0)>[&]->p<s(0)(0)(0)>[&])) (ppp<s(0)(0)(0)>[&]->arg1<s(0)(0)(0)>[&], ppp<s(0)(0)(0)>[&]->arg3<s(0)(0)(0)>[&], ppp<s(0)(0)(0)>[&]->arg4<s(0)(0)(0)>[&].arg<s(0)(0)(0)>[&], ppp<s(0)(0)(0)>[&]->arg5<s(0)(0)(0)>[&], ppp<s(0)(0)(0)>[&]->arg6<s(0)(0)(0)>[&], ppp<s(0)(0)(0)>[&]->arg2<s(0)(0)(0)>[&]);
                }
            }
        }

        ppp1<s(0)(0)(0)>[&] = ppp1<s(0)(0)(0)>[&]->pNext<s(0)(0)(0)>[&];
        if (0 == isCall<s(0)(0)(0)>[&])
        {
            if (((void *)0)  == pCahEm4Head<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]]->pNext<s(0)(0)(0)>[&])
            {
                printf<s(0)(0)(0)>[&] ("\r\nEM4 link empty");
                break;
            }
            pCahEm4Head<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]] = pCahEm4Head<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]]->pNext<s(0)(0)(0)>[&];
            ppp<s(0)(0)(0)>[&]->pNext<s(0)(0)(0)>[&] = ((void *)0) ;
            free<s(0)(0)(0)>[&] (ppp<s(0)(0)(0)>[&]);
            ppp<s(0)(0)(0)>[&] = ((void *)0) ;
        }
        if (ppp1<s(0)(0)(0)>[&])
        {
            if (((void *)0)  == ppp1<s(0)(0)(0)>[&]->p<s(0)(0)(0)>[&])
            {
                printf<s(0)(0)(0)>[&] ("\r\nem4 link end!!!");
                if (0 == isCall<s(0)(0)(0)>[&])
                    for (j<s(0)(0)(0)>[&] = 0; j<s(0)(0)(0)>[&] < 11; j<s(0)(0)(0)>[&]++)
                    {
                        gpCahEm4HashHead<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]][j<s(0)(0)(0)>[&]] = &gCahEm4Head<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]];
                    }
                break;
            }
            if (((void *)0)  == ppp1<s(0)(0)(0)>[&]->pNext<s(0)(0)(0)>[&])
            {
                printf<s(0)(0)(0)>[&] ("\r\nEM4 link empty");
                if (0 == isCall<s(0)(0)(0)>[&])
                    for (j<s(0)(0)(0)>[&] = 0; j<s(0)(0)(0)>[&] < 11; j<s(0)(0)(0)>[&]++)
                    {
                        gpCahEm4HashHead<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]][j<s(0)(0)(0)>[&]] = &gCahEm4Head<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]];
                    }
                break;
            }
        }
        else
        {
            printf<s(0)(0)(0)>[&] ("\r\nlink end for NULL");
            if (0 == isCall<s(0)(0)(0)>[&])
                for (j<s(0)(0)(0)>[&] = 0; j<s(0)(0)(0)>[&] < 11; j<s(0)(0)(0)>[&]++)
                {
                    gpCahEm4HashHead<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]][j<s(0)(0)(0)>[&]] = &gCahEm4Head<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]];
                }
            break;
        }
    }

    return (0);
}



 


void
cah_em4_initLink<s(0)(0)(0)>[&] (void)
{
    int i<s(0)(0)(0)>[&] =(D2) 0, j<s(0)(0)(0)>[&] =(D2) 0;

    for (i<s(0)(0)(0)>[&] = 0; i<s(0)(0)(0)>[&] < ((1) ) ; i<s(0)(0)(0)>[&]++)
    {
        pCahEm4Head<s(0)(0)(0)>[&][i<s(0)(0)(0)>[&]] = &gCahEm4Head<s(0)(0)(0)>[&][i<s(0)(0)(0)>[&]];
        for (j<s(0)(0)(0)>[&] = 0; j<s(0)(0)(0)>[&] < 11; j<s(0)(0)(0)>[&]++)
        {
            gpCahEm4HashHead<s(0)(0)(0)>[&][i<s(0)(0)(0)>[&]][j<s(0)(0)(0)>[&]] = &gCahEm4Head<s(0)(0)(0)>[&][i<s(0)(0)(0)>[&]];
        }
        memset<s(0)(0)(0)>[&] (&gCahEm4Head<s(0)(0)(0)>[&][i<s(0)(0)(0)>[&]], 0, sizeof (E1_CALL<s(0)(0)(0)>[T]));
    }
}



 


int
cah_em4_registerCall<s(0)(0)(0)>[&] (PMyFun<s(0)(0)(0)>[T] pFun<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&], int arg4<s(0)(0)(0)>[&], int arg5<s(0)(0)(0)>[&], int sn<s(0)(0)(0)>[&], char *fname<s(0)(0)(0)>[&])
{
    E1_CALL<s(0)(0)(0)>[T] *p<s(0)(0)(0)>[&] =(D2) ((void *)0) , *pold<s(0)(0)(0)>[&] =(D2) ((void *)0) ;
    int fd<s(0)(0)(0)>[&] =(D2) 0;
    int hash<s(0)(0)(0)>[&] =(D2) 0;

    if (0 == gCahEm4LinkFlag<s(0)(0)(0)>[&])
    {
        cah_em4_initLink<s(0)(0)(0)>[&] ();
        gCahEm4LinkFlag<s(0)(0)(0)>[&] = 1;
    }
    fd<s(0)(0)(0)>[&] = cah_em4_ent2fd<s(0)(0)(0)>[&] (0);

if (1) return 0;

    pold<s(0)(0)(0)>[&] = ((void *)0) ;

    pold<s(0)(0)(0)>[&] = cah_em4_findCall2<s(0)(0)(0)>[&] (0, pFun<s(0)(0)(0)>[&], 0, 0, port<s(0)(0)(0)>[&], sn<s(0)(0)(0)>[&]);
    if (pold<s(0)(0)(0)>[&])
    {
        pold<s(0)(0)(0)>[&]->p<s(0)(0)(0)>[&] = pFun<s(0)(0)(0)>[&];
        pold<s(0)(0)(0)>[&]->arg1<s(0)(0)(0)>[&] = 0;
        pold<s(0)(0)(0)>[&]->arg2<s(0)(0)(0)>[&] = 0;
        pold<s(0)(0)(0)>[&]->arg3<s(0)(0)(0)>[&] = port<s(0)(0)(0)>[&];

         


        if (5 == sn<s(0)(0)(0)>[&] || 6 == sn<s(0)(0)(0)>[&])
        {
            memcpy<s(0)(0)(0)>[&] (pold<s(0)(0)(0)>[&]->arg4<s(0)(0)(0)>[&].tti<s(0)(0)(0)>[&], (unsigned char *) arg4<s(0)(0)(0)>[&], 16);
        }
        else
        {
            pold<s(0)(0)(0)>[&]->arg4<s(0)(0)(0)>[&].arg<s(0)(0)(0)>[&] = arg4<s(0)(0)(0)>[&];
        }
        pold<s(0)(0)(0)>[&]->arg5<s(0)(0)(0)>[&] = arg5<s(0)(0)(0)>[&];
        pold<s(0)(0)(0)>[&]->arg6<s(0)(0)(0)>[&] = arg5<s(0)(0)(0)>[&];
        pold<s(0)(0)(0)>[&]->sn<s(0)(0)(0)>[&] = sn<s(0)(0)(0)>[&];

        return (0);
    }

    if (((void *)0)  == (p<s(0)(0)(0)>[&] = (E1_CALL<s(0)(0)(0)>[T] *) malloc<s(0)(0)(0)>[&] (sizeof (E1_CALL<s(0)(0)(0)>[T]))))
    {
        printf<s(0)(0)(0)>[&] ("\r\n%s: malloc error", __FUNCTION__<s(0)(0)(0)>[&]);
        return (0);
    }
    p<s(0)(0)(0)>[&]->id<s(0)(0)(0)>[&] = pCahEm4Head<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]]->id<s(0)(0)(0)>[&] + 1;
    p<s(0)(0)(0)>[&]->p<s(0)(0)(0)>[&] = pFun<s(0)(0)(0)>[&];
    p<s(0)(0)(0)>[&]->arg1<s(0)(0)(0)>[&] = 0;
    p<s(0)(0)(0)>[&]->arg2<s(0)(0)(0)>[&] = 0;
    p<s(0)(0)(0)>[&]->arg3<s(0)(0)(0)>[&] = port<s(0)(0)(0)>[&];
    memcpy<s(0)(0)(0)>[&] (p<s(0)(0)(0)>[&]->fname<s(0)(0)(0)>[&], fname<s(0)(0)(0)>[&], strlen<s(0)(0)(0)>[&] (fname<s(0)(0)(0)>[&]));
    if (5 == sn<s(0)(0)(0)>[&] || 6 == sn<s(0)(0)(0)>[&])
    {
        memcpy<s(0)(0)(0)>[&] (p<s(0)(0)(0)>[&]->arg4<s(0)(0)(0)>[&].tti<s(0)(0)(0)>[&], (unsigned char *) arg4<s(0)(0)(0)>[&], 16);
    }
    else
    {
        p<s(0)(0)(0)>[&]->arg4<s(0)(0)(0)>[&].arg<s(0)(0)(0)>[&] = arg4<s(0)(0)(0)>[&];
    }
    p<s(0)(0)(0)>[&]->arg5<s(0)(0)(0)>[&] = arg5<s(0)(0)(0)>[&];
    p<s(0)(0)(0)>[&]->arg6<s(0)(0)(0)>[&] = arg5<s(0)(0)(0)>[&];
    p<s(0)(0)(0)>[&]->sn<s(0)(0)(0)>[&] = sn<s(0)(0)(0)>[&];

    p<s(0)(0)(0)>[&]->pNext<s(0)(0)(0)>[&] = pCahEm4Head<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]];
     
    hash<s(0)(0)(0)>[&] = cah_em4_hash<s(0)(0)(0)>[&] (sn<s(0)(0)(0)>[&]);
    p<s(0)(0)(0)>[&]->pHashNext<s(0)(0)(0)>[&][hash<s(0)(0)(0)>[&]] = gpCahEm4HashHead<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]][hash<s(0)(0)(0)>[&]];     
    pCahEm4Head<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]] = p<s(0)(0)(0)>[&];
    gpCahEm4HashHead<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]][hash<s(0)(0)(0)>[&]] = p<s(0)(0)(0)>[&];      

    return (0);
}




 


int
cahem4tree<s(0)(0)(0)>[&] (void)
{
    E1_CALL<s(0)(0)(0)>[T] *ppp<s(0)(0)(0)>[&] =(D2) ((void *)0) , *ppp1<s(0)(0)(0)>[&] =(D2) ((void *)0) ;
    int fd<s(0)(0)(0)>[&] =(D2) 0;
	ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&] =(D2) 0;

    if (((void *)0)  == cah_em4_getEntity<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&]))
    {
        printf<s(0)(0)(0)>[&] ("\r\nEnt(%d) NOT active", entity<s(0)(0)(0)>[&]);
        return (0);
    }

    fd<s(0)(0)(0)>[&] = cah_em4_ent2fd<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&]);
    if (((void *)0)  == pCahEm4Head<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]])
    {
        printf<s(0)(0)(0)>[&] ("\r\n%s, pointer NULL entity(%d)", __FUNCTION__<s(0)(0)(0)>[&], entity<s(0)(0)(0)>[&]);
        return (0);
    }

    ppp1<s(0)(0)(0)>[&] = pCahEm4Head<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]];

    for (;;)
    {
        ppp<s(0)(0)(0)>[&] = ppp1<s(0)(0)(0)>[&];
        if (1)
        {
            if (((void *)0)  == ppp<s(0)(0)(0)>[&]->p<s(0)(0)(0)>[&])
            {
                printf<s(0)(0)(0)>[&] ("\r\npCahEm4Head[%d]->p NULL", fd<s(0)(0)(0)>[&]);
                break;
            }
            else
            {
                 
                if (5 == ppp<s(0)(0)(0)>[&]->sn<s(0)(0)(0)>[&] || 6 == ppp<s(0)(0)(0)>[&]->sn<s(0)(0)(0)>[&])
                {
                    printf<s(0)(0)(0)>[&] ("\r\nid(%2d), arg3(%d), arg4(%d), sn(%3d), n(%s)",
                            ppp<s(0)(0)(0)>[&]->id<s(0)(0)(0)>[&], ppp<s(0)(0)(0)>[&]->arg3<s(0)(0)(0)>[&], ppp<s(0)(0)(0)>[&]->arg4<s(0)(0)(0)>[&].arg<s(0)(0)(0)>[&], ppp<s(0)(0)(0)>[&]->sn<s(0)(0)(0)>[&],
                            ppp<s(0)(0)(0)>[&]->fname<s(0)(0)(0)>[&]);
                }
                else
                {
                    printf<s(0)(0)(0)>[&] ("\r\nid(%2d), arg3(%d), arg4(%d), sn(%3d), n(%s)",
                            ppp<s(0)(0)(0)>[&]->id<s(0)(0)(0)>[&], ppp<s(0)(0)(0)>[&]->arg3<s(0)(0)(0)>[&], ppp<s(0)(0)(0)>[&]->arg4<s(0)(0)(0)>[&].arg<s(0)(0)(0)>[&], ppp<s(0)(0)(0)>[&]->sn<s(0)(0)(0)>[&],
                            ppp<s(0)(0)(0)>[&]->fname<s(0)(0)(0)>[&]);
                }
            }
        }

        ppp1<s(0)(0)(0)>[&] = ppp1<s(0)(0)(0)>[&]->pNext<s(0)(0)(0)>[&];
        if (0)
        {
            pCahEm4Head<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]] = pCahEm4Head<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]]->pNext<s(0)(0)(0)>[&];
            ppp<s(0)(0)(0)>[&]->pNext<s(0)(0)(0)>[&] = ((void *)0) ;
            free<s(0)(0)(0)>[&] (ppp<s(0)(0)(0)>[&]);
            ppp<s(0)(0)(0)>[&] = ((void *)0) ;
        }
        if (((void *)0)  == ppp1<s(0)(0)(0)>[&]->p<s(0)(0)(0)>[&])
        {
            printf<s(0)(0)(0)>[&] ("\r\nem4 link end!!!");
            break;
        }
    }

    return (0);
}




  










E1_CALL<s(0)(0)(0)>[T] *
cah_em4_findCall2<s(0)(0)(0)>[&] (ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], void *pfun<s(0)(0)(0)>[&], int arg1<s(0)(0)(0)>[&]   ,
                   int arg2<s(0)(0)(0)>[&]   ,
                   int arg3<s(0)(0)(0)>[&]   ,
                   int sn<s(0)(0)(0)>[&])
{
    E1_CALL<s(0)(0)(0)>[T] *ppp<s(0)(0)(0)>[&] =(D2) ((void *)0) , *ppp1<s(0)(0)(0)>[&] =(D2) ((void *)0) ;
    E1_CALL<s(0)(0)(0)>[T] *pr<s(0)(0)(0)>[&] =(D2) ((void *)0) ;
    int fd<s(0)(0)(0)>[&] =(D2) 0;
    int hash<s(0)(0)(0)>[&] =(D2) 0;
     

    if (((void *)0)  == cah_em4_getEntityPtr<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&]))
    {
        printf<s(0)(0)(0)>[&] ("\r\nEnt(%d) NOT active", entity<s(0)(0)(0)>[&]);
        return (((void *)0) );
    }

    hash<s(0)(0)(0)>[&] = cah_em4_hash<s(0)(0)(0)>[&] (sn<s(0)(0)(0)>[&]);

    fd<s(0)(0)(0)>[&] = cah_em4_ent2fd<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&]);
    if (((void *)0)  == gpCahEm4HashHead<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]][hash<s(0)(0)(0)>[&]])
    {
        printf<s(0)(0)(0)>[&] ("\r\n%s, pointer NULL entity(%d)", __FUNCTION__<s(0)(0)(0)>[&], entity<s(0)(0)(0)>[&]);
        return (((void *)0) );
    }

    ppp1<s(0)(0)(0)>[&] = gpCahEm4HashHead<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]][hash<s(0)(0)(0)>[&]];

    for (;;)
    {
        ppp<s(0)(0)(0)>[&] = ppp1<s(0)(0)(0)>[&];
        if (((void *)0)  == ppp<s(0)(0)(0)>[&]->p<s(0)(0)(0)>[&])
        {
            printf<s(0)(0)(0)>[&] ("\r\n%s(): pEm4HashHead[%d]->p NULL, func NOT found, first time!", __FUNCTION__<s(0)(0)(0)>[&], fd<s(0)(0)(0)>[&]);
            break;
        }
        else
        {
             


            if (ppp1<s(0)(0)(0)>[&]->p<s(0)(0)(0)>[&] == pfun<s(0)(0)(0)>[&] && ppp1<s(0)(0)(0)>[&]->sn<s(0)(0)(0)>[&] == sn<s(0)(0)(0)>[&] && ppp1<s(0)(0)(0)>[&]->arg1<s(0)(0)(0)>[&] == arg1<s(0)(0)(0)>[&] && ppp1<s(0)(0)(0)>[&]->arg2<s(0)(0)(0)>[&] == arg2<s(0)(0)(0)>[&]
                && ppp1<s(0)(0)(0)>[&]->arg3<s(0)(0)(0)>[&] == arg3<s(0)(0)(0)>[&])
            {
                 
                pr<s(0)(0)(0)>[&] = ppp1<s(0)(0)(0)>[&];
                cah_em4_trace<s(0)(0)(0)>[&] (4, "\r\n%s: GOT ent(%d:%d), su(%d), port(%d)", __FUNCTION__<s(0)(0)(0)>[&], entity<s(0)(0)(0)>[&],
                               arg1<s(0)(0)(0)>[&], arg2<s(0)(0)(0)>[&], arg3<s(0)(0)(0)>[&]);
                return (pr<s(0)(0)(0)>[&]);
            }

        }

        ppp1<s(0)(0)(0)>[&] = ppp1<s(0)(0)(0)>[&]->pHashNext<s(0)(0)(0)>[&][hash<s(0)(0)(0)>[&]];

        if (((void *)0)  == ppp1<s(0)(0)(0)>[&]->p<s(0)(0)(0)>[&])
        {
            break;
        }
    }

    return (((void *)0) );
}




  




int
cah_em4_hash<s(0)(0)(0)>[&] (int sn<s(0)(0)(0)>[&])
{
    int r<s(0)(0)(0)>[&] =(D2) 0;

    switch (sn<s(0)(0)(0)>[&])
    {
    case 4:
        r<s(0)(0)(0)>[&] = 0;
        break;
    case 2:
        r<s(0)(0)(0)>[&] = 1;
        break;
    case 8:
        r<s(0)(0)(0)>[&] = 2;
        break;
    case 6:
        r<s(0)(0)(0)>[&] = 3;
        break;
    case 99:
        r<s(0)(0)(0)>[&] = 4;
        break;
    case 1:
        r<s(0)(0)(0)>[&] = 5;
        break;
    case 5:
        r<s(0)(0)(0)>[&] = 6;
        break;
    case 9:
        r<s(0)(0)(0)>[&] = 7;
        break;
    case 111:
        r<s(0)(0)(0)>[&] = 8;
        break;

    case 25:
    case 26:
        r<s(0)(0)(0)>[&] = 9;
        break;

    default:
        r<s(0)(0)(0)>[&] = 9;
        break;
    }

    return (r<s(0)(0)(0)>[&]);
}


 


int
cahem4tree2<s(0)(0)(0)>[&] (int hash<s(0)(0)(0)>[&])
{
    E1_CALL<s(0)(0)(0)>[T] *ppp<s(0)(0)(0)>[&] =(D2) ((void *)0) , *ppp1<s(0)(0)(0)>[&] =(D2) ((void *)0) ;
    int fd<s(0)(0)(0)>[&] =(D2) 0;
	ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&] =(D2) 0;

    if (0 > hash<s(0)(0)(0)>[&] || 10 < hash<s(0)(0)(0)>[&])
    {
        printf<s(0)(0)(0)>[&] ("\r\nhash index error");
        return (0);
    }

    if (((void *)0)  == cah_em4_getEntity<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&]))
    {
        printf<s(0)(0)(0)>[&] ("\r\nEnt(%d) NOT active", entity<s(0)(0)(0)>[&]);
        return (0);
    }

    fd<s(0)(0)(0)>[&] = cah_em4_ent2fd<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&]);
    if (((void *)0)  == gpCahEm4HashHead<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]][hash<s(0)(0)(0)>[&]])
    {
        printf<s(0)(0)(0)>[&] ("\r\n%s, pointer NULL entity(%d)", __FUNCTION__<s(0)(0)(0)>[&], entity<s(0)(0)(0)>[&]);
        return (0);
    }

    ppp1<s(0)(0)(0)>[&] = gpCahEm4HashHead<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]][hash<s(0)(0)(0)>[&]];

    for (;;)
    {
        ppp<s(0)(0)(0)>[&] = ppp1<s(0)(0)(0)>[&];
        if (1)
        {
            if (((void *)0)  == ppp<s(0)(0)(0)>[&]->p<s(0)(0)(0)>[&])
            {
                printf<s(0)(0)(0)>[&] ("\r\ngpCahEm4HashHead[%d][%d]->p NULL", fd<s(0)(0)(0)>[&], hash<s(0)(0)(0)>[&]);
                break;
            }
            else
            {
                if (5 == ppp<s(0)(0)(0)>[&]->sn<s(0)(0)(0)>[&] || 6 == ppp<s(0)(0)(0)>[&]->sn<s(0)(0)(0)>[&])
                {
                    printf<s(0)(0)(0)>[&] ("\r\nid(%4d), arg3(%d), arg4(%d), sn(%3d),n(%s)",
                            ppp<s(0)(0)(0)>[&]->id<s(0)(0)(0)>[&], ppp<s(0)(0)(0)>[&]->arg3<s(0)(0)(0)>[&], ppp<s(0)(0)(0)>[&]->arg4<s(0)(0)(0)>[&].arg<s(0)(0)(0)>[&], ppp<s(0)(0)(0)>[&]->sn<s(0)(0)(0)>[&],
                            ppp<s(0)(0)(0)>[&]->fname<s(0)(0)(0)>[&]);
                }
                else
                {
                    printf<s(0)(0)(0)>[&] ("\r\nid(%4d), arg3(%d), arg4(%d), sn(%3d),n(%s)",
                            ppp<s(0)(0)(0)>[&]->id<s(0)(0)(0)>[&], ppp<s(0)(0)(0)>[&]->arg3<s(0)(0)(0)>[&], ppp<s(0)(0)(0)>[&]->arg4<s(0)(0)(0)>[&].arg<s(0)(0)(0)>[&], ppp<s(0)(0)(0)>[&]->sn<s(0)(0)(0)>[&],
                            ppp<s(0)(0)(0)>[&]->fname<s(0)(0)(0)>[&]);
                }
            }
        }

        ppp1<s(0)(0)(0)>[&] = ppp1<s(0)(0)(0)>[&]->pHashNext<s(0)(0)(0)>[&][hash<s(0)(0)(0)>[&]];
        if (0)
        {
            gpCahEm4HashHead<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]][hash<s(0)(0)(0)>[&]] = gpCahEm4HashHead<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]][hash<s(0)(0)(0)>[&]]->pHashNext<s(0)(0)(0)>[&][hash<s(0)(0)(0)>[&]];
            ppp<s(0)(0)(0)>[&]->pNext<s(0)(0)(0)>[&] = ((void *)0) ;
            free<s(0)(0)(0)>[&] (ppp<s(0)(0)(0)>[&]);
            ppp<s(0)(0)(0)>[&] = ((void *)0) ;
        }
        if (((void *)0)  == ppp1<s(0)(0)(0)>[&]->p<s(0)(0)(0)>[&])
        {
            printf<s(0)(0)(0)>[&] ("\r\nem4 link end!!!");
            break;
        }
    }

    return (0);
}

int em4GetPrbsStateTest<s(0)(0)(0)>[&] (int port<s(0)(0)(0)>[&])
{
    BOOL<s(0)(0)(0)>[T] s<s(0)(0)(0)>[&] =(D2) 0 ;
    DWORD<s(0)(0)(0)>[T] cnt<s(0)(0)(0)>[&] =(D2) 0;

    {if (125 <  port<s(0)(0)(0)>[&] ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  port<s(0)(0)(0)>[&] ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;

    CAH_EM4_GetPrbsState<s(0)(0)(0)>[&] (0, port<s(0)(0)(0)>[&], &s<s(0)(0)(0)>[&]);
    CAH_EM4_GetPrbsErrCount<s(0)(0)(0)>[&] (0, port<s(0)(0)(0)>[&], &cnt<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\n%s(): status (%d), cnt(%d)", __FUNCTION__<s(0)(0)(0)>[&], s<s(0)(0)(0)>[&], cnt<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\n");

    return 0;
}


WORD<s(0)(0)(0)>[T]
CAH_EM4_GetPrbsState<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] * bPrbsSucc<s(0)(0)(0)>[&])
{
    void *base<s(0)(0)(0)>[&] =(D2) (void *) 0;
    short u<s(0)(0)(0)>[&] =(D2) 0;
    int port<s(0)(0)(0)>[&] =(D2) SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]);

	{if (125 <  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;
	port<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&])) - 1;
    base<s(0)(0)(0)>[&] = cah_em4_getEntityBase<s(0)(0)(0)>[&] (0, SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]));
    cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x05 << 10) | 0x20 , port<s(0)(0)(0)>[&] & 0x003f);
    taskDelay<s(0)(0)(0)>[&] (sysClkRateGet<s(0)(0)(0)>[&] () / 10);
    u<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x05 << 10) | 0x20 );
	*bPrbsSucc<s(0)(0)(0)>[&] = ((u<s(0)(0)(0)>[&] & 0x8000) ? 1 : 0);

    return ((WORD<s(0)(0)(0)>[T])0x0) ;
}

void
cah_em4_getprbsname<s(0)(0)(0)>[&] (int tempStatus<s(0)(0)(0)>[&], char *almType<s(0)(0)(0)>[&])
{
    switch (tempStatus<s(0)(0)(0)>[&])
    {
    case PRBS_STATUS_NA<s(0)(0)(0)>[&]:
        (((char*) almType<s(0)(0)(0)>[&] )[((int)(  4 + 1 ) <= 0) ? 0 : (  4 + 1 )-1] = '\0', strncpy<s(0)(0)(0)>[&]( almType<s(0)(0)(0)>[&] ,   "NONE" , ((int)(  4 + 1 ) <= 0) ? 0 : (  4 + 1 )-1)) ;
        break;
    case PRBS_STATUS_SYNCING<s(0)(0)(0)>[&]:
        (((char*) almType<s(0)(0)(0)>[&] )[((int)(  7 + 1 ) <= 0) ? 0 : (  7 + 1 )-1] = '\0', strncpy<s(0)(0)(0)>[&]( almType<s(0)(0)(0)>[&] ,   "SYNCING" , ((int)(  7 + 1 ) <= 0) ? 0 : (  7 + 1 )-1)) ;
        break;
    case PRBS_STATUS_SYNC_SUCC<s(0)(0)(0)>[&]:
        (((char*) almType<s(0)(0)(0)>[&] )[((int)(  4 + 1 ) <= 0) ? 0 : (  4 + 1 )-1] = '\0', strncpy<s(0)(0)(0)>[&]( almType<s(0)(0)(0)>[&] ,   "SUCC" , ((int)(  4 + 1 ) <= 0) ? 0 : (  4 + 1 )-1)) ;
        break;
    case PRBS_STATUS_SYNC_FAIL<s(0)(0)(0)>[&]:
        (((char*) almType<s(0)(0)(0)>[&] )[((int)(  4 + 1 ) <= 0) ? 0 : (  4 + 1 )-1] = '\0', strncpy<s(0)(0)(0)>[&]( almType<s(0)(0)(0)>[&] ,   "FAIL" , ((int)(  4 + 1 ) <= 0) ? 0 : (  4 + 1 )-1)) ;
        break;
    case PRBS_STATUS_SYNC_ERROR<s(0)(0)(0)>[&]:
        (((char*) almType<s(0)(0)(0)>[&] )[((int)(  7 + 1 ) <= 0) ? 0 : (  7 + 1 )-1] = '\0', strncpy<s(0)(0)(0)>[&]( almType<s(0)(0)(0)>[&] ,   "SYNCERR" , ((int)(  7 + 1 ) <= 0) ? 0 : (  7 + 1 )-1)) ;
        break;
    default:
        (((char*) almType<s(0)(0)(0)>[&] )[((int)(  7 + 1 ) <= 0) ? 0 : (  7 + 1 )-1] = '\0', strncpy<s(0)(0)(0)>[&]( almType<s(0)(0)(0)>[&] ,   "UNKNOWN" , ((int)(  7 + 1 ) <= 0) ? 0 : (  7 + 1 )-1)) ;
        break;
    }

}



 








 








int
cah_em4_pohWrite<s(0)(0)(0)>[&] (void *base<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&], unsigned short reg<s(0)(0)(0)>[&], unsigned short val<s(0)(0)(0)>[&])
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0x0000;

    u<s(0)(0)(0)>[&] |= (port<s(0)(0)(0)>[&] << 8);
    u<s(0)(0)(0)>[&] |= reg<s(0)(0)(0)>[&];
    u<s(0)(0)(0)>[&] |= 0x8000;                 
    u<s(0)(0)(0)>[&] |= 0x4000;                 

    cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x02 << 10) | 0x02 , val<s(0)(0)(0)>[&]);
    cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 , u<s(0)(0)(0)>[&]);
    cah_em4_pollBit<s(0)(0)(0)>[&] ((unsigned short *) base<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 );

    return ((WORD<s(0)(0)(0)>[T])0x0) ;
}

 





unsigned short
cah_em4_pohRead<s(0)(0)(0)>[&] (void *base<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&], unsigned short reg<s(0)(0)(0)>[&])
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0x0000;
    unsigned short result<s(0)(0)(0)>[&] =(D2) 0x00000;

    u<s(0)(0)(0)>[&] |= (port<s(0)(0)(0)>[&] << 8);
    u<s(0)(0)(0)>[&] |= reg<s(0)(0)(0)>[&];
    u<s(0)(0)(0)>[&] |= 0x8000;                 
    u<s(0)(0)(0)>[&] |= 0x0000;                 

    cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 , u<s(0)(0)(0)>[&]);
    cah_em4_pollBit<s(0)(0)(0)>[&] ((unsigned short *) base<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 );
    result<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x02 << 10) | 0x03 );

    return (result<s(0)(0)(0)>[&]);
}

 



unsigned short
cah_em4_readDemapper<s(0)(0)(0)>[&] (void *base<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&], unsigned short reg<s(0)(0)(0)>[&])
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0x0000;
    unsigned short result<s(0)(0)(0)>[&] =(D2) 0x00000;

    u<s(0)(0)(0)>[&] |= (port<s(0)(0)(0)>[&]);
    u<s(0)(0)(0)>[&] |= 0x8000;                 

    cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x05 << 10) | 0x01 , u<s(0)(0)(0)>[&]);
    cah_em4_pollBitDmapper<s(0)(0)(0)>[&] ((unsigned short *) base<s(0)(0)(0)>[&], (0x05 << 10) | 0x01 );
    result<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], reg<s(0)(0)(0)>[&]);

    return (result<s(0)(0)(0)>[&]);
}

 




CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *
cah_em4_getEntity<s(0)(0)(0)>[&] (ENTITY_T<s(0)(0)(0)>[T] ent<s(0)(0)(0)>[&])
{
    int i<s(0)(0)(0)>[&] =(D2) 0;
    CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *p<s(0)(0)(0)>[&] =(D2) (CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *) 0;

    i<s(0)(0)(0)>[&] = 0;
    p<s(0)(0)(0)>[&] = gppCahEm4CfgVar<s(0)(0)(0)>[&][i<s(0)(0)(0)>[&]];

    return p<s(0)(0)(0)>[&];
}

 





void *
cah_em4_getEntityBase<s(0)(0)(0)>[&] (ENTITY_T<s(0)(0)(0)>[T] ent<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&])
{
    CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *p<s(0)(0)(0)>[&] =(D2) (CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *) 0;
    void *base<s(0)(0)(0)>[&] =(D2) 0x0000;

    p<s(0)(0)(0)>[&] = cah_em4_getEntity<s(0)(0)(0)>[&] (ent<s(0)(0)(0)>[&]);
    base<s(0)(0)(0)>[&] = (void *) p<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][cah_em4_port2chip<s(0)(0)(0)>[&] (port<s(0)(0)(0)>[&]) - 1].cfg<s(0)(0)(0)>[&].baseAddr<s(0)(0)(0)>[&];

    return base<s(0)(0)(0)>[&];
}

 


CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *
cah_em4_OpenEx<s(0)(0)(0)>[&] (void)
{
    int memSize<s(0)(0)(0)>[&] =(D2) 0;
    CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *p<s(0)(0)(0)>[&] =(D2) ((void *)0) ;

     





	if (((void *)0)  != gppCahEm4CfgVar<s(0)(0)(0)>[&][0])
	{
		printf<s(0)(0)(0)>[&] ("\r\n%s(): gppCahEm4CfgVar[0](%p) NOT NULL !!!", __FUNCTION__<s(0)(0)(0)>[&], gppCahEm4CfgVar<s(0)(0)(0)>[&][0]);
		return ((void *)0) ;
	}

    memSize<s(0)(0)(0)>[&] = (sizeof (CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T]) + sizeof (EM4_CHIP_VAR_T<s(0)(0)(0)>[T]) * 1) * 2;

    p<s(0)(0)(0)>[&] = (CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *) malloc<s(0)(0)(0)>[&]( memSize<s(0)(0)(0)>[&] ); ;
    if (!p<s(0)(0)(0)>[&])
    {
        printf<s(0)(0)(0)>[&] ("\r\n%s():\tFD malloc failed !!!!!!", __FUNCTION__<s(0)(0)(0)>[&]);
        return ((void *)0) ;
    }








    gppCahEm4CfgVar<s(0)(0)(0)>[&][0] = p<s(0)(0)(0)>[&];      
    memset<s(0)(0)(0)>[&]((INT1<s(0)(0)(0)>[T] *)( p<s(0)(0)(0)>[&] ), (  0x00 ), (  memSize<s(0)(0)(0)>[&] )) ;

    return p<s(0)(0)(0)>[&];
}


int
cah_em4_ent2fd<s(0)(0)(0)>[&] (ENTITY_T<s(0)(0)(0)>[T] ent<s(0)(0)(0)>[&])
{
    int i<s(0)(0)(0)>[&] =(D2) 0;

    return (i<s(0)(0)(0)>[&]);
}


CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *
cah_em4_fd2entptr<s(0)(0)(0)>[&] (int fd<s(0)(0)(0)>[&])
{
    return gppCahEm4CfgVar<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]];
}

int
cah_em4_fd2ent<s(0)(0)(0)>[&] (int fd<s(0)(0)(0)>[&])
{
    return (gppCahEm4CfgVar<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]]->entity<s(0)(0)(0)>[&]);
}

CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *
cah_em4_getEntityPtr<s(0)(0)(0)>[&] (ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&])
{
    return cah_em4_getEntity<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&]);
}




 





int
cah_em4_ent2Id<s(0)(0)(0)>[&] (ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&])
{
    int id<s(0)(0)(0)>[&] =(D2) 0;

    if (((void *)0)  == g_pTransFunc<s(0)(0)(0)>[&])
    {
        printf<s(0)(0)(0)>[&] ("\r\n%s:KEY translation function not registered!!!", __FUNCTION__<s(0)(0)(0)>[&]);
        return -1;
    }

    id<s(0)(0)(0)>[&] = (*g_pTransFunc<s(0)(0)(0)>[&]) (entity<s(0)(0)(0)>[&]);

    return id<s(0)(0)(0)>[&];
}




void
em4Mi<s(0)(0)(0)>[&] (void)
{
    int fd<s(0)(0)(0)>[&] =(D2) 0;

    for (fd<s(0)(0)(0)>[&] = 0; fd<s(0)(0)(0)>[&] < (((1) ) ); fd<s(0)(0)(0)>[&]++)
    {
        printf<s(0)(0)(0)>[&] ("\r\nfd(%2d) m-base(%p), status(%6s), liu-base(%p)",
                fd<s(0)(0)(0)>[&], cah_em4_getEntityBase<s(0)(0)(0)>[&] (cah_em4_fd2ent<s(0)(0)(0)>[&] (fd<s(0)(0)(0)>[&]), 1),
                (eEm4EntAct<s(0)(0)(0)>[&] == gppCahEm4CfgVar<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]]->state<s(0)(0)(0)>[&]) ? "ACTIVE" : (eEm4EntInit<s(0)(0)(0)>[&] ==
                                                                         gppCahEm4CfgVar<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]]->
                                                                         state<s(0)(0)(0)>[&] ? "INIT" : "IDLE"),
                (void *) 0xffff   );
    }
    printf<s(0)(0)(0)>[&] ("\r\n");
}




void
cah_em4Info<s(0)(0)(0)>[&] (void)
{
    int i<s(0)(0)(0)>[&] =(D2) 0;
    UINT32<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&];(D1:entity:0)
    CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *pEntity<s(0)(0)(0)>[&];(D1:pEntity:0)

    for (i<s(0)(0)(0)>[&] = 0; i<s(0)(0)(0)>[&] < ((1) ) ; i<s(0)(0)(0)>[&]++)
    {
        if (gppCahEm4CfgVar<s(0)(0)(0)>[&][i<s(0)(0)(0)>[&]] == ((void *)0) )
        {
            continue;
        }

         
        if (gppCahEm4CfgVar<s(0)(0)(0)>[&][i<s(0)(0)(0)>[&]]->state<s(0)(0)(0)>[&] != eEm4EntAct<s(0)(0)(0)>[&])
        {
            continue;
        }

        entity<s(0)(0)(0)>[&] = gppCahEm4CfgVar<s(0)(0)(0)>[&][i<s(0)(0)(0)>[&]]->entity<s(0)(0)(0)>[&];

        pEntity<s(0)(0)(0)>[&] = cah_em4_getEntityPtr<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&]);

        printf<s(0)(0)(0)>[&] ("\r\nentity(%d), base(0x%x)", entity<s(0)(0)(0)>[&], pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][0].cfg<s(0)(0)(0)>[&].baseAddr<s(0)(0)(0)>[&]);
    }

    printf<s(0)(0)(0)>[&] ("\r\n");
}


void
em4AllInLoop<s(0)(0)(0)>[&] (int flag<s(0)(0)(0)>[&])
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0x0000;
	int ent<s(0)(0)(0)>[&] =(D2) 0;

    if (((void *)0)  == cah_em4_getEntity<s(0)(0)(0)>[&] (ent<s(0)(0)(0)>[&]))
    {
        printf<s(0)(0)(0)>[&] ("\r\nent(%d) NOT active", ent<s(0)(0)(0)>[&]);
        return;
    }


    u<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (cah_em4_getEntityBase<s(0)(0)(0)>[&] (ent<s(0)(0)(0)>[&], 1), (((0x00 << 10) | 0x01)) );
    if (flag<s(0)(0)(0)>[&])
    {
        u<s(0)(0)(0)>[&] |= 0x0002;
    }
    else
    {
        u<s(0)(0)(0)>[&] &= ~0x0002;
    }

    cah_em4_wr<s(0)(0)(0)>[&] (cah_em4_getEntityBase<s(0)(0)(0)>[&] (ent<s(0)(0)(0)>[&], 1), (((0x00 << 10) | 0x01)) , u<s(0)(0)(0)>[&]);
    u<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (cah_em4_getEntityBase<s(0)(0)(0)>[&] (ent<s(0)(0)(0)>[&], 100), (((0x00 << 10) | 0x01)) );
    if (flag<s(0)(0)(0)>[&])
    {
        u<s(0)(0)(0)>[&] |= 0x0002;
    }
    else
    {
        u<s(0)(0)(0)>[&] &= ~0x0002;
    }

    cah_em4_wr<s(0)(0)(0)>[&] (cah_em4_getEntityBase<s(0)(0)(0)>[&] (ent<s(0)(0)(0)>[&], 100), (((0x00 << 10) | 0x01)) , u<s(0)(0)(0)>[&]);
}


int
em4ShowIntMask<s(0)(0)(0)>[&] (int ulPort<s(0)(0)(0)>[&])
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0x0000, uu<s(0)(0)(0)>[&] =(D2) 0;
	int port<s(0)(0)(0)>[&] =(D2) 0;

	{if (125 <  ulPort<s(0)(0)(0)>[&] ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  ulPort<s(0)(0)(0)>[&] ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;
	port<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (ulPort<s(0)(0)(0)>[&]) - 1;
    u<s(0)(0)(0)>[&] = 	cah_em4_pohRead<s(0)(0)(0)>[&] ((void *)(0x50000000) , port<s(0)(0)(0)>[&], 0x00 );
    uu<s(0)(0)(0)>[&] = 	cah_em4_pohRead<s(0)(0)(0)>[&] ((void *)(0x60000000) , port<s(0)(0)(0)>[&], 0x00 );
    printf<s(0)(0)(0)>[&] ("\r\nbase\t(%p)(%p)", (void *)(0x50000000) , (void *)(0x60000000) );
    printf<s(0)(0)(0)>[&] ("\r\nssf\t(%s)(%s), ", 	u<s(0)(0)(0)>[&] & 0x4000 ? "ENABLE" : "DISABLE", 
									uu<s(0)(0)(0)>[&] & 0x4000 ? "ENABLE" : "DISABLE");
    printf<s(0)(0)(0)>[&] ("\r\nerdi\t(%s)(%s), ", u<s(0)(0)(0)>[&] & 0x0200 ? "ENABLE" : "DISABLE", 
									uu<s(0)(0)(0)>[&] & 0x0200 ? "ENABLE" : "DISABLE");
    printf<s(0)(0)(0)>[&] ("\r\ntsl\t(%s)(%s), ", 	u<s(0)(0)(0)>[&] & 0x0100 ? "ENABLE" : "DISABLE", 
									uu<s(0)(0)(0)>[&] & 0x0100 ? "ENABLE" : "DISABLE");
    printf<s(0)(0)(0)>[&] ("\r\ntti\t(%s)(%s), ", 	u<s(0)(0)(0)>[&] & 0x0080 ? "ENABLE" : "DISABLE", 
									uu<s(0)(0)(0)>[&] & 0x0080 ? "ENABLE" : "DISABLE");
    printf<s(0)(0)(0)>[&] ("\r\nsf\t(%s)(%s), ", 	u<s(0)(0)(0)>[&] & 0x0040 ? "ENABLE" : "DISABLE", 
									uu<s(0)(0)(0)>[&] & 0x0040 ? "ENABLE" : "DISABLE");
    printf<s(0)(0)(0)>[&] ("\r\nsd\t(%s)(%s), ", 	u<s(0)(0)(0)>[&] & 0x0020 ? "ENABLE" : "DISABLE", 
									uu<s(0)(0)(0)>[&] & 0x0020 ? "ENABLE" : "DISABLE");
    printf<s(0)(0)(0)>[&] ("\r\nrdi\t(%s)(%s), ", 	u<s(0)(0)(0)>[&] & 0x0010 ? "ENABLE" : "DISABLE", 
									uu<s(0)(0)(0)>[&] & 0x0010 ? "ENABLE" : "DISABLE");
    printf<s(0)(0)(0)>[&] ("\r\nuneq\t(%s)(%s), ", u<s(0)(0)(0)>[&] & 0x0008 ? "ENABLE" : "DISABLE", 
									uu<s(0)(0)(0)>[&] & 0x0008 ? "ENABLE" : "DISABLE");
    printf<s(0)(0)(0)>[&] ("\r\nplm\t(%s)(%s), ", 	u<s(0)(0)(0)>[&] & 0x0004 ? "ENABLE" : "DISABLE", 
									uu<s(0)(0)(0)>[&] & 0x0004 ? "ENABLE" : "DISABLE");
    printf<s(0)(0)(0)>[&] ("\r\ntiu\t(%s)(%s), ", 	u<s(0)(0)(0)>[&] & 0x0002 ? "ENABLE" : "DISABLE", 
									uu<s(0)(0)(0)>[&] & 0x0002 ? "ENABLE" : "DISABLE");
    printf<s(0)(0)(0)>[&] ("\r\ntim\t(%s)(%s)", 	u<s(0)(0)(0)>[&] & 0x0001 ? "ENABLE" : "DISABLE", 
									uu<s(0)(0)(0)>[&] & 0x0001 ? "ENABLE" : "DISABLE");
    printf<s(0)(0)(0)>[&] ("\r\n");
	return 0;
}



int
em4ShowCons<s(0)(0)(0)>[&] (int port<s(0)(0)(0)>[&])
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0x0000, uu<s(0)(0)(0)>[&] =(D2) 0;
	int ulPort<s(0)(0)(0)>[&] =(D2) 0;

	{if (125 <  port<s(0)(0)(0)>[&] ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  port<s(0)(0)(0)>[&] ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;
	ulPort<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (port<s(0)(0)(0)>[&]) - 1;
    u<s(0)(0)(0)>[&] = cah_em4_pohRead<s(0)(0)(0)>[&] ((void *) (0x50000000) , ulPort<s(0)(0)(0)>[&], 0x01 );
    uu<s(0)(0)(0)>[&] = cah_em4_pohRead<s(0)(0)(0)>[&] ((void *) (0x60000000) , ulPort<s(0)(0)(0)>[&], 0x01 );
    printf<s(0)(0)(0)>[&] ("\r\nbase       (%x)(%x)", (0x50000000) , (0x60000000) );
    printf<s(0)(0)(0)>[&] ("\r\nuneqrdi    (%s)(%s), ", u<s(0)(0)(0)>[&] & 0x0080 ? "ON" : "OFF", uu<s(0)(0)(0)>[&] & 0x0080 ? "ON" : "OFF");
    printf<s(0)(0)(0)>[&] ("\r\nplmrdi     (%s)(%s), ", u<s(0)(0)(0)>[&] & 0x0040 ? "ON" : "OFF", uu<s(0)(0)(0)>[&] & 0x0040 ? "ON" : "OFF");
    printf<s(0)(0)(0)>[&] ("\r\nuneqais    (%s)(%s), ", u<s(0)(0)(0)>[&] & 0x0020 ? "ON" : "OFF", uu<s(0)(0)(0)>[&] & 0x0020 ? "ON" : "OFF");
    printf<s(0)(0)(0)>[&] ("\r\nplmais     (%s)(%s), ", u<s(0)(0)(0)>[&] & 0x0010 ? "ON" : "OFF", uu<s(0)(0)(0)>[&] & 0x0010 ? "ON" : "OFF");
    printf<s(0)(0)(0)>[&] ("\r\ntimrdi     (%s)(%s), ", u<s(0)(0)(0)>[&] & 0x0008 ? "ON" : "OFF", uu<s(0)(0)(0)>[&] & 0x0008 ? "ON" : "OFF");
    printf<s(0)(0)(0)>[&] ("\r\ntimais     (%s)(%s), ", u<s(0)(0)(0)>[&] & 0x0004 ? "ON" : "OFF", uu<s(0)(0)(0)>[&] & 0x0004 ? "ON" : "OFF");
    printf<s(0)(0)(0)>[&] ("\r\nttimode    (%s)(%s), ", u<s(0)(0)(0)>[&] & 0x0001 ? "1-BYTEMODE" : "16-BYTEMODE", uu<s(0)(0)(0)>[&] & 0x0001 ? "1-BYTEMODE" : "16-BYTEMODE");
    printf<s(0)(0)(0)>[&] ("\r\n");
	return 0;
}



int
cah_em4_trace<s(0)(0)(0)>[&] (int level<s(0)(0)(0)>[&], char *msg<s(0)(0)(0)>[&], ...)
{
    va_list<s(0)(0)(0)>[T] argptr<s(0)(0)(0)>[&];(D1:argptr:0)
    int cnt<s(0)(0)(0)>[&] =(D2) 0;

    if (level<s(0)(0)(0)>[&] == gCahEm4DebugLevel<s(0)(0)(0)>[&])
    {
        printf<s(0)(0)(0)>[&] ("\r\n");
        (__builtin_next_arg<s(0)(0)(0)>[&] (  msg<s(0)(0)(0)>[&] ), __builtin_memcpy<s(0)(0)(0)>[&] ((  argptr<s(0)(0)(0)>[&]  ), __builtin_saveregs<s(0)(0)(0)>[&] (), sizeof(__gnuc_va_list<s(0)(0)(0)>[T])) ) ;
        cnt<s(0)(0)(0)>[&] = vprintf<s(0)(0)(0)>[&] (msg<s(0)(0)(0)>[&], argptr<s(0)(0)(0)>[&]);
        ((void)0) ;
    }

    return (cnt<s(0)(0)(0)>[&]);
}


int
em4ShowEnable<s(0)(0)(0)>[&] (int ulPort<s(0)(0)(0)>[&])
{
    int ent<s(0)(0)(0)>[&] =(D2) 0;
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0x0000, uu<s(0)(0)(0)>[&],(D1:uu:0) u1<s(0)(0)(0)>[&] =(D2) 0, u0<s(0)(0)(0)>[&] =(D2) 0;
	int port<s(0)(0)(0)>[&] =(D2) cah_em4_mapPort<s(0)(0)(0)>[&] (ulPort<s(0)(0)(0)>[&]) - 1;

	{if (125 <  ulPort<s(0)(0)(0)>[&] ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  ulPort<s(0)(0)(0)>[&] ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;
    u1<s(0)(0)(0)>[&] = em4MapRd<s(0)(0)(0)>[&] (5, 0x100 + port<s(0)(0)(0)>[&], &u0<s(0)(0)(0)>[&], &u1<s(0)(0)(0)>[&]);

    cah_em4_wr<s(0)(0)(0)>[&] ((void *) (0x50000000) , (0x04 << 10) | 0x30 , port<s(0)(0)(0)>[&]);
    u<s(0)(0)(0)>[&] = em4Map1Rd<s(0)(0)(0)>[&] (4, 0x40);

    cah_em4_wr<s(0)(0)(0)>[&] ((void *) (0x60000000) , (0x04 << 10) | 0x30 , port<s(0)(0)(0)>[&]);
    uu<s(0)(0)(0)>[&] = em4Map2Rd<s(0)(0)(0)>[&] (4, 0x40);
    printf<s(0)(0)(0)>[&] ("\r\nentity(%d), port(%d), u(%x), uu(%x)", ent<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&], u<s(0)(0)(0)>[&], uu<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\nrdi_force     (%d)(%d)", u<s(0)(0)(0)>[&] & 0x0001 ? 1 : 0, uu<s(0)(0)(0)>[&] & 0x0001 ? 1 : 0);
    printf<s(0)(0)(0)>[&] ("\r\nrdi_en        (%d)(%d)", u<s(0)(0)(0)>[&] & 0x0002 ? 1 : 0, uu<s(0)(0)(0)>[&] & 0x0002 ? 1 : 0);
    printf<s(0)(0)(0)>[&] ("\r\nrei_force     (%d)(%d)", u<s(0)(0)(0)>[&] & 0x0040 ? 1 : 0, uu<s(0)(0)(0)>[&] & 0x0040 ? 1 : 0);
    printf<s(0)(0)(0)>[&] ("\r\nrei_en        (%d)(%d)", u<s(0)(0)(0)>[&] & 0x0080 ? 1 : 0, uu<s(0)(0)(0)>[&] & 0x0080 ? 1 : 0);
    printf<s(0)(0)(0)>[&] ("\r\nbip2_disable  (%d)(%d)", u<s(0)(0)(0)>[&] & 0x0100 ? 1 : 0, uu<s(0)(0)(0)>[&] & 0x0100 ? 1 : 0);
    printf<s(0)(0)(0)>[&] ("\r\nerdi_en       (%d)(%d)", u<s(0)(0)(0)>[&] & 0x0200 ? 1 : 0, uu<s(0)(0)(0)>[&] & 0x0200 ? 1 : 0);
    printf<s(0)(0)(0)>[&] ("\r\nerdi_force    (%d)(%d)", u<s(0)(0)(0)>[&] & 0x0400 ? 1 : 0, uu<s(0)(0)(0)>[&] & 0x0400 ? 1 : 0);
    printf<s(0)(0)(0)>[&] ("\r\ntu12_aisforce (%d)(%d)", u<s(0)(0)(0)>[&] & 0x8000 ? 1 : 0, uu<s(0)(0)(0)>[&] & 0x8000 ? 1 : 0);
    printf<s(0)(0)(0)>[&] ("\r\nrfi[force]    (%d)(%d)", u<s(0)(0)(0)>[&] & 0x0020 ? 1 : 0, uu<s(0)(0)(0)>[&] & 0x0020 ? 1 : 0);
    printf<s(0)(0)(0)>[&] ("\r\nretiming      (%d)(%d)", u0<s(0)(0)(0)>[&] & 0x0001 ? 1 : 0, u1<s(0)(0)(0)>[&] & 0x0001 ? 1 : 0);
    printf<s(0)(0)(0)>[&] ("\r\n");

	return 0;
}


void
em4ShowJ2Acc<s(0)(0)(0)>[&] (int ent<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&])
{
    int i<s(0)(0)(0)>[&] =(D2) 0;
    void *baseaddr<s(0)(0)(0)>[&] =(D2) (void *) 0;
    unsigned char j2exp<s(0)(0)(0)>[&][66];(D1:j2exp:0)

    if (((void *)0)  == cah_em4_getEntity<s(0)(0)(0)>[&] (ent<s(0)(0)(0)>[&]))
    {
        printf<s(0)(0)(0)>[&] ("\r\nEnt(%d) NOT active", ent<s(0)(0)(0)>[&]);
        return;
    }

    baseaddr<s(0)(0)(0)>[&] = cah_em4_getEntityBase<s(0)(0)(0)>[&] (ent<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&]);

    cah_em4_getJ2Acc<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&], j2exp<s(0)(0)(0)>[&]);

    printf<s(0)(0)(0)>[&] ("\r\nj2: entity(%d), port(%d)", ent<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&]);
    for (i<s(0)(0)(0)>[&] = 0; i<s(0)(0)(0)>[&] <= 15; i<s(0)(0)(0)>[&]++)
    {
        printf<s(0)(0)(0)>[&] ("\r\nj2[%2d]= (0x%2x), char(%c)",
                i<s(0)(0)(0)>[&], j2exp<s(0)(0)(0)>[&][i<s(0)(0)(0)>[&]], (j2exp<s(0)(0)(0)>[&][i<s(0)(0)(0)>[&]] >= 0x20 && j2exp<s(0)(0)(0)>[&][i<s(0)(0)(0)>[&]] <= 0x7e) ? j2exp<s(0)(0)(0)>[&][i<s(0)(0)(0)>[&]] : 'Y');
    }
}


void
em4ShowPageAddr<s(0)(0)(0)>[&] (void)
{
    printf<s(0)(0)(0)>[&] ("\r\npage0x01<<10 = (0x400      * 2 = 0x0800)");
    printf<s(0)(0)(0)>[&] ("\r\npage0x02<<10 = (0x800      * 2 = 0x1000)");
    printf<s(0)(0)(0)>[&] ("\r\npage0x04<<10 = (0x1000     * 2 = 0x2000)");
    printf<s(0)(0)(0)>[&] ("\r\npage0x05<<10 = (0x1400     * 2 = 0x2800)");
}



int 
em4ShowAlarms<s(0)(0)(0)>[&] (int ulPort<s(0)(0)(0)>[&])
{
    int ent<s(0)(0)(0)>[&] =(D2) 0;
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0, u1<s(0)(0)(0)>[&] =(D2) 0, u2<s(0)(0)(0)>[&] =(D2) 0, u3<s(0)(0)(0)>[&] =(D2) 0, u4<s(0)(0)(0)>[&] =(D2) 0;
    unsigned short mu<s(0)(0)(0)>[&] =(D2) 0, mu1<s(0)(0)(0)>[&] =(D2) 0, mu2<s(0)(0)(0)>[&] =(D2) 0, mu3<s(0)(0)(0)>[&] =(D2) 0, mu4<s(0)(0)(0)>[&] =(D2) 0;
    void *baseaddr<s(0)(0)(0)>[&] =(D2) (void *) 0;
    unsigned short uu<s(0)(0)(0)>[&] =(D2) 0;
    unsigned short muu<s(0)(0)(0)>[&] =(D2) 0;
    int regcnt<s(0)(0)(0)>[&] =(D2) 0;
    CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *pEntity<s(0)(0)(0)>[&] =(D2) ((void *)0) ;
	int port<s(0)(0)(0)>[&] =(D2) 0;

	{if (125 <  ulPort<s(0)(0)(0)>[&] ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  ulPort<s(0)(0)(0)>[&] ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;
	port<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (ulPort<s(0)(0)(0)>[&]) - 1;

    baseaddr<s(0)(0)(0)>[&] = cah_em4_getEntityBase<s(0)(0)(0)>[&] (ent<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&] + 1);
    printf<s(0)(0)(0)>[&] ("\r\n%s(): base(%p)", __FUNCTION__<s(0)(0)(0)>[&], baseaddr<s(0)(0)(0)>[&]);

 



    u<s(0)(0)(0)>[&] = cah_em4_pohRead<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&], 0x03 );
    mu<s(0)(0)(0)>[&] = cah_em4_pohRead<s(0)(0)(0)>[&] ((void *)(0x60000000) , port<s(0)(0)(0)>[&], 0x03 );

    u1<s(0)(0)(0)>[&] = cah_em4_pohRead<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&], 0x04 );
    mu1<s(0)(0)(0)>[&] = cah_em4_pohRead<s(0)(0)(0)>[&] ((void *)(0x60000000) , port<s(0)(0)(0)>[&], 0x04 );


 


    cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], ((0x01 << 10) | 0x03) , 0x8000 | port<s(0)(0)(0)>[&]);
    regcnt<s(0)(0)(0)>[&] = 0;
    while (1)
    {
        uu<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], ((0x01 << 10) | 0x03) );
        if (!(0x8000 & uu<s(0)(0)(0)>[&]))
        {
            break;
        }
        else
        {
            regcnt<s(0)(0)(0)>[&]++;
            if (regcnt<s(0)(0)(0)>[&] > 100)
            {
                printf<s(0)(0)(0)>[&] ("\r\nsomething wrong when read_hardware entity(%d)", ent<s(0)(0)(0)>[&]);
                break;
            }
        }
    }
    u2<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], ((0x01 << 10) | 0x10) );  

    regcnt<s(0)(0)(0)>[&] = 0;
    cah_em4_wr<s(0)(0)(0)>[&] ((void *)(0x60000000) , ((0x01 << 10) | 0x03) , 0x8000 | port<s(0)(0)(0)>[&]);
    while (1)
    {
        muu<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] ((void *)(0x60000000) , ((0x01 << 10) | 0x03) );
        if (!(0x8000 & uu<s(0)(0)(0)>[&]))
        {
            break;
        }
        else
        {
            regcnt<s(0)(0)(0)>[&]++;
            if (regcnt<s(0)(0)(0)>[&] > 100)
            {
                printf<s(0)(0)(0)>[&] ("\r\nsomething wrong when read_hardware entity(%d)", ent<s(0)(0)(0)>[&]);
                break;
            }
        }
    }
    mu2<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] ((void *)(0x60000000) , ((0x01 << 10) | 0x10) );  
 


    pEntity<s(0)(0)(0)>[&] = cah_em4_getEntity<s(0)(0)(0)>[&] (ent<s(0)(0)(0)>[&]);
    u3<s(0)(0)(0)>[&] = cah_em4_readPdhAlarm<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&]);
    mu3<s(0)(0)(0)>[&] = cah_em4_readPdhAlarm<s(0)(0)(0)>[&] ((void *)(0x60000000) , port<s(0)(0)(0)>[&]);

    printf<s(0)(0)(0)>[&] ("\r\nent(%d), port(%d)", ent<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\nSTATUS\t\t\t\tINTR");
    printf<s(0)(0)(0)>[&] ("\r\n______________________________________________________+++");

    printf<s(0)(0)(0)>[&] ("\r\nlop\t(%s)(%s)\t", (u2<s(0)(0)(0)>[&] & 0x0003) == 0x0001 ? "AIS-RISE" : ((u2<s(0)(0)(0)>[&] & 0x0003) == 0x0002 ? "LOP-RISE" : "NORMAL"),
				(mu2<s(0)(0)(0)>[&] & 0x0003) == 0x0001 ? "AIS-RISE" : ((mu2<s(0)(0)(0)>[&] & 0x0003) == 0x0002 ? "LOP-RISE" : "NORMAL"));

    printf<s(0)(0)(0)>[&] ("\r\npi_ssf\t(%s)(%s)\t", (u<s(0)(0)(0)>[&] & 0x4000) ? " RISE" : "CLEAR", (mu<s(0)(0)(0)>[&] & 0x4000) ? " RISE" : "CLEAR");
    printf<s(0)(0)(0)>[&] ("\tssf\t(%s)(%s)", (u1<s(0)(0)(0)>[&] & 0x4000) ? " RISE" : "CLEAR",
		(mu1<s(0)(0)(0)>[&] & 0x4000) ? " RISE" : "CLEAR");


    printf<s(0)(0)(0)>[&] ("\r\ntsl_ais\t(%s)(%s)\t", (u<s(0)(0)(0)>[&] & 0x0800) ? " RISE" : "CLEAR",
			(mu<s(0)(0)(0)>[&] & 0x0800) ? " RISE" : "CLEAR");
    printf<s(0)(0)(0)>[&] ("\ttslais\t(%s)(%s)", (u1<s(0)(0)(0)>[&] & 0x0800) ? " RISE" : "CLEAR",
			(mu1<s(0)(0)(0)>[&] & 0x0800) ? " RISE" : "CLEAR");

    printf<s(0)(0)(0)>[&] ("\r\nsf\t(%s)(%s)\t", (u<s(0)(0)(0)>[&] & 0x0040) ? " RISE" : "CLEAR", 
			(mu<s(0)(0)(0)>[&] & 0x0040) ? " RISE" : "CLEAR");
    printf<s(0)(0)(0)>[&] ("\tsf\t(%s)(%s)", (u1<s(0)(0)(0)>[&] & 0x0040) ? " RISE" : "CLEAR", 
			(mu1<s(0)(0)(0)>[&] & 0x0040) ? " RISE" : "CLEAR");

    printf<s(0)(0)(0)>[&] ("\r\nsd\t(%s)(%s)\t", (u<s(0)(0)(0)>[&] & 0x0020) ? " RISE" : "CLEAR", 
			(mu<s(0)(0)(0)>[&] & 0x0020) ? " RISE" : "CLEAR");
    printf<s(0)(0)(0)>[&] ("\tsd\t(%s)(%s)", (u1<s(0)(0)(0)>[&] & 0x0020) ? " RISE" : "CLEAR", 
			(mu1<s(0)(0)(0)>[&] & 0x0020) ? " RISE" : "CLEAR");

    printf<s(0)(0)(0)>[&] ("\r\nrdi\t(%s)(%s)\t", (u<s(0)(0)(0)>[&] & 0x0010) ? " RISE" : "CLEAR", 
			(mu<s(0)(0)(0)>[&] & 0x0010) ? " RISE" : "CLEAR");
    printf<s(0)(0)(0)>[&] ("\trdi\t(%s)(%s)", (u1<s(0)(0)(0)>[&] & 0x0010) ? " RISE" : "CLEAR", 
			(mu1<s(0)(0)(0)>[&] & 0x0010) ? " RISE" : "CLEAR");

    printf<s(0)(0)(0)>[&] ("\r\nuneq\t(%s)(%s)\t", (u<s(0)(0)(0)>[&] & 0x0008) ? " RISE" : "CLEAR", 
			(mu<s(0)(0)(0)>[&] & 0x0008) ? " RISE" : "CLEAR");
    printf<s(0)(0)(0)>[&] ("\tuneq\t(%s)(%s)", (u1<s(0)(0)(0)>[&] & 0x0008) ? " RISE" : "CLEAR", 
			(mu1<s(0)(0)(0)>[&] & 0x0008) ? " RISE" : "CLEAR");

    printf<s(0)(0)(0)>[&] ("\r\nplm\t(%s)(%s)\t", (u<s(0)(0)(0)>[&] & 0x0004) ? " RISE" : "CLEAR", 
			(mu<s(0)(0)(0)>[&] & 0x0004) ? " RISE" : "CLEAR");
    printf<s(0)(0)(0)>[&] ("\tplm\t(%s)(%s)", (u1<s(0)(0)(0)>[&] & 0x0004) ? " RISE" : "CLEAR", 
			(mu1<s(0)(0)(0)>[&] & 0x0004) ? " RISE" : "CLEAR");

    printf<s(0)(0)(0)>[&] ("\r\ntiu\t(%s)(%s)\t", (u<s(0)(0)(0)>[&] & 0x0002) ? " RISE" : "CLEAR", 
			(mu<s(0)(0)(0)>[&] & 0x0002) ? " RISE" : "CLEAR");
    printf<s(0)(0)(0)>[&] ("\ttiu\t(%s)(%s)", (u1<s(0)(0)(0)>[&] & 0x0002) ? " RISE" : "CLEAR", 
			(mu1<s(0)(0)(0)>[&] & 0x0002) ? " RISE" : "CLEAR");

    printf<s(0)(0)(0)>[&] ("\r\ntim\t(%s)(%s)\t", (u<s(0)(0)(0)>[&] & 0x0001) ? " RISE" : "CLEAR", 
			(mu<s(0)(0)(0)>[&] & 0x0001) ? " RISE" : "CLEAR");
    printf<s(0)(0)(0)>[&] ("\ttim\t(%s)(%s)", (u1<s(0)(0)(0)>[&] & 0x0001) ? " RISE" : "CLEAR", 
			(mu1<s(0)(0)(0)>[&] & 0x0001) ? " RISE" : "CLEAR");

 


    printf<s(0)(0)(0)>[&] ("\r\ne1lof\t(%s)(%s)\t", (u3<s(0)(0)(0)>[&] & 0x0004) ? "RISE" : "CLEAR", 
			(mu3<s(0)(0)(0)>[&] & 0x0004) ? "RISE" : "CLEAR");
    printf<s(0)(0)(0)>[&] ("\r\ne1lom\t(%s)(%s)\t", (u3<s(0)(0)(0)>[&] & 0x0002) ? "RISE" : "CLEAR", 
			(mu3<s(0)(0)(0)>[&] & 0x0002) ? "RISE" : "CLEAR");
    printf<s(0)(0)(0)>[&] ("\r\ne1rdi\t(%s)(%s)\t", (u3<s(0)(0)(0)>[&] & 0x0001) ? "RISE" : "CLEAR", 
			(mu3<s(0)(0)(0)>[&] & 0x0001) ? "RISE" : "CLEAR");
    printf<s(0)(0)(0)>[&] ("\r\ne1ais\t(%s)(%s)\t", (u3<s(0)(0)(0)>[&] & 0x0008) ? "RISE" : "CLEAR", 
			(mu3<s(0)(0)(0)>[&] & 0x0008) ? "RISE" : "CLEAR");


 


	u4<s(0)(0)(0)>[&] = em4Map1Rd<s(0)(0)(0)>[&] (0, 0x12);
	mu4<s(0)(0)(0)>[&] = em4Map2Rd<s(0)(0)(0)>[&] (0, 0x12);
    printf<s(0)(0)(0)>[&] ("\r\ne1los\t(%x)(%x)\t", (u4<s(0)(0)(0)>[&]), (mu4<s(0)(0)(0)>[&]));

    printf<s(0)(0)(0)>[&] ("\r\n______________________________________________________+++");
    printf<s(0)(0)(0)>[&] ("\r\n");

	return 0;
}

char *
cah_em4_fid2name<s(0)(0)(0)>[&] (int id<s(0)(0)(0)>[&], char *pname<s(0)(0)(0)>[&])
{
    char *name<s(0)(0)(0)>[&] =(D2) pname<s(0)(0)(0)>[&];

    switch (id<s(0)(0)(0)>[&])
    {
    case 111:
        sprintf<s(0)(0)(0)>[&] (pname<s(0)(0)(0)>[&], "%s", "EM4_EnableRetiming");
        break;
    case 1:
        sprintf<s(0)(0)(0)>[&] (pname<s(0)(0)(0)>[&], "%s", "EM4_SetTransPsl");
        break;
    case 2:
        sprintf<s(0)(0)(0)>[&] (pname<s(0)(0)(0)>[&], "%s", "EM4_SetExpPsl");
        break;
    case 3:
        sprintf<s(0)(0)(0)>[&] (pname<s(0)(0)(0)>[&], "%s", "EM4_GetRcvPsl");
        break;
    case 4:
        sprintf<s(0)(0)(0)>[&] (pname<s(0)(0)(0)>[&], "%s", "EM4_EnablePlm");
        break;
    case 5:
        sprintf<s(0)(0)(0)>[&] (pname<s(0)(0)(0)>[&], "%s", "EM4_SetTransTti");
        break;
    case 6:
        sprintf<s(0)(0)(0)>[&] (pname<s(0)(0)(0)>[&], "%s", "EM4_SetExpTti");
        break;
    case 7:
        sprintf<s(0)(0)(0)>[&] (pname<s(0)(0)(0)>[&], "%s", "EM4_GetAccTti");
        break;
    case 8:
        sprintf<s(0)(0)(0)>[&] (pname<s(0)(0)(0)>[&], "%s", "EM4_EnableTim");
        break;
    case 9:
        sprintf<s(0)(0)(0)>[&] (pname<s(0)(0)(0)>[&], "%s", "EM4_SetTransTtiMode");
        break;
    case 10:
        sprintf<s(0)(0)(0)>[&] (pname<s(0)(0)(0)>[&], "%s", "EM4_SetTransTti");
        break;
    case 11:
        sprintf<s(0)(0)(0)>[&] (pname<s(0)(0)(0)>[&], "%s", "EM4_SetPdhPortMode");
        break;
    case 12:
        sprintf<s(0)(0)(0)>[&] (pname<s(0)(0)(0)>[&], "%s", "EM4_GetPortType");
        break;
    case 13:
        sprintf<s(0)(0)(0)>[&] (pname<s(0)(0)(0)>[&], "%s", "EM4_SetPortLoopback");
        break;


    case 14:
        sprintf<s(0)(0)(0)>[&] (pname<s(0)(0)(0)>[&], "%s", "EM4_EnablePort");
        break;
    case 15:
        sprintf<s(0)(0)(0)>[&] (pname<s(0)(0)(0)>[&], "%s", "EM4_GetPortState");
        break;

    case 16:
        sprintf<s(0)(0)(0)>[&] (pname<s(0)(0)(0)>[&], "%s", "EM4_PrbsEnable");
        break;
    case 17:
        sprintf<s(0)(0)(0)>[&] (pname<s(0)(0)(0)>[&], "%s", "EM4_SetPrbsMode");
        break;
    case 18:
        sprintf<s(0)(0)(0)>[&] (pname<s(0)(0)(0)>[&], "%s", "EM4_GetPrbsMode");
        break;
    case 19:
        sprintf<s(0)(0)(0)>[&] (pname<s(0)(0)(0)>[&], "%s", "EM4_GetPrbsErrCount");
        break;
    case 20:
        sprintf<s(0)(0)(0)>[&] (pname<s(0)(0)(0)>[&], "%s", "EM4_ForceInsertAis");
        break;
    case 21:
        sprintf<s(0)(0)(0)>[&] (pname<s(0)(0)(0)>[&], "%s", "EM4_ForceInsertRdi");
        break;

    case 24:
        sprintf<s(0)(0)(0)>[&] (pname<s(0)(0)(0)>[&], "%s", "EM4_BlockAIS");
        break;


    case 25:
        sprintf<s(0)(0)(0)>[&] (pname<s(0)(0)(0)>[&], "%s", "EM4_SelectFrame");
        break;
    case 26:
        sprintf<s(0)(0)(0)>[&] (pname<s(0)(0)(0)>[&], "%s", "EM4_EnableLOMLOF");
        break;

    case 99:
        sprintf<s(0)(0)(0)>[&] (pname<s(0)(0)(0)>[&], "%s", "EM4_SetRcvTtiMode");
        break;
    default:
        printf<s(0)(0)(0)>[&] (pname<s(0)(0)(0)>[&], "%d", id<s(0)(0)(0)>[&]);
        break;
    }

    return (name<s(0)(0)(0)>[&]);
}


 


















char *
cah_em4_id2name<s(0)(0)(0)>[&] (int id<s(0)(0)(0)>[&])
{
    if ((32  != id<s(0)(0)(0)>[&])
        && (34  != id<s(0)(0)(0)>[&])
        && (36  != id<s(0)(0)(0)>[&])
        && (37  != id<s(0)(0)(0)>[&])
        && (38  != id<s(0)(0)(0)>[&])
        && (42  != id<s(0)(0)(0)>[&])
        && (39  != id<s(0)(0)(0)>[&])
        && (69  != id<s(0)(0)(0)>[&])
        && (91  != id<s(0)(0)(0)>[&])
        && (92  != id<s(0)(0)(0)>[&])
        && (230  != id<s(0)(0)(0)>[&])
        && (231  != id<s(0)(0)(0)>[&])
        && (232  != id<s(0)(0)(0)>[&])
        && (233  != id<s(0)(0)(0)>[&]) && (235  != id<s(0)(0)(0)>[&]))
    {
        printf<s(0)(0)(0)>[&] ("\r\ncah_em4_id2name: unknown id(%d)", id<s(0)(0)(0)>[&]);
        if (g_fflag<s(0)(0)(0)>[&])
        {
            logBackN<s(0)(0)(0)>[&] ("unkonwn id", 5);
            g_fflag<s(0)(0)(0)>[&] = 0;
        }
        sprintf<s(0)(0)(0)>[&] (g_aname<s(0)(0)(0)>[&], "%s", "unknown id");
        return g_aname<s(0)(0)(0)>[&];
    }

 








    switch (id<s(0)(0)(0)>[&])
    {
    case 91 :
        sprintf<s(0)(0)(0)>[&] (g_aname<s(0)(0)(0)>[&], "%s", "ppi-nslip");
        break;
    case 92 :
        sprintf<s(0)(0)(0)>[&] (g_aname<s(0)(0)(0)>[&], "%s", "ppi-pslip");
        break;
    case 32 :
        sprintf<s(0)(0)(0)>[&] (g_aname<s(0)(0)(0)>[&], "%s", "tu-lop");
        break;
    case 34 :
        sprintf<s(0)(0)(0)>[&] (g_aname<s(0)(0)(0)>[&], "%s", "tu-ais");
        break;
    case 36 :
        sprintf<s(0)(0)(0)>[&] (g_aname<s(0)(0)(0)>[&], "%s", "lp-tim");
        break;
    case 37 :
        sprintf<s(0)(0)(0)>[&] (g_aname<s(0)(0)(0)>[&], "%s", "lp-uneq");
        break;
    case 38 :
        sprintf<s(0)(0)(0)>[&] (g_aname<s(0)(0)(0)>[&], "%s", "lp-rdi");
        break;
    case 42 :
        sprintf<s(0)(0)(0)>[&] (g_aname<s(0)(0)(0)>[&], "%s", "lp-rfi");
        break;
    case 39 :
        sprintf<s(0)(0)(0)>[&] (g_aname<s(0)(0)(0)>[&], "%s", "lp-plm");
        break;
    case 69 :
        sprintf<s(0)(0)(0)>[&] (g_aname<s(0)(0)(0)>[&], "%s", "ppi-los");
        break;
         


    case 230 :
        sprintf<s(0)(0)(0)>[&] (g_aname<s(0)(0)(0)>[&], "%s", "ppi-lof");
        break;
    case 231 :
        sprintf<s(0)(0)(0)>[&] (g_aname<s(0)(0)(0)>[&], "%s", "ppi-lom");
        break;
    case 232 :
        sprintf<s(0)(0)(0)>[&] (g_aname<s(0)(0)(0)>[&], "%s", "ppi-rdi");
        break;
    case 235 :
        sprintf<s(0)(0)(0)>[&] (g_aname<s(0)(0)(0)>[&], "%s", "lpvc_tlct");
        break;
    case 233 :
        sprintf<s(0)(0)(0)>[&] (g_aname<s(0)(0)(0)>[&], "%s", "ppi-crc");
        break;
    default:
        break;
    }
    return g_aname<s(0)(0)(0)>[&];
}


 


int
cah_em4_isPDHRiseOrClear<s(0)(0)(0)>[&] (CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] * pEntity<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&], int almNum<s(0)(0)(0)>[&])
{
    return (pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].e1state<s(0)(0)(0)>[&][almNum<s(0)(0)(0)>[&]] & 0x0001 );
}


 


int
cah_em4_isRiseOrClear<s(0)(0)(0)>[&] (CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] * pEntity<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&], int almNum<s(0)(0)(0)>[&])
{
    return (pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].state<s(0)(0)(0)>[&][almNum<s(0)(0)(0)>[&]] & 0x0001 );
}


int
cah_em4_isPDHAlmRPTNow<s(0)(0)(0)>[&] (CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] * pEntity<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&], int almNum<s(0)(0)(0)>[&])
{
    return (pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].e1state<s(0)(0)(0)>[&][almNum<s(0)(0)(0)>[&]] & 0x8000 );
}


int
cah_em4_isAlmRPTNow<s(0)(0)(0)>[&] (CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] * pEntity<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&], int almNum<s(0)(0)(0)>[&])
{
    return (pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].state<s(0)(0)(0)>[&][almNum<s(0)(0)(0)>[&]] & 0x8000 );
}

int
cah_em4_isAlmForced<s(0)(0)(0)>[&] (CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] * pEntity<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&])
{
    return (pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].forceRptAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]] == 1 );
}


int
cah_em4_isPDHAlmForced<s(0)(0)(0)>[&] (CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] * pEntity<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&])
{
    return (pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].forceRptAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]] == 1 );
}


void
cah_em4_clearAlmForced<s(0)(0)(0)>[&] (CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] * pEntity<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&])
{
    pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].forceRptAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]] = 0 ;
}






BOOL<s(0)(0)(0)>[T]
cah_em4_isPDHAlmSet<s(0)(0)(0)>[&] (CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] * pEntity<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&], int almNum<s(0)(0)(0)>[&])
{
    return (pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].e1state<s(0)(0)(0)>[&][almNum<s(0)(0)(0)>[&]] & 0x0001 );
}


BOOL<s(0)(0)(0)>[T]
cah_em4_isAlmSet<s(0)(0)(0)>[&] (CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] * pEntity<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&], int almNum<s(0)(0)(0)>[&])
{
    return (pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].state<s(0)(0)(0)>[&][almNum<s(0)(0)(0)>[&]] & 0x0001 );
}

int
cah_em4_isEntLive<s(0)(0)(0)>[&] (int fd<s(0)(0)(0)>[&])
{
    return (eEm4EntAct<s(0)(0)(0)>[&] == gppCahEm4CfgVar<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]]->state<s(0)(0)(0)>[&]) ? 1 : 0;
}




 


int
cah_em4_isCardOn<s(0)(0)(0)>[&] (int instance<s(0)(0)(0)>[&])
{
    if (SDD_BOARD_PRESENT<s(0)(0)(0)>[&] == SDD_GetBoardPresence<s(0)(0)(0)>[&] ((CTD_SlotToInstance<s(0)(0)(0)>[&]( instance<s(0)(0)(0)>[&] )) ))
    {
        return 1;
    }
    else
    {
        if (33 == gCahEm4DebugLevel<s(0)(0)(0)>[&])
            printf<s(0)(0)(0)>[&] ("\r\niscardon: inst(%d) FALL-OFF", instance<s(0)(0)(0)>[&]);
        return 0;
    }
    return 1;
}




 

































unsigned short
cah_em4_getPlm<s(0)(0)(0)>[&] (ALARM_REGISTER_T<s(0)(0)(0)>[T] * alarmCtrlReg<s(0)(0)(0)>[&])
{
    return (alarmCtrlReg<s(0)(0)(0)>[&]->alarmCtrlBit<s(0)(0)(0)>[&].plm<s(0)(0)(0)>[&]);
}


unsigned short
cah_em4_getUneq<s(0)(0)(0)>[&] (ALARM_REGISTER_T<s(0)(0)(0)>[T] * alarmCtrlReg<s(0)(0)(0)>[&])
{
    return (alarmCtrlReg<s(0)(0)(0)>[&]->alarmCtrlBit<s(0)(0)(0)>[&].uneq<s(0)(0)(0)>[&]);
}

unsigned short
cah_em4_getTim<s(0)(0)(0)>[&] (ALARM_REGISTER_T<s(0)(0)(0)>[T] * alarmCtrlReg<s(0)(0)(0)>[&])
{
    return (alarmCtrlReg<s(0)(0)(0)>[&]->alarmCtrlBit<s(0)(0)(0)>[&].tim<s(0)(0)(0)>[&]);
}


unsigned short
cah_em4_getRdi<s(0)(0)(0)>[&] (ALARM_REGISTER_T<s(0)(0)(0)>[T] * alarmCtrlReg<s(0)(0)(0)>[&])
{
    return (alarmCtrlReg<s(0)(0)(0)>[&]->alarmCtrlBit<s(0)(0)(0)>[&].rdi<s(0)(0)(0)>[&]);
}

unsigned short
cah_em4_getRfi<s(0)(0)(0)>[&] (ALARM_REGISTER_T<s(0)(0)(0)>[T] * alarmCtrlReg<s(0)(0)(0)>[&])
{
    return (alarmCtrlReg<s(0)(0)(0)>[&]->alarmCtrlBit<s(0)(0)(0)>[&].rfi<s(0)(0)(0)>[&]);
}


PB_ERROR_CODE_T<s(0)(0)(0)>[T]
cah_em4_GetSlip<s(0)(0)(0)>[&] (int dwPos<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] * pPSlip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] * pNSlip<s(0)(0)(0)>[&])
{
    unsigned short slip<s(0)(0)(0)>[&] =(D2) 0;
    void *base<s(0)(0)(0)>[&] =(D2) 0;
    int ulPort<s(0)(0)(0)>[&] =(D2) 0;

	{if (125 <  byPortNo<s(0)(0)(0)>[&] ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  byPortNo<s(0)(0)(0)>[&] ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;
	ulPort<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (byPortNo<s(0)(0)(0)>[&]) - 1;
       base<s(0)(0)(0)>[&] = cah_em4_getEntityBase<s(0)(0)(0)>[&] (0, byPortNo<s(0)(0)(0)>[&]);

       slip<s(0)(0)(0)>[&] = cah_em4_readDemapper<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], ulPort<s(0)(0)(0)>[&], (0x05 << 10) | 0X02 );
    *pPSlip<s(0)(0)(0)>[&] = ((slip<s(0)(0)(0)>[&] & 0xff00) >> 8);       
    *pNSlip<s(0)(0)(0)>[&] = (slip<s(0)(0)(0)>[&] & 0x00ff);      

    cah_em4_trace<s(0)(0)(0)>[&] (21, "%s: entity(%d), port(%d), base(%x), reg(%x), val(%x)",
                   __FUNCTION__<s(0)(0)(0)>[&], 0, byPortNo<s(0)(0)(0)>[&], base<s(0)(0)(0)>[&], (0x05 << 10) | 0X02 , slip<s(0)(0)(0)>[&]);

    return ((WORD<s(0)(0)(0)>[T])0x0) ;
}


int
cah_em4_simslip<s(0)(0)(0)>[&] (ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&], int n<s(0)(0)(0)>[&], int flag<s(0)(0)(0)>[&])
{
    int i<s(0)(0)(0)>[&] =(D2) 0;
    unsigned int pslip<s(0)(0)(0)>[&],(D1:pslip:0) nslip<s(0)(0)(0)>[&];(D1:nslip:0)

    if (0 == flag<s(0)(0)(0)>[&])
    {
        return 0;
    }

    for (i<s(0)(0)(0)>[&] = 0; i<s(0)(0)(0)>[&] < n<s(0)(0)(0)>[&]; i<s(0)(0)(0)>[&]++)
    {
        taskDelay<s(0)(0)(0)>[&] (100);
        cah_em4_GetSlip<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&], ulPort<s(0)(0)(0)>[&], &pslip<s(0)(0)(0)>[&], &nslip<s(0)(0)(0)>[&]);
        printf<s(0)(0)(0)>[&] ("\r\nnslip(%d), pslip(%d)", nslip<s(0)(0)(0)>[&], pslip<s(0)(0)(0)>[&]);
    }
    return 0;
}



BOOL<s(0)(0)(0)>[T]
cah_em4_isTTI16Byte<s(0)(0)(0)>[&] (CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] * pEntity<s(0)(0)(0)>[&], int ulChip<s(0)(0)(0)>[&], int ulPort<s(0)(0)(0)>[&])
{
    return (PbTIModeType_mode16Byte<s(0)(0)(0)>[&] == pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].strRcvJ2<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].J2Mode<s(0)(0)(0)>[&]);

}


BOOL<s(0)(0)(0)>[T]
cah_em4_isTimEnable<s(0)(0)(0)>[&] (CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] * pEntity<s(0)(0)(0)>[&], int ulChip<s(0)(0)(0)>[&], int ulPort<s(0)(0)(0)>[&])
{
    return (pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].bTimEnable<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]]);
}




BOOL<s(0)(0)(0)>[T]
cah_em4_isPLMEnable<s(0)(0)(0)>[&] (CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] * pEntity<s(0)(0)(0)>[&], int ulChip<s(0)(0)(0)>[&], int ulPort<s(0)(0)(0)>[&])
{
    return (pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].bPlmEnable<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]]);
}

 


UINT16<s(0)(0)(0)>[T]
cah_em4_getAlarmId<s(0)(0)(0)>[&] (CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] * pEntity<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&], int almNum<s(0)(0)(0)>[&])
{
    UINT16<s(0)(0)(0)>[T] almID<s(0)(0)(0)>[&];(D1:almID:0)

    almID<s(0)(0)(0)>[&] = pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].almID<s(0)(0)(0)>[&][almNum<s(0)(0)(0)>[&]];

    return almID<s(0)(0)(0)>[&];
}






BOOL<s(0)(0)(0)>[T]
cah_em4_isPDHAlarmRised<s(0)(0)(0)>[&] (UINT16<s(0)(0)(0)>[T] wTemp<s(0)(0)(0)>[&], CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] * pEntity<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&],
                         UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&], int almNum<s(0)(0)(0)>[&])
{
    return (wTemp<s(0)(0)(0)>[&] && (!cah_em4_isPDHAlmSet<s(0)(0)(0)>[&] (pEntity<s(0)(0)(0)>[&], ulChip<s(0)(0)(0)>[&], ulPort<s(0)(0)(0)>[&], almNum<s(0)(0)(0)>[&])));
}


 






BOOL<s(0)(0)(0)>[T]
cah_em4_isAlarmRised<s(0)(0)(0)>[&] (UINT16<s(0)(0)(0)>[T] wTemp<s(0)(0)(0)>[&], CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] * pEntity<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&],
                      int almNum<s(0)(0)(0)>[&])
{
    return (wTemp<s(0)(0)(0)>[&] && (!cah_em4_isAlmSet<s(0)(0)(0)>[&] (pEntity<s(0)(0)(0)>[&], ulChip<s(0)(0)(0)>[&], ulPort<s(0)(0)(0)>[&], almNum<s(0)(0)(0)>[&])));
}


BOOL<s(0)(0)(0)>[T]
cah_em4_isAlarmCleared<s(0)(0)(0)>[&] (UINT16<s(0)(0)(0)>[T] wTemp<s(0)(0)(0)>[&], CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] * pEntity<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&],
                        int almNum<s(0)(0)(0)>[&])
{
    return ((!wTemp<s(0)(0)(0)>[&]) && (cah_em4_isAlmSet<s(0)(0)(0)>[&] (pEntity<s(0)(0)(0)>[&], ulChip<s(0)(0)(0)>[&], ulPort<s(0)(0)(0)>[&], almNum<s(0)(0)(0)>[&])));
}

BOOL<s(0)(0)(0)>[T]
cah_em4_isPDHAlarmCleared<s(0)(0)(0)>[&] (UINT16<s(0)(0)(0)>[T] wTemp<s(0)(0)(0)>[&], CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] * pEntity<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&],
                           UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&], int almNum<s(0)(0)(0)>[&])
{
    return ((!wTemp<s(0)(0)(0)>[&]) && (cah_em4_isPDHAlmSet<s(0)(0)(0)>[&] (pEntity<s(0)(0)(0)>[&], ulChip<s(0)(0)(0)>[&], ulPort<s(0)(0)(0)>[&], almNum<s(0)(0)(0)>[&])));
}

int
cah_em4_getAlarmType<s(0)(0)(0)>[&] (CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] * pEntity<s(0)(0)(0)>[&],
                      UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&], UINT16<s(0)(0)(0)>[T] almID<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] * almType<s(0)(0)(0)>[&])
{

    memset<s(0)(0)(0)>[&]((INT1<s(0)(0)(0)>[T] *)( almType<s(0)(0)(0)>[&] ), (  0 ), (  sizeof (almType<s(0)(0)(0)>[&]) )) ;
    switch (almID<s(0)(0)(0)>[&])
    {
    case 91 :
        (((char*) almType<s(0)(0)(0)>[&] )[((int)(  9 + 1 ) <= 0) ? 0 : (  9 + 1 )-1] = '\0', strncpy<s(0)(0)(0)>[&]( almType<s(0)(0)(0)>[&] ,   "PPI-NSLIP" , ((int)(  9 + 1 ) <= 0) ? 0 : (  9 + 1 )-1)) ;
        break;
    case 92 :
        (((char*) almType<s(0)(0)(0)>[&] )[((int)(  9 + 1 ) <= 0) ? 0 : (  9 + 1 )-1] = '\0', strncpy<s(0)(0)(0)>[&]( almType<s(0)(0)(0)>[&] ,   "PPI-PSLIP" , ((int)(  9 + 1 ) <= 0) ? 0 : (  9 + 1 )-1)) ;
        break;
    case 38 :
        (((char*) almType<s(0)(0)(0)>[&] )[((int)(  6 + 1 ) <= 0) ? 0 : (  6 + 1 )-1] = '\0', strncpy<s(0)(0)(0)>[&]( almType<s(0)(0)(0)>[&] ,   "LP-RDI" , ((int)(  6 + 1 ) <= 0) ? 0 : (  6 + 1 )-1)) ;
        if (0)
            if (pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].bRestrainRDI<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]])
            {
                return -1;
            }
        (((char*) almType<s(0)(0)(0)>[&] )[((int)(  6 + 1 ) <= 0) ? 0 : (  6 + 1 )-1] = '\0', strncpy<s(0)(0)(0)>[&]( almType<s(0)(0)(0)>[&] ,   "LP-RDI" , ((int)(  6 + 1 ) <= 0) ? 0 : (  6 + 1 )-1)) ;
        break;
    case 42 :
        (((char*) almType<s(0)(0)(0)>[&] )[((int)(  6 + 1 ) <= 0) ? 0 : (  6 + 1 )-1] = '\0', strncpy<s(0)(0)(0)>[&]( almType<s(0)(0)(0)>[&] ,   "LP-RFI" , ((int)(  6 + 1 ) <= 0) ? 0 : (  6 + 1 )-1)) ;
        if (0)
            if (pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].bRestrainRDI<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]])
            {
                return -1;
            }
        (((char*) almType<s(0)(0)(0)>[&] )[((int)(  6 + 1 ) <= 0) ? 0 : (  6 + 1 )-1] = '\0', strncpy<s(0)(0)(0)>[&]( almType<s(0)(0)(0)>[&] ,   "LP-RFI" , ((int)(  6 + 1 ) <= 0) ? 0 : (  6 + 1 )-1)) ;
        break;
    case 34 :
        (((char*) almType<s(0)(0)(0)>[&] )[((int)(  6 + 1 ) <= 0) ? 0 : (  6 + 1 )-1] = '\0', strncpy<s(0)(0)(0)>[&]( almType<s(0)(0)(0)>[&] ,   "TU-AIS" , ((int)(  6 + 1 ) <= 0) ? 0 : (  6 + 1 )-1)) ;
        break;
    case 32 :
        (((char*) almType<s(0)(0)(0)>[&] )[((int)(  6 + 1 ) <= 0) ? 0 : (  6 + 1 )-1] = '\0', strncpy<s(0)(0)(0)>[&]( almType<s(0)(0)(0)>[&] ,   "TU-LOP" , ((int)(  6 + 1 ) <= 0) ? 0 : (  6 + 1 )-1)) ;
        break;
    case 36 :
         





        (((char*) almType<s(0)(0)(0)>[&] )[((int)(  6 + 1 ) <= 0) ? 0 : (  6 + 1 )-1] = '\0', strncpy<s(0)(0)(0)>[&]( almType<s(0)(0)(0)>[&] ,   "LP-TIM" , ((int)(  6 + 1 ) <= 0) ? 0 : (  6 + 1 )-1)) ;
        break;
    case 39 :
         





        (((char*) almType<s(0)(0)(0)>[&] )[((int)(  6 + 1 ) <= 0) ? 0 : (  6 + 1 )-1] = '\0', strncpy<s(0)(0)(0)>[&]( almType<s(0)(0)(0)>[&] ,   "LP-PLM" , ((int)(  6 + 1 ) <= 0) ? 0 : (  6 + 1 )-1)) ;
        break;
    case 37 :
        (((char*) almType<s(0)(0)(0)>[&] )[((int)(  8 + 1 ) <= 0) ? 0 : (  8 + 1 )-1] = '\0', strncpy<s(0)(0)(0)>[&]( almType<s(0)(0)(0)>[&] ,   "LP-UNREQ" , ((int)(  8 + 1 ) <= 0) ? 0 : (  8 + 1 )-1)) ;
        break;
    default:
        (((char*) almType<s(0)(0)(0)>[&] )[((int)(  7 + 1 ) <= 0) ? 0 : (  7 + 1 )-1] = '\0', strncpy<s(0)(0)(0)>[&]( almType<s(0)(0)(0)>[&] ,   "UNKNOWN" , ((int)(  7 + 1 ) <= 0) ? 0 : (  7 + 1 )-1)) ;
        break;
    }

    return 0;
}


FMA_ALM_STATE<s(0)(0)(0)>[T]
cah_em4_getPlmStatus<s(0)(0)(0)>[&] (CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] * pEntity<s(0)(0)(0)>[&],
                      UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&], FMA_ALM_STATE<s(0)(0)(0)>[T] state<s(0)(0)(0)>[&])
{
    if (0  == pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].bPlmEnable<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]])
    {
        return FMA_ALM_CLEAR<s(0)(0)(0)>[&];
    }

     


    return state<s(0)(0)(0)>[&];
}


FMA_ALM_STATE<s(0)(0)(0)>[T]
cah_em4_getTimStatus<s(0)(0)(0)>[&] (CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] * pEntity<s(0)(0)(0)>[&],
                      UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&], FMA_ALM_STATE<s(0)(0)(0)>[T] state<s(0)(0)(0)>[&])
{
    if (0  == pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].bTimEnable<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]])
    {
        return FMA_ALM_CLEAR<s(0)(0)(0)>[&];
    }

    if (PbTIModeType_mode16Byte<s(0)(0)(0)>[&] != pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].strRcvJ2<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].J2Mode<s(0)(0)(0)>[&])
    {
        return FMA_ALM_CLEAR<s(0)(0)(0)>[&];
    }

     


    return state<s(0)(0)(0)>[&];
}


void
cah_em4_addSsfFc<s(0)(0)(0)>[&] (ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&])
{
    CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *pEntity<s(0)(0)(0)>[&] =(D2) ((void *)0) ;


    pEntity<s(0)(0)(0)>[&] = cah_em4_getEntity<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&]);
    pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][0].pohAlm<s(0)(0)(0)>[&][port<s(0)(0)(0)>[&]].e1ssfFc<s(0)(0)(0)>[&]++;

}


void
cah_em4_Dpr<s(0)(0)(0)>[&] ()
{
    unsigned int entity<s(0)(0)(0)>[&] =(D2) 0;
    CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *pEntity<s(0)(0)(0)>[&];(D1:pEntity:0)
    int instance<s(0)(0)(0)>[&] =(D2) 0;
    int fd<s(0)(0)(0)>[&] =(D2) 0;

    while (1)
    {
         


        if (!gbCahEm4RunPollingTask<s(0)(0)(0)>[&][1 ])
        {
            taskDelay<s(0)(0)(0)>[&] (100);
            printf<s(0)(0)(0)>[&] ("\r\ngbCahEm4RunPollingTask[EM4_DPR_TASK_ID]");
            continue;
        }
        entity<s(0)(0)(0)>[&] = gCahEm4TribVar<s(0)(0)(0)>[&].latchent<s(0)(0)(0)>[&];

        if ((( entity<s(0)(0)(0)>[&]  >= ((1) ) )) )
        {
            printf<s(0)(0)(0)>[&] ("\r\n**Error!  Entity= %d; File=%s; Line=%d  \r\n", entity<s(0)(0)(0)>[&], "cah_126e1.c", 5185);
            continue;
        }

        if (((void *)0)  == (pEntity<s(0)(0)(0)>[&] = cah_em4_getEntityPtr<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&])))
        {
            printf<s(0)(0)(0)>[&] ("\r\n**Error!  Entity= %d; File=%s; Line=%d  \r\n", entity<s(0)(0)(0)>[&], "cah_126e1.c", 5191);
            continue;
        }

        fd<s(0)(0)(0)>[&] = cah_em4_ent2fd<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&]);
        if (eEm4EntAct<s(0)(0)(0)>[&] != pEntity<s(0)(0)(0)>[&]->state<s(0)(0)(0)>[&])
        {
            printf<s(0)(0)(0)>[&] ("\r\ncah_em4_Dpr!  entity(%d) NOT active", entity<s(0)(0)(0)>[&]);
            continue;
        }

        instance<s(0)(0)(0)>[&] = (CTD_SlotToInstance<s(0)(0)(0)>[&]((  entity<s(0)(0)(0)>[&]  ) )) ;

        if (EM4_ENTITY_DELATCH<s(0)(0)(0)>[&] == gCahEm4TribVar<s(0)(0)(0)>[&].EM4LatchStatus<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]])
        {
            printf<s(0)(0)(0)>[&] ("\r\n**Error!  Entity= %d; File=%s; Line=%d  \r\n", entity<s(0)(0)(0)>[&], "cah_126e1.c", 5206);
            continue;
        }
        else
        {
            printf<s(0)(0)(0)>[&] ("\r\nset DELATCH");
            gCahEm4TribVar<s(0)(0)(0)>[&].EM4LatchStatus<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]] = EM4_ENTITY_DELATCH<s(0)(0)(0)>[&];
        }

        cah_em4_trace<s(0)(0)(0)>[&] (20, "%s detach entity:%d status:%d !!! \r\n", __FUNCTION__<s(0)(0)(0)>[&], entity<s(0)(0)(0)>[&],
                       gCahEm4TribVar<s(0)(0)(0)>[&].EM4LatchStatus<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]   ]);
    }
}

int
pbFpgaIntrEnable<s(0)(0)(0)>[&] (int handle<s(0)(0)(0)>[&])
{
    return 0 ;
}

int
pbFpgaIsrHookAdd<s(0)(0)(0)>[&] (int fpga<s(0)(0)(0)>[&], int bank<s(0)(0)(0)>[&], int device<s(0)(0)(0)>[&], FPGA_HOOK_FUNC<s(0)(0)(0)>[T] usrHookFunc<s(0)(0)(0)>[&],
                  FPGA_HOOK_ARG<s(0)(0)(0)>[T] usrHookArg<s(0)(0)(0)>[&])
{
    return 0 ;
}

PB_ERROR_CODE_T<s(0)(0)(0)>[T]
cah_em4_intConnect<s(0)(0)(0)>[&] (ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&])
{
    CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *pEntity<s(0)(0)(0)>[&];(D1:pEntity:0)
     
    int fpga<s(0)(0)(0)>[&],(D1:fpga:0) bank<s(0)(0)(0)>[&],(D1:bank:0) device<s(0)(0)(0)>[&];(D1:device:0)
    int fd<s(0)(0)(0)>[&] =(D2) 0;


    if (((void *)0)  == (pEntity<s(0)(0)(0)>[&] = cah_em4_getEntityPtr<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&])))
    {
         
        return PB_ERR_PARAM<s(0)(0)(0)>[&];
    }
     
    fd<s(0)(0)(0)>[&] = cah_em4_ent2fd<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&]);

    fpga<s(0)(0)(0)>[&] = 1;
    bank<s(0)(0)(0)>[&] = 0;
    device<s(0)(0)(0)>[&] = ( entity<s(0)(0)(0)>[&] )  - 1;
    gCahEm4TribVar<s(0)(0)(0)>[&].fpgaHanle<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]] =
        pbFpgaIsrHookAdd<s(0)(0)(0)>[&] (fpga<s(0)(0)(0)>[&], bank<s(0)(0)(0)>[&], device<s(0)(0)(0)>[&], (FPGA_HOOK_FUNC<s(0)(0)(0)>[T]) cah_em4_isrFunc<s(0)(0)(0)>[&], entity<s(0)(0)(0)>[&]);

    if (((FPGA_HANDLE<s(0)(0)(0)>[T])(-1))  == gCahEm4TribVar<s(0)(0)(0)>[&].fpgaHanle<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]])
    {
        printf<s(0)(0)(0)>[&] ("\r\n**Error!  Entity= %d; File=%s; Line=%d  \r\n", entity<s(0)(0)(0)>[&], "cah_126e1.c", 5258);
        return ((WORD<s(0)(0)(0)>[T])0x1) ;
    }
    printf<s(0)(0)(0)>[&] ("\r\n126xe1rt entity(%d) interrupt handler installed ok", entity<s(0)(0)(0)>[&]);
     
    if (0  != pbFpgaIntrEnable<s(0)(0)(0)>[&] (gCahEm4TribVar<s(0)(0)(0)>[&].fpgaHanle<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]]))
    {
        printf<s(0)(0)(0)>[&] ("\r\n**Error!  Entity= %d; File=%s; Line=%d  \r\n", entity<s(0)(0)(0)>[&], "cah_126e1.c", 5265);
        return ((WORD<s(0)(0)(0)>[T])0x1) ;
    }

    pbFpgaIsrEnable<s(0)(0)(0)>[&] (fpga<s(0)(0)(0)>[&]);

    return ((WORD<s(0)(0)(0)>[T])0x0) ;
}


void
cah_em4_init_nothing<s(0)(0)(0)>[&] ()
{
    static int flag<s(0)(0)(0)>[&] =(D2) 1;
    int i<s(0)(0)(0)>[&] =(D2) 0;

    if (flag<s(0)(0)(0)>[&])
    {
        memset<s(0)(0)(0)>[&]((INT1<s(0)(0)(0)>[T] *)( &gCahEm4TribVar<s(0)(0)(0)>[&] ), (  0 ), (  sizeof (CAH_EM4_ENTITY_TRIB_T<s(0)(0)(0)>[T]) )) ;
        for (i<s(0)(0)(0)>[&] = 0; i<s(0)(0)(0)>[&] < ((1) ) ; i<s(0)(0)(0)>[&]++)
        {
            gppCahEm4CfgVar<s(0)(0)(0)>[&][i<s(0)(0)(0)>[&]] = 0;
            printf<s(0)(0)(0)>[&] ("\r\n%s(): set gppCahEm4CfgVar[%d] to 0", __FUNCTION__<s(0)(0)(0)>[&], i<s(0)(0)(0)>[&]);
        }
        flag<s(0)(0)(0)>[&] = 0;
    }
}

BOOL<s(0)(0)(0)>[T]
cah_em4_IsLatchIntEnable<s(0)(0)(0)>[&] (UINT32<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&])
{
    BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&] =(D2) 0 ;
    void *baseaddr<s(0)(0)(0)>[&] =(D2) cah_em4_getEntityBase<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&], 100);
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0;

    cah_ReadRegister<s(0)(0)(0)>[&] ((DWORD<s(0)(0)(0)>[T]) baseaddr<s(0)(0)(0)>[&], (((0x00 << 10) | 0X09) ), &u<s(0)(0)(0)>[&], 0xffff, CAH_REG_ATTRBT_RO<s(0)(0)(0)>[&]);



    if (0x0001 & u<s(0)(0)(0)>[&])
    {
        bEnable<s(0)(0)(0)>[&] = 1 ;
    }
    else
    {
        bEnable<s(0)(0)(0)>[&] = 0 ;
    }

    return bEnable<s(0)(0)(0)>[&];
}



void
cah_em4_enableLatchInt<s(0)(0)(0)>[&] (UINT32<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] Enable<s(0)(0)(0)>[&])
{
    void *baseAddr<s(0)(0)(0)>[&] =(D2) cah_em4_getEntityBase<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&], 1);

    if (Enable<s(0)(0)(0)>[&])
    {
        cah_em4_enableLatchIntr<s(0)(0)(0)>[&] (baseAddr<s(0)(0)(0)>[&], 1);
    }
    else
    {
        cah_em4_enableLatchIntr<s(0)(0)(0)>[&] (baseAddr<s(0)(0)(0)>[&], 0);
    }
}


void
cah_em4_isrFunc<s(0)(0)(0)>[&] (FPGA_HANDLE<s(0)(0)(0)>[T] handle<s(0)(0)(0)>[&], FPGA_HOOK_ARG<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&])
{
    int fd<s(0)(0)(0)>[&] =(D2) 0;

    if ((( entity<s(0)(0)(0)>[&]  >= ((1) ) )) )
    {
        return;
    }

    cah_em4_enableLatchInt<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&], 0 );

     



    fd<s(0)(0)(0)>[&] = cah_em4_ent2fd<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&]);
    gCahEm4TribVar<s(0)(0)(0)>[&].IntCount<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]   ]++;
    g_isrcount<s(0)(0)(0)>[&]++;
    gCahEm4TribVar<s(0)(0)(0)>[&].latchent<s(0)(0)(0)>[&] = entity<s(0)(0)(0)>[&];
    g_cah_em4entity<s(0)(0)(0)>[&] = entity<s(0)(0)(0)>[&];
}


PB_ERROR_CODE_T<s(0)(0)(0)>[T]
cah_em4_intUnConnect<s(0)(0)(0)>[&] (ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&])
{
    CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *pEntity<s(0)(0)(0)>[&];(D1:pEntity:0)
     
    int ReturnValue<s(0)(0)(0)>[&];(D1:ReturnValue:0)
    int fd<s(0)(0)(0)>[&] =(D2) 0;


    if (((void *)0)  == (pEntity<s(0)(0)(0)>[&] = cah_em4_getEntityPtr<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&])))
    {
         
        return PB_ERR_PARAM<s(0)(0)(0)>[&];
    }

     
    fd<s(0)(0)(0)>[&] = cah_em4_ent2fd<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&]);

    if (((FPGA_HANDLE<s(0)(0)(0)>[T])(-1))  == gCahEm4TribVar<s(0)(0)(0)>[&].fpgaHanle<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]])
    {
         
        return ((WORD<s(0)(0)(0)>[T])0x1) ;
    }

    ReturnValue<s(0)(0)(0)>[&] = pbFpgaIntrDisable<s(0)(0)(0)>[&] (gCahEm4TribVar<s(0)(0)(0)>[&].fpgaHanle<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]]);
    if (ReturnValue<s(0)(0)(0)>[&] != 0 )
    {
         
        return ((WORD<s(0)(0)(0)>[T])0x1) ;
    }

    ReturnValue<s(0)(0)(0)>[&] = pbFpgaIsrHookDel<s(0)(0)(0)>[&] (gCahEm4TribVar<s(0)(0)(0)>[&].fpgaHanle<s(0)(0)(0)>[&][fd<s(0)(0)(0)>[&]]);
    if (ReturnValue<s(0)(0)(0)>[&] != 0 )
    {
         
        return ((WORD<s(0)(0)(0)>[T])0x1) ;
    }

    return ((WORD<s(0)(0)(0)>[T])0x0) ;
}



void
cah_em4_latch<s(0)(0)(0)>[&] ()
{
    UINT8<s(0)(0)(0)>[T] fd<s(0)(0)(0)>[&]   ;(D1:fd:0)
    CAH_EM4_ENTITY_LATCH_T<s(0)(0)(0)>[T] Status<s(0)(0)(0)>[&];(D1:Status:0)
    CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *pEntity<s(0)(0)(0)>[&] =(D2) ((void *)0) ;
    UINT16<s(0)(0)(0)>[T] intCount<s(0)(0)(0)>[&];(D1:intCount:0)
    INT32<s(0)(0)(0)>[T] intLockRet<s(0)(0)(0)>[&];(D1:intLockRet:0)
    void *baseaddr<s(0)(0)(0)>[&] =(D2) ((void *)0) ;
    int instance<s(0)(0)(0)>[&] =(D2) 0;
    int fdd<s(0)(0)(0)>[&] =(D2) 0;

    while (1)
    {
        taskDelay<s(0)(0)(0)>[&] (100);

        if (!gbCahEm4RunPollingTask<s(0)(0)(0)>[&][2 ])
        {
            printf<s(0)(0)(0)>[&] ("\r\ncah_em4_latch (): gbCahEm4RunPollingTask[EM4_EPG_TASK_ID] NULL");
            continue;
        }

        for (fd<s(0)(0)(0)>[&] = 0; fd<s(0)(0)(0)>[&] < ((1) ) ; fd<s(0)(0)(0)>[&]++)
        {
            if (!cah_em4_isEntLive<s(0)(0)(0)>[&] (fd<s(0)(0)(0)>[&]))
            {
                cah_em4_trace<s(0)(0)(0)>[&] (2, "FD(%2d), state NOT active, continue", fd<s(0)(0)(0)>[&]);
                continue;
            }

            if (!cah_em4_isCardOn<s(0)(0)(0)>[&] (( cah_em4_fd2ent<s(0)(0)(0)>[&] (fd<s(0)(0)(0)>[&]) ) ))
            {
                printf<s(0)(0)(0)>[&] ("\r\nFD(%2d), card NOT on", fd<s(0)(0)(0)>[&]);
                continue;
            }

             
            pEntity<s(0)(0)(0)>[&] = cah_em4_fd2entptr<s(0)(0)(0)>[&] (fd<s(0)(0)(0)>[&]);
            cah_em4_trace<s(0)(0)(0)>[&] (22, "%s, entity(%d)", __FUNCTION__<s(0)(0)(0)>[&], pEntity<s(0)(0)(0)>[&]->entity<s(0)(0)(0)>[&]);

            Status<s(0)(0)(0)>[&] = CAH_EM4_getLatchStatus<s(0)(0)(0)>[&] (pEntity<s(0)(0)(0)>[&]->entity<s(0)(0)(0)>[&]);
             
            fdd<s(0)(0)(0)>[&] = cah_em4_ent2fd<s(0)(0)(0)>[&] (pEntity<s(0)(0)(0)>[&]->entity<s(0)(0)(0)>[&]);
            baseaddr<s(0)(0)(0)>[&] = cah_em4_getEntityBase<s(0)(0)(0)>[&] (pEntity<s(0)(0)(0)>[&]->entity<s(0)(0)(0)>[&], 100);
            instance<s(0)(0)(0)>[&] = (CTD_SlotToInstance<s(0)(0)(0)>[&]((  pEntity<s(0)(0)(0)>[&]->entity<s(0)(0)(0)>[&]  ) )) ;

            if (EM4_ENTITY_LATCH<s(0)(0)(0)>[&] == Status<s(0)(0)(0)>[&])
            {
                if ((EM4_ENTITY_LATCH<s(0)(0)(0)>[&] != gCahEm4TribVar<s(0)(0)(0)>[&].EM4LatchStatus<s(0)(0)(0)>[&][fdd<s(0)(0)(0)>[&]   ])
                    || (gCahEm4TribVar<s(0)(0)(0)>[&].EM4LatchForceRpt<s(0)(0)(0)>[&][   fdd<s(0)(0)(0)>[&]]))
                {
                    gCahEm4TribVar<s(0)(0)(0)>[&].EM4LatchStatus<s(0)(0)(0)>[&][   fdd<s(0)(0)(0)>[&]] = EM4_ENTITY_LATCH<s(0)(0)(0)>[&];

                    printf<s(0)(0)(0)>[&] ("\r\nEM4_EpgPoll fd %d Latch Attached! \r\n", fd<s(0)(0)(0)>[&]);
                }

                if (gCahEm4TribVar<s(0)(0)(0)>[&].EM4LatchForceRpt<s(0)(0)(0)>[&][fdd<s(0)(0)(0)>[&]   ])
                {
                    gCahEm4TribVar<s(0)(0)(0)>[&].EM4LatchForceRpt<s(0)(0)(0)>[&][fdd<s(0)(0)(0)>[&]   ] = 0 ;
                }

                if (!cah_em4_IsLatchIntEnable<s(0)(0)(0)>[&] (pEntity<s(0)(0)(0)>[&]->entity<s(0)(0)(0)>[&]))
                {
                     
                    cah_em4_enableLatchIntr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], 1);
                }
            }
            else if (EM4_ENTITY_DELATCH<s(0)(0)(0)>[&] == Status<s(0)(0)(0)>[&])
            {
                if (cah_em4_IsLatchIntEnable<s(0)(0)(0)>[&] (pEntity<s(0)(0)(0)>[&]->entity<s(0)(0)(0)>[&]))
                {
                     
                    cah_em4_enableLatchIntr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], 0);

                }

                if ((EM4_ENTITY_DELATCH<s(0)(0)(0)>[&] != gCahEm4TribVar<s(0)(0)(0)>[&].EM4LatchStatus<s(0)(0)(0)>[&][fdd<s(0)(0)(0)>[&]   ])
                    || (gCahEm4TribVar<s(0)(0)(0)>[&].EM4LatchForceRpt<s(0)(0)(0)>[&][   fdd<s(0)(0)(0)>[&]]))
                {
                    gCahEm4TribVar<s(0)(0)(0)>[&].EM4LatchStatus<s(0)(0)(0)>[&][fdd<s(0)(0)(0)>[&]   ] = EM4_ENTITY_DELATCH<s(0)(0)(0)>[&];
                    gCahEm4TribVar<s(0)(0)(0)>[&].EM4LatchForceRpt<s(0)(0)(0)>[&][fdd<s(0)(0)(0)>[&]   ] = 0 ;

                    printf<s(0)(0)(0)>[&] ("\r\nEM4_EpgPoll fd %d Latch Detached! \r\n", fd<s(0)(0)(0)>[&]);
                }

                if (gCahEm4TribVar<s(0)(0)(0)>[&].EM4LatchForceRpt<s(0)(0)(0)>[&][fdd<s(0)(0)(0)>[&]   ])
                {
                    gCahEm4TribVar<s(0)(0)(0)>[&].EM4LatchForceRpt<s(0)(0)(0)>[&][fdd<s(0)(0)(0)>[&]   ] = 0 ;
                }
            }

            intLockRet<s(0)(0)(0)>[&] = intLock<s(0)(0)(0)>[&] ();
            intCount<s(0)(0)(0)>[&] = gCahEm4TribVar<s(0)(0)(0)>[&].IntCount<s(0)(0)(0)>[&][fdd<s(0)(0)(0)>[&]   ];

            if (intCount<s(0)(0)(0)>[&] < 80 )
            {
                intLockRet<s(0)(0)(0)>[&] = intLock<s(0)(0)(0)>[&] ();
                gCahEm4TribVar<s(0)(0)(0)>[&].IntCount<s(0)(0)(0)>[&][fdd<s(0)(0)(0)>[&]   ] = 0;
            }
            else
            {
                printf<s(0)(0)(0)>[&] ("\r\n**Error!  Entity= %d; File=%s; Line=%d  \r\n", fd<s(0)(0)(0)>[&], "cah_126e1.c", 5502);
            }
        }
    }
}



 


int
CAH_EM4_enableLOMLOF<s(0)(0)(0)>[&] (ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&], int chip<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&], int enable<s(0)(0)(0)>[&])
{
    CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *pEntity<s(0)(0)(0)>[&] =(D2) ((void *)0) ;
     


    cah_em4_trace<s(0)(0)(0)>[&] (36, "%s: entity(%d), port(%d), enalbe(%d)", __FUNCTION__<s(0)(0)(0)>[&], entity<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&], enable<s(0)(0)(0)>[&]);

    if (0 > port<s(0)(0)(0)>[&] || 62 < port<s(0)(0)(0)>[&])
    {
        printf<s(0)(0)(0)>[&] ("\r\n%s: port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&]);
        return ((WORD<s(0)(0)(0)>[T])0x1) ;
    }

    pEntity<s(0)(0)(0)>[&] = cah_em4_getEntityPtr<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&]);
    cah_em4_registerCall<s(0)(0)(0)>[&] ((PMyFun<s(0)(0)(0)>[T]) CAH_EM4_enableLOMLOF<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&], enable<s(0)(0)(0)>[&], 0, 26, __FUNCTION__<s(0)(0)(0)>[&]);

    if (pEntity<s(0)(0)(0)>[&]->state<s(0)(0)(0)>[&] != eEm4EntAct<s(0)(0)(0)>[&])
    {
        return PB_ERR_STATE<s(0)(0)(0)>[&];
    }


    cah_em4_trace<s(0)(0)(0)>[&] (35, "%s: entity(%d), port(%d), enalbe(%d)", __FUNCTION__<s(0)(0)(0)>[&], entity<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&], enable<s(0)(0)(0)>[&]);
    pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][chip<s(0)(0)(0)>[&]].isRptLOM<s(0)(0)(0)>[&][port<s(0)(0)(0)>[&]] = enable<s(0)(0)(0)>[&];
    pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][chip<s(0)(0)(0)>[&]].forceRptAlm<s(0)(0)(0)>[&][port<s(0)(0)(0)>[&]] = 1 ;

    return ((WORD<s(0)(0)(0)>[T])0x0) ;
}




PB_ERROR_CODE_T<s(0)(0)(0)>[T]
CAH_EM4_initModule<s(0)(0)(0)>[&] ()
{
    return cah_em4_initModule<s(0)(0)(0)>[&] ();
}

int cah_em4_initPortMap<s(0)(0)(0)>[&] (void);(D1:cah_em4_initPortMap:0)
PB_ERROR_CODE_T<s(0)(0)(0)>[T]
CAH_EM4_loadModule<s(0)(0)(0)>[&] ()
{
    static int flag<s(0)(0)(0)>[&] =(D2) 0;

    if (flag<s(0)(0)(0)>[&]) return 0;
    flag<s(0)(0)(0)>[&] = 1;
    cah_em4_init_nothing<s(0)(0)(0)>[&] ();
    cah_em4_initPortMap<s(0)(0)(0)>[&] ();
    return cah_em4_loadModule<s(0)(0)(0)>[&] ();
}


PB_ERROR_CODE_T<s(0)(0)(0)>[T]
CAH_EM4_ForceAIS<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], int nport<s(0)(0)(0)>[&], eEM4SWITCH<s(0)(0)(0)>[T] ais<s(0)(0)(0)>[&])
{



    void *base<s(0)(0)(0)>[&] =(D2) ((void *)0) ;
    CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *pEntity<s(0)(0)(0)>[&] =(D2) ((void *)0) ;
    ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&] =(D2) 0;
    int port<s(0)(0)(0)>[&] =(D2) 0;

    port<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (nport<s(0)(0)(0)>[&]) - 1;;

    if (0 > port<s(0)(0)(0)>[&] || 62 < port<s(0)(0)(0)>[&])
    {
        printf<s(0)(0)(0)>[&] ("\r\nEM4_ForceAIS : port(%d) overflow", port<s(0)(0)(0)>[&]);
        return (((WORD<s(0)(0)(0)>[T])0x1) );
    }

    base<s(0)(0)(0)>[&] = cah_em4_getEntityBase<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&]);
    if (gCahEm4SelectPort<s(0)(0)(0)>[&] == port<s(0)(0)(0)>[&])
    {
        cah_em4_trace<s(0)(0)(0)>[&] (40 , "\r\n%s(): entity(%d), port(%d), base(%p)", __FUNCTION__<s(0)(0)(0)>[&],
                       entity<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&], base<s(0)(0)(0)>[&]);
    }
    cah_em4_forceAis<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&], ais<s(0)(0)(0)>[&]);
    pEntity<s(0)(0)(0)>[&] = cah_em4_getEntity<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&]);

    pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][0].isFrcais<s(0)(0)(0)>[&][port<s(0)(0)(0)>[&]] = ais<s(0)(0)(0)>[&];

    return (((WORD<s(0)(0)(0)>[T])0x0) );


    return 0;

}

 





PB_ERROR_CODE_T<s(0)(0)(0)>[T]
CAH_EM4_forceRDI<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], int nport<s(0)(0)(0)>[&], eEM4SWITCH<s(0)(0)(0)>[T] rdi<s(0)(0)(0)>[&])
{




    CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *pEntity<s(0)(0)(0)>[&] =(D2) ((void *)0) ;
    void *base<s(0)(0)(0)>[&] =(D2) ((void *)0) ;
    ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&] =(D2) 0;
    int port<s(0)(0)(0)>[&] =(D2) 0;

    port<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (nport<s(0)(0)(0)>[&]) - 1;;

    base<s(0)(0)(0)>[&] = cah_em4_getEntityBase<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&]);
    cah_em4_trace<s(0)(0)(0)>[&] (34, "\r\nentity(%d), port(%d), base(%p), rdi(%d)", entity<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&], base<s(0)(0)(0)>[&], rdi<s(0)(0)(0)>[&]);
    cah_em4_forceRdi<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&], rdi<s(0)(0)(0)>[&]);

    pEntity<s(0)(0)(0)>[&] = cah_em4_getEntity<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&]);
    pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][0].isFrcrdi<s(0)(0)(0)>[&][port<s(0)(0)(0)>[&]] = rdi<s(0)(0)(0)>[&];

    return (((WORD<s(0)(0)(0)>[T])0x0) );


    return 0;
}


WORD<s(0)(0)(0)>[T]
CAH_EM4_EnableReTiming<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&])
{




    void *base<s(0)(0)(0)>[&] =(D2) ((void *)0) ;
    int ulPort<s(0)(0)(0)>[&] =(D2) 0;

    {if (125 <  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;
    ulPort<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&])) - 1;
    base<s(0)(0)(0)>[&] = cah_em4_getEntityBase<s(0)(0)(0)>[&] (0, SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]));
    cah_em4_registerCall<s(0)(0)(0)>[&] ((PMyFun<s(0)(0)(0)>[T]) CAH_EM4_EnableReTiming<s(0)(0)(0)>[&], (int) SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]), (int) bEnable<s(0)(0)(0)>[&], 0, 111, __FUNCTION__<s(0)(0)(0)>[&]);
    cah_em4_set_inloopretiming<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], ulPort<s(0)(0)(0)>[&], eEM4_DISABLE<s(0)(0)(0)>[&]   ,
                                bEnable<s(0)(0)(0)>[&] ? eEM4_ENABLE<s(0)(0)(0)>[&] : eEM4_DISABLE<s(0)(0)(0)>[&]);

    return ((WORD<s(0)(0)(0)>[T])0x0) ;

}

WORD<s(0)(0)(0)>[T] cah_em4_getTimingRef<s(0)(0)(0)>[&] (BYTE<s(0)(0)(0)>[T] mid_port<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] *byPort<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&])
{
    return 0;
}

int em4_queryPortFromSlot<s(0)(0)(0)>[&](int slot<s(0)(0)(0)>[&]);(D1:slot:0)
int testgettiming<s(0)(0)(0)>[&] (byclocknum<s(0)(0)(0)>[&])
{
    BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&] =(D2) 0;
    BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&] =(D2) 0;

    CAH_EM4_GetTimingRef<s(0)(0)(0)>[&] (0, byclocknum<s(0)(0)(0)>[&], &byPortNo<s(0)(0)(0)>[&], &bEnable<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\n%s(): byclock(%d), byPort(%d), enable(%d)", __FUNCTION__<s(0)(0)(0)>[&], byclocknum<s(0)(0)(0)>[&], byPortNo<s(0)(0)(0)>[&], bEnable<s(0)(0)(0)>[&]);
    return 0;
}

int g_testtiming<s(0)(0)(0)>[&] =(D2) 0;
int g_testtiming1<s(0)(0)(0)>[&] =(D2) 0;

 
WORD<s(0)(0)(0)>[T]
CAH_EM4_GetTimingRef<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byClockNum<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] * byPortNo<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] * bEnable<s(0)(0)(0)>[&])
{
    WORD<s(0)(0)(0)>[T]   wRtn<s(0)(0)(0)>[&]       =(D2) ((WORD<s(0)(0)(0)>[T])0x0) ;
    BYTE<s(0)(0)(0)>[T]	wRegValue<s(0)(0)(0)>[&] =(D2) 0x0;
    BYTE<s(0)(0)(0)>[T] port<s(0)(0)(0)>[&] =(D2) 0;  

    wRtn<s(0)(0)(0)>[&] = cah_Read8Reg<s(0)(0)(0)>[&](0x70000000 , 0x1b  + byClockNum<s(0)(0)(0)>[&], &wRegValue<s(0)(0)(0)>[&], 0x0F, CAH_REG_ATTRBT_RW<s(0)(0)(0)>[&]);
    port<s(0)(0)(0)>[&] = (wRegValue<s(0)(0)(0)>[&] & 0x7) + 1;
if (g_testtiming1<s(0)(0)(0)>[&])
printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%3d), wRegValue(%4x)", __FUNCTION__<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&] - 1, wRegValue<s(0)(0)(0)>[&]);
    if(!(wRegValue<s(0)(0)(0)>[&] & 0x08))
    {
		*bEnable<s(0)(0)(0)>[&] = 1 ;	
    }
    else
    {
		*bEnable<s(0)(0)(0)>[&] = 0 ;
		port<s(0)(0)(0)>[&] = 0;
    }
 
    if (0 == port<s(0)(0)(0)>[&]) 
    {
        *byPortNo<s(0)(0)(0)>[&] = 0;
        return ((WORD<s(0)(0)(0)>[T])0x0) ;
    } else {
        *byPortNo<s(0)(0)(0)>[&] = em4_queryPortFromSlot<s(0)(0)(0)>[&](port<s(0)(0)(0)>[&]);
if (g_testtiming1<s(0)(0)(0)>[&])
        printf<s(0)(0)(0)>[&] ("\r\n%s(): virtualport(%3d), realport(%3d)", __FUNCTION__<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&], *byPortNo<s(0)(0)(0)>[&]);
    }

    { { if (DBG_GetLevel<s(0)(0)(0)>[&](  gCahDbgModuleNo<s(0)(0)(0)>[&] ,    CAH_DEBUG_LEVEL_CLOCK<s(0)(0)(0)>[&]  )) {printf<s(0)(0)(0)>[&]("[%s] %d: ", "cah_126e1.c", 5710); printf<s(0)(0)(0)>[&]   ("\r\n CAH_S14_GetTimingRef: Port = [%d], clock = [%d], wRegValue = [0x%x], bEnable = [%d]", *byPortNo<s(0)(0)(0)>[&] , byClockNum<s(0)(0)(0)>[&], wRegValue<s(0)(0)(0)>[&], *bEnable<s(0)(0)(0)>[&])  ;} if (DBG_NvGetLevel<s(0)(0)(0)>[&](  gCahDbgModuleNo<s(0)(0)(0)>[&] ,    CAH_DEBUG_LEVEL_CLOCK<s(0)(0)(0)>[&]  ))    ; } ; } ;    
 
    return ((WORD<s(0)(0)(0)>[T])0x0) ;
}

 


int em4_queryPortFromSlot<s(0)(0)(0)>[&](int slot<s(0)(0)(0)>[&])
{
    int port<s(0)(0)(0)>[&] =(D2) 0;
    void * base<s(0)(0)(0)>[&] =(D2) 0;
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0;

    if (4 >= slot<s(0)(0)(0)>[&])
    {
        base<s(0)(0)(0)>[&] = cah_em4_getEntityBase<s(0)(0)(0)>[&] (0, 1);     
        u<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], ((0x05 << 10) | 0x200 ) + (slot<s(0)(0)(0)>[&]-1) / 2);
        if ((slot<s(0)(0)(0)>[&]) % 2)
        {
            if ((0x3f)  == (u<s(0)(0)(0)>[&] & 0xff))
            {
                return 0;
            } else {
                return (u<s(0)(0)(0)>[&] & 0xff);
            }
        } else {
            if ((0x3f)  == ((u<s(0)(0)(0)>[&] & 0xff00)>>8))
            {
                return 0;
            } else {
                return ((u<s(0)(0)(0)>[&] & 0xff00)>>8);
            }
        }
    } else {
        base<s(0)(0)(0)>[&] = cah_em4_getEntityBase<s(0)(0)(0)>[&] (0, 100);     
        u<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], ((0x05 << 10) | 0x200 ) + (slot<s(0)(0)(0)>[&]-1-4) / 2);
if (g_testtiming1<s(0)(0)(0)>[&])
printf<s(0)(0)(0)>[&] ("\r\nbase(%p), u(%x), slot(%d),(slot-1-4)/2(%d)", base<s(0)(0)(0)>[&], u<s(0)(0)(0)>[&], slot<s(0)(0)(0)>[&], (slot<s(0)(0)(0)>[&]-1-4)/2);
        if ((slot<s(0)(0)(0)>[&]) % 2)
        {
            if ((0x3f)  == (u<s(0)(0)(0)>[&] & 0xff))
            {
                return 0;
            } else {
                return (u<s(0)(0)(0)>[&] & 0xff) + 63;
            }
        } else {
            if ((0x3f)  == ((u<s(0)(0)(0)>[&] & 0xff00)>>8))
            {
                return 0;
            } else {
                return ((u<s(0)(0)(0)>[&] & 0xff00)>>8) + 63;
            }
        }
    }

    return (port<s(0)(0)(0)>[&]);
}

int g_timingVirtualSlot<s(0)(0)(0)>[&] [8];(D1:g_timingVirtualSlot:0)

int em4_getSlotFrom126port<s(0)(0)(0)>[&] (int port<s(0)(0)(0)>[&], int enable<s(0)(0)(0)>[&])
{
    int slot<s(0)(0)(0)>[&] =(D2) 99;
    int n<s(0)(0)(0)>[&] =(D2) 0;
    void * base<s(0)(0)(0)>[&] =(D2) 0;
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0, u1<s(0)(0)(0)>[&] =(D2) 0;


    n<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (port<s(0)(0)(0)>[&]) - 1;
    base<s(0)(0)(0)>[&] = cah_em4_getEntityBase<s(0)(0)(0)>[&] (0, port<s(0)(0)(0)>[&]);     
    u<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x05 << 10) | 0x200 );
    u1<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], ((0x05 << 10) | 0x200 ) + 1);
    if (g_testtiming<s(0)(0)(0)>[&]) printf<s(0)(0)(0)>[&] ("\r\n%s(): EM4_RCK_0_1_SEL(%x),EM4_RCK_0_1_SEL+1(%x)", __FUNCTION__<s(0)(0)(0)>[&], u<s(0)(0)(0)>[&], u1<s(0)(0)(0)>[&]);

    
    if (0 <= port<s(0)(0)(0)>[&] && 62 >= port<s(0)(0)(0)>[&])
    {
        if ((u<s(0)(0)(0)>[&] & 0xff) == n<s(0)(0)(0)>[&]) 
        {            
            if (g_testtiming<s(0)(0)(0)>[&]) printf<s(0)(0)(0)>[&] ("\r\n%s(): found: 0", __FUNCTION__<s(0)(0)(0)>[&]);
            slot<s(0)(0)(0)>[&] = 0;
            if (0 == enable<s(0)(0)(0)>[&])
            {
                g_timingVirtualSlot<s(0)(0)(0)>[&][0] = (0x3f) ;
                u<s(0)(0)(0)>[&] &= 0xff00;
                u<s(0)(0)(0)>[&] |= 0x00ff;
                cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x05 << 10) | 0x200 , u<s(0)(0)(0)>[&]);
            }
        }
        if (((u<s(0)(0)(0)>[&] & 0xff00) >> 8) == n<s(0)(0)(0)>[&]) 
        {
            if (g_testtiming<s(0)(0)(0)>[&]) printf<s(0)(0)(0)>[&] ("\r\n%s(): found: 1", __FUNCTION__<s(0)(0)(0)>[&]);
            slot<s(0)(0)(0)>[&] = 1;
            if (0 == enable<s(0)(0)(0)>[&])
            {
                g_timingVirtualSlot<s(0)(0)(0)>[&][1] = (0x3f) ;
                u<s(0)(0)(0)>[&] &= 0x00ff;
                u<s(0)(0)(0)>[&] |= 0xff00;
                cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x05 << 10) | 0x200 , u<s(0)(0)(0)>[&]);
            }
        }

        if ((u1<s(0)(0)(0)>[&] & 0xff) == n<s(0)(0)(0)>[&])         
        {
            if (g_testtiming<s(0)(0)(0)>[&]) printf<s(0)(0)(0)>[&] ("\r\n%s(): found: 2", __FUNCTION__<s(0)(0)(0)>[&]);
            slot<s(0)(0)(0)>[&] = 2;
            if (0 == enable<s(0)(0)(0)>[&])
            {
                g_timingVirtualSlot<s(0)(0)(0)>[&][2] = (0x3f) ;
                u1<s(0)(0)(0)>[&] &= 0xff00;
                u1<s(0)(0)(0)>[&] |= 0x00ff;
                cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (((0x05 << 10) | 0x200 )+1), u1<s(0)(0)(0)>[&]);
            }
        }
        if (((u1<s(0)(0)(0)>[&] & 0xff00) >> 8) == n<s(0)(0)(0)>[&])  
        { 
            if (g_testtiming<s(0)(0)(0)>[&]) printf<s(0)(0)(0)>[&] ("\r\n%s(): found: 3", __FUNCTION__<s(0)(0)(0)>[&]);
            slot<s(0)(0)(0)>[&] = 3;
            if (0 == enable<s(0)(0)(0)>[&])
            {
                g_timingVirtualSlot<s(0)(0)(0)>[&][3] = (0x3f) ;
                u1<s(0)(0)(0)>[&] &= 0x00ff;
                u1<s(0)(0)(0)>[&] |= 0xff00;
                cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (((0x05 << 10) | 0x200 )+1), u1<s(0)(0)(0)>[&]);
            }
        }
    } else {
        if ((u<s(0)(0)(0)>[&] & 0xff) == n<s(0)(0)(0)>[&])
        {
            if (g_testtiming<s(0)(0)(0)>[&]) printf<s(0)(0)(0)>[&] ("\r\n%s(): found: 4", __FUNCTION__<s(0)(0)(0)>[&]);
            slot<s(0)(0)(0)>[&] = 4;
            if (0 == enable<s(0)(0)(0)>[&])
            {
                g_timingVirtualSlot<s(0)(0)(0)>[&][4] = (0x3f) ;
                u<s(0)(0)(0)>[&] &= 0xff00;
                u<s(0)(0)(0)>[&] |= 0x00ff;
                cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], ((0x05 << 10) | 0x200 ), u<s(0)(0)(0)>[&]);
            }
        }
        if (((u<s(0)(0)(0)>[&] & 0xff00) >> 8) == n<s(0)(0)(0)>[&])    
        {
            if (g_testtiming<s(0)(0)(0)>[&]) printf<s(0)(0)(0)>[&] ("\r\n%s(): found: 5", __FUNCTION__<s(0)(0)(0)>[&]);
            slot<s(0)(0)(0)>[&] = 5;
            if (0 == enable<s(0)(0)(0)>[&])
            {
                g_timingVirtualSlot<s(0)(0)(0)>[&][5] = (0x3f) ;
                u<s(0)(0)(0)>[&] &= 0x00ff;
                u<s(0)(0)(0)>[&] |= 0xff00;
                cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], ((0x05 << 10) | 0x200 ), u<s(0)(0)(0)>[&]);
            }
        }
        if ((u1<s(0)(0)(0)>[&] & 0xff) == n<s(0)(0)(0)>[&])            
        {
            if (g_testtiming<s(0)(0)(0)>[&]) printf<s(0)(0)(0)>[&] ("\r\n%s(): found: 6", __FUNCTION__<s(0)(0)(0)>[&]);
            slot<s(0)(0)(0)>[&] = 6;
            if (0 == enable<s(0)(0)(0)>[&])
            {
                g_timingVirtualSlot<s(0)(0)(0)>[&][6] = (0x3f) ;
                u1<s(0)(0)(0)>[&] &= 0xff00;
                u1<s(0)(0)(0)>[&] |= 0x00ff;
                cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (((0x05 << 10) | 0x200 ) + 1), u1<s(0)(0)(0)>[&]);
            }
        }
        if (((u1<s(0)(0)(0)>[&] & 0xff00) >> 8) == n<s(0)(0)(0)>[&])   
        {
            if (g_testtiming<s(0)(0)(0)>[&]) printf<s(0)(0)(0)>[&] ("\r\n%s(): found: 7", __FUNCTION__<s(0)(0)(0)>[&]);
            slot<s(0)(0)(0)>[&] = 7;
            if (0 == enable<s(0)(0)(0)>[&])
            {
                g_timingVirtualSlot<s(0)(0)(0)>[&][7] = (0x3f) ;
                u1<s(0)(0)(0)>[&] &= 0x00ff;
                u1<s(0)(0)(0)>[&] |= 0xff00;
                cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (((0x05 << 10) | 0x200 ) + 1), u1<s(0)(0)(0)>[&]);
            }
        }
    }









     
    if (99 == slot<s(0)(0)(0)>[&])
    {
        if (0 <= port<s(0)(0)(0)>[&] && 62 >= port<s(0)(0)(0)>[&])
        {
            if ((u<s(0)(0)(0)>[&] & 0xff) == (0x3f) )
            {
                if (g_testtiming<s(0)(0)(0)>[&]) printf<s(0)(0)(0)>[&] ("\r\n%s(): alloc: 0", __FUNCTION__<s(0)(0)(0)>[&]);
                u<s(0)(0)(0)>[&] &= 0xff00;
                u<s(0)(0)(0)>[&] |= n<s(0)(0)(0)>[&];
                slot<s(0)(0)(0)>[&] = 0;
                cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x05 << 10) | 0x200 , u<s(0)(0)(0)>[&]);
                goto allocend<s(0)(0)(0)>[&];
            }
            if (((u<s(0)(0)(0)>[&] & 0xff00)>>8) == (0x3f) )
            {
                if (g_testtiming<s(0)(0)(0)>[&]) printf<s(0)(0)(0)>[&] ("\r\n%s(): alloc: 1", __FUNCTION__<s(0)(0)(0)>[&]);
                u<s(0)(0)(0)>[&] &= 0xff;
                u<s(0)(0)(0)>[&] |= (n<s(0)(0)(0)>[&] << 8);
                slot<s(0)(0)(0)>[&] = 1;
                cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x05 << 10) | 0x200 , u<s(0)(0)(0)>[&]);
                goto allocend<s(0)(0)(0)>[&];
            }
            if ((u1<s(0)(0)(0)>[&] & 0xff) == (0x3f) )
            {
                if (g_testtiming<s(0)(0)(0)>[&]) printf<s(0)(0)(0)>[&] ("\r\n%s(): alloc: 2", __FUNCTION__<s(0)(0)(0)>[&]);
                u1<s(0)(0)(0)>[&] &= 0xff00;
                u1<s(0)(0)(0)>[&] |= n<s(0)(0)(0)>[&];
                slot<s(0)(0)(0)>[&] = 2;
                cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], ((0x05 << 10) | 0x200 ) + 1, u1<s(0)(0)(0)>[&]);
                goto allocend<s(0)(0)(0)>[&];
            }
            if (((u1<s(0)(0)(0)>[&] & 0xff00)>>8) == (0x3f) )
            {
                if (g_testtiming<s(0)(0)(0)>[&]) printf<s(0)(0)(0)>[&] ("\r\n%s(): alloc: 3", __FUNCTION__<s(0)(0)(0)>[&]);
                u1<s(0)(0)(0)>[&] &= 0xff;
                u1<s(0)(0)(0)>[&] |= (n<s(0)(0)(0)>[&] << 8);
                slot<s(0)(0)(0)>[&] = 3;
                cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], ((0x05 << 10) | 0x200 ) + 1, u1<s(0)(0)(0)>[&]);
                goto allocend<s(0)(0)(0)>[&];
            }
        } else {
            if ((u<s(0)(0)(0)>[&] & 0xff) == (0x3f) )
            {
                if (g_testtiming<s(0)(0)(0)>[&]) printf<s(0)(0)(0)>[&] ("\r\n%s(): alloc: 4", __FUNCTION__<s(0)(0)(0)>[&]);
                u<s(0)(0)(0)>[&] &= 0xff00;
                u<s(0)(0)(0)>[&] |= n<s(0)(0)(0)>[&];
                slot<s(0)(0)(0)>[&] = 4;
                cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x05 << 10) | 0x200 , u<s(0)(0)(0)>[&]);
                goto allocend<s(0)(0)(0)>[&];
            }
            if (((u<s(0)(0)(0)>[&] & 0xff00)>>8) == (0x3f) )
            {
                if (g_testtiming<s(0)(0)(0)>[&]) printf<s(0)(0)(0)>[&] ("\r\n%s(): alloc: 5", __FUNCTION__<s(0)(0)(0)>[&]);
                u<s(0)(0)(0)>[&] &= 0xff;
                u<s(0)(0)(0)>[&] |= (n<s(0)(0)(0)>[&] << 8);
                slot<s(0)(0)(0)>[&] = 5;
                cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x05 << 10) | 0x200 , u<s(0)(0)(0)>[&]);
                goto allocend<s(0)(0)(0)>[&];
            }
            if ((u1<s(0)(0)(0)>[&] & 0xff) == (0x3f) )
            {
                if (g_testtiming<s(0)(0)(0)>[&]) printf<s(0)(0)(0)>[&] ("\r\n%s(): alloc: 6", __FUNCTION__<s(0)(0)(0)>[&]);
                u1<s(0)(0)(0)>[&] &= 0xff00;
                u1<s(0)(0)(0)>[&] |= n<s(0)(0)(0)>[&];
                slot<s(0)(0)(0)>[&] = 6;
                cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], ((0x05 << 10) | 0x200 ) + 1, u1<s(0)(0)(0)>[&]);
                goto allocend<s(0)(0)(0)>[&];
            }
            if (((u1<s(0)(0)(0)>[&] & 0xff00)>>8) == (0x3f) )
            {
                if (g_testtiming<s(0)(0)(0)>[&]) printf<s(0)(0)(0)>[&] ("\r\n%s(): alloc: 7", __FUNCTION__<s(0)(0)(0)>[&]);
                u1<s(0)(0)(0)>[&] &= 0xff;
                u1<s(0)(0)(0)>[&] |= (n<s(0)(0)(0)>[&] << 8);
                slot<s(0)(0)(0)>[&] = 7;
                cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], ((0x05 << 10) | 0x200 ) + 1, u1<s(0)(0)(0)>[&]);
                goto allocend<s(0)(0)(0)>[&];
            }
        }
    }

allocend<s(0)(0)(0)>[&]:
    return (slot<s(0)(0)(0)>[&] + 1);
}

int g_timing<s(0)(0)(0)>[&] =(D2) 0;

int cah_em4_setTimingRef84<s(0)(0)(0)>[&] (port_mid<s(0)(0)(0)>[&], byClockNum<s(0)(0)(0)>[&], bEnable<s(0)(0)(0)>[&])
{
    WORD<s(0)(0)(0)>[T]   wRtn<s(0)(0)(0)>[&]       =(D2) ((WORD<s(0)(0)(0)>[T])0x0) ;
    int byPortNo<s(0)(0)(0)>[&] =(D2) port_mid<s(0)(0)(0)>[&];

if (g_timing<s(0)(0)(0)>[&]) printf<s(0)(0)(0)>[&] ("\r\n%s(): port_mid(%d)", __FUNCTION__<s(0)(0)(0)>[&], port_mid<s(0)(0)(0)>[&]);

    if (bEnable<s(0)(0)(0)>[&])
    {
    	 
    	wRtn<s(0)(0)(0)>[&] = cah_Write8Reg<s(0)(0)(0)>[&] (0x70000000 ,                      0x1b  + byClockNum<s(0)(0)(0)>[&],                      byPortNo<s(0)(0)(0)>[&],                      0x07,                      CAH_REG_ATTRBT_RW<s(0)(0)(0)>[&]);




	     
    	wRtn<s(0)(0)(0)>[&] = cah_Write8Reg<s(0)(0)(0)>[&] (0x70000000 ,                      0x1b  + byClockNum<s(0)(0)(0)>[&],                      0x0,                      0x08,                      CAH_REG_ATTRBT_RW<s(0)(0)(0)>[&]);




	
    } else {
    	
    	wRtn<s(0)(0)(0)>[&] = cah_Write8Reg<s(0)(0)(0)>[&] (0x70000000 ,                      0x1b  + byClockNum<s(0)(0)(0)>[&],                      0x07,                      0x07,                      CAH_REG_ATTRBT_RW<s(0)(0)(0)>[&]);




	 
    	wRtn<s(0)(0)(0)>[&] = cah_Write8Reg<s(0)(0)(0)>[&] (0x70000000 ,                      0x1b  + byClockNum<s(0)(0)(0)>[&],                       0x0,                       0x08 ,                       CAH_REG_ATTRBT_RW<s(0)(0)(0)>[&]);




	
    }
     
    return wRtn<s(0)(0)(0)>[&];
}

void cah_em4_InitTiming<s(0)(0)(0)>[&] (void)
{
    static int flag<s(0)(0)(0)>[&] =(D2) 0;

    if (flag<s(0)(0)(0)>[&] == 1)
    {   
        return ;
    }
   
    flag<s(0)(0)(0)>[&] = 1;
 
    cah_em4_wr<s(0)(0)(0)>[&] ((void *)(0x50000000) , (0x05 << 10) | 0x200 , (0x3f)  | ((0x3f)  << 8));
    cah_em4_wr<s(0)(0)(0)>[&] ((void *)(0x50000000) , (0x05 << 10) | 0x201 , (0x3f)  | ((0x3f)  << 8));
    cah_em4_wr<s(0)(0)(0)>[&] ((void *)(0x60000000) , (0x05 << 10) | 0x200 , (0x3f)  | ((0x3f)  << 8));
    cah_em4_wr<s(0)(0)(0)>[&] ((void *)(0x60000000) , (0x05 << 10) | 0x201 , (0x3f)  | ((0x3f)  << 8));
}

int cah_em4_initPortMap<s(0)(0)(0)>[&] (void)
{
    int i<s(0)(0)(0)>[&] =(D2) 0;

    memset<s(0)(0)(0)>[&] (g_phyportmap<s(0)(0)(0)>[&], 0, 4 * 130);
    for (i<s(0)(0)(0)>[&] = 0; i<s(0)(0)(0)>[&] < 130; i<s(0)(0)(0)>[&] ++)
    {
        g_phyportmap<s(0)(0)(0)>[&][i<s(0)(0)(0)>[&]] = i<s(0)(0)(0)>[&];
    }

    g_phyportmap<s(0)(0)(0)>[&][9] = 9;
    g_phyportmap<s(0)(0)(0)>[&][10] = 10;
    g_phyportmap<s(0)(0)(0)>[&][11] = 11;
    g_phyportmap<s(0)(0)(0)>[&][12] = 12;
    g_phyportmap<s(0)(0)(0)>[&][34] = 34;
    g_phyportmap<s(0)(0)(0)>[&][35] = 35;
    g_phyportmap<s(0)(0)(0)>[&][39] = 39;
    g_phyportmap<s(0)(0)(0)>[&][40] = 40;
    g_phyportmap<s(0)(0)(0)>[&][41] = 41;
    g_phyportmap<s(0)(0)(0)>[&][42] = 42;
    g_phyportmap<s(0)(0)(0)>[&][43] = 43;
    g_phyportmap<s(0)(0)(0)>[&][44] = 44;
    g_phyportmap<s(0)(0)(0)>[&][63] = 63;
    g_phyportmap<s(0)(0)(0)>[&][64] = 64;


    return 0;
}



unsigned short em4_bpc_wr<s(0)(0)(0)>[&] (int page<s(0)(0)(0)>[&], int off<s(0)(0)(0)>[&], unsigned short val<s(0)(0)(0)>[&]);(D1:val:0)
WORD<s(0)(0)(0)>[T]
CAH_EM4_SetTimingRef<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPort<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byClockNum<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&])
{
    int port_mid<s(0)(0)(0)>[&] =(D2) 0 , n<s(0)(0)(0)>[&] =(D2) 0;
    void * base<s(0)(0)(0)>[&] =(D2) ((void *)0) ;
    BYTE<s(0)(0)(0)>[T] byPortCopy<s(0)(0)(0)>[&] =(D2) SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPort<s(0)(0)(0)>[&]), realport<s(0)(0)(0)>[&] =(D2) 0;
    BOOL<s(0)(0)(0)>[T] status<s(0)(0)(0)>[&];(D1:status:0)
    unsigned short c1<s(0)(0)(0)>[&] =(D2) 0, c2<s(0)(0)(0)>[&] =(D2) 0, ccc<s(0)(0)(0)>[&] =(D2) 0;
    unsigned char pt<s(0)(0)(0)>[&] =(D2) 0;

     
    {if (125 <  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPort<s(0)(0)(0)>[&]) ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPort<s(0)(0)(0)>[&]) ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;
    cah_em4_registerCall<s(0)(0)(0)>[&] ((PMyFun<s(0)(0)(0)>[T]) CAH_EM4_SetTimingRef<s(0)(0)(0)>[&], (int) SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPort<s(0)(0)(0)>[&]), (int) byClockNum<s(0)(0)(0)>[&], bEnable<s(0)(0)(0)>[&], 1, __FUNCTION__<s(0)(0)(0)>[&]);
    
    if (0 == bEnable<s(0)(0)(0)>[&])
    {
        CAH_EM4_GetTimingRef<s(0)(0)(0)>[&] (0, byClockNum<s(0)(0)(0)>[&], &realport<s(0)(0)(0)>[&], &status<s(0)(0)(0)>[&]);
        byPortCopy<s(0)(0)(0)>[&] = realport<s(0)(0)(0)>[&];
        if (g_testtiming<s(0)(0)(0)>[&]) printf<s(0)(0)(0)>[&] ("\r\nGetRef() GOT: byClockNum(%d), realport(%03d)",byClockNum<s(0)(0)(0)>[&], realport<s(0)(0)(0)>[&]); 
    }

    n<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPort<s(0)(0)(0)>[&])) - 1;
    base<s(0)(0)(0)>[&] = cah_em4_getEntityBase<s(0)(0)(0)>[&] (0, byPortCopy<s(0)(0)(0)>[&]);     

    port_mid<s(0)(0)(0)>[&] = em4_getSlotFrom126port<s(0)(0)(0)>[&] (byPortCopy<s(0)(0)(0)>[&], bEnable<s(0)(0)(0)>[&]);
    if (g_testtiming<s(0)(0)(0)>[&]) printf<s(0)(0)(0)>[&] ("\r\n%s(): byPortCopy(%03d)(%03d), byClockNum(%d), en(%d), mid(%d)", __FUNCTION__<s(0)(0)(0)>[&], byPortCopy<s(0)(0)(0)>[&], byPort<s(0)(0)(0)>[&], byClockNum<s(0)(0)(0)>[&], bEnable<s(0)(0)(0)>[&], port_mid<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\n%s(): byPortCopy(%03d)(%03d), byClockNum(%d), en(%d), mid(%d)", __FUNCTION__<s(0)(0)(0)>[&], byPortCopy<s(0)(0)(0)>[&], byPort<s(0)(0)(0)>[&], byClockNum<s(0)(0)(0)>[&], bEnable<s(0)(0)(0)>[&], port_mid<s(0)(0)(0)>[&]);








 
    c1<s(0)(0)(0)>[&] = em4Map1Rd<s(0)(0)(0)>[&] (5, 0x200);
    pt<s(0)(0)(0)>[&] = (c1<s(0)(0)(0)>[&] & 0xff) + 1; if (pt<s(0)(0)(0)>[&] > 129) return (((WORD<s(0)(0)(0)>[T])0x2) );
    ccc<s(0)(0)(0)>[&] = (g_phyportmap<s(0)(0)(0)>[&][pt<s(0)(0)(0)>[&]] - 1);
    c1<s(0)(0)(0)>[&] &= 0xff00;
    c1<s(0)(0)(0)>[&] |= ccc<s(0)(0)(0)>[&];

    pt<s(0)(0)(0)>[&] = ((c1<s(0)(0)(0)>[&] & 0xff00)>>8) + 1; if (pt<s(0)(0)(0)>[&] > 129) return (((WORD<s(0)(0)(0)>[T])0x2) );
    ccc<s(0)(0)(0)>[&] = (g_phyportmap<s(0)(0)(0)>[&][pt<s(0)(0)(0)>[&]] - 1);
    c1<s(0)(0)(0)>[&] &= 0xff;
    c1<s(0)(0)(0)>[&] |= ccc<s(0)(0)(0)>[&] << 8;

 
    c2<s(0)(0)(0)>[&] = em4Map1Rd<s(0)(0)(0)>[&] (5, 0x201);
    pt<s(0)(0)(0)>[&] = (c2<s(0)(0)(0)>[&] & 0xff) + 1; if (pt<s(0)(0)(0)>[&] > 129) return (((WORD<s(0)(0)(0)>[T])0x2) );
    ccc<s(0)(0)(0)>[&] = (g_phyportmap<s(0)(0)(0)>[&][pt<s(0)(0)(0)>[&]] - 1);
    c2<s(0)(0)(0)>[&] &= 0xff00;
    c2<s(0)(0)(0)>[&] |= ccc<s(0)(0)(0)>[&];

    pt<s(0)(0)(0)>[&] = ((c2<s(0)(0)(0)>[&] & 0xff00)>>8) + 1; if (pt<s(0)(0)(0)>[&] > 129) return (((WORD<s(0)(0)(0)>[T])0x2) );
    ccc<s(0)(0)(0)>[&] = (g_phyportmap<s(0)(0)(0)>[&][pt<s(0)(0)(0)>[&]] - 1);
    c2<s(0)(0)(0)>[&] &= 0xff;
    c2<s(0)(0)(0)>[&] |= ccc<s(0)(0)(0)>[&] << 8;


    em4_bpc_wr<s(0)(0)(0)>[&] (0x03, 0x07, c1<s(0)(0)(0)>[&]);
    em4_bpc_wr<s(0)(0)(0)>[&] (0x03, 0x08, c2<s(0)(0)(0)>[&]);


 

 
    c1<s(0)(0)(0)>[&] = em4Map2Rd<s(0)(0)(0)>[&] (5, 0x200);
    pt<s(0)(0)(0)>[&] = (c1<s(0)(0)(0)>[&] & 0xff) + 1; if (pt<s(0)(0)(0)>[&] > 129) return (((WORD<s(0)(0)(0)>[T])0x2) );
    ccc<s(0)(0)(0)>[&] = (g_phyportmap<s(0)(0)(0)>[&][pt<s(0)(0)(0)>[&]] - 1);
    c1<s(0)(0)(0)>[&] &= 0xff00;
    c1<s(0)(0)(0)>[&] |= ccc<s(0)(0)(0)>[&];

    pt<s(0)(0)(0)>[&] = ((c1<s(0)(0)(0)>[&] & 0xff00)>>8) + 1; if (pt<s(0)(0)(0)>[&] > 129) return (((WORD<s(0)(0)(0)>[T])0x2) );
    ccc<s(0)(0)(0)>[&] = (g_phyportmap<s(0)(0)(0)>[&][pt<s(0)(0)(0)>[&]] - 1);
    c1<s(0)(0)(0)>[&] &= 0xff;
    c1<s(0)(0)(0)>[&] |= ccc<s(0)(0)(0)>[&] << 8;

 
    c2<s(0)(0)(0)>[&] = em4Map2Rd<s(0)(0)(0)>[&] (5, 0x201);
    pt<s(0)(0)(0)>[&] = (c2<s(0)(0)(0)>[&] & 0xff) + 1; if (pt<s(0)(0)(0)>[&] > 129) return (((WORD<s(0)(0)(0)>[T])0x2) );
    ccc<s(0)(0)(0)>[&] = (g_phyportmap<s(0)(0)(0)>[&][pt<s(0)(0)(0)>[&]] - 1);
    c2<s(0)(0)(0)>[&] &= 0xff00;
    c2<s(0)(0)(0)>[&] |= ccc<s(0)(0)(0)>[&];

    pt<s(0)(0)(0)>[&] = ((c2<s(0)(0)(0)>[&] & 0xff00)>>8) + 1; if (pt<s(0)(0)(0)>[&] > 129) return (((WORD<s(0)(0)(0)>[T])0x2) );
    ccc<s(0)(0)(0)>[&] = (g_phyportmap<s(0)(0)(0)>[&][pt<s(0)(0)(0)>[&]] - 1);
    c2<s(0)(0)(0)>[&] &= 0xff;
    c2<s(0)(0)(0)>[&] |= ccc<s(0)(0)(0)>[&] << 8;

    em4_bpc_wr<s(0)(0)(0)>[&] (0x03, 0x09, c1<s(0)(0)(0)>[&]);
    em4_bpc_wr<s(0)(0)(0)>[&] (0x03, 0x0a, c2<s(0)(0)(0)>[&]);




    cah_em4_setTimingRef84<s(0)(0)(0)>[&] (port_mid<s(0)(0)(0)>[&] - 1, byClockNum<s(0)(0)(0)>[&], bEnable<s(0)(0)(0)>[&]);

    return ((WORD<s(0)(0)(0)>[T])0x0) ;
}

PB_ERROR_CODE_T<s(0)(0)(0)>[T]
CAH_EM4_setTransPsl<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] nulPort<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] PSL<s(0)(0)(0)>[&])
{




    void *base<s(0)(0)(0)>[&] =(D2) 0x0000;
    int ulPort<s(0)(0)(0)>[&] =(D2) 0;

	{if (125 <  nulPort<s(0)(0)(0)>[&] ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  nulPort<s(0)(0)(0)>[&] ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;
     ulPort<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (nulPort<s(0)(0)(0)>[&]) - 1;
    cah_em4_registerCall<s(0)(0)(0)>[&] ((PMyFun<s(0)(0)(0)>[T]) CAH_EM4_setTransPsl<s(0)(0)(0)>[&], (int) nulPort<s(0)(0)(0)>[&], (int) PSL<s(0)(0)(0)>[&], 0, 1, __FUNCTION__<s(0)(0)(0)>[&]);
    base<s(0)(0)(0)>[&] = (void *) cah_em4_getEntityBase<s(0)(0)(0)>[&] (0, nulPort<s(0)(0)(0)>[&]);
   em4SetPsl2<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], ulPort<s(0)(0)(0)>[&], PSL<s(0)(0)(0)>[&]);
   

    return ((WORD<s(0)(0)(0)>[T])0x0) ;

}

 
WORD<s(0)(0)(0)>[T]
CAH_EM4_SetRxExpLpPsl<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byC2Value<s(0)(0)(0)>[&])
{




    void *base<s(0)(0)(0)>[&] =(D2) 0x00000;
    int ulPort<s(0)(0)(0)>[&] =(D2) SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]);

	{if (125 <  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;
   ulPort<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&])) - 1;
    base<s(0)(0)(0)>[&] = (void *) cah_em4_getEntityBase<s(0)(0)(0)>[&](0, SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]));
    cah_em4_registerCall<s(0)(0)(0)>[&] ((PMyFun<s(0)(0)(0)>[T]) CAH_EM4_SetRxExpLpPsl<s(0)(0)(0)>[&], (int) SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]), (int) byC2Value<s(0)(0)(0)>[&], 0, 2, __FUNCTION__<s(0)(0)(0)>[&]);
    em4SetPslexp<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], ulPort<s(0)(0)(0)>[&], byC2Value<s(0)(0)(0)>[&]);

    return ((WORD<s(0)(0)(0)>[T])0x0) ;

}

void
cah_em4_get_j2acc<s(0)(0)(0)>[&] (void *baseaddr<s(0)(0)(0)>[&], int port<s(0)(0)(0)>[&], unsigned char *j2exp<s(0)(0)(0)>[&])
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0;
    int i<s(0)(0)(0)>[&] =(D2) 0;

    for (i<s(0)(0)(0)>[&] = 0; i<s(0)(0)(0)>[&] < 16; i<s(0)(0)(0)>[&]++)
    {
        cah_em4_wr<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 , 0x8000 + (port<s(0)(0)(0)>[&] << 8) + (0x10  + i<s(0)(0)(0)>[&]));
        cah_em4_pollBit<s(0)(0)(0)>[&] ((unsigned short *) baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x01 );
        u<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], (0x02 << 10) | 0x03 );
        *(j2exp<s(0)(0)(0)>[&] + i<s(0)(0)(0)>[&]) = u<s(0)(0)(0)>[&] & (0x00ff);
    }
}

int em4TtiTxTest<s(0)(0)(0)>[&] (int port<s(0)(0)(0)>[&])
{
	{if (125 <  port<s(0)(0)(0)>[&] ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  port<s(0)(0)(0)>[&] ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;
	 
	CAH_EM4_SetTxLpTti<s(0)(0)(0)>[&] (0, port<s(0)(0)(0)>[&], TTI_LEN_16BYTE<s(0)(0)(0)>[&], "f1234567890ABCDE");
	return 0;
}


int em4TtiRxTest<s(0)(0)(0)>[&] (int n<s(0)(0)(0)>[&])
{
	unsigned char tti<s(0)(0)(0)>[&][16] ;(D1:tti:0)

	{if (125 <  n<s(0)(0)(0)>[&] ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  n<s(0)(0)(0)>[&] ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;
	memset<s(0)(0)(0)>[&] (tti<s(0)(0)(0)>[&], 0, 16);
	CAH_EM4_GetRxRcvLpTti<s(0)(0)(0)>[&] (0, n<s(0)(0)(0)>[&], TTI_LEN_16BYTE<s(0)(0)(0)>[&], tti<s(0)(0)(0)>[&]);
	tti<s(0)(0)(0)>[&][15] = '\0';
	printf<s(0)(0)(0)>[&] ("%s(): tti(%s)", __FUNCTION__<s(0)(0)(0)>[&], tti<s(0)(0)(0)>[&]);
	return 0;
}

 
WORD<s(0)(0)(0)>[T]
CAH_EM4_GetRxRcvLpTti<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], TTI_LEN_T<s(0)(0)(0)>[T] eTtiMode<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] * pbyTtiValue<s(0)(0)(0)>[&])
{
	int entity<s(0)(0)(0)>[&] =(D2) 0;
	int i<s(0)(0)(0)>[&] =(D2) 0;
	int ulPort<s(0)(0)(0)>[&] =(D2) 0;

	{if (125 <  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;
    if (!pbyTtiValue<s(0)(0)(0)>[&])
    {
        printf<s(0)(0)(0)>[&] ("\r\nEM4_GetAccTti: entity(%d), file(%s) line(%d), tti is NULL!  \r\n", entity<s(0)(0)(0)>[&], "cah_126e1.c", 6279);
        return PB_ERR_PARAM<s(0)(0)(0)>[&];
    }
	
	ulPort<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&])) - 1;
	cah_em4_get_j2acc<s(0)(0)(0)>[&] (cah_em4_getEntityBase<s(0)(0)(0)>[&] (0, SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&])), ulPort<s(0)(0)(0)>[&], pbyTtiValue<s(0)(0)(0)>[&]);
	if (TTI_LEN_16BYTE<s(0)(0)(0)>[&] == eTtiMode<s(0)(0)(0)>[&])
	{
	} else if (TTI_LEN_FIXED1B<s(0)(0)(0)>[&] == eTtiMode<s(0)(0)(0)>[&]) {
		for (i<s(0)(0)(0)>[&] = 1; i<s(0)(0)(0)>[&] < 16; i<s(0)(0)(0)>[&] ++)
		{
			pbyTtiValue<s(0)(0)(0)>[&][i<s(0)(0)(0)>[&]] = pbyTtiValue<s(0)(0)(0)>[&][0];
		}
	}

    return ((WORD<s(0)(0)(0)>[T])0x0) ;
}

int em4SetExpPslTest<s(0)(0)(0)>[&] (int port<s(0)(0)(0)>[&], int c2<s(0)(0)(0)>[&])
{
	{if (125 <  port<s(0)(0)(0)>[&] ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  port<s(0)(0)(0)>[&] ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;
	CAH_EM4_SetRxExpLpPsl<s(0)(0)(0)>[&] (0, port<s(0)(0)(0)>[&], c2<s(0)(0)(0)>[&]);
	printf<s(0)(0)(0)>[&] ("\r\n%s(): write c2(%d)", __FUNCTION__<s(0)(0)(0)>[&], c2<s(0)(0)(0)>[&]);
	return 0;
}

int em4GetExpPslTest<s(0)(0)(0)>[&] (int port<s(0)(0)(0)>[&])
{
	unsigned char u<s(0)(0)(0)>[&] =(D2) 0;

	{if (125 <  port<s(0)(0)(0)>[&] ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  port<s(0)(0)(0)>[&] ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;
	CAH_EM4_GetRxExpLpPsl<s(0)(0)(0)>[&] (0, port<s(0)(0)(0)>[&], &u<s(0)(0)(0)>[&]);
	printf<s(0)(0)(0)>[&] ("\r\npsl(%x)", u<s(0)(0)(0)>[&]);
	printf<s(0)(0)(0)>[&] ("\r\n");
	return 0;
}

 
WORD<s(0)(0)(0)>[T]
CAH_EM4_GetRxExpLpPsl<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] * byC2Value<s(0)(0)(0)>[&])
{
    void *base<s(0)(0)(0)>[&] =(D2) 0x00000;
    int ulPort<s(0)(0)(0)>[&] =(D2) SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]);
	unsigned short u<s(0)(0)(0)>[&] =(D2) 0;

	{if (125 <  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;
    ulPort<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&])) - 1;
    base<s(0)(0)(0)>[&] = (void *) cah_em4_getEntityBase<s(0)(0)(0)>[&](0, SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]));
    cah_em4_registerCall<s(0)(0)(0)>[&] ((PMyFun<s(0)(0)(0)>[T]) CAH_EM4_SetRxExpLpPsl<s(0)(0)(0)>[&], (int) SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]), (int) byC2Value<s(0)(0)(0)>[&], 0, 2, __FUNCTION__<s(0)(0)(0)>[&]);
    u<s(0)(0)(0)>[&] = cah_em4_pohRead<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&],  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]), 0x00 );
	u<s(0)(0)(0)>[&] = u<s(0)(0)(0)>[&] & (0x3800);
	u<s(0)(0)(0)>[&] = (u<s(0)(0)(0)>[&] >> 11);
	*byC2Value<s(0)(0)(0)>[&] = u<s(0)(0)(0)>[&];

    return ((WORD<s(0)(0)(0)>[T])0x0) ;
}

 
WORD<s(0)(0)(0)>[T]
CAH_EM4_SetTxLpPsl<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byC2Value<s(0)(0)(0)>[&])
{
	return CAH_EM4_setTransPsl<s(0)(0)(0)>[&]  (dwPos<s(0)(0)(0)>[&], 0, SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]), byC2Value<s(0)(0)(0)>[&]);
}

 
WORD<s(0)(0)(0)>[T]
CAH_EM4_SetRxTxLpPsl<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byC2Value<s(0)(0)(0)>[&])
{
	return CAH_EM4_setTransPsl<s(0)(0)(0)>[&]  (dwPos<s(0)(0)(0)>[&], 0, SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]), byC2Value<s(0)(0)(0)>[&]);
}

int em4GetRxRcvPslTest<s(0)(0)(0)>[&] (int port<s(0)(0)(0)>[&])
{
	unsigned char c2<s(0)(0)(0)>[&] =(D2) 0;

	{if (125 <  port<s(0)(0)(0)>[&] ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  port<s(0)(0)(0)>[&] ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;
	CAH_EM4_GetRxRcvLpPsl<s(0)(0)(0)>[&] (0, port<s(0)(0)(0)>[&], &c2<s(0)(0)(0)>[&]);
	printf<s(0)(0)(0)>[&] ("\r\nc2(%x)", c2<s(0)(0)(0)>[&]);
	printf<s(0)(0)(0)>[&] ("\r\n\r\n");
	return 0;
}

 
WORD<s(0)(0)(0)>[T]
CAH_EM4_GetRxRcvLpPsl<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] * pbyC2Value<s(0)(0)(0)>[&])
{




    void *base<s(0)(0)(0)>[&] =(D2) 0x0000;
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0x0000;
    int ulPort<s(0)(0)(0)>[&] =(D2) SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]);
    int nulPort<s(0)(0)(0)>[&] =(D2) SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]);

	{if (125 <  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;
    ulPort<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (nulPort<s(0)(0)(0)>[&]) - 1;

    if (!pbyC2Value<s(0)(0)(0)>[&])
    {
        printf<s(0)(0)(0)>[&] ("\r\n%s(): pPSL is NULL!", __FUNCTION__<s(0)(0)(0)>[&]);
        return ((WORD<s(0)(0)(0)>[T])0x1) ;
    }

    base<s(0)(0)(0)>[&] = (void *) cah_em4_getEntityBase<s(0)(0)(0)>[&] (0, SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]));
    cah_em4_getTslNow<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&],SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]), &u<s(0)(0)(0)>[&]);
    *pbyC2Value<s(0)(0)(0)>[&] = u<s(0)(0)(0)>[&];
    return ((WORD<s(0)(0)(0)>[T])0x0) ;

}


 


void
em4_PollBit<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] addrOffset<s(0)(0)(0)>[&], int byPortNo<s(0)(0)(0)>[&])
{
    WORD<s(0)(0)(0)>[T] i<s(0)(0)(0)>[&] =(D2) 0;
    WORD<s(0)(0)(0)>[T] data<s(0)(0)(0)>[&] =(D2) 0x0000;
    int chipno<s(0)(0)(0)>[&] =(D2) cah_em4_port2chip<s(0)(0)(0)>[&] (byPortNo<s(0)(0)(0)>[&]);
    DWORD<s(0)(0)(0)>[T] base<s(0)(0)(0)>[&] =(D2) cah_em4_getChipBase<s(0)(0)(0)>[&] (0, chipno<s(0)(0)(0)>[&]);

    for (;;)
    {

         
        cah_ReadRegister<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (addrOffset<s(0)(0)(0)>[&]), &data<s(0)(0)(0)>[&], 0xFFFF, CAH_REG_ATTRBT_RW<s(0)(0)(0)>[&]);
        if (data<s(0)(0)(0)>[&] & 0x8000)
        {
            i<s(0)(0)(0)>[&] = (WORD<s(0)(0)(0)>[T]) (i<s(0)(0)(0)>[&] + 1);
            if (i<s(0)(0)(0)>[&] >= 100 )
            {
                 

                 

                break;
            }
        }
        else
        {
            break;
        }
    }
}

 
PB_ERROR_CODE_T<s(0)(0)(0)>[T]
CAH_EM4_enablePlm<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] nulPort<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&])
{




    CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *pEntity<s(0)(0)(0)>[&];(D1:pEntity:0)
    void *baseaddr<s(0)(0)(0)>[&] =(D2) ((void *)0) ;
    ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&] =(D2) 0;
    int ulPort<s(0)(0)(0)>[&] =(D2) 0;

	{if (125 <  nulPort<s(0)(0)(0)>[&] ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  nulPort<s(0)(0)(0)>[&] ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;
    pEntity<s(0)(0)(0)>[&] = cah_em4_getEntityPtr<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&]);
    ulPort<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (nulPort<s(0)(0)(0)>[&]) - 1;
    cah_em4_registerCall<s(0)(0)(0)>[&] ((PMyFun<s(0)(0)(0)>[T]) CAH_EM4_enablePlm<s(0)(0)(0)>[&], (int) nulPort<s(0)(0)(0)>[&], (int) bEnable<s(0)(0)(0)>[&], 0, 4, __FUNCTION__<s(0)(0)(0)>[&]);

    baseaddr<s(0)(0)(0)>[&] = cah_em4_getEntityBase<s(0)(0)(0)>[&] (0, nulPort<s(0)(0)(0)>[&]);
    cah_em4_enablePlm<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], 0, ulPort<s(0)(0)(0)>[&], bEnable<s(0)(0)(0)>[&]);
    


    return ((WORD<s(0)(0)(0)>[T])0x0) ;

}


WORD<s(0)(0)(0)>[T]
CAH_EM4_SetRxLpPslEnable<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&])
{
    WORD<s(0)(0)(0)>[T] data<s(0)(0)(0)>[&];(D1:data:0)

	data<s(0)(0)(0)>[&] = 0;
	CAH_EM4_enablePlm<s(0)(0)(0)>[&] (dwPos<s(0)(0)(0)>[&], 0, SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]), bEnable<s(0)(0)(0)>[&]);

    return ((WORD<s(0)(0)(0)>[T])0x0) ;
}


 
WORD<s(0)(0)(0)>[T]
CAH_EM4_SetTxLpTti<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], TTI_LEN_T<s(0)(0)(0)>[T] eTtiMode<s(0)(0)(0)>[&], const BYTE<s(0)(0)(0)>[T] * pbyTtiValue<s(0)(0)(0)>[&])
{





    void *base<s(0)(0)(0)>[&] =(D2) 0x0000;
	int i<s(0)(0)(0)>[&] =(D2) 0;
	unsigned char mytti<s(0)(0)(0)>[&][16];(D1:mytti:0)
    ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&] =(D2) 0;
	int ulPort<s(0)(0)(0)>[&] =(D2) 0;

	{if (125 <  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;
       ulPort<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&])) - 1;
	memset<s(0)(0)(0)>[&] (mytti<s(0)(0)(0)>[&], 0, 16);

    cah_em4_registerCall<s(0)(0)(0)>[&] ((PMyFun<s(0)(0)(0)>[T]) CAH_EM4_SetTxLpTti<s(0)(0)(0)>[&], (int) SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]), (int) pbyTtiValue<s(0)(0)(0)>[&], 0, 5, __FUNCTION__<s(0)(0)(0)>[&]);

    base<s(0)(0)(0)>[&] = (void *) cah_em4_getEntityBase<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&], SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]));
	memcpy<s(0)(0)(0)>[&] (mytti<s(0)(0)(0)>[&], pbyTtiValue<s(0)(0)(0)>[&], 16);
	if (TTI_LEN_FIXED1B<s(0)(0)(0)>[&] == eTtiMode<s(0)(0)(0)>[&])
	{
		for (i<s(0)(0)(0)>[&] = 0; i<s(0)(0)(0)>[&] < 16; i<s(0)(0)(0)>[&] ++) mytti<s(0)(0)(0)>[&][i<s(0)(0)(0)>[&]] = pbyTtiValue<s(0)(0)(0)>[&][0];
	}
    cahem4setTxj2_2<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&],  ulPort<s(0)(0)(0)>[&], mytti<s(0)(0)(0)>[&]);
   

    return ((WORD<s(0)(0)(0)>[T])0x0) ;

}


 
WORD<s(0)(0)(0)>[T]
CAH_EM4_SetRxExpLpTti<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], TTI_LEN_T<s(0)(0)(0)>[T] eTtiMode<s(0)(0)(0)>[&], const BYTE<s(0)(0)(0)>[T] * pbyTtiValue<s(0)(0)(0)>[&])
{





    void *base<s(0)(0)(0)>[&] =(D2) 0x0000;
    int ulPort<s(0)(0)(0)>[&] =(D2) 0;
	char mytti<s(0)(0)(0)>[&][16];(D1:mytti:0)
	int i<s(0)(0)(0)>[&] =(D2) 0;

	{if (125 <  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;
      ulPort<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&])) - 1;

	memset<s(0)(0)(0)>[&] (mytti<s(0)(0)(0)>[&], 0, 16); memcpy<s(0)(0)(0)>[&] (mytti<s(0)(0)(0)>[&], pbyTtiValue<s(0)(0)(0)>[&], 16);
    cah_em4_registerCall<s(0)(0)(0)>[&] ((PMyFun<s(0)(0)(0)>[T]) CAH_EM4_SetRxExpLpTti<s(0)(0)(0)>[&], (int) SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]), (int) pbyTtiValue<s(0)(0)(0)>[&], 0, 6, __FUNCTION__<s(0)(0)(0)>[&]);
	
    base<s(0)(0)(0)>[&] = (void *) cah_em4_getEntityBase<s(0)(0)(0)>[&] (0, SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]));
	if (TTI_LEN_FIXED1B<s(0)(0)(0)>[&] == eTtiMode<s(0)(0)(0)>[&])
	{
		 
		for (i<s(0)(0)(0)>[&] = 0; i<s(0)(0)(0)>[&] < 16; i<s(0)(0)(0)>[&] ++) mytti<s(0)(0)(0)>[&][i<s(0)(0)(0)>[&]] = pbyTtiValue<s(0)(0)(0)>[&][1];
	}
   cah_em4_set_j2exp<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], ulPort<s(0)(0)(0)>[&], mytti<s(0)(0)(0)>[&]);
  

    return ((WORD<s(0)(0)(0)>[T])0x0) ;

}

int em4GetExpTtiTest<s(0)(0)(0)>[&] (int port<s(0)(0)(0)>[&])
{
	unsigned char tti<s(0)(0)(0)>[&][16];(D1:tti:0)
	int i<s(0)(0)(0)>[&] =(D2) 0;

	memset<s(0)(0)(0)>[&] (tti<s(0)(0)(0)>[&], 0, 16);
	CAH_EM4_GetRxExpLpTti<s(0)(0)(0)>[&] (0, port<s(0)(0)(0)>[&], TTI_LEN_16BYTE<s(0)(0)(0)>[&], tti<s(0)(0)(0)>[&]);
	tti<s(0)(0)(0)>[&][15] = '\0';
	printf<s(0)(0)(0)>[&] ("\r\ntti(%s)", tti<s(0)(0)(0)>[&]);
	printf<s(0)(0)(0)>[&] ("\r\n\t");
	for (i<s(0)(0)(0)>[&] = 0; i<s(0)(0)(0)>[&] < 16; i<s(0)(0)(0)>[&] ++)
	{
		printf<s(0)(0)(0)>[&] ("(%x)", tti<s(0)(0)(0)>[&][i<s(0)(0)(0)>[&]]);
	}
	printf<s(0)(0)(0)>[&] ("\r\n");

	return 0;
}

int em4SetExpTtiTest<s(0)(0)(0)>[&] (int port<s(0)(0)(0)>[&])
{
	{if (125 <  port<s(0)(0)(0)>[&] ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  port<s(0)(0)(0)>[&] ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;
	CAH_EM4_SetRxExpLpTti<s(0)(0)(0)>[&] (0, port<s(0)(0)(0)>[&], TTI_LEN_16BYTE<s(0)(0)(0)>[&], "f0987654321abcde");
	return 0;
}

 
WORD<s(0)(0)(0)>[T]
CAH_EM4_GetRxExpLpTti<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], TTI_LEN_T<s(0)(0)(0)>[T] eTtiMode<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] * pbyTtiValue<s(0)(0)(0)>[&])
{
	void * base<s(0)(0)(0)>[&] =(D2) 0;
	int ulPort<s(0)(0)(0)>[&] =(D2) 0;
	unsigned char mytti<s(0)(0)(0)>[&][16];(D1:mytti:0)

	{if (125 <  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;
	ulPort<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&])) - 1;
	base<s(0)(0)(0)>[&] = cah_em4_getEntityBase<s(0)(0)(0)>[&] (0, SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]));
       cah_em4_get_j2exp<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], ulPort<s(0)(0)(0)>[&], mytti<s(0)(0)(0)>[&]);
      
	memcpy<s(0)(0)(0)>[&] (pbyTtiValue<s(0)(0)(0)>[&], mytti<s(0)(0)(0)>[&], 16);
    return 0;
}

int cah_em4_ManualInsertPayloadAIS<s(0)(0)(0)>[&] (int byPortNo<s(0)(0)(0)>[&], int flag<s(0)(0)(0)>[&] )
{
     void * base<s(0)(0)(0)>[&] =(D2) 0;
     int byte<s(0)(0)(0)>[&] =(D2) 0;
      int ulPort<s(0)(0)(0)>[&] =(D2) 0;
      int bit<s(0)(0)(0)>[&] =(D2) 0;
      unsigned short val<s(0)(0)(0)>[&] =(D2) 0;

       ulPort<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (byPortNo<s(0)(0)(0)>[&]) - 1;
	base<s(0)(0)(0)>[&] = cah_em4_getEntityBase<s(0)(0)(0)>[&] (0, byPortNo<s(0)(0)(0)>[&]);
	byte<s(0)(0)(0)>[&] = ulPort<s(0)(0)(0)>[&] / 16;
	bit<s(0)(0)(0)>[&] = ulPort<s(0)(0)(0)>[&] % 16;
	

	val<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], ((((0x00 << 10) | 0x20) ) + byte<s(0)(0)(0)>[&]));
	if (flag<s(0)(0)(0)>[&] == 1 )
	{
        val<s(0)(0)(0)>[&] = val<s(0)(0)(0)>[&] | (1 << bit<s(0)(0)(0)>[&]);
	} else {
        val<s(0)(0)(0)>[&] = val<s(0)(0)(0)>[&] & (~(1 << bit<s(0)(0)(0)>[&]));
	}

	cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], ((((0x00 << 10) | 0x20) ) + byte<s(0)(0)(0)>[&]), val<s(0)(0)(0)>[&]);

    return 0;
}
 










WORD<s(0)(0)(0)>[T]
CAH_EM4_SetInsertAlm<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], CTD_INSERT_ALM_TYPE_T<s(0)(0)(0)>[T] eAlmType<s(0)(0)(0)>[&],
                      CTD_INSERT_ALM_DIR_T<s(0)(0)(0)>[T] eInsAlmDir<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&])
{
	void * base<s(0)(0)(0)>[&] =(D2) 0;
	int port<s(0)(0)(0)>[&] =(D2) 0;
	unsigned short alm<s(0)(0)(0)>[&] =(D2) 0;
	UINT8<s(0)(0)(0)>[T] byLoop<s(0)(0)(0)>[&] =(D2) 0x0;

	{if (125 <  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;
    cah_em4_registerCall<s(0)(0)(0)>[&] ((PMyFun<s(0)(0)(0)>[T]) CAH_EM4_SetInsertAlm<s(0)(0)(0)>[&], (int) SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]), (int) eAlmType<s(0)(0)(0)>[&], bEnable<s(0)(0)(0)>[&], 8, __FUNCTION__<s(0)(0)(0)>[&]);

	base<s(0)(0)(0)>[&] = cah_em4_getEntityBase<s(0)(0)(0)>[&] (0, SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]));
	port<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&])) - 1;
       cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x04 << 10) | 0x30 , port<s(0)(0)(0)>[&]);       
       
	alm<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x04 << 10) | 0x40 );

	if (CTD_INSERT_ALM_TYPE_TUAIS<s(0)(0)(0)>[&] == eAlmType<s(0)(0)(0)>[&] 
		&& CTD_INSERT_ALM_OUT_LASER<s(0)(0)(0)>[&] == eInsAlmDir<s(0)(0)(0)>[&])
	{
		if (1  == bEnable<s(0)(0)(0)>[&])
		{
			alm<s(0)(0)(0)>[&] |= 0x8000;
		} else {
			alm<s(0)(0)(0)>[&] &= ~0x8000;
		}
              cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x04 << 10) | 0x30 , port<s(0)(0)(0)>[&]);       
		alm<s(0)(0)(0)>[&] = cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x04 << 10) | 0x40 , alm<s(0)(0)(0)>[&]);
	}

	if (CTD_INSERT_ALM_TYPE_AIS<s(0)(0)(0)>[&] == eAlmType<s(0)(0)(0)>[&] 
		&& CTD_INSERT_ALM_OUT_LASER<s(0)(0)(0)>[&] == eInsAlmDir<s(0)(0)(0)>[&])
	{
		if (1  == bEnable<s(0)(0)(0)>[&])
		{
		}
		else 
		{
            if (SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) == 0)
            {
                for (byLoop<s(0)(0)(0)>[&]=0;byLoop<s(0)(0)(0)>[&]<126;byLoop<s(0)(0)(0)>[&]++)
	                cah_em4_ManualInsertPayloadAIS<s(0)(0)(0)>[&](byLoop<s(0)(0)(0)>[&], 0 );
			}
		}
	}
	if (CTD_INSERT_ALM_TYPE_RDI<s(0)(0)(0)>[&] == eAlmType<s(0)(0)(0)>[&]
		&& CTD_INSERT_ALM_OUT_LASER<s(0)(0)(0)>[&] == eInsAlmDir<s(0)(0)(0)>[&])
	{
		if (1  == bEnable<s(0)(0)(0)>[&])
		{
			alm<s(0)(0)(0)>[&] |= 0x0001;
            alm<s(0)(0)(0)>[&] &= ~0x0002;
		} else {
			alm<s(0)(0)(0)>[&] &= ~0x0001;
            alm<s(0)(0)(0)>[&] |= 0x0002;
		}
              cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x04 << 10) | 0x30 , port<s(0)(0)(0)>[&]);       
	      alm<s(0)(0)(0)>[&] = cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x04 << 10) | 0x40 , alm<s(0)(0)(0)>[&]);
	}
	
    return ((WORD<s(0)(0)(0)>[T])0x0) ;
}



 
WORD<s(0)(0)(0)>[T]
CAH_EM4_SetRxLpTtiAlmEnable<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&])
{




    CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *pEntity<s(0)(0)(0)>[&] =(D2) ((void *)0) ;
    void *baseaddr<s(0)(0)(0)>[&] =(D2) ((void *)0) ;
    int ulPort<s(0)(0)(0)>[&] =(D2) 0;

    cah_em4_trace<s(0)(0)(0)>[&] (15, "\r\n%s:, ulPort(%d) bEnable(%d)", __FUNCTION__<s(0)(0)(0)>[&], ulPort<s(0)(0)(0)>[&], bEnable<s(0)(0)(0)>[&]);
    

    ulPort<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&])) - 1;
    pEntity<s(0)(0)(0)>[&] = cah_em4_getEntityPtr<s(0)(0)(0)>[&] (0);
    cah_em4_registerCall<s(0)(0)(0)>[&] ((PMyFun<s(0)(0)(0)>[T]) CAH_EM4_SetRxLpTtiAlmEnable<s(0)(0)(0)>[&], (int) SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]), (int) bEnable<s(0)(0)(0)>[&], 0, 8, __FUNCTION__<s(0)(0)(0)>[&]);
    baseaddr<s(0)(0)(0)>[&] = cah_em4_getEntityBase<s(0)(0)(0)>[&] (0, SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]));
    cah_em4_enableTimRdi<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], 0, ulPort<s(0)(0)(0)>[&], bEnable<s(0)(0)(0)>[&]);
    

    return ((WORD<s(0)(0)(0)>[T])0x0) ;

}

 
WORD<s(0)(0)(0)>[T]
CAH_EM4_SetRxLpTtiAisEnable<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&])
{




    CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *pEntity<s(0)(0)(0)>[&] =(D2) ((void *)0) ;
    void *baseaddr<s(0)(0)(0)>[&] =(D2) ((void *)0) ;
    int ulPort<s(0)(0)(0)>[&] =(D2) 0;

    cah_em4_trace<s(0)(0)(0)>[&] (15, "\r\n%s:, ulPort(%d) bEnable(%d)", __FUNCTION__<s(0)(0)(0)>[&], ulPort<s(0)(0)(0)>[&], bEnable<s(0)(0)(0)>[&]);
    
    ulPort<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&])) - 1;
    pEntity<s(0)(0)(0)>[&] = cah_em4_getEntityPtr<s(0)(0)(0)>[&] (0);
    cah_em4_registerCall<s(0)(0)(0)>[&] ((PMyFun<s(0)(0)(0)>[T]) CAH_EM4_SetRxLpTtiAlmEnable<s(0)(0)(0)>[&], (int) SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]), (int) bEnable<s(0)(0)(0)>[&], 0, 8, __FUNCTION__<s(0)(0)(0)>[&]);
    baseaddr<s(0)(0)(0)>[&] = cah_em4_getEntityBase<s(0)(0)(0)>[&] (0, SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]));
    cah_em4_enableTimAis<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], 0, ulPort<s(0)(0)(0)>[&], bEnable<s(0)(0)(0)>[&]);
    

    return ((WORD<s(0)(0)(0)>[T])0x0) ;

}

 
WORD<s(0)(0)(0)>[T]
CAH_EM4_SetTxLpTtiMode<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], TTI_LEN_T<s(0)(0)(0)>[T] eTtiMode<s(0)(0)(0)>[&])
{



    return ((WORD<s(0)(0)(0)>[T])0x0) ;

    return ((WORD<s(0)(0)(0)>[T])0x0) ;
}

UINT8<s(0)(0)(0)>[T]
cah_em4_readChReg<s(0)(0)(0)>[&] (CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] * pEntity<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] addrOffset<s(0)(0)(0)>[&])
{
    UINT8<s(0)(0)(0)>[T] data<s(0)(0)(0)>[&] =(D2) 0;
    UINT32<s(0)(0)(0)>[T] offset<s(0)(0)(0)>[&] =(D2) (0x2000  + ulPort<s(0)(0)(0)>[&] * 0x1000  + addrOffset<s(0)(0)(0)>[&]);

    data<s(0)(0)(0)>[&] = (*((volatile UINT8<s(0)(0)(0)>[T] *)( (pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].cfg<s(0)(0)(0)>[&].baseAddr<s(0)(0)(0)>[&]) )+(  offset<s(0)(0)(0)>[&] ))) ;

    return data<s(0)(0)(0)>[&];
}


void
cah_em4_writeChReg<s(0)(0)(0)>[&] (CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] * pEntity<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&],
                    UINT32<s(0)(0)(0)>[T] addrOffset<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] data<s(0)(0)(0)>[&])
{
    UINT32<s(0)(0)(0)>[T] offset<s(0)(0)(0)>[&] =(D2) (0x2000  + ulPort<s(0)(0)(0)>[&] * 0x1000  + addrOffset<s(0)(0)(0)>[&]);

    (*((volatile UINT8<s(0)(0)(0)>[T] *)( (pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].cfg<s(0)(0)(0)>[&].baseAddr<s(0)(0)(0)>[&]) )+(  offset<s(0)(0)(0)>[&] )))=(UINT8<s(0)(0)(0)>[T])(  data<s(0)(0)(0)>[&] ) ;
}


 
WORD<s(0)(0)(0)>[T]
CAH_EM4_SetRxLpTtiMode<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], TTI_LEN_T<s(0)(0)(0)>[T] eTtiMode<s(0)(0)(0)>[&])
{




    return ((WORD<s(0)(0)(0)>[T])0x0) ;
}

PB_ERROR_CODE_T<s(0)(0)(0)>[T]
CAH_EM4_setPdhPortMode<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] nulPort<s(0)(0)(0)>[&], PDH_PORT_MODE_T<s(0)(0)(0)>[T] type<s(0)(0)(0)>[&])
{




    void *base<s(0)(0)(0)>[&] =(D2) 0x0000;
    int port<s(0)(0)(0)>[&] =(D2) 0;
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0x0000;
    CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *pEntity<s(0)(0)(0)>[&] =(D2) ((void *)0) ;
    ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&] =(D2) 0;
    int ulPort<s(0)(0)(0)>[&] =(D2) 0;

    ulPort<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (nulPort<s(0)(0)(0)>[&]);


    pEntity<s(0)(0)(0)>[&] = cah_em4_getEntityPtr<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&]);
    cah_em4_registerCall<s(0)(0)(0)>[&] ((PMyFun<s(0)(0)(0)>[T]) CAH_EM4_setPdhPortMode<s(0)(0)(0)>[&], (int) nulPort<s(0)(0)(0)>[&], (int) type<s(0)(0)(0)>[&], 0, 11, __FUNCTION__<s(0)(0)(0)>[&]);

    if (pEntity<s(0)(0)(0)>[&]->state<s(0)(0)(0)>[&] != eEm4EntAct<s(0)(0)(0)>[&])
    {
         
        return PB_ERR_STATE<s(0)(0)(0)>[&];
    }
    base<s(0)(0)(0)>[&] = (void *) cah_em4_getEntityBase<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&], ulPort<s(0)(0)(0)>[&]);
    
   u<s(0)(0)(0)>[&] = cah_em4_pohRead<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&] = ulPort<s(0)(0)(0)>[&], 0x00 );
   
    u<s(0)(0)(0)>[&] &= ~0x000c;                
    cah_em4_pohWrite<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&], 0x00 , u<s(0)(0)(0)>[&]);
    

    return ((WORD<s(0)(0)(0)>[T])0x0) ;




    return 0;
}



 


PB_ERROR_CODE_T<s(0)(0)(0)>[T]
CAH_EM4_getPortType<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] nulPort<s(0)(0)(0)>[&], PDH_PORT_MODE_T<s(0)(0)(0)>[T] * pType<s(0)(0)(0)>[&])
{





    CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *pEntity<s(0)(0)(0)>[&];(D1:pEntity:0)
    ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&] =(D2) 0;
    int ulPort<s(0)(0)(0)>[&] =(D2) 0;

    ulPort<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (nulPort<s(0)(0)(0)>[&]);


    if ((((  entity<s(0)(0)(0)>[&]   >= ((1) ) )) || ((   ulChip<s(0)(0)(0)>[&]  )  >=  (1) ) || ((   ulPort<s(0)(0)(0)>[&]  ) >= (63 ) ) ) )
    {
        printf<s(0)(0)(0)>[&] ("\r\n**Error!  Entity= %d; File=%s; Line=%d  \r\n", entity<s(0)(0)(0)>[&], "cah_126e1.c", 6839);
        return PB_ERR_PARAM<s(0)(0)(0)>[&];
    }

    if (!pType<s(0)(0)(0)>[&])
    {
        printf<s(0)(0)(0)>[&] ("\r\nEntity%d: %s %d EM4_GetPortType pType is NULL!  \r\n", entity<s(0)(0)(0)>[&], "cah_126e1.c",
                6846);
        return PB_ERR_PARAM<s(0)(0)(0)>[&];
    }

    pEntity<s(0)(0)(0)>[&] = cah_em4_getEntityPtr<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&]);
    if (pEntity<s(0)(0)(0)>[&]->state<s(0)(0)(0)>[&] == eEm4EntInit<s(0)(0)(0)>[&])
    {
        return ((WORD<s(0)(0)(0)>[T])0x0) ;
    }

    if (pEntity<s(0)(0)(0)>[&]->state<s(0)(0)(0)>[&] != eEm4EntAct<s(0)(0)(0)>[&])
    {
         
        return PB_ERR_STATE<s(0)(0)(0)>[&];
    }

   *pType<s(0)(0)(0)>[&] = pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].portType<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]];
  


    return ((WORD<s(0)(0)(0)>[T])0x0) ;




    return 0;
}


 



PB_ERROR_CODE_T<s(0)(0)(0)>[T]
CAH_EM4_enablePort<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&], PORT_STATE_T<s(0)(0)(0)>[T] state<s(0)(0)(0)>[&])
{






    return ((WORD<s(0)(0)(0)>[T])0x0) ;





    return 0;
}



 



PB_ERROR_CODE_T<s(0)(0)(0)>[T]
CAH_EM4_getPortState<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] nulPort<s(0)(0)(0)>[&], PORT_STATE_T<s(0)(0)(0)>[T] * pState<s(0)(0)(0)>[&])
{




    CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *pEntity<s(0)(0)(0)>[&];(D1:pEntity:0)
    ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&] =(D2) 0;
    int ulPort<s(0)(0)(0)>[&] =(D2) 0;

    ulPort<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (nulPort<s(0)(0)(0)>[&]) - 1;


     if ((((  entity<s(0)(0)(0)>[&]   >= ((1) ) )) || ((   ulChip<s(0)(0)(0)>[&]  )  >=  (1) ) || ((   ulPort<s(0)(0)(0)>[&]  ) >= (63 ) ) ) )     
    {
        printf<s(0)(0)(0)>[&] ("\r\n**Error!  Entity= %d; File=%s; Line=%d  \r\n", entity<s(0)(0)(0)>[&], "cah_126e1.c", 6963);
        return PB_ERR_PARAM<s(0)(0)(0)>[&];
    }

    if (!pState<s(0)(0)(0)>[&])
    {
        printf<s(0)(0)(0)>[&] ("\r\nEntity%d: %s %d EM4_GetPortState pState is NULL!  \r\n", entity<s(0)(0)(0)>[&], "cah_126e1.c",
                6970);
        return PB_ERR_PARAM<s(0)(0)(0)>[&];
    }

    pEntity<s(0)(0)(0)>[&] = cah_em4_getEntityPtr<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&]);
    if (pEntity<s(0)(0)(0)>[&]->state<s(0)(0)(0)>[&] == eEm4EntInit<s(0)(0)(0)>[&])
    {
        return ((WORD<s(0)(0)(0)>[T])0x0) ;
    }

    if (pEntity<s(0)(0)(0)>[&]->state<s(0)(0)(0)>[&] != eEm4EntAct<s(0)(0)(0)>[&])
    {
         
        return PB_ERR_STATE<s(0)(0)(0)>[&];
    }

   *pState<s(0)(0)(0)>[&] = pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].adminState<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]];
  

    return ((WORD<s(0)(0)(0)>[T])0x0) ;




    return 0;
}


WORD<s(0)(0)(0)>[T]
CAH_EM4_EnablePrbs<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&])
{




      int port<s(0)(0)(0)>[&] =(D2) 0;
	void * base<s(0)(0)(0)>[&] =(D2) 0;

	{if (125 <  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;
       port<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&])) - 1;
	base<s(0)(0)(0)>[&] = cah_em4_getEntityBase<s(0)(0)(0)>[&] (0, SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]));

    cah_em4_registerCall<s(0)(0)(0)>[&] ((PMyFun<s(0)(0)(0)>[T]) CAH_EM4_EnablePrbs<s(0)(0)(0)>[&], (int) SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]), (int) bEnable<s(0)(0)(0)>[&], 0, 17, __FUNCTION__<s(0)(0)(0)>[&]);

    if (bEnable<s(0)(0)(0)>[&])
    {
        cah_em4_setPrbs2<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&], eEM4_ENABLE<s(0)(0)(0)>[&]);
        
    }
    else
    {
        cah_em4_setPrbs2<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&], eEM4_DISABLE<s(0)(0)(0)>[&]);
        
    }
    return ((WORD<s(0)(0)(0)>[T])0x0) ;

}

PB_ERROR_CODE_T<s(0)(0)(0)>[T]
CAH_EM4_getPrbsMode<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] nulPort<s(0)(0)(0)>[&], PRBS_MODE_T<s(0)(0)(0)>[T] * pMode<s(0)(0)(0)>[&])
{




    CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *pEntity<s(0)(0)(0)>[&];(D1:pEntity:0)
    ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&] =(D2) 0;
    int ulPort<s(0)(0)(0)>[&] =(D2) 0;

    ulPort<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (nulPort<s(0)(0)(0)>[&]);


    if ((((  entity<s(0)(0)(0)>[&]   >= ((1) ) )) || ((   ulChip<s(0)(0)(0)>[&]  )  >=  (1) ) || ((   ulPort<s(0)(0)(0)>[&]  ) >= (63 ) ) ) )     
    {
        printf<s(0)(0)(0)>[&] ("\r\n**Error!  Entity= %d; File=%s; Line=%d  \r\n", entity<s(0)(0)(0)>[&], "cah_126e1.c", 7044);
        return PB_ERR_PARAM<s(0)(0)(0)>[&];
    }

    if (!pMode<s(0)(0)(0)>[&])
    {
        printf<s(0)(0)(0)>[&] ("\r\nEntity%d: %s %d EM4_GetPrbsMode pMode is NULL!  \r\n", entity<s(0)(0)(0)>[&], "cah_126e1.c",
                7051);
        return PB_ERR_PARAM<s(0)(0)(0)>[&];
    }

    pEntity<s(0)(0)(0)>[&] = cah_em4_getEntityPtr<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&]);
    if (pEntity<s(0)(0)(0)>[&]->state<s(0)(0)(0)>[&] == eEm4EntInit<s(0)(0)(0)>[&])
    {
        return ((WORD<s(0)(0)(0)>[T])0x0) ;
    }

    if (pEntity<s(0)(0)(0)>[&]->state<s(0)(0)(0)>[&] != eEm4EntAct<s(0)(0)(0)>[&])
    {
         
        return PB_ERR_STATE<s(0)(0)(0)>[&];
    }

    *pMode<s(0)(0)(0)>[&] = pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].prbsCfg<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].prbsMode<s(0)(0)(0)>[&];    
    return ((WORD<s(0)(0)(0)>[T])0x0) ;





    return 0;
}






int em4GetPrbsErrTest<s(0)(0)(0)>[&] (int port<s(0)(0)(0)>[&])
{
    DWORD<s(0)(0)(0)>[T] cnt<s(0)(0)(0)>[&] =(D2) 0;

    {if (125 <  port<s(0)(0)(0)>[&] ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  port<s(0)(0)(0)>[&] ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;

    CAH_EM4_GetPrbsErrCount<s(0)(0)(0)>[&] (0, port<s(0)(0)(0)>[&], &cnt<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\n%s(): cnt(%d)", __FUNCTION__<s(0)(0)(0)>[&], cnt<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\n");
    return 0;
}
 


WORD<s(0)(0)(0)>[T]
CAH_EM4_GetPrbsErrCount<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] * dwPrbsCnt<s(0)(0)(0)>[&])
{




    int ulPort<s(0)(0)(0)>[&] =(D2) 0;
    int nulPort<s(0)(0)(0)>[&] =(D2) SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]);
	void * base<s(0)(0)(0)>[&] =(D2) 0;
	unsigned short c1<s(0)(0)(0)>[&] =(D2) 0, c2<s(0)(0)(0)>[&] =(D2) 0;

	{if (125 <  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;
       ulPort<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (nulPort<s(0)(0)(0)>[&]) - 1;
	base<s(0)(0)(0)>[&] = cah_em4_getEntityBase<s(0)(0)(0)>[&] (0, SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]));

     












	
    cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x05 << 10) | 0x20 , ulPort<s(0)(0)(0)>[&] & 0x003f);    
    c2<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x05 << 10) | 0x22 );
    c1<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x05 << 10) | 0x21 );
	*dwPrbsCnt<s(0)(0)(0)>[&] = (c2<s(0)(0)(0)>[&] + (c1<s(0)(0)(0)>[&] << 16));
    return ((WORD<s(0)(0)(0)>[T])0x0) ;

}

PB_ERROR_CODE_T<s(0)(0)(0)>[T]
CAH_EM4_forceRptDefect<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] nulPort<s(0)(0)(0)>[&])
{





    CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *pEntity<s(0)(0)(0)>[&];(D1:pEntity:0)
    ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&] =(D2) 0;
    int ulPort<s(0)(0)(0)>[&] =(D2) 0;

    ulPort<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (nulPort<s(0)(0)(0)>[&]);


    if ((((  entity<s(0)(0)(0)>[&]   >= ((1) ) )) || ((   ulChip<s(0)(0)(0)>[&]  )  >=  (1) ) || ((   ulPort<s(0)(0)(0)>[&]  ) >= (63 ) ) ) )  
    {
        printf<s(0)(0)(0)>[&] ("\r\n**Error!  Entity= %d; File=%s; Line=%d  \r\n", entity<s(0)(0)(0)>[&], "cah_126e1.c", 7219);
        return PB_ERR_PARAM<s(0)(0)(0)>[&];
    }

    pEntity<s(0)(0)(0)>[&] = cah_em4_getEntityPtr<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&]);
    if (pEntity<s(0)(0)(0)>[&]->state<s(0)(0)(0)>[&] != eEm4EntAct<s(0)(0)(0)>[&])
    {
        printf<s(0)(0)(0)>[&] ("\r\n**Error!  Entity= %d; File=%s; Line=%d  \r\n", entity<s(0)(0)(0)>[&], "cah_126e1.c", 7226);
        return PB_ERR_STATE<s(0)(0)(0)>[&];
    }

    pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].forceRptAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]] = 1 ;    

    return ((WORD<s(0)(0)(0)>[T])0x0) ;





    return 0;
}

PB_ERROR_CODE_T<s(0)(0)(0)>[T]
CAH_EM4_forceReportEpg<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&])
{




    UINT8<s(0)(0)(0)>[T] chipNo<s(0)(0)(0)>[&];(D1:chipNo:0)
    ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&] =(D2) 0;

    chipNo<s(0)(0)(0)>[&] = cah_em4_ent2chipno<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&]);

    gCahEm4TribVar<s(0)(0)(0)>[&].EM4LatchForceRpt<s(0)(0)(0)>[&][chipNo<s(0)(0)(0)>[&]] = 1 ;

    return ((WORD<s(0)(0)(0)>[T])0x0) ;

    return 0;
}



 


PB_ERROR_CODE_T<s(0)(0)(0)>[T]
CAH_EM4_forceInsertAis<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] nulPort<s(0)(0)(0)>[&], ALARM_DIRECTION_T<s(0)(0)(0)>[T] dir<s(0)(0)(0)>[&],
                        BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&])
{




    int ulPort<s(0)(0)(0)>[&] =(D2) 0;

    ulPort<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (nulPort<s(0)(0)(0)>[&]);
    return ((WORD<s(0)(0)(0)>[T])0x0) ;


    return 0;
}

 


PB_ERROR_CODE_T<s(0)(0)(0)>[T]
CAH_EM4_forceInsertRdi<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] nulPort<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&])
{




    CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *pEntity<s(0)(0)(0)>[&];(D1:pEntity:0)
    void *base<s(0)(0)(0)>[&] =(D2) 0x0000;
    int port<s(0)(0)(0)>[&] =(D2) 0;
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0x0000;
    ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&] =(D2) 0;
    int ulPort<s(0)(0)(0)>[&] =(D2) 0;
    __EXAR_INSERT_CTRL_T<s(0)(0)(0)>[T] insertCtrlReg<s(0)(0)(0)>[&];(D1:insertCtrlReg:0)
    UINT8<s(0)(0)(0)>[T] G1<s(0)(0)(0)>[&] =(D2) 0;

    ulPort<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (nulPort<s(0)(0)(0)>[&]);

     



    if (1)
        return ((WORD<s(0)(0)(0)>[T])0x0) ;

    if ((((  entity<s(0)(0)(0)>[&]   >= ((1) ) )) || ((   ulChip<s(0)(0)(0)>[&]  )  >=  (1) ) || ((   ulPort<s(0)(0)(0)>[&]  ) >= (63 ) ) ) )    
    {
        printf<s(0)(0)(0)>[&] ("\r\n**Error!  Entity= %d; File=%s; Line=%d  \r\n", entity<s(0)(0)(0)>[&], "cah_126e1.c", 7312);
        return PB_ERR_PARAM<s(0)(0)(0)>[&];
    }

    pEntity<s(0)(0)(0)>[&] = cah_em4_getEntityPtr<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&]);

    cah_em4_registerCall<s(0)(0)(0)>[&] ((PMyFun<s(0)(0)(0)>[T]) CAH_EM4_forceInsertRdi<s(0)(0)(0)>[&], (int) nulPort<s(0)(0)(0)>[&], (int) bEnable<s(0)(0)(0)>[&], 0, 21, __FUNCTION__<s(0)(0)(0)>[&]);

     



    memset<s(0)(0)(0)>[&]((INT1<s(0)(0)(0)>[T] *)( &insertCtrlReg<s(0)(0)(0)>[&] ), (  0 ), (  sizeof (insertCtrlReg<s(0)(0)(0)>[&]) )) ;

    base<s(0)(0)(0)>[&] = (void *) cah_em4_getEntityBase<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&]);
    cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x04 << 10) | 0x30 , port<s(0)(0)(0)>[&]);       
    taskDelay<s(0)(0)(0)>[&] (5);
    u<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x04 << 10) | 0x40 );
    insertCtrlReg<s(0)(0)(0)>[&].insertCtrlBit<s(0)(0)(0)>[&].rdi<s(0)(0)(0)>[&] = ((u<s(0)(0)(0)>[&] & 0x00ff) & 0x0001) ? 1 : 0;

    if (bEnable<s(0)(0)(0)>[&])
    {
        insertCtrlReg<s(0)(0)(0)>[&].insertCtrlBit<s(0)(0)(0)>[&].rdi<s(0)(0)(0)>[&] = 0x01;
        G1<s(0)(0)(0)>[&] = 0x08;
         
         pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].frdiMode<s(0)(0)(0)>[&][nulPort<s(0)(0)(0)>[&]] = EM4_UP_FORCE<s(0)(0)(0)>[&];
    }
    else
    {
        insertCtrlReg<s(0)(0)(0)>[&].insertCtrlBit<s(0)(0)(0)>[&].rdi<s(0)(0)(0)>[&] = 0x00;
        G1<s(0)(0)(0)>[&] = 0;
         
         pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].frdiMode<s(0)(0)(0)>[&][nulPort<s(0)(0)(0)>[&]] = EM4_NONE_FORCE<s(0)(0)(0)>[&];
    }

 


     


    if (insertCtrlReg<s(0)(0)(0)>[&].insertCtrlBit<s(0)(0)(0)>[&].rdi<s(0)(0)(0)>[&])
    {
        u<s(0)(0)(0)>[&] |= 0x0003;
    }
    else
    {
        u<s(0)(0)(0)>[&] &= ~0x0001;
    }
    u<s(0)(0)(0)>[&] |= 0x0002;
    u<s(0)(0)(0)>[&] &= ~0x0020;
    cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], (0x04 << 10) | 0x40 , u<s(0)(0)(0)>[&]);
    taskDelay<s(0)(0)(0)>[&] (5);

    return ((WORD<s(0)(0)(0)>[T])0x0) ;


    return 0;
}

int em4GetPpiBipTest<s(0)(0)(0)>[&] (int port<s(0)(0)(0)>[&])
{
    DWORD<s(0)(0)(0)>[T] bip<s(0)(0)(0)>[&] =(D2) 0, rei<s(0)(0)(0)>[&] =(D2) 0;

    {if (125 <  port<s(0)(0)(0)>[&] ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  port<s(0)(0)(0)>[&] ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;
    CAH_EM4_GetPpiBipCount<s(0)(0)(0)>[&] (0, port<s(0)(0)(0)>[&], &bip<s(0)(0)(0)>[&], &rei<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("%s(): bip(%d), rei(%d)", __FUNCTION__<s(0)(0)(0)>[&], bip<s(0)(0)(0)>[&], rei<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\n");

    return 0;
}



WORD<s(0)(0)(0)>[T]
CAH_EM4_GetPpiBipCount<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] * pPpiBip<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] * pPpiFebe<s(0)(0)(0)>[&])
{
	int port<s(0)(0)(0)>[&] =(D2) 0;
	void * base<s(0)(0)(0)>[&] =(D2) 0;
	unsigned short remote<s(0)(0)(0)>[&] =(D2) 0;
	unsigned short near<s(0)(0)(0)>[&] =(D2) 0, err<s(0)(0)(0)>[&] =(D2) 0;

	{if (125 <  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;
	port<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&])) - 1;
	base<s(0)(0)(0)>[&] = cah_em4_getEntityBase<s(0)(0)(0)>[&] (0, SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]));





	err<s(0)(0)(0)>[&] = cah_em4_readCrc4RemoteReg<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&], &near<s(0)(0)(0)>[&], &remote<s(0)(0)(0)>[&]);	

	
	*pPpiBip<s(0)(0)(0)>[&] = near<s(0)(0)(0)>[&];
	*pPpiFebe<s(0)(0)(0)>[&] = remote<s(0)(0)(0)>[&];

    return ((WORD<s(0)(0)(0)>[T])0x0) ;
}

int em4GetBipTest<s(0)(0)(0)>[&] (int port<s(0)(0)(0)>[&])
{
    DWORD<s(0)(0)(0)>[T] bip<s(0)(0)(0)>[&] =(D2) 0, rei<s(0)(0)(0)>[&] =(D2) 0;

    {if (125 <  port<s(0)(0)(0)>[&] ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  port<s(0)(0)(0)>[&] ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;
    CAH_EM4_GetLpBipCount<s(0)(0)(0)>[&] (0, port<s(0)(0)(0)>[&], &bip<s(0)(0)(0)>[&], &rei<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("%s(): bip(%d), rei(%d)", __FUNCTION__<s(0)(0)(0)>[&], bip<s(0)(0)(0)>[&], rei<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\n");

    return 0;
}


WORD<s(0)(0)(0)>[T]
CAH_EM4_GetLpBipCount<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] * pLpBip<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] * pLpRei<s(0)(0)(0)>[&])
{
	void * base<s(0)(0)(0)>[&] =(D2) 0;
	int port<s(0)(0)(0)>[&] =(D2) 0;
	unsigned short bip2<s(0)(0)(0)>[&] =(D2) 0;
	unsigned short rei<s(0)(0)(0)>[&] =(D2) 0;

	{if (125 <  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;

	port<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&])) - 1;
	base<s(0)(0)(0)>[&] = cah_em4_getEntityBase<s(0)(0)(0)>[&] (0, SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]));

	bip2<s(0)(0)(0)>[&] = cah_em4_pohRead<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&], 0x05 );
	rei<s(0)(0)(0)>[&]  = cah_em4_pohRead<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&], 0x06 );	
	*pLpBip<s(0)(0)(0)>[&] = bip2<s(0)(0)(0)>[&];
	*pLpRei<s(0)(0)(0)>[&] = rei<s(0)(0)(0)>[&];

    return ((WORD<s(0)(0)(0)>[T])0x0) ;
}

PB_ERROR_CODE_T<s(0)(0)(0)>[T]
CAH_EM4_getLpPmPara<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] nulPort<s(0)(0)(0)>[&], MSHPLP_PMPARA_T<s(0)(0)(0)>[T] * pPmPara<s(0)(0)(0)>[&])
{





    CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *pEntity<s(0)(0)(0)>[&] =(D2) ((void *)0) ;
    UINT32<s(0)(0)(0)>[T] data<s(0)(0)(0)>[&] =(D2) 0;
    UINT32<s(0)(0)(0)>[T] temp<s(0)(0)(0)>[&] =(D2) 0;
    unsigned int d1<s(0)(0)(0)>[&] =(D2) 0, d2<s(0)(0)(0)>[&] =(D2) 0;
    MSHPLP_PMPARA_T<s(0)(0)(0)>[T] pmParm<s(0)(0)(0)>[&];(D1:pmParm:0)
    void *base<s(0)(0)(0)>[&] =(D2) 0x0000;
    int port<s(0)(0)(0)>[&] =(D2) 0;
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0x0000;
    ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&] =(D2) 0;
    int ulPort<s(0)(0)(0)>[&] =(D2) 0;

    ulPort<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (nulPort<s(0)(0)(0)>[&]);


    if ((((  entity<s(0)(0)(0)>[&]   >= ((1) ) )) || ((   ulChip<s(0)(0)(0)>[&]  )  >=  (1) ) || ((   ulPort<s(0)(0)(0)>[&]  ) >= (63 ) ) ) )  
    {
        printf<s(0)(0)(0)>[&] ("\r\n**Error!  Entity= %d; File=%s; Line=%d  \r\n", entity<s(0)(0)(0)>[&], "cah_126e1.c", 7488);
        return PB_ERR_PARAM<s(0)(0)(0)>[&];
    }

    if (!pPmPara<s(0)(0)(0)>[&])
    {
        printf<s(0)(0)(0)>[&] ("\r\nEntity%d: %s %d EM4_GetLpPmPara pPmPara is NULL!  \r\n", entity<s(0)(0)(0)>[&], "cah_126e1.c",
                7495);
        return PB_ERR_PARAM<s(0)(0)(0)>[&];
    }

    if (((void *)0)  == (pEntity<s(0)(0)(0)>[&] = cah_em4_getEntityPtr<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&])))
    {
        printf<s(0)(0)(0)>[&] ("\r\nlppm: entity(%d) NULL", entity<s(0)(0)(0)>[&]);
        return PB_ERR_PARAM<s(0)(0)(0)>[&];
    }

    if (pEntity<s(0)(0)(0)>[&]->state<s(0)(0)(0)>[&] == eEm4EntInit<s(0)(0)(0)>[&])
    {
        return ((WORD<s(0)(0)(0)>[T])0x0) ;
    }

    if (eEm4EntAct<s(0)(0)(0)>[&] != pEntity<s(0)(0)(0)>[&]->state<s(0)(0)(0)>[&])
    {
        printf<s(0)(0)(0)>[&] ("\r\ngetpm: entity(%d), not active", entity<s(0)(0)(0)>[&]);
        return PB_ERR_STATE<s(0)(0)(0)>[&];
    }

    memset<s(0)(0)(0)>[&]((INT1<s(0)(0)(0)>[T] *)( &pmParm<s(0)(0)(0)>[&] ), (  0 ), (  sizeof (MSHPLP_PMPARA_T<s(0)(0)(0)>[T]) )) ;
     
     


    base<s(0)(0)(0)>[&] = (void *) cah_em4_getEntityBase<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&], ulPort<s(0)(0)(0)>[&]);
   
    u<s(0)(0)(0)>[&] = port<s(0)(0)(0)>[&] = ulPort<s(0)(0)(0)>[&];
    temp<s(0)(0)(0)>[&] = cah_em4_pohRead<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&], 0x05 );    
    d1<s(0)(0)(0)>[&] = data<s(0)(0)(0)>[&] = temp<s(0)(0)(0)>[&];

    pmParm<s(0)(0)(0)>[&].bip<s(0)(0)(0)>[&] = data<s(0)(0)(0)>[&];

    data<s(0)(0)(0)>[&] = 0;


    base<s(0)(0)(0)>[&] = (void *) cah_em4_getEntityBase<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&], ulPort<s(0)(0)(0)>[&]);    
    u<s(0)(0)(0)>[&] = port<s(0)(0)(0)>[&] = ulPort<s(0)(0)(0)>[&];
    temp<s(0)(0)(0)>[&] = cah_em4_pohRead<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], port<s(0)(0)(0)>[&], 0x06 );    
    d2<s(0)(0)(0)>[&] = data<s(0)(0)(0)>[&] = (temp<s(0)(0)(0)>[&]);

    pmParm<s(0)(0)(0)>[&].rei<s(0)(0)(0)>[&] = data<s(0)(0)(0)>[&];


    if (pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].ssf<s(0)(0)(0)>[&]   )
    {
        pmParm<s(0)(0)(0)>[&].bip<s(0)(0)(0)>[&] = 0;
        pmParm<s(0)(0)(0)>[&].rei<s(0)(0)(0)>[&] = 0;
        pmParm<s(0)(0)(0)>[&].fefc<s(0)(0)(0)>[&] = 0;
         
        pmParm<s(0)(0)(0)>[&].fc<s(0)(0)(0)>[&] = 1 + pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][nulPort<s(0)(0)(0)>[&]].ssfFc<s(0)(0)(0)>[&];
    }
    else
    {
        pmParm<s(0)(0)(0)>[&].fc<s(0)(0)(0)>[&] = 0;
        if (pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].rdi<s(0)(0)(0)>[&]
              )
        {
            pmParm<s(0)(0)(0)>[&].fefc<s(0)(0)(0)>[&] = 1
                + pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].rdiFc<s(0)(0)(0)>[&]
                + pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].rfiFc<s(0)(0)(0)>[&];             
            pmParm<s(0)(0)(0)>[&].rei<s(0)(0)(0)>[&] = 0;
        }                        



        else
        {
            pmParm<s(0)(0)(0)>[&].fefc<s(0)(0)(0)>[&] = 0;
        }
    }

    if (pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].ssf<s(0)(0)(0)>[&] == 0x0100 )
    {
        pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].ssf<s(0)(0)(0)>[&] = 0;
    }
    pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].ssfFc<s(0)(0)(0)>[&] = 0;

    if (pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].rdi<s(0)(0)(0)>[&] == 0x0100 )
    {
        pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].rdi<s(0)(0)(0)>[&] = 0;
    }
    pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].rdiFc<s(0)(0)(0)>[&] = 0;
    if (pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].rfi<s(0)(0)(0)>[&] == 0x0100 )
    {
        pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].rfi<s(0)(0)(0)>[&] = 0;
    }
    pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].rfiFc<s(0)(0)(0)>[&] = 0;
    
    

    memcpy<s(0)(0)(0)>[&]((INT1<s(0)(0)(0)>[T] *)( pPmPara<s(0)(0)(0)>[&] ), (INT1<s(0)(0)(0)>[T] *)(  &pmParm<s(0)(0)(0)>[&] ), (  sizeof (pmParm<s(0)(0)(0)>[&]) )) ;

    cah_em4_trace<s(0)(0)(0)>[&] (18, "ent(%d), port(%d), bip(%d:%d), rei(%d:%d), fc(%d), fefc(%d), ssf(%x)",
                   entity<s(0)(0)(0)>[&], ulPort<s(0)(0)(0)>[&], pPmPara<s(0)(0)(0)>[&]->bip<s(0)(0)(0)>[&], d1<s(0)(0)(0)>[&], pPmPara<s(0)(0)(0)>[&]->rei<s(0)(0)(0)>[&], d2<s(0)(0)(0)>[&], pPmPara<s(0)(0)(0)>[&]->fc<s(0)(0)(0)>[&], pPmPara<s(0)(0)(0)>[&]->fefc<s(0)(0)(0)>[&],
                   pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].pohAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].ssf<s(0)(0)(0)>[&]);
    
    
    return ((WORD<s(0)(0)(0)>[T])0x0) ;








    return 0;
}


WORD<s(0)(0)(0)>[T]
CAH_EM4_DetectCardState<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] * pbActive<s(0)(0)(0)>[&])
{




    CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *p<s(0)(0)(0)>[&]=(D2) ((void *)0) ;
    PB_ERROR_CODE_T<s(0)(0)(0)>[T] ret<s(0)(0)(0)>[&];(D1:ret:0)

    if (!pbActive<s(0)(0)(0)>[&])
    {
        printf<s(0)(0)(0)>[&] ("\r\n%s(): pbActive is NULL!  \r\n", __FUNCTION__<s(0)(0)(0)>[&]);
        return PB_ERR_PARAM<s(0)(0)(0)>[&];
    }

    ret<s(0)(0)(0)>[&] = cah_em4_detectCardStateEx<s(0)(0)(0)>[&] (p<s(0)(0)(0)>[&], pbActive<s(0)(0)(0)>[&]);

    return ret<s(0)(0)(0)>[&];

}

PB_ERROR_CODE_T<s(0)(0)(0)>[T]
CAH_EM4_blockAIS<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bEnable<s(0)(0)(0)>[&])
{





    CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *pEntity<s(0)(0)(0)>[&] =(D2) ((void *)0) ;
    UINT32<s(0)(0)(0)>[T] ulChip<s(0)(0)(0)>[&] =(D2) 0;
    UINT32<s(0)(0)(0)>[T] ulPort<s(0)(0)(0)>[&] =(D2) 0;
    ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&] =(D2) 0;

    pEntity<s(0)(0)(0)>[&] = cah_em4_getEntityPtr<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&]);

    cah_em4_registerCall<s(0)(0)(0)>[&] ((PMyFun<s(0)(0)(0)>[T]) CAH_EM4_blockAIS<s(0)(0)(0)>[&], 0, 0, bEnable<s(0)(0)(0)>[&], 24, __FUNCTION__<s(0)(0)(0)>[&]);

    if (pEntity<s(0)(0)(0)>[&]->state<s(0)(0)(0)>[&] != eEm4EntAct<s(0)(0)(0)>[&])
    {
         
        return PB_ERR_STATE<s(0)(0)(0)>[&];
    }


    for (ulChip<s(0)(0)(0)>[&] = 0; ulChip<s(0)(0)(0)>[&] < pEntity<s(0)(0)(0)>[&]->chipNum<s(0)(0)(0)>[&]; ulChip<s(0)(0)(0)>[&]++)
    {
        for (ulPort<s(0)(0)(0)>[&] = 0; ulPort<s(0)(0)(0)>[&] < (63 ) ; ulPort<s(0)(0)(0)>[&]++)
        {
            if (bEnable<s(0)(0)(0)>[&])
            {
                pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].bBlockAis<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]] = 1 ;
                cah_em4_insertUpAis<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&], ulChip<s(0)(0)(0)>[&], ulPort<s(0)(0)(0)>[&], 0 );
            }
            else
            {
                pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].bBlockAis<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]] = 0 ;
            }
        }
    }

    return ((WORD<s(0)(0)(0)>[T])0x0) ;




    return 0;
}










WORD<s(0)(0)(0)>[T]
CAH_EM4_Initialize<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&])
{
    printf<s(0)(0)(0)>[&] ("\r\n%s():\t called dwPos(%d)", __FUNCTION__<s(0)(0)(0)>[&], dwPos<s(0)(0)(0)>[&]);

	CAH_EM4_activateEntity<s(0)(0)(0)>[&] (0, 0 );
    return ((WORD<s(0)(0)(0)>[T])0x0) ;
}



 





WORD<s(0)(0)(0)>[T]
CAH_EM4_GetInnerB1Err<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] *pdwB1Err<s(0)(0)(0)>[&])
{
    return ((WORD<s(0)(0)(0)>[T])0x0) ;
}



 





WORD<s(0)(0)(0)>[T]
CAH_EM4_GetTdmLinkErr<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] *pdwTdmErr<s(0)(0)(0)>[&])
{
    return ((WORD<s(0)(0)(0)>[T])0x0) ;
}


 




WORD<s(0)(0)(0)>[T]
CAH_EM4_Get8KClkState<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] *pbActive<s(0)(0)(0)>[&])
{
    return ((WORD<s(0)(0)(0)>[T])0x0) ;
}

 





WORD<s(0)(0)(0)>[T]
CAH_EM4_Get19MClkState<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] *pbActive<s(0)(0)(0)>[&])
{
    return ((WORD<s(0)(0)(0)>[T])0x0) ;
}

 




WORD<s(0)(0)(0)>[T]
CAH_EM4_GetPllState<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] * pbPllLock<s(0)(0)(0)>[&])
{
    unsigned char * p<s(0)(0)(0)>[&] =(D2) (unsigned char *)0x70000110 ;

    *pbPllLock<s(0)(0)(0)>[&] = ((*p<s(0)(0)(0)>[&]) & 0x02) ? 1  : 0 ;

    return ((WORD<s(0)(0)(0)>[T])0x0) ;
}



 

































WORD<s(0)(0)(0)>[T]
CAH_EM4_InitEntity<s(0)(0)(0)>[&] (ENTITY_T<s(0)(0)(0)>[T] etEntity<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], CTD_MODE_TYPE_T<s(0)(0)(0)>[T] eporttype<s(0)(0)(0)>[&])
{




    CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *pEntity<s(0)(0)(0)>[&];(D1:pEntity:0)
	int ulChip<s(0)(0)(0)>[&] =(D2) 0, ulPort<s(0)(0)(0)>[&] =(D2) 0, i<s(0)(0)(0)>[&] =(D2) 0;

    cah_em4_showbuild<s(0)(0)(0)>[&] ();
    CAH_EM4_loadModule<s(0)(0)(0)>[&] ();

    printf<s(0)(0)(0)>[&] ("\r\n%s():\tentity(%d),\tdwPos(%d),\tporttype(%d)", __FUNCTION__<s(0)(0)(0)>[&], etEntity<s(0)(0)(0)>[&], dwPos<s(0)(0)(0)>[&], eporttype<s(0)(0)(0)>[&]);
    cah_em4_trace<s(0)(0)(0)>[&] (1 , "%s: File(%s) Line(%d)", __FUNCTION__<s(0)(0)(0)>[&], "cah_126e1.c", 7832);

    if (((void *)0)  == (pEntity<s(0)(0)(0)>[&] = cah_em4_OpenEx<s(0)(0)(0)>[&] ()))
    {
        printf<s(0)(0)(0)>[&] ("\r\n%s(): cah_em4_OpenEx() CANNOT GET FD!!!", __FUNCTION__<s(0)(0)(0)>[&]);
        return ((WORD<s(0)(0)(0)>[T])0x1) ;
    }

    cah_em4_printf<s(0)(0)(0)>[&] ("\r\n126xe1rt: pEntity(%p)", pEntity<s(0)(0)(0)>[&]);

     


    pEntity<s(0)(0)(0)>[&]->entity<s(0)(0)(0)>[&] = 0;
    pEntity<s(0)(0)(0)>[&]->dwPos<s(0)(0)(0)>[&] = 0;
    pEntity<s(0)(0)(0)>[&]->chipNum<s(0)(0)(0)>[&] = 2;
    pEntity<s(0)(0)(0)>[&]->state<s(0)(0)(0)>[&] = eEm4EntInit<s(0)(0)(0)>[&];
    pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][0].cfg<s(0)(0)(0)>[&].baseAddr<s(0)(0)(0)>[&] = (0x50000000) ;
    pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][1].cfg<s(0)(0)(0)>[&].baseAddr<s(0)(0)(0)>[&] = (0x60000000) ;
    pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][0].su_id<s(0)(0)(0)>[&] = 0;
    pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][1].su_id<s(0)(0)(0)>[&] = 0;

    cah_em4_initVars<s(0)(0)(0)>[&] (pEntity<s(0)(0)(0)>[&], 2);
    for (i<s(0)(0)(0)>[&] = 0; i<s(0)(0)(0)>[&] < 8; i<s(0)(0)(0)>[&] ++) g_timingVirtualSlot<s(0)(0)(0)>[&][i<s(0)(0)(0)>[&]] = 0;

    for (ulChip<s(0)(0)(0)>[&] = 0; ulChip<s(0)(0)(0)>[&] < (int)pEntity<s(0)(0)(0)>[&]->chipNum<s(0)(0)(0)>[&]; ulChip<s(0)(0)(0)>[&]++)
    {
        for (ulPort<s(0)(0)(0)>[&] = 0; ulPort<s(0)(0)(0)>[&] < (63 ) ; ulPort<s(0)(0)(0)>[&]++)
        {
             


            pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].forceRptAlm<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]] = 1 ;
            pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].prbsCfg<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]].bForceRpt<s(0)(0)(0)>[&] = 1 ;
            pEntity<s(0)(0)(0)>[&]->chip_var<s(0)(0)(0)>[&][ulChip<s(0)(0)(0)>[&]].nPrbsDelayCount<s(0)(0)(0)>[&][ulPort<s(0)(0)(0)>[&]] = 0;
        }
    }
    return ((WORD<s(0)(0)(0)>[T])0x0) ;

    return 0;
}


CAH_EM4_CHIP_CONFIG_T<s(0)(0)(0)>[T] g_cahEm4ChipCfg<s(0)(0)(0)>[&][2];(D1:g_cahEm4ChipCfg:0)
CAH_EM4_CALLBACKS_T<s(0)(0)(0)>[T] g_callback<s(0)(0)(0)>[&];(D1:g_callback:0)

typedef struct
{
    UINT32<s(1)(1)(0)>[T] address<s(1)(1)(0)>[&];
    unsigned short value<s(1)(1)(0)>[&];
}
CAH_EM4_REG_CONF<s(0)(0)(0)>[&];(D1:CAH_EM4_REG_CONF:1)[[TYPENAME:CAH_EM4_REG_CONF]]

 























 























extern struct _GlobalParams<s(1)(0)(1)>[&] *pGlobalParams<s(0)(0)(0)>[&];(D1:pGlobalParams:0)

extern void sysHardDelayUs<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T] us<s(0)(0)(0)>[&]);(D1:us:0)
extern void InitGlobalParams<s(0)(0)(0)>[&](void);(D1:InitGlobalParams:0)

UINT<s(0)(0)(0)>[T] GetBootProperties<s(0)(0)(0)>[&](void);(D1:GetBootProperties:0)
int GetBoardStyle<s(0)(0)(0)>[&](void);(D1:GetBoardStyle:0)
int GetCardFunction<s(0)(0)(0)>[&](void);(D1:GetCardFunction:0)
UINT<s(0)(0)(0)>[T] GetBoardProperties<s(0)(0)(0)>[&](void);(D1:GetBoardProperties:0)
UINT<s(0)(0)(0)>[T] GetBoardRev<s(0)(0)(0)>[&](void);(D1:GetBoardRev:0)
UINT<s(0)(0)(0)>[T] GetChassisRev<s(0)(0)(0)>[&](void);(D1:GetChassisRev:0)

int GetFlashSize<s(0)(0)(0)>[&] (void);(D1:GetFlashSize:0)
int GetRamSize<s(0)(0)(0)>[&] (void);(D1:GetRamSize:0)
int GetFlashType<s(0)(0)(0)>[&](void);(D1:GetFlashType:0)
int GetSysFlashAddr<s(0)(0)(0)>[&] (void);(D1:GetSysFlashAddr:0)

BOOL<s(0)(0)(0)>[T] GetBoardFlashBoot<s(0)(0)(0)>[&](void);(D1:GetBoardFlashBoot:0)
BOOL<s(0)(0)(0)>[T] GetBoardFlashStorage<s(0)(0)(0)>[&](void);(D1:GetBoardFlashStorage:0)

UCHAR<s(0)(0)(0)>[T] *GetBoardMacAddr<s(0)(0)(0)>[&](void);(D1:GetBoardMacAddr:0)

UINT8<s(0)(0)(0)>[T] GetSlotNumber<s(0)(0)(0)>[&](void);(D1:GetSlotNumber:0)

UCHAR<s(0)(0)(0)>[T] *GetBootVersion<s(0)(0)(0)>[&](void);(D1:GetBootVersion:0)
UCHAR<s(0)(0)(0)>[T] *GetBootDate<s(0)(0)(0)>[&](void);(D1:GetBootDate:0)

u_long<s(0)(0)(0)>[T] GetMainIP<s(0)(0)(0)>[&](void);(D1:GetMainIP:0)

UINT32<s(0)(0)(0)>[T] GetBootHostAddress<s(0)(0)(0)>[&](void);(D1:GetBootHostAddress:0)
 
UINT32<s(0)(0)(0)>[T] ppcTBLfreq<s(0)(0)(0)>[&](void);(D1:ppcTBLfreq:0)
UINT32<s(0)(0)(0)>[T] ppcTBLrd<s(0)(0)(0)>[&](void);(D1:ppcTBLrd:0)
UINT32<s(0)(0)(0)>[T] ppcTBUrd<s(0)(0)(0)>[&](void);(D1:ppcTBUrd:0)

void ppcTBLwr<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T]);(D1:UINT32:0)
void ppcTBUwr<s(0)(0)(0)>[&](UINT32<s(0)(0)(0)>[T]);(D1:UINT32:0)

UINT8<s(0)(0)(0)>[T] sysModck13Get<s(0)(0)(0)>[&](void);(D1:sysModck13Get:0)
int sysClkRateGet<s(0)(0)(0)>[&](void);(D1:sysClkRateGet:0)

void enablePrintProcess<s(0)(0)(0)>[&](void);(D1:enablePrintProcess:0)
void disablePrintProcess<s(0)(0)(0)>[&](void);(D1:disablePrintProcess:0)

int GetBoardSStatus<s(0)(0)(0)>[&](void);(D1:GetBoardSStatus:0)
void ClearBoardSStatus<s(0)(0)(0)>[&](int value<s(0)(0)(0)>[&]);(D1:value:0)
void SetBoardSStatus<s(0)(0)(0)>[&](int value<s(0)(0)(0)>[&]);(D1:value:0)
int GetBoardUStatus<s(0)(0)(0)>[&](void);(D1:GetBoardUStatus:0)
void SetBoardUStatus<s(0)(0)(0)>[&](int value<s(0)(0)(0)>[&]);(D1:value:0)

UINT32<s(0)(0)(0)>[T] GetBpSerialNumber<s(0)(0)(0)>[&](char * buffer<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] bufLen<s(0)(0)(0)>[&]);(D1:bufLen:0)
UINT32<s(0)(0)(0)>[T] GetBpManDate<s(0)(0)(0)>[&](char * buffer<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] bufLen<s(0)(0)(0)>[&]);(D1:bufLen:0)


UINT32<s(0)(0)(0)>[T] GetSlotSerialNumber<s(0)(0)(0)>[&](PbSlotNumberType_Tval<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&], char * buffer<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] bufLen<s(0)(0)(0)>[&]);(D1:bufLen:0)
UINT32<s(0)(0)(0)>[T] GetSlotManDate<s(0)(0)(0)>[&](PbSlotNumberType_Tval<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&], char * buffer<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] bufLen<s(0)(0)(0)>[&]);(D1:bufLen:0)
UINT32<s(0)(0)(0)>[T] GetSlotPbCode<s(0)(0)(0)>[&](PbSlotNumberType_Tval<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&], char * buffer<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] bufLen<s(0)(0)(0)>[&]);(D1:bufLen:0)
UINT32<s(0)(0)(0)>[T] GetSlotSiProductNumber<s(0)(0)(0)>[&](PbSlotNumberType_Tval<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&],char * buffer<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] bufLen<s(0)(0)(0)>[&]);(D1:bufLen:0)
UINT32<s(0)(0)(0)>[T] GetSlotOEMProductNumber<s(0)(0)(0)>[&](PbSlotNumberType_Tval<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&], char * buffer<s(0)(0)(0)>[&], UINT32<s(0)(0)(0)>[T] bufLen<s(0)(0)(0)>[&]);(D1:bufLen:0)
int GetSlotCardFunction<s(0)(0)(0)>[&](PbSlotNumberType_Tval<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&]);(D1:slot:0)
int GetSlotBoardStyle<s(0)(0)(0)>[&](PbSlotNumberType_Tval<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&]);(D1:slot:0)
UINT<s(0)(0)(0)>[T] GetSlotBoardRev<s(0)(0)(0)>[&](PbSlotNumberType_Tval<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&]);(D1:slot:0)
UINT<s(0)(0)(0)>[T] GetSlotConfigOption<s(0)(0)(0)>[&](PbSlotNumberType_Tval<s(0)(0)(0)>[T] slot<s(0)(0)(0)>[&]);(D1:slot:0)
void setFusionMisc<s(0)(0)(0)>[&](void);(D1:setFusionMisc:0)
UINT8<s(0)(0)(0)>[T] GetFusionMisc<s(0)(0)(0)>[&](void);(D1:GetFusionMisc:0)
UINT8<s(0)(0)(0)>[T] scFpgaByteRead<s(0)(0)(0)>[&](int addr<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] readClear<s(0)(0)(0)>[&], const char * func<s(0)(0)(0)>[&], int line<s(0)(0)(0)>[&] );(D1:line:0)
INT32<s(0)(0)(0)>[T] scFpgaByteWrite<s(0)(0)(0)>[&](int addr<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] value<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] writeClear<s(0)(0)(0)>[&], const char * func<s(0)(0)(0)>[&], int line<s(0)(0)(0)>[&] );(D1:line:0)
UINT8<s(0)(0)(0)>[T] scFpgaBitRead<s(0)(0)(0)>[&](int addr<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] mask<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] readClear<s(0)(0)(0)>[&], const char * func<s(0)(0)(0)>[&], int line<s(0)(0)(0)>[&] );(D1:line:0)
INT32<s(0)(0)(0)>[T] scFpgaBitWrite<s(0)(0)(0)>[&](int addr<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] value<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] mask<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] writeClear<s(0)(0)(0)>[&], const char * func<s(0)(0)(0)>[&], int line<s(0)(0)(0)>[&] );(D1:line:0)


int slowJobAdd<s(0)(0)(0)>[&](FUNCPTR<s(0)(0)(0)>[T] routine<s(0)(0)(0)>[&], int param1<s(0)(0)(0)>[&], int param2<s(0)(0)(0)>[&], int param3<s(0)(0)(0)>[&], int param4<s(0)(0)(0)>[&]);(D1:param4:0)

void RomWriteEnable<s(0)(0)(0)>[&](void);(D1:RomWriteEnable:0)
void RomWriteDisable<s(0)(0)(0)>[&](void);(D1:RomWriteDisable:0)
void setBootFlashVpp<s(0)(0)(0)>[&](int );(D1:setBootFlashVpp:0)
    














 




 































	

























     

     






    typedef enum {
        FPGA_CTRL_OK<s(0)(0)(0)>[&] = 0,
        FPGA_CTRL_ERROR<s(0)(0)(0)>[&] = -1,
        FPGA_UNDEFINE_BOARDSTYLE<s(0)(0)(0)>[&] = 101,
        FPGA_SETDABDL_FAIL<s(0)(0)(0)>[&],
        FPGA_SETDABACCESS_FAIL<s(0)(0)(0)>[&],
        FPGA_SETOFFLINE_FAIL<s(0)(0)(0)>[&],
        FPGA_SETCLOCK_FAIL<s(0)(0)(0)>[&],
        FPGA_RESETCARD_FAIL<s(0)(0)(0)>[&],
        FPGA_DLFPGA_FAIL<s(0)(0)(0)>[&],
        FPGA_INVALID_PARAM<s(0)(0)(0)>[&],
        FPGA_BOARD_REV_ERROR<s(0)(0)(0)>[&],
        FPGA_GLUE_TEST_ERROR<s(0)(0)(0)>[&]
    }FPGA_DLFPGA_T<s(0)(0)(0)>[&];(D1:FPGA_DLFPGA_T:1)[[TYPENAME:FPGA_DLFPGA_T]]
     


     
    int fpga_InitCard<s(0)(0)(0)>[&] ( int slot<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] bDLFPGA<s(0)(0)(0)>[&] );(D1:bDLFPGA:0)






 
































void em4SetTbLoop<s(0)(0)(0)>[&] (void)
{
	unsigned short u<s(0)(0)(0)>[&] =(D2) 0;

	u<s(0)(0)(0)>[&] = em4Map1Rd<s(0)(0)(0)>[&] (0, 1);
	u<s(0)(0)(0)>[&] |= 0x0002;
	em4Map1Wr<s(0)(0)(0)>[&] (0, 1, u<s(0)(0)(0)>[&]);

	u<s(0)(0)(0)>[&] = em4Map2Rd<s(0)(0)(0)>[&] (0, 1);
	u<s(0)(0)(0)>[&] |= 0x0002;
	em4Map2Wr<s(0)(0)(0)>[&] (0, 1, u<s(0)(0)(0)>[&]);
	cah_em4_printf<s(0)(0)(0)>[&] ("\r\n%s(): bpc loop set !!!", __FUNCTION__<s(0)(0)(0)>[&]);
cah_em4_printf<s(0)(0)(0)>[&] ("\r\n");
cah_em4_printf<s(0)(0)(0)>[&] ("\r\n");
cah_em4_printf<s(0)(0)(0)>[&] ("\r\n");
cah_em4_printf<s(0)(0)(0)>[&] ("\r\n");
cah_em4_printf<s(0)(0)(0)>[&] ("\r\n");
cah_em4_printf<s(0)(0)(0)>[&] ("\r\n");
}



int wydact<s(0)(0)(0)>[&] (void);(D1:wydact:0)
int
wydinit<s(0)(0)(0)>[&] ()
{
    printf<s(0)(0)(0)>[&] ("\r\n%s(): downloading fpga for slot 25...", __FUNCTION__<s(0)(0)(0)>[&]);
    fpga_InitCard<s(0)(0)(0)>[&] (GetSlotNumber<s(0)(0)(0)>[&] (), 1);
printf<s(0)(0)(0)>[&] ("\r\n");
printf<s(0)(0)(0)>[&] ("\r\n");
printf<s(0)(0)(0)>[&] ("\r\n");
printf<s(0)(0)(0)>[&] ("\r\n");
printf<s(0)(0)(0)>[&] ("\r\n");
printf<s(0)(0)(0)>[&] ("\r\n");
    printf<s(0)(0)(0)>[&] ("\r\n%s(): wait for 3 seconds between donwloading fpga and initialize procedure ...", __FUNCTION__<s(0)(0)(0)>[&]);
    taskDelay<s(0)(0)(0)>[&] (sysClkRateGet<s(0)(0)(0)>[&] () * 3);
    memset<s(0)(0)(0)>[&] (&g_cahEm4ChipCfg<s(0)(0)(0)>[&], 0, sizeof (CAH_EM4_CHIP_CONFIG_T<s(0)(0)(0)>[T]));
    memset<s(0)(0)(0)>[&] (&g_callback<s(0)(0)(0)>[&], 0, sizeof (CAH_EM4_CALLBACKS_T<s(0)(0)(0)>[T]));
    if (((WORD<s(0)(0)(0)>[T])0x1)  == CAH_EM4_InitEntity<s(0)(0)(0)>[&] (0, 0, 2))
	{
		printf<s(0)(0)(0)>[&] ("\r\nCAH_EM4_InitEntity () error, abort !!!");
		return 0;
	}

    wydact<s(0)(0)(0)>[&] ();
	taskDelay<s(0)(0)(0)>[&] (sysClkRateGet<s(0)(0)(0)>[&] () * 3);
	em4SetTbLoop<s(0)(0)(0)>[&] ();
    return 0;
}


unsigned short
em4Map2Wr<s(0)(0)(0)>[&] (int page<s(0)(0)(0)>[&], int off<s(0)(0)(0)>[&], unsigned short val<s(0)(0)(0)>[&])
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0;


    cah_em4_wr<s(0)(0)(0)>[&] ((void *) (0x60000000) , ((page<s(0)(0)(0)>[&] << 10) + off<s(0)(0)(0)>[&]), val<s(0)(0)(0)>[&]);
    return u<s(0)(0)(0)>[&];
}


unsigned short
em4Map1Wr<s(0)(0)(0)>[&] (int page<s(0)(0)(0)>[&], int off<s(0)(0)(0)>[&], unsigned short val<s(0)(0)(0)>[&])
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0;


    cah_em4_wr<s(0)(0)(0)>[&] ((void *) (0x50000000) , ((page<s(0)(0)(0)>[&] << 10) + off<s(0)(0)(0)>[&]), val<s(0)(0)(0)>[&]);
    return u<s(0)(0)(0)>[&];
}

unsigned short
em4MapRd<s(0)(0)(0)>[&] (int page<s(0)(0)(0)>[&], int off<s(0)(0)(0)>[&], unsigned short *pU1<s(0)(0)(0)>[&], unsigned short *pU2<s(0)(0)(0)>[&])
{
    unsigned short u2<s(0)(0)(0)>[&] =(D2) 0;
    unsigned short u1<s(0)(0)(0)>[&] =(D2) 0;
    *pU1<s(0)(0)(0)>[&] = u1<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] ((void *) (0x50000000) , ((page<s(0)(0)(0)>[&] << 10) + off<s(0)(0)(0)>[&]));
    *pU2<s(0)(0)(0)>[&] = u2<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] ((void *) (0x60000000) , ((page<s(0)(0)(0)>[&] << 10) + off<s(0)(0)(0)>[&]));

    return u1<s(0)(0)(0)>[&];
}

unsigned short
em4Map2Rd<s(0)(0)(0)>[&] (int page<s(0)(0)(0)>[&], int off<s(0)(0)(0)>[&])
{
    unsigned short u1<s(0)(0)(0)>[&] =(D2) 0;
    u1<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] ((void *) (0x60000000) , ((page<s(0)(0)(0)>[&] << 10) + off<s(0)(0)(0)>[&]));

    return u1<s(0)(0)(0)>[&];
}


unsigned short
em4Map1Rd<s(0)(0)(0)>[&] (int page<s(0)(0)(0)>[&], int off<s(0)(0)(0)>[&])
{
    unsigned short u1<s(0)(0)(0)>[&] =(D2) 0;
    u1<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] ((void *) (0x50000000) , ((page<s(0)(0)(0)>[&] << 10) + off<s(0)(0)(0)>[&]));

    return u1<s(0)(0)(0)>[&];
}

unsigned short
em4_bpc_wr<s(0)(0)(0)>[&] (int page<s(0)(0)(0)>[&], int off<s(0)(0)(0)>[&], unsigned short val<s(0)(0)(0)>[&])
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0;


    cah_em4_wr<s(0)(0)(0)>[&] ((void *) (0x80000000) , ((page<s(0)(0)(0)>[&] << 10) + off<s(0)(0)(0)>[&]), val<s(0)(0)(0)>[&]);
    return u<s(0)(0)(0)>[&];
}

unsigned short
em4_fus_rd<s(0)(0)(0)>[&] (void)
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0;
    u<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] ((void *) 0x70000010, 0);

    return u<s(0)(0)(0)>[&];
}

unsigned short
em4_bpc_rd<s(0)(0)(0)>[&] (int page<s(0)(0)(0)>[&], int off<s(0)(0)(0)>[&])
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0;
    u<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] ((void *) (0x80000000) , ((page<s(0)(0)(0)>[&] << 10) + off<s(0)(0)(0)>[&]));

    return u<s(0)(0)(0)>[&];
}

static void
bpc_mgt_wps<s(0)(0)(0)>[&] (void)
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0;

    u<s(0)(0)(0)>[&] = em4_bpc_rd<s(0)(0)(0)>[&] (1, 0x001);
    if (u<s(0)(0)(0)>[&] & 0x8000)
    {
        printf<s(0)(0)(0)>[&] ("\r\npage(1)off(0x001):\twork channel select");
    }
    else
    {
        printf<s(0)(0)(0)>[&] ("\r\npage(1)off(0x001):\tprotect channel select");
    }
}

void
bpc_dcm_rst_al<s(0)(0)(0)>[&] (void)
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0;

    printf<s(0)(0)(0)>[&] ("\r\npage(4)off(0x000):\treset all dcm");
    em4_bpc_wr<s(0)(0)(0)>[&] (4, 0x000, 0x007);
     
    u<s(0)(0)(0)>[&] = 1;
    return;
}

void
bpc_dcm_st<s(0)(0)(0)>[&] (void)
{
    unsigned short u1<s(0)(0)(0)>[&] =(D2) em4_bpc_rd<s(0)(0)(0)>[&] (4, 0x010);
    unsigned short u2<s(0)(0)(0)>[&] =(D2) em4_bpc_rd<s(0)(0)(0)>[&] (4, 0x011);

    printf<s(0)(0)(0)>[&] ("\r\npage(4)off(0x010):\tclk77m locked: (%x)", u1<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\npage(4)off(0x011):\tclk93m locked: (%x)", u2<s(0)(0)(0)>[&]);

    return;
}

void
bpc_rst<s(0)(0)(0)>[&] (void)
{
    em4_bpc_wr<s(0)(0)(0)>[&] (0, 0x003, 0x0001);
     
    taskDelay<s(0)(0)(0)>[&] (10);
    em4_bpc_wr<s(0)(0)(0)>[&] (0, 0x003, 0x0000);
}

void
mgt_pwr<s(0)(0)(0)>[&] (int flag<s(0)(0)(0)>[&])
{
    if (flag<s(0)(0)(0)>[&])
    {
        em4_bpc_wr<s(0)(0)(0)>[&] (1, 0x20, 0);
        em4_bpc_wr<s(0)(0)(0)>[&] (1, 0x30, 0);
    }
    else
    {
        em4_bpc_wr<s(0)(0)(0)>[&] (1, 0x20, 1);
        em4_bpc_wr<s(0)(0)(0)>[&] (1, 0x30, 1);
    }
}

void
bpc_mgt_descram<s(0)(0)(0)>[&] (int ch<s(0)(0)(0)>[&], int en<s(0)(0)(0)>[&])
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0;

    if (ch<s(0)(0)(0)>[&])
    {
        cah_em4_printf<s(0)(0)(0)>[&] ("\r\npage(1)off(0x34):\tprotect channel");
        u<s(0)(0)(0)>[&] = em4_bpc_rd<s(0)(0)(0)>[&] (1, 0x034);
    }
    else
    {
        cah_em4_printf<s(0)(0)(0)>[&] ("\r\npage(1)off0x024):\twork channel");
        u<s(0)(0)(0)>[&] = em4_bpc_rd<s(0)(0)(0)>[&] (1, 0x024);
    }

    if (en<s(0)(0)(0)>[&])
    {
        cah_em4_printf<s(0)(0)(0)>[&] ("(enable)");
        u<s(0)(0)(0)>[&] = u<s(0)(0)(0)>[&] | 0x0020;
    }
    else
    {
        cah_em4_printf<s(0)(0)(0)>[&] ("(disable)");
        u<s(0)(0)(0)>[&] = u<s(0)(0)(0)>[&] & 0xffdf;
    }

    if (ch<s(0)(0)(0)>[&])
    {
        em4_bpc_wr<s(0)(0)(0)>[&] (1, 0x034, u<s(0)(0)(0)>[&]);
    }
    else
    {
        em4_bpc_wr<s(0)(0)(0)>[&] (1, 0x024, u<s(0)(0)(0)>[&]);
    }
}


void
bpc_mgt_up_scram<s(0)(0)(0)>[&] (int en<s(0)(0)(0)>[&])
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0;

    u<s(0)(0)(0)>[&] = em4_bpc_rd<s(0)(0)(0)>[&] (1, 0x003);
    if (en<s(0)(0)(0)>[&])
    {
        cah_em4_printf<s(0)(0)(0)>[&] ("\r\npage(1)off(0x003):\tmgt up scram enable");
        em4_bpc_wr<s(0)(0)(0)>[&] (1, 0x003, u<s(0)(0)(0)>[&] | 0x0001);
    }
    else
    {
        cah_em4_printf<s(0)(0)(0)>[&] ("\r\npage(1)off(0x003):\tmgt up scram disable");
        em4_bpc_wr<s(0)(0)(0)>[&] (1, 0x003, u<s(0)(0)(0)>[&] & 0xfffe);
    }
}

 
















 
void
bpc_rst_mgt_fifo<s(0)(0)(0)>[&] (void)
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0;

    cah_em4_printf<s(0)(0)(0)>[&] ("\r\npage(1)off(0x020/0x030):\treset mgt tx/rx fifo ...");
    
     
    u<s(0)(0)(0)>[&] = em4_bpc_rd<s(0)(0)(0)>[&] (1, 0x003);
    em4_bpc_wr<s(0)(0)(0)>[&] (1,  0x003, u<s(0)(0)(0)>[&] | 0x0010);
     
    
    u<s(0)(0)(0)>[&] = em4_bpc_rd<s(0)(0)(0)>[&] (1, 0x020);
    em4_bpc_wr<s(0)(0)(0)>[&] (1, 0x020, u<s(0)(0)(0)>[&] | 0x0060);
    u<s(0)(0)(0)>[&] = em4_bpc_rd<s(0)(0)(0)>[&] (1, 0x030);
    em4_bpc_wr<s(0)(0)(0)>[&] (1, 0x030, u<s(0)(0)(0)>[&] | 0x0060);
    
    taskDelay<s(0)(0)(0)>[&] (10);
    
      
    u<s(0)(0)(0)>[&] = em4_bpc_rd<s(0)(0)(0)>[&] (1, 0x003);
    em4_bpc_wr<s(0)(0)(0)>[&] (1,  0x003, u<s(0)(0)(0)>[&] & 0xFFEF);
     
    
    u<s(0)(0)(0)>[&] = em4_bpc_rd<s(0)(0)(0)>[&] (1, 0x020);
    em4_bpc_wr<s(0)(0)(0)>[&] (1, 0x020, u<s(0)(0)(0)>[&] & 0xff9f);
    u<s(0)(0)(0)>[&] = em4_bpc_rd<s(0)(0)(0)>[&] (1, 0x030);
    em4_bpc_wr<s(0)(0)(0)>[&] (1, 0x030, u<s(0)(0)(0)>[&] & 0xff9f);
    cah_em4_printf<s(0)(0)(0)>[&] ("           (done)");
}

void
bpc_mgt_8k_mon_w<s(0)(0)(0)>[&] (void)
{
    unsigned short dly8k_now<s(0)(0)(0)>[&] =(D2) 0;
    unsigned short row_now<s(0)(0)(0)>[&] =(D2) 0;
    unsigned short col_now<s(0)(0)(0)>[&] =(D2) 0;
    unsigned short cyc_now<s(0)(0)(0)>[&] =(D2) 0;

    unsigned short dly8k<s(0)(0)(0)>[&] =(D2) 0;
    unsigned short cyc<s(0)(0)(0)>[&] =(D2) 0;
    unsigned short col<s(0)(0)(0)>[&] =(D2) 0;
    unsigned short row<s(0)(0)(0)>[&] =(D2) 0;

    dly8k_now<s(0)(0)(0)>[&] = em4_bpc_rd<s(0)(0)(0)>[&] (1, 0x002);
    row_now<s(0)(0)(0)>[&] = (dly8k_now<s(0)(0)(0)>[&] & 0xf000) >> 12;
    col_now<s(0)(0)(0)>[&] = (dly8k_now<s(0)(0)(0)>[&] & 0x0ff8) >> 3;
    cyc_now<s(0)(0)(0)>[&] = (dly8k_now<s(0)(0)(0)>[&] & 0x0003);
    cah_em4_printf<s(0)(0)(0)>[&] ("\r\npage(1)off(0x002):\tmgt c1 delay set now : row %d ; col %d ; cyc %d", row_now<s(0)(0)(0)>[&],
            col_now<s(0)(0)(0)>[&], cyc_now<s(0)(0)(0)>[&]);

    cah_em4_printf<s(0)(0)(0)>[&] ("\r\npage(1)off(0x026):\tRead out work channel phase ofset is : ");
    dly8k<s(0)(0)(0)>[&] = em4_bpc_rd<s(0)(0)(0)>[&] (1, 0x026);
    cyc<s(0)(0)(0)>[&] = dly8k<s(0)(0)(0)>[&] - ((dly8k<s(0)(0)(0)>[&] / 4) * 4);
    col<s(0)(0)(0)>[&] = dly8k<s(0)(0)(0)>[&] / 4 - dly8k<s(0)(0)(0)>[&] / (270 * 4) * 270;
    row<s(0)(0)(0)>[&] = dly8k<s(0)(0)(0)>[&] / (4 * 270);
    cah_em4_printf<s(0)(0)(0)>[&] ("row : %d ; col : %d ; cyc : %d", row<s(0)(0)(0)>[&], col<s(0)(0)(0)>[&], cyc<s(0)(0)(0)>[&]);

}


void
bpc_mgt_8k_mon_p<s(0)(0)(0)>[&] (void)
{
    unsigned short dly8k_now<s(0)(0)(0)>[&] =(D2) 0;
    unsigned short row_now<s(0)(0)(0)>[&] =(D2) 0;
    unsigned short col_now<s(0)(0)(0)>[&] =(D2) 0;
    unsigned short cyc_now<s(0)(0)(0)>[&] =(D2) 0;

    unsigned short dly8k<s(0)(0)(0)>[&] =(D2) 0;
    unsigned short cyc<s(0)(0)(0)>[&] =(D2) 0;
    unsigned short col<s(0)(0)(0)>[&] =(D2) 0;
    unsigned short row<s(0)(0)(0)>[&] =(D2) 0;


    dly8k_now<s(0)(0)(0)>[&] = em4_bpc_rd<s(0)(0)(0)>[&] (1, 0x002);
    row_now<s(0)(0)(0)>[&] = (dly8k_now<s(0)(0)(0)>[&] & 0xf000) >> 12;
    col_now<s(0)(0)(0)>[&] = (dly8k_now<s(0)(0)(0)>[&] & 0x0ff8) >> 3;
    cyc_now<s(0)(0)(0)>[&] = (dly8k_now<s(0)(0)(0)>[&] & 0x003);
    cah_em4_printf<s(0)(0)(0)>[&] ("\r\npage(1)off(0x002):\tmgt c1 delay set now : row %d ; col %d ; cyc %d", row_now<s(0)(0)(0)>[&],
            col_now<s(0)(0)(0)>[&], cyc_now<s(0)(0)(0)>[&]);

    cah_em4_printf<s(0)(0)(0)>[&] ("\r\npage(1)off(0x036):\tRead out work channel phase ofset is : ");
    dly8k<s(0)(0)(0)>[&] = em4_bpc_rd<s(0)(0)(0)>[&] (1, 0x036);
    cyc<s(0)(0)(0)>[&] = dly8k<s(0)(0)(0)>[&] - ((dly8k<s(0)(0)(0)>[&] / 4) * 4);
    col<s(0)(0)(0)>[&] = dly8k<s(0)(0)(0)>[&] / 4 - dly8k<s(0)(0)(0)>[&] / (270 * 4) * 270;
    row<s(0)(0)(0)>[&] = dly8k<s(0)(0)(0)>[&] / (4 * 270);
    cah_em4_printf<s(0)(0)(0)>[&] ("row : %d ; col : %d ; cyc : %d", row<s(0)(0)(0)>[&], col<s(0)(0)(0)>[&], cyc<s(0)(0)(0)>[&]);

}

void
set_c1j1_a<s(0)(0)(0)>[&] (unsigned short row<s(0)(0)(0)>[&], unsigned short col<s(0)(0)(0)>[&], unsigned short cyc<s(0)(0)(0)>[&])
{
    em4_bpc_wr<s(0)(0)(0)>[&] (2, 3, (row<s(0)(0)(0)>[&] << 12) + (col<s(0)(0)(0)>[&] << 3) + cyc<s(0)(0)(0)>[&]);
}

void
set_c1j1_b<s(0)(0)(0)>[&] (unsigned short row<s(0)(0)(0)>[&], unsigned short col<s(0)(0)(0)>[&], unsigned short cyc<s(0)(0)(0)>[&])
{
    em4_bpc_wr<s(0)(0)(0)>[&] (2, 4, (row<s(0)(0)(0)>[&] << 12) + (col<s(0)(0)(0)>[&] << 3) + cyc<s(0)(0)(0)>[&]);
}

int
em4MapShow<s(0)(0)(0)>[&] ()
{
    unsigned short u1<s(0)(0)(0)>[&] =(D2) 0, u2<s(0)(0)(0)>[&] =(D2) 0;


    printf<s(0)(0)(0)>[&] ("\r\n--- 126xE1 Mapper Fpga Chip ---");
    printf<s(0)(0)(0)>[&] ("\r\n[page 0]");
    em4MapRd<s(0)(0)(0)>[&] (0, 0, &u1<s(0)(0)(0)>[&], &u2<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x00),\tval(0x%x)(0x%x): \tdevice version", u1<s(0)(0)(0)>[&], u2<s(0)(0)(0)>[&]);


    em4MapRd<s(0)(0)(0)>[&] (0, 0x01, &u1<s(0)(0)(0)>[&], &u2<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x01),\tval(0x%x)(0x%x): \ttb_out_edge, tb_out_loop", u1<s(0)(0)(0)>[&], u2<s(0)(0)(0)>[&]);

    em4MapRd<s(0)(0)(0)>[&] (0, 0x02, &u1<s(0)(0)(0)>[&], &u2<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x02),\tval(0x%x)(0x%x): \tdevice id", u1<s(0)(0)(0)>[&], u2<s(0)(0)(0)>[&]);

    em4MapRd<s(0)(0)(0)>[&] (0, 0x03, &u1<s(0)(0)(0)>[&], &u2<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x03),\tval(0x%x)(0x%x): \tcontrol c1 add/drop", u1<s(0)(0)(0)>[&], u2<s(0)(0)(0)>[&]);

    em4MapRd<s(0)(0)(0)>[&] (0, 0x05, &u1<s(0)(0)(0)>[&], &u2<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x05),\tval(0x%x)(0x%x): \tirq in", u1<s(0)(0)(0)>[&], u2<s(0)(0)(0)>[&]);


    em4MapRd<s(0)(0)(0)>[&] (0, 0x09, &u1<s(0)(0)(0)>[&], &u2<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x09),\tval(0x%x)(0x%x): \tmask", u1<s(0)(0)(0)>[&], u2<s(0)(0)(0)>[&]);

    em4MapRd<s(0)(0)(0)>[&] (0, 0x0a, &u1<s(0)(0)(0)>[&], &u2<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x0a),\tval(0x%x)(0x%x): \tdcm_locked/reset_cnt", u1<s(0)(0)(0)>[&], u2<s(0)(0)(0)>[&]);

    em4MapRd<s(0)(0)(0)>[&] (0, 0x0b, &u1<s(0)(0)(0)>[&], &u2<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x0b),\tval(0x%x)(0x%x): \ttimeing_sel1", u1<s(0)(0)(0)>[&], u2<s(0)(0)(0)>[&]);
    em4MapRd<s(0)(0)(0)>[&] (0, 0x10, &u1<s(0)(0)(0)>[&], &u2<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x10),\tval(0x%x)(0x%x): \ttest_reg", u1<s(0)(0)(0)>[&], u2<s(0)(0)(0)>[&]);

    em4MapRd<s(0)(0)(0)>[&] (0, 0x12, &u1<s(0)(0)(0)>[&], &u2<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x12),\tval(0x%x)(0x%x): \te1_los", u1<s(0)(0)(0)>[&], u2<s(0)(0)(0)>[&]);

    printf<s(0)(0)(0)>[&] ("\r\n[page 0]");

    em4MapRd<s(0)(0)(0)>[&] (1, 0x00, &u1<s(0)(0)(0)>[&], &u2<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x00),\tval(0x%x)(0x%x): \th4_lom", u1<s(0)(0)(0)>[&], u2<s(0)(0)(0)>[&]);

    em4MapRd<s(0)(0)(0)>[&] (1, 0x01, &u1<s(0)(0)(0)>[&], &u2<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x01),\tval(0x%x)(0x%x): \th4_lom_d", u1<s(0)(0)(0)>[&], u2<s(0)(0)(0)>[&]);

    em4MapRd<s(0)(0)(0)>[&] (1, 0x02, &u1<s(0)(0)(0)>[&], &u2<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x02),\tval(0x%x)(0x%x): \th4_lom_m", u1<s(0)(0)(0)>[&], u2<s(0)(0)(0)>[&]);

    em4MapRd<s(0)(0)(0)>[&] (1, 0x03, &u1<s(0)(0)(0)>[&], &u2<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x03),\tval(0x%x)(0x%x): \tlopi_vc12", u1<s(0)(0)(0)>[&], u2<s(0)(0)(0)>[&]);

    em4MapRd<s(0)(0)(0)>[&] (1, 0x04, &u1<s(0)(0)(0)>[&], &u2<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x04),\tval(0x%x)(0x%x): \tlop_v1/v2", u1<s(0)(0)(0)>[&], u2<s(0)(0)(0)>[&]);

    em4MapRd<s(0)(0)(0)>[&] (1, 0x10, &u1<s(0)(0)(0)>[&], &u2<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x10),\tval(0x%x)(0x%x): \tlopi_state", u1<s(0)(0)(0)>[&], u2<s(0)(0)(0)>[&]);


    printf<s(0)(0)(0)>[&] ("\r\n[page 2]: POH Monitor");

    printf<s(0)(0)(0)>[&] ("\r\n");

    printf<s(0)(0)(0)>[&] ("\r\n[page 4]: POH Monitor");

    em4MapRd<s(0)(0)(0)>[&] (4, 0x000, &u1<s(0)(0)(0)>[&], &u2<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x000),\tval(0x%x)(0x%x): \tc1_unstable/c1_delay/edge/rst", u1<s(0)(0)(0)>[&], u2<s(0)(0)(0)>[&]);


    em4MapRd<s(0)(0)(0)>[&] (4, 0x001, &u1<s(0)(0)(0)>[&], &u2<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x001),\tval(0x%x)(0x%x): \tthresh_high/low", u1<s(0)(0)(0)>[&], u2<s(0)(0)(0)>[&]);

    em4MapRd<s(0)(0)(0)>[&] (4, 0x00c, &u1<s(0)(0)(0)>[&], &u2<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x00c),\tval(0x%x)(0x%x): \tcfg_vc12_pdh", u1<s(0)(0)(0)>[&], u2<s(0)(0)(0)>[&]);
    em4MapRd<s(0)(0)(0)>[&] (4, 0x00d, &u1<s(0)(0)(0)>[&], &u2<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x00d),\tval(0x%x)(0x%x): \tcfg_vc12_pdh", u1<s(0)(0)(0)>[&], u2<s(0)(0)(0)>[&]);
    em4MapRd<s(0)(0)(0)>[&] (4, 0x00e, &u1<s(0)(0)(0)>[&], &u2<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x00e),\tval(0x%x)(0x%x): \tcfg_vc12_pdh", u1<s(0)(0)(0)>[&], u2<s(0)(0)(0)>[&]);
    em4MapRd<s(0)(0)(0)>[&] (4, 0x00f, &u1<s(0)(0)(0)>[&], &u2<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x00f),\tval(0x%x)(0x%x): \tcfg_vc12_pdh", u1<s(0)(0)(0)>[&], u2<s(0)(0)(0)>[&]);

    em4MapRd<s(0)(0)(0)>[&] (4, 0x010, &u1<s(0)(0)(0)>[&], &u2<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x010),\tval(0x%x)(0x%x): \te1_outloop", u1<s(0)(0)(0)>[&], u2<s(0)(0)(0)>[&]);
    em4MapRd<s(0)(0)(0)>[&] (4, 0x011, &u1<s(0)(0)(0)>[&], &u2<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x011),\tval(0x%x)(0x%x): \te1_outloop", u1<s(0)(0)(0)>[&], u2<s(0)(0)(0)>[&]);
    em4MapRd<s(0)(0)(0)>[&] (4, 0x012, &u1<s(0)(0)(0)>[&], &u2<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x012),\tval(0x%x)(0x%x): \te1_outloop", u1<s(0)(0)(0)>[&], u2<s(0)(0)(0)>[&]);
    em4MapRd<s(0)(0)(0)>[&] (4, 0x013, &u1<s(0)(0)(0)>[&], &u2<s(0)(0)(0)>[&]);
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x013),\tval(0x%x)(0x%x): \te1_outloop", u1<s(0)(0)(0)>[&], u2<s(0)(0)(0)>[&]);

    printf<s(0)(0)(0)>[&] ("\r\n");
    return 0;
}

int
em4BpcShow<s(0)(0)(0)>[&] ()
{
    printf<s(0)(0)(0)>[&] ("\r\n--- Back Plane Converter ---");
    printf<s(0)(0)(0)>[&] ("\r\n[page 0]");
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x00),\tval(0x%x): \tmajor &minor version", em4_bpc_rd<s(0)(0)(0)>[&] (0, 0));
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x01),\tval(0x%x): \ttest_reg", em4_bpc_rd<s(0)(0)(0)>[&] (0, 1));
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x03),\tval(0x%x): \tsw_rst", em4_bpc_rd<s(0)(0)(0)>[&] (0, 3));
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x04),\tval(0x%x): \tref8k", em4_bpc_rd<s(0)(0)(0)>[&] (0, 4));
    printf<s(0)(0)(0)>[&] ("\r\n[page 1]");
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x00),\tval(0x%x): \ttest_reg", em4_bpc_rd<s(0)(0)(0)>[&] (1, 0));
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x01),\tval(0x%x): \twpsel", em4_bpc_rd<s(0)(0)(0)>[&] (1, 1));
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x02),\tval(0x%x): \tc1delay", em4_bpc_rd<s(0)(0)(0)>[&] (1, 2));
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x03),\tval(0x%x): \tc1delay", em4_bpc_rd<s(0)(0)(0)>[&] (1, 3));
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x04),\tval(0x%x): \tfrm_up_haps", em4_bpc_rd<s(0)(0)(0)>[&] (1, 4));
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x05),\tval(0x%x): \tfrm_up_haps", em4_bpc_rd<s(0)(0)(0)>[&] (1, 5));
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x06),\tval(0x%x): \tfrm_up_haps", em4_bpc_rd<s(0)(0)(0)>[&] (1, 6));



    printf<s(0)(0)(0)>[&] ("\r\noffset(0x20),\tval(0x%x): \tmgt", em4_bpc_rd<s(0)(0)(0)>[&] (1, 0x20));
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x21),\tval(0x%x): \tmgt", em4_bpc_rd<s(0)(0)(0)>[&] (1, 0x21));
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x22),\tval(0x%x): \tauto_mgt_tx_rst_cnt", em4_bpc_rd<s(0)(0)(0)>[&] (1, 0x22));
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x23),\tval(0x%x): \tfrm_ds_b1_cnt", em4_bpc_rd<s(0)(0)(0)>[&] (1, 0x23));
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x24),\tval(0x%x): \tfrm_ds", em4_bpc_rd<s(0)(0)(0)>[&] (1, 0x24));
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x25),\tval(0x%x): \tdbg_edge/data_sel", em4_bpc_rd<s(0)(0)(0)>[&] (1, 0x25));
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x26),\tval(0x%x): \tfp8k_mon", em4_bpc_rd<s(0)(0)(0)>[&] (1, 0x26));
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x27),\tval(0x%x): \tmgt_tx/rx_center", em4_bpc_rd<s(0)(0)(0)>[&] (1, 0x27));
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x28),\tval(0x%x): \tline c1 realtime mon", em4_bpc_rd<s(0)(0)(0)>[&] (1, 0x28));
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x29),\tval(0x%x): \tlof_cnt", em4_bpc_rd<s(0)(0)(0)>[&] (1, 0x29));
    printf<s(0)(0)(0)>[&] ("\r\n\"Port 1(protection channel) configuration/status ");
    printf<s(0)(0)(0)>[&] ("\r\n0x30, 0x31, 0x32, 0x33,0x34,0x35,0x36,0x37\"");
    printf<s(0)(0)(0)>[&] ("\r\n[page 2]");

    printf<s(0)(0)(0)>[&] ("\r\noffset(0x00),\tval(0x%x): \ttest_reg", em4_bpc_rd<s(0)(0)(0)>[&] (2, 0x0));
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x01),\tval(0x%x): \ttbi_19m_out/inloop", em4_bpc_rd<s(0)(0)(0)>[&] (2, 0x1));
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x02),\tval(0x%x): \tadd_19m_c1delay_row/col", em4_bpc_rd<s(0)(0)(0)>[&] (2, 0x2));
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x03),\tval(0x%x): \ttbi_add_a_c1delay_row/col", em4_bpc_rd<s(0)(0)(0)>[&] (2, 0x3));
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x04),\tval(0x%x): \ttbi_add_b_c1delay_row/col", em4_bpc_rd<s(0)(0)(0)>[&] (2, 0x4));


    printf<s(0)(0)(0)>[&] ("\r\n[page 3]");
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x000),\tval(0x%x): \ttest_reg", em4_bpc_rd<s(0)(0)(0)>[&] (3, 0x000));
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x004),\tval(0x%x): \tepg_alarm_a/b_fall_edge_en", em4_bpc_rd<s(0)(0)(0)>[&] (3, 0x004));
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x005),\tval(0x%x): \tepg_alarm_a/b_even_err_msk", em4_bpc_rd<s(0)(0)(0)>[&] (3, 0x005));
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x007),\tval(0x%x): \tlos_num_a0/1", em4_bpc_rd<s(0)(0)(0)>[&] (3, 0x007));
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x008),\tval(0x%x): \tlos_num_a2/3", em4_bpc_rd<s(0)(0)(0)>[&] (3, 0x008));
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x009),\tval(0x%x): \tlos_num_b0/1", em4_bpc_rd<s(0)(0)(0)>[&] (3, 0x009));
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x00a),\tval(0x%x): \tlos_num_b2/3", em4_bpc_rd<s(0)(0)(0)>[&] (3, 0x00a));
    printf<s(0)(0)(0)>[&] ("\r\n[page 4]");

    printf<s(0)(0)(0)>[&] ("\r\noffset(0x000),\tval(0x%x): \tintr,cpu_dcm_all_rst", em4_bpc_rd<s(0)(0)(0)>[&] (4, 0x000));
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x005),\tval(0x%x): \ttest_reg", em4_bpc_rd<s(0)(0)(0)>[&] (4, 0x005));
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x010),\tval(0x%x): \tint_dcm_rst_cnt_77m", em4_bpc_rd<s(0)(0)(0)>[&] (4, 0x010));
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x011),\tval(0x%x): \tint_dcm_rst_cnt_93m", em4_bpc_rd<s(0)(0)(0)>[&] (4, 0x011));
    printf<s(0)(0)(0)>[&] ("\r\noffset(0x012),\tval(0x%x): \tint_dcm_rst_cnt_19m", em4_bpc_rd<s(0)(0)(0)>[&] (4, 0x012));



    printf<s(0)(0)(0)>[&] ("\r\n");

    return 0;
}

int
cah_em4_initFusion<s(0)(0)(0)>[&] (void)
{





  
    return 0;
}



int buffer_reset<s(0)(0)(0)>[&] (void)
{
    unsigned short u<s(0)(0)(0)>[&] =(D2) 0;
    
    u<s(0)(0)(0)>[&] = em4_bpc_rd<s(0)(0)(0)>[&] (1, 0x003);
    u<s(0)(0)(0)>[&] |= 0x0011;
    em4_bpc_wr<s(0)(0)(0)>[&] (1, 0x003, u<s(0)(0)(0)>[&]);    

    printf<s(0)(0)(0)>[&] ("\r\nwaiting for clear ...");
    taskDelay<s(0)(0)(0)>[&] (1);
    u<s(0)(0)(0)>[&] &= ~0x0010;
    em4_bpc_wr<s(0)(0)(0)>[&] (1, 0x003, u<s(0)(0)(0)>[&]);    
    
    return 0;
}
void  cah_em4_initCpu<s(0)(0)(0)>[&]  (void)
{

    ((UINT32<s(0)(0)(0)>[T])(*(volatile UINT32<s(0)(0)(0)>[T]*)( 0xf0000120 )))  = 0x70000401;    
    ((UINT32<s(0)(0)(0)>[T])(*(volatile UINT32<s(0)(0)(0)>[T]*)( 0xf0000124 )))  = 0xffff0e3e;
    
    ((UINT32<s(0)(0)(0)>[T])(*(volatile UINT32<s(0)(0)(0)>[T]*)( 0xf0000110 )))  = 0x50000801;  
    ((UINT32<s(0)(0)(0)>[T])(*(volatile UINT32<s(0)(0)(0)>[T]*)( 0xf0000114  )))  =0xff00014a;  
       
    ((UINT32<s(0)(0)(0)>[T])(*(volatile UINT32<s(0)(0)(0)>[T]*)( 0xf0000118 )))  = 0x60000801;  
    ((UINT32<s(0)(0)(0)>[T])(*(volatile UINT32<s(0)(0)(0)>[T]*)( 0xf000011c )))  = 0xff00014a ;      
}

void cah_em4_init_fus<s(0)(0)(0)>[&] (void)
{
  UINT8<s(0)(0)(0)>[T] u<s(0)(0)(0)>[&]=(D2)0;

    ((UINT8<s(0)(0)(0)>[T])(*(volatile UINT8<s(0)(0)(0)>[T]*)( (0x70000000)  +0x0102 )))  =0x02;
   taskDelay<s(0)(0)(0)>[&](10);
   ((UINT8<s(0)(0)(0)>[T])(*(volatile UINT8<s(0)(0)(0)>[T]*)( (0x70000000)  +0x0102 )))  =0x06;
   taskDelay<s(0)(0)(0)>[&](10);
    ((UINT8<s(0)(0)(0)>[T])(*(volatile UINT8<s(0)(0)(0)>[T]*)( (0x70000000)  + 0x04 )))  = 0x00;

   u<s(0)(0)(0)>[&]= ((UINT8<s(0)(0)(0)>[T])(*(volatile UINT8<s(0)(0)(0)>[T]*)( (0x70000000)  + 0x02 ))) ;
   u<s(0)(0)(0)>[&]=u<s(0)(0)(0)>[&]&0x02;
   if (u<s(0)(0)(0)>[&] == 0x02)
   {
   	  printf<s(0)(0)(0)>[&] ("\r\ncah_em4_init_fus:Select work CC!");
   }
   else
   {
        printf<s(0)(0)(0)>[&] ("\r\ncah_em4_init_fus:Select protect CC!!");
   }
    
   ((UINT8<s(0)(0)(0)>[T])(*(volatile UINT8<s(0)(0)(0)>[T]*)( (0x70000000)  +0x03 )))  = 0x00;
   ((UINT8<s(0)(0)(0)>[T])(*(volatile UINT8<s(0)(0)(0)>[T]*)( (0x70000000)  +0x04 )))  = 0x00;
   ((UINT8<s(0)(0)(0)>[T])(*(volatile UINT8<s(0)(0)(0)>[T]*)( (0x70000000)  +0x05 )))  = 0x00;
   ((UINT8<s(0)(0)(0)>[T])(*(volatile UINT8<s(0)(0)(0)>[T]*)( (0x70000000)  +0x06  )))  = 0x00;

   
  ((UINT8<s(0)(0)(0)>[T])(*(volatile UINT8<s(0)(0)(0)>[T]*)( (0x70000000)  +0x000b )))  = 0x00;
  ((UINT8<s(0)(0)(0)>[T])(*(volatile UINT8<s(0)(0)(0)>[T]*)( (0x70000000)  +0x000d )))  = 0x00;
  ((UINT8<s(0)(0)(0)>[T])(*(volatile UINT8<s(0)(0)(0)>[T]*)( (0x70000000)  +0x000f )))  = 0x00;
  ((UINT8<s(0)(0)(0)>[T])(*(volatile UINT8<s(0)(0)(0)>[T]*)( (0x70000000)  +0x0011 )))  = 0x00;
  ((UINT8<s(0)(0)(0)>[T])(*(volatile UINT8<s(0)(0)(0)>[T]*)( (0x70000000)  +0x0013 )))  = 0x16;
  ((UINT8<s(0)(0)(0)>[T])(*(volatile UINT8<s(0)(0)(0)>[T]*)( (0x70000000)  +0x0015 )))  =0x16;
 
  
 ((UINT8<s(0)(0)(0)>[T])(*(volatile UINT8<s(0)(0)(0)>[T]*)( (0x70000000)  + 0x001b )))  =  0x00;
  ((UINT8<s(0)(0)(0)>[T])(*(volatile UINT8<s(0)(0)(0)>[T]*)( (0x70000000)  +0x001c )))  =  0x00;
  ((UINT8<s(0)(0)(0)>[T])(*(volatile UINT8<s(0)(0)(0)>[T]*)( (0x70000000)  +0x001d )))  =  0x03;
  ((UINT8<s(0)(0)(0)>[T])(*(volatile UINT8<s(0)(0)(0)>[T]*)( (0x70000000)  +0x001e )))  =  0x03; 
 printf<s(0)(0)(0)>[&] ("\r\ncah_em4_init_fus:fusion initializtion is ok!");
    
} 
int cah_em4_initBpc<s(0)(0)(0)>[&] (void)
{
    printf<s(0)(0)(0)>[&] ("\r\n<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<");
     





    cah_em4_printf<s(0)(0)(0)>[&] ("\r\n%s(): init BackPlane Converter at base(%x)", __FUNCTION__<s(0)(0)(0)>[&], (0x80000000) );
    cah_em4_printf<s(0)(0)(0)>[&] ("\r\n%s(): The version register(%x)", __FUNCTION__<s(0)(0)(0)>[&], (em4_bpc_rd<s(0)(0)(0)>[&] (0, 0)));
    cah_em4_printf<s(0)(0)(0)>[&] ("\r\n%s(): The major version is (%x)", __FUNCTION__<s(0)(0)(0)>[&], (em4_bpc_rd<s(0)(0)(0)>[&] (0, 0) >> 8));
    cah_em4_printf<s(0)(0)(0)>[&] ("\r\n%s(): The minor version is (%x)", __FUNCTION__<s(0)(0)(0)>[&], (em4_bpc_rd<s(0)(0)(0)>[&] (0, 0) & 0xff));
    cah_em4_printf<s(0)(0)(0)>[&] ("\r\n%s(): The micro version is (%x)", __FUNCTION__<s(0)(0)(0)>[&], em4_bpc_rd<s(0)(0)(0)>[&] (0, 1));
    bpc_mgt_wps<s(0)(0)(0)>[&] ();

    bpc_dcm_rst_al<s(0)(0)(0)>[&] ();
     
    taskDelay<s(0)(0)(0)>[&](10);
    
    bpc_dcm_st<s(0)(0)(0)>[&] ();
    printf<s(0)(0)(0)>[&] ("\r\npage(0)off(0x003):\tsoftware reset");
    bpc_rst<s(0)(0)(0)>[&] ();


    buffer_reset<s(0)(0)(0)>[&] ();     
    taskDelay<s(0)(0)(0)>[&] (10);


    cah_em4_printf<s(0)(0)(0)>[&] ("\r\npage(1)off(0x20/0x30):\tinitialize mgt");
    mgt_pwr<s(0)(0)(0)>[&] (1);
     
    taskDelay<s(0)(0)(0)>[&] (10);

    cah_em4_printf<s(0)(0)(0)>[&] ("\r\nscram enable");
    bpc_mgt_descram<s(0)(0)(0)>[&] (0, 1);
    bpc_mgt_descram<s(0)(0)(0)>[&] (1, 1);
    bpc_mgt_up_scram<s(0)(0)(0)>[&] (1);

    cah_em4_printf<s(0)(0)(0)>[&] ("\r\npage(1)off(0x002):\tset bpc rx 8k delay");
    em4_bpc_wr<s(0)(0)(0)>[&] (1, 0x002, 0x87b0);
    
    cah_em4_printf<s(0)(0)(0)>[&] ("\r\nFIFO reset");
     
    taskDelay<s(0)(0)(0)>[&] (50);
    bpc_rst_mgt_fifo<s(0)(0)(0)>[&] ();

    taskDelay<s(0)(0)(0)>[&] (10);
    bpc_mgt_8k_mon_w<s(0)(0)(0)>[&] ();
    bpc_mgt_8k_mon_p<s(0)(0)(0)>[&] ();

    printf<s(0)(0)(0)>[&] ("\r\npage(2)off(1):\tinitialize the TBI");

    em4_bpc_wr<s(0)(0)(0)>[&] (2, 1, 0x0000);
    
    cah_em4_printf<s(0)(0)(0)>[&] ("\r\npage(2)off(3/4):\t set c1j1 a/b");
    set_c1j1_a<s(0)(0)(0)>[&] (0, 2, 0);
    set_c1j1_b<s(0)(0)(0)>[&] (0, 2, 0);
    
    cah_em4_printf<s(0)(0)(0)>[&] ("\r\npage(3)off(0x4):\t  set  epg alarm page ");
    em4_bpc_wr<s(0)(0)(0)>[&] (3, 0x04, 0x0000);
    
    printf<s(0)(0)(0)>[&] ("\r\n126xE1 bpc initialization complete");
    printf<s(0)(0)(0)>[&] ("\r\n>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");

    return 0;
}




 


PB_ERROR_CODE_T<s(0)(0)(0)>[T]
CAH_EM4_activateEntity<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BOOL<s(0)(0)(0)>[T] b_warm<s(0)(0)(0)>[&])
{




    CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *pEntity<s(0)(0)(0)>[&] =(D2) 0;
    ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&] =(D2) 0;

    cah_em4_trace<s(0)(0)(0)>[&] (1 , "\r\n(%s): Enter EM4_activateEntity File=%s; Line=%d  ", __FUNCTION__<s(0)(0)(0)>[&], "cah_126e1.c", 8639);

    if (!b_warm<s(0)(0)(0)>[&])
    {
         


         
        printf<s(0)(0)(0)>[&] ("\r\n%s(): cah_em4_initCpu ()", __FUNCTION__<s(0)(0)(0)>[&]);
         
         
         
         
        printf<s(0)(0)(0)>[&] ("\r\n%s(): cah_em4_initChip", __FUNCTION__<s(0)(0)(0)>[&]);
        cah_em4_initBpc<s(0)(0)(0)>[&]();
         
         
         
        printf<s(0)(0)(0)>[&] ("\r\n%s(): BPC initialized @0x80000000", __FUNCTION__<s(0)(0)(0)>[&]);
        
        printf<s(0)(0)(0)>[&] ("\r\n[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[");
        if (((WORD<s(0)(0)(0)>[T])0x0)  != cah_em4_initChip<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&]))
        {
            printf<s(0)(0)(0)>[&] ("\r\EM4_activateEntity: **Error!  Entity= %d; File=%s; Line=%d  ", entity<s(0)(0)(0)>[&], "cah_126e1.c", 8662);
    		printf<s(0)(0)(0)>[&] ("\r\n]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]");
            return ((WORD<s(0)(0)(0)>[T])0x1) ;
        }





    }
    printf<s(0)(0)(0)>[&] ("\r\n]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]");

    gCahEm4TribVar<s(0)(0)(0)>[&].bEM4Running<s(0)(0)(0)>[&] = 1 ;
    pEntity<s(0)(0)(0)>[&]->state<s(0)(0)(0)>[&] = eEm4EntAct<s(0)(0)(0)>[&];
      
     
     
      

    return ((WORD<s(0)(0)(0)>[T])0x0) ;
}


int
wydact<s(0)(0)(0)>[&] (void)
{
    CAH_EM4_activateEntity<s(0)(0)(0)>[&] (0, 0);
    return 0;
}



PB_ERROR_CODE_T<s(0)(0)(0)>[T]
CAH_EM4_deActEntity<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&])
{




    CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *pEntity<s(0)(0)(0)>[&] =(D2) ((void *)0) ;
    ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&] =(D2) 0;

    printf<s(0)(0)(0)>[&] ("\r\nEM4_DEACTENTITY: ENTITY(%d) DEACTIVE", entity<s(0)(0)(0)>[&]);

    if (((void *)0)  == (pEntity<s(0)(0)(0)>[&] = cah_em4_getEntityPtr<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&])))
    {
        printf<s(0)(0)(0)>[&] ("\r\nEM4_DeactEntity:  entity(%d) ptr NULL, File(%s), line(%d)", entity<s(0)(0)(0)>[&], "cah_126e1.c", 8708);
        return PB_ERR_PARAM<s(0)(0)(0)>[&];
    }

    if (eEm4EntAct<s(0)(0)(0)>[&] != pEntity<s(0)(0)(0)>[&]->state<s(0)(0)(0)>[&])
    {
        printf<s(0)(0)(0)>[&] ("\r\nEM4_DeactEntity: entity(%d) status error, file(%s), line(%d)", entity<s(0)(0)(0)>[&], "cah_126e1.c", 8714);
        return PB_ERR_STATE<s(0)(0)(0)>[&];
    }

    pEntity<s(0)(0)(0)>[&]->state<s(0)(0)(0)>[&] = eEm4EntInit<s(0)(0)(0)>[&];
    printf<s(0)(0)(0)>[&] ("\r\nEM4_DeactEntity : entity(%d) intUnconnected", entity<s(0)(0)(0)>[&]);

    return ((WORD<s(0)(0)(0)>[T])0x0) ;

}



WORD<s(0)(0)(0)>[T]
CAH_EM4_DeInitEntity<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&])
{




	CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *p<s(0)(0)(0)>[&] =(D2) ((void *)0) ;
    printf<s(0)(0)(0)>[&] ("\r\n%s(): enter function ", __FUNCTION__<s(0)(0)(0)>[&]);

	p<s(0)(0)(0)>[&] = cah_em4_getEntityPtr<s(0)(0)(0)>[&] (0);
    cah_em4_revise<s(0)(0)(0)>[&] (0);

	if (!p<s(0)(0)(0)>[&])
	{
		printf<s(0)(0)(0)>[&] ("\r\n%s(): pointer gppCahEm4CfgVar[0] NULL ", __FUNCTION__<s(0)(0)(0)>[&]);
		return ((WORD<s(0)(0)(0)>[T])0x1) ;
	}

	if (p<s(0)(0)(0)>[&]->state<s(0)(0)(0)>[&])
	{
		printf<s(0)(0)(0)>[&] ("\r\n%s(): card state(%d) error", __FUNCTION__<s(0)(0)(0)>[&], gppCahEm4CfgVar<s(0)(0)(0)>[&][0]->state<s(0)(0)(0)>[&]);
		return ((WORD<s(0)(0)(0)>[T])0x1) ;
	}

   	{ if( p<s(0)(0)(0)>[&] ) { free<s(0)(0)(0)>[&]((void*) p<s(0)(0)(0)>[&] );  p<s(0)(0)(0)>[&]  = ((void *)0) ; }} ;
    gppCahEm4CfgVar<s(0)(0)(0)>[&][0] = ((void *)0) ;

    return ((WORD<s(0)(0)(0)>[T])0x0) ;

}





void
CAH_EM4_setTransFunc<s(0)(0)(0)>[&] (CahEm4pTransFunc<s(0)(0)(0)>[T] pfunc<s(0)(0)(0)>[&])
{



    g_pTransFunc<s(0)(0)(0)>[&] = pfunc<s(0)(0)(0)>[&];


    return;
}



WORD<s(0)(0)(0)>[T]
CAH_EM4_GetSlip<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] * pdwPSlip<s(0)(0)(0)>[&], DWORD<s(0)(0)(0)>[T] * pdwNSlip<s(0)(0)(0)>[&])
{
    cah_em4_GetSlip<s(0)(0)(0)>[&] (dwPos<s(0)(0)(0)>[&], SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]), pdwPSlip<s(0)(0)(0)>[&], pdwNSlip<s(0)(0)(0)>[&]);
    return 0;
}

WORD<s(0)(0)(0)>[T]
CAH_EM4_getLatchStatus<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&])
{




    CAH_EM4_ENTITY_LATCH_T<s(0)(0)(0)>[T] ret<s(0)(0)(0)>[&] =(D2) EM4_ENTITY_UNKNOWN<s(0)(0)(0)>[&];
    void *baseaddr<s(0)(0)(0)>[&] =(D2) ((void *)0) ;
    unsigned short status<s(0)(0)(0)>[&] =(D2) 0;
    CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *pEntity<s(0)(0)(0)>[&];(D1:pEntity:0)
    ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&] =(D2) 0;

    baseaddr<s(0)(0)(0)>[&] = cah_em4_getEntityBase<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&], 100);
    pEntity<s(0)(0)(0)>[&] = cah_em4_getEntityPtr<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&]);
    status<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (baseaddr<s(0)(0)(0)>[&], ((0x00 << 10) | 0x05) );
    if (status<s(0)(0)(0)>[&] & 0x01)
    {
        ret<s(0)(0)(0)>[&] = EM4_ENTITY_DELATCH<s(0)(0)(0)>[&];
    } else {
        ret<s(0)(0)(0)>[&] = EM4_ENTITY_LATCH<s(0)(0)(0)>[&];
    }
    return ret<s(0)(0)(0)>[&];

}


WORD<s(0)(0)(0)>[T]
CAH_EM4_GetTuAlmState<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], CTD_TU_ALARM_T<s(0)(0)(0)>[T] * psTuAlarm<s(0)(0)(0)>[&])
{

     int ulPort<s(0)(0)(0)>[&] =(D2) 0;
	unsigned short uu<s(0)(0)(0)>[&] =(D2) 0, u<s(0)(0)(0)>[&] =(D2) 0;
	void * base<s(0)(0)(0)>[&] =(D2) 0;
	int regcnt<s(0)(0)(0)>[&] =(D2) 0;

	{if (125 <  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;
	base<s(0)(0)(0)>[&] = cah_em4_getEntityBase<s(0)(0)(0)>[&] (0, SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]));
      ulPort<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&])) - 1;

	 
     cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], ((0x01 << 10) | 0x03) , ulPort<s(0)(0)(0)>[&] | 0x8000);
     

    regcnt<s(0)(0)(0)>[&] = 0;
    while (1)
    {
        uu<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], ((0x01 << 10) | 0x03) );
        if (!(0x8000 & uu<s(0)(0)(0)>[&]))
        {
            break;
        }
        else
        {
            regcnt<s(0)(0)(0)>[&]++;
            if (regcnt<s(0)(0)(0)>[&] > 100)
            {
				printf<s(0)(0)(0)>[&] ("\r\n%s(): fpga read error ", __FUNCTION__<s(0)(0)(0)>[&]);
                break;
            }
        }
    }

    u<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], ((0x01 << 10) | 0x10) ) & 0x0003;
    psTuAlarm<s(0)(0)(0)>[&]->ais<s(0)(0)(0)>[&] = (0x0001 == u<s(0)(0)(0)>[&]) ? 1 : 0;
    psTuAlarm<s(0)(0)(0)>[&]->lop<s(0)(0)(0)>[&] = (0x0002 == u<s(0)(0)(0)>[&]) ? 1 : 0;

    return ((WORD<s(0)(0)(0)>[T])0x0) ;
}



WORD<s(0)(0)(0)>[T]
CAH_EM4_GetLpAlmState<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], CTD_LP_ALARM_T<s(0)(0)(0)>[T] * psLpAlarm<s(0)(0)(0)>[&])
{
     int ulPort<s(0)(0)(0)>[&] =(D2) 0; 
	void * base<s(0)(0)(0)>[&] =(D2) 0;
	unsigned short u<s(0)(0)(0)>[&] =(D2) 0;

	{if (125 <  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;
	base<s(0)(0)(0)>[&] = cah_em4_getEntityBase<s(0)(0)(0)>[&] (0, SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]));
       ulPort<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&])) - 1;
	 u<s(0)(0)(0)>[&] = cah_em4_pohRead<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], ulPort<s(0)(0)(0)>[&], 0x03 );
	

    psLpAlarm<s(0)(0)(0)>[&]->tim<s(0)(0)(0)>[&] 	= ((u<s(0)(0)(0)>[&] & 0x0001) ? 1 : 0);
    psLpAlarm<s(0)(0)(0)>[&]->plm<s(0)(0)(0)>[&] 	= ((u<s(0)(0)(0)>[&] & 0x0004) ? 1 : 0);
    psLpAlarm<s(0)(0)(0)>[&]->uneq<s(0)(0)(0)>[&] = ((u<s(0)(0)(0)>[&] & 0x0008) ? 1 : 0);
    psLpAlarm<s(0)(0)(0)>[&]->rdi<s(0)(0)(0)>[&] 	= ((u<s(0)(0)(0)>[&] & 0x0010) ? 1 : 0);
    psLpAlarm<s(0)(0)(0)>[&]->rfi<s(0)(0)(0)>[&] 	= ((u<s(0)(0)(0)>[&] & 0x0080) ? 1 : 0);
    
	return ((WORD<s(0)(0)(0)>[T])0x0) ;
}

int g_mon<s(0)(0)(0)>[&] =(D2) 0;
int g_monport<s(0)(0)(0)>[&] =(D2) 0;

int cah_em4_readPortSchemeLos<s(0)(0)(0)>[&] (int groupport<s(0)(0)(0)>[&] , int group<s(0)(0)(0)>[&])
{
    int phyport<s(0)(0)(0)>[&] =(D2) 0;
    UINT16<s(0)(0)(0)>[T] reg<s(0)(0)(0)>[&] =(D2) 0;
    int los<s(0)(0)(0)>[&] =(D2) 0;

    if (0 > groupport<s(0)(0)(0)>[&] || 71 < groupport<s(0)(0)(0)>[&])
    {
        printf<s(0)(0)(0)>[&] ("(%s): port number(%d) overflow", "cah_126e1.c", groupport<s(0)(0)(0)>[&]);
        return -1;
    }

    phyport<s(0)(0)(0)>[&] = g_phyportmap<s(0)(0)(0)>[&] [groupport<s(0)(0)(0)>[&] + 1] - 1;
    reg<s(0)(0)(0)>[&] = em4_bpc_rd<s(0)(0)(0)>[&] (3, (phyport<s(0)(0)(0)>[&]/16)+((!group<s(0)(0)(0)>[&]) ? ((0x021) ):0x26));
    if (g_mon<s(0)(0)(0)>[&] && g_monport<s(0)(0)(0)>[&] == groupport<s(0)(0)(0)>[&])
    {
            printf<s(0)(0)(0)>[&] ("group(%d)phyport(%2d)reg(%4x)off(%4x)\r\n", group<s(0)(0)(0)>[&], phyport<s(0)(0)(0)>[&], reg<s(0)(0)(0)>[&],   (phyport<s(0)(0)(0)>[&]/16)+((!group<s(0)(0)(0)>[&]) ? ((0x021) ):0x26) );
    }
    los<s(0)(0)(0)>[&] = (reg<s(0)(0)(0)>[&] & (0x0001 << ((phyport<s(0)(0)(0)>[&]) % 16))) ? 1 : 0;

    return los<s(0)(0)(0)>[&];
}


WORD<s(0)(0)(0)>[T]
cah_em4_getPhyLos<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], CTD_PPI_ALARM_T<s(0)(0)(0)>[T] * psPpiAlarm<s(0)(0)(0)>[&])
{
    ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&] =(D2) 0;
    int ulPort<s(0)(0)(0)>[&] =(D2) 0;
    CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *pEntity<s(0)(0)(0)>[&];(D1:pEntity:0)
	void * base<s(0)(0)(0)>[&] =(D2) 0;
    int schemePort<s(0)(0)(0)>[&] =(D2) 0;

	{if (125 <  byPortNo<s(0)(0)(0)>[&] ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  byPortNo<s(0)(0)(0)>[&] ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;

    pEntity<s(0)(0)(0)>[&] = cah_em4_getEntityPtr<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&]);
    ulPort<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (byPortNo<s(0)(0)(0)>[&]) - 1;
    base<s(0)(0)(0)>[&] = cah_em4_getEntityBase<s(0)(0)(0)>[&] (0, byPortNo<s(0)(0)(0)>[&]);

    schemePort<s(0)(0)(0)>[&] = g_phyportmap<s(0)(0)(0)>[&] [ulPort<s(0)(0)(0)>[&] + 1] - 1;
    
     psPpiAlarm<s(0)(0)(0)>[&]->los<s(0)(0)(0)>[&] = cah_em4_readPortSchemeLos<s(0)(0)(0)>[&] (ulPort<s(0)(0)(0)>[&], byPortNo<s(0)(0)(0)>[&] / 63);
     



    return psPpiAlarm<s(0)(0)(0)>[&]->los<s(0)(0)(0)>[&];
}

 


static int
isIOAbsent<s(0)(0)(0)>[&](int port<s(0)(0)(0)>[&], unsigned char *pIO<s(0)(0)(0)>[&])
{
    int absent<s(0)(0)(0)>[&] =(D2) 0;
    unsigned short val<s(0)(0)(0)>[&] =(D2) 0;
    int io<s(0)(0)(0)>[&] =(D2) 0;

    io<s(0)(0)(0)>[&] = 0;

    if (port<s(0)(0)(0)>[&] >= 0 && port<s(0)(0)(0)>[&] <=20){
        val<s(0)(0)(0)>[&] = em4Map1Rd<s(0)(0)(0)>[&] (0, 0x12);
        absent<s(0)(0)(0)>[&] = (val<s(0)(0)(0)>[&] & 0x02) ? 1 : 0;
        *pIO<s(0)(0)(0)>[&] = 5;    
    } else if (21 <= port<s(0)(0)(0)>[&] && port<s(0)(0)(0)>[&] <= 41){
        val<s(0)(0)(0)>[&] = em4Map1Rd<s(0)(0)(0)>[&] (0, 0x12);
        absent<s(0)(0)(0)>[&] = (val<s(0)(0)(0)>[&] & 0x04) ? 1 : 0;
        *pIO<s(0)(0)(0)>[&] = 3; 
    } else if (42 <= port<s(0)(0)(0)>[&] && port<s(0)(0)(0)>[&] <= 62){
        val<s(0)(0)(0)>[&] = em4Map1Rd<s(0)(0)(0)>[&] (0, 0x12);
        absent<s(0)(0)(0)>[&] = (val<s(0)(0)(0)>[&] & 0x08) ? 1 : 0;
        *pIO<s(0)(0)(0)>[&] = 1; 
    } else if ((0 + 63) <= port<s(0)(0)(0)>[&] && port<s(0)(0)(0)>[&] <= (20 + 63)){
        val<s(0)(0)(0)>[&] = em4Map2Rd<s(0)(0)(0)>[&] (0, 0x12);
        absent<s(0)(0)(0)>[&] = (val<s(0)(0)(0)>[&] & 0x02) ? 1 : 0;
        *pIO<s(0)(0)(0)>[&] = 6; 
    } else if ((21 + 63) <= port<s(0)(0)(0)>[&] && port<s(0)(0)(0)>[&] <= (41 + 63)) {
        val<s(0)(0)(0)>[&] = em4Map2Rd<s(0)(0)(0)>[&] (0, 0x12);
        absent<s(0)(0)(0)>[&] = (val<s(0)(0)(0)>[&] & 0x04) ? 1 : 0;
        *pIO<s(0)(0)(0)>[&] = 4; 
    } else if ((42 + 63) <= port<s(0)(0)(0)>[&] && port<s(0)(0)(0)>[&] <= (62 + 63)) {
        val<s(0)(0)(0)>[&] = em4Map2Rd<s(0)(0)(0)>[&] (0, 0x12);
        absent<s(0)(0)(0)>[&] = (val<s(0)(0)(0)>[&] & 0x08) ? 1 : 0;
        *pIO<s(0)(0)(0)>[&] = 2; 
    }
   
    return (absent<s(0)(0)(0)>[&]);
}




 


int clr_payload_ais<s(0)(0)(0)>[&] (int port<s(0)(0)(0)>[&])
{
	void * base<s(0)(0)(0)>[&] =(D2) 0;
    unsigned short val<s(0)(0)(0)>[&] =(D2) 0;
    int byte<s(0)(0)(0)>[&] =(D2) 0, bit<s(0)(0)(0)>[&] =(D2) 0;

    byte<s(0)(0)(0)>[&] = port<s(0)(0)(0)>[&] / 16;
    bit<s(0)(0)(0)>[&] = port<s(0)(0)(0)>[&] % 16;
    
    val<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], ((((0x00 << 10) | 0x20) ) + byte<s(0)(0)(0)>[&]));
    
    if (val<s(0)(0)(0)>[&] & (0x01 << bit<s(0)(0)(0)>[&])) 
    {
         


        val<s(0)(0)(0)>[&] &= ~(0x01 << bit<s(0)(0)(0)>[&]);
        cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], ((((0x00 << 10) | 0x20) ) + byte<s(0)(0)(0)>[&]), val<s(0)(0)(0)>[&]);
    } else {
    }

    return 0;

}


 


int set_payload_ais<s(0)(0)(0)>[&] (int port<s(0)(0)(0)>[&])
{
	void * base<s(0)(0)(0)>[&] =(D2) 0;
    unsigned short val<s(0)(0)(0)>[&] =(D2) 0;
    int byte<s(0)(0)(0)>[&] =(D2) 0, bit<s(0)(0)(0)>[&] =(D2) 0;

    byte<s(0)(0)(0)>[&] = port<s(0)(0)(0)>[&] / 16;
    bit<s(0)(0)(0)>[&] = port<s(0)(0)(0)>[&] % 16;
    
    val<s(0)(0)(0)>[&] = cah_em4_rd<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], ((((0x00 << 10) | 0x20) ) + byte<s(0)(0)(0)>[&]));
    
    if (val<s(0)(0)(0)>[&] & (0x01 << bit<s(0)(0)(0)>[&])) 
    {
    } else {
        val<s(0)(0)(0)>[&] |= (0x01 << bit<s(0)(0)(0)>[&]);
        cah_em4_wr<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], ((((0x00 << 10) | 0x20) ) + byte<s(0)(0)(0)>[&]), val<s(0)(0)(0)>[&]);
    }

    return 0;
}


int set_ioN_ais<s(0)(0)(0)>[&] (int io<s(0)(0)(0)>[&])
{
    int firstport<s(0)(0)(0)>[&] =(D2) 0, lastport<s(0)(0)(0)>[&] =(D2) 0;
    int i<s(0)(0)(0)>[&] =(D2) 0;

    sdd_get_ioN_port<s(0)(0)(0)>[&] (io<s(0)(0)(0)>[&], &firstport<s(0)(0)(0)>[&], &lastport<s(0)(0)(0)>[&]);

    for (i<s(0)(0)(0)>[&] = firstport<s(0)(0)(0)>[&]; i<s(0)(0)(0)>[&] <= lastport<s(0)(0)(0)>[&]; i<s(0)(0)(0)>[&] ++);
    {
        set_payload_ais<s(0)(0)(0)>[&] (i<s(0)(0)(0)>[&]);
    }
    
    return 0;
}





int clear_IO_payload_si<s(0)(0)(0)>[&] (io<s(0)(0)(0)>[&])
{
    int firstport<s(0)(0)(0)>[&] =(D2) 0, lastport<s(0)(0)(0)>[&] =(D2) 0;
    int i<s(0)(0)(0)>[&] =(D2) 0;

    sdd_get_ioN_port<s(0)(0)(0)>[&] (io<s(0)(0)(0)>[&], &firstport<s(0)(0)(0)>[&], &lastport<s(0)(0)(0)>[&]);

    for (i<s(0)(0)(0)>[&] = firstport<s(0)(0)(0)>[&]; i<s(0)(0)(0)>[&] <= lastport<s(0)(0)(0)>[&]; i<s(0)(0)(0)>[&] ++);
    {
        clr_payload_ais<s(0)(0)(0)>[&] (i<s(0)(0)(0)>[&]);
    }
    
    return 0;
}




int g_ioabsent<s(0)(0)(0)>[&] =(D2) 0;





WORD<s(0)(0)(0)>[T]
CAH_EM4_GetPpiAlmState<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], UINT8<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], CTD_PPI_ALARM_T<s(0)(0)(0)>[T] * psPpiAlarm<s(0)(0)(0)>[&])
{
    ENTITY_T<s(0)(0)(0)>[T] entity<s(0)(0)(0)>[&] =(D2) 0;
    int ulPort<s(0)(0)(0)>[&] =(D2) 0;
    CAH_EM4_ENTITY_DATA_T<s(0)(0)(0)>[T] *pEntity<s(0)(0)(0)>[&];(D1:pEntity:0)
	unsigned short u<s(0)(0)(0)>[&] =(D2) 0;
	void * base<s(0)(0)(0)>[&] =(D2) 0;
    int isloop<s(0)(0)(0)>[&] =(D2) 0;
    CTD_PPI_ALARM_T<s(0)(0)(0)>[T] alm<s(0)(0)(0)>[&];(D1:alm:0)
    unsigned short val<s(0)(0)(0)>[&] =(D2) 0;
    unsigned char io<s(0)(0)(0)>[&] =(D2) 0;

    val<s(0)(0)(0)>[&] = 0;

	{if (125 <  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ) { printf<s(0)(0)(0)>[&] ("\r\n%s(): port(%d) overflow", __FUNCTION__<s(0)(0)(0)>[&],  SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) ); printf<s(0)(0)(0)>[&] ("\r\n\r\n\r\n"); return ((WORD<s(0)(0)(0)>[T])0x1) ; } } ;
    memset<s(0)(0)(0)>[&] (&alm<s(0)(0)(0)>[&], 0, sizeof (CTD_PPI_ALARM_T<s(0)(0)(0)>[T]));

    pEntity<s(0)(0)(0)>[&] = cah_em4_getEntityPtr<s(0)(0)(0)>[&] (entity<s(0)(0)(0)>[&]);
    ulPort<s(0)(0)(0)>[&] = cah_em4_mapPort<s(0)(0)(0)>[&] (SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&])) - 1;
	base<s(0)(0)(0)>[&] = cah_em4_getEntityBase<s(0)(0)(0)>[&] (0, SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]));
    if (byPortNo<s(0)(0)(0)>[&] == g_ulport<s(0)(0)(0)>[&])
    {
        printf<s(0)(0)(0)>[&] ("\r\nCAH_EM4_GetPpiAlmState: ulport(%d)", ulPort<s(0)(0)(0)>[&]); 
    }
    u<s(0)(0)(0)>[&] = cah_em4_readPdhAlarm<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], ulPort<s(0)(0)(0)>[&]);
    
    isloop<s(0)(0)(0)>[&] = cah_em4_gete1outloop<s(0)(0)(0)>[&] (base<s(0)(0)(0)>[&], ulPort<s(0)(0)(0)>[&]);

    psPpiAlarm<s(0)(0)(0)>[&]->lom<s(0)(0)(0)>[&] = (u<s(0)(0)(0)>[&] & 0x0002) ? 1 : 0;
    psPpiAlarm<s(0)(0)(0)>[&]->ais<s(0)(0)(0)>[&] = (u<s(0)(0)(0)>[&] & 0x0008) ? 1 : 0;  
    psPpiAlarm<s(0)(0)(0)>[&]->rdi<s(0)(0)(0)>[&] = (u<s(0)(0)(0)>[&] & 0x0001) ? 1 : 0;
    psPpiAlarm<s(0)(0)(0)>[&]->lof<s(0)(0)(0)>[&] = (u<s(0)(0)(0)>[&] & 0x0004) ? 1 : 0;

     


    psPpiAlarm<s(0)(0)(0)>[&]->los<s(0)(0)(0)>[&] = cah_em4_getPhyLos<s(0)(0)(0)>[&] (dwPos<s(0)(0)(0)>[&], SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]), &alm<s(0)(0)(0)>[&]);

     


    if (isloop<s(0)(0)(0)>[&]) psPpiAlarm<s(0)(0)(0)>[&]->los<s(0)(0)(0)>[&] = 0;



     




    if (isIOAbsent<s(0)(0)(0)>[&](SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]), &io<s(0)(0)(0)>[&]))
    {
        if ((SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) == 13 || SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]) == 120) && g_ioabsent<s(0)(0)(0)>[&])
        {
            printf<s(0)(0)(0)>[&] ("\r\nport(%d)'s IO is absent , skip it", SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]));
        }
        psPpiAlarm<s(0)(0)(0)>[&]->los<s(0)(0)(0)>[&] = 1;
         



        clear_IO_payload_si<s(0)(0)(0)>[&] (io<s(0)(0)(0)>[&]);

    } else {
        if (psPpiAlarm<s(0)(0)(0)>[&]->los<s(0)(0)(0)>[&])
        {
            cah_em4_ManualInsertPayloadAIS<s(0)(0)(0)>[&] (SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]), 1 );
        }
        else
        {
            cah_em4_ManualInsertPayloadAIS<s(0)(0)(0)>[&] (SDD_126xE1IOPortConvert<s(0)(0)(0)>[&](byPortNo<s(0)(0)(0)>[&]), 0 );
        }
    }

     
    return ((WORD<s(0)(0)(0)>[T])0x0) ;
}

WORD<s(0)(0)(0)>[T]
CAH_EM4_GetFpgaVersion<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], char *pucFpgaVer<s(0)(0)(0)>[&])
{
	unsigned short version<s(0)(0)(0)>[&] =(D2) 0, v1<s(0)(0)(0)>[&] =(D2) 0;

	version<s(0)(0)(0)>[&] = em4Map1Rd<s(0)(0)(0)>[&] (0, 0);
    v1<s(0)(0)(0)>[&] = em4_bpc_rd<s(0)(0)(0)>[&] (0, 0);
	 
    sprintf<s(0)(0)(0)>[&] (pucFpgaVer<s(0)(0)(0)>[&], "V%d.%d, V%d.%d", 
        (version<s(0)(0)(0)>[&] & 0xff00) >> 8, (version<s(0)(0)(0)>[&] & 0xff),
        (v1<s(0)(0)(0)>[&] && 0xff00) >> 8, (v1<s(0)(0)(0)>[&] && 0x00ff));
    return (((WORD<s(0)(0)(0)>[T])0x0) );
}


WORD<s(0)(0)(0)>[T]
CAH_EM4_GetTxLpTti<s(0)(0)(0)>[&] (DWORD<s(0)(0)(0)>[T] dwPos<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] byPortNo<s(0)(0)(0)>[&], TTI_LEN_T<s(0)(0)(0)>[T] eTtiMode<s(0)(0)(0)>[&], BYTE<s(0)(0)(0)>[T] * pbyTtiValue<s(0)(0)(0)>[&])
{
    return ((WORD<s(0)(0)(0)>[T])0x0) ;
}




int
pbFpgaIsrHookDel<s(0)(0)(0)>[&] (int handle<s(0)(0)(0)>[&])
{
    return 0 ;
}

int
pbFpgaIsrEnable<s(0)(0)(0)>[&] (int chip<s(0)(0)(0)>[&])
{
    return 0 ;
}

int
pbFpgaIntrDisable<s(0)(0)(0)>[&] (int handle<s(0)(0)(0)>[&])
{
    return 0 ;
}

 





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































 








>>>>>>> 26367c5e5efc49e0321b0abfa018e3da71d41acf
