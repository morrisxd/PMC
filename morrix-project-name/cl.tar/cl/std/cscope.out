cscope 15 $HOME/morrix-project-name/cl.tar/cl/std -q 0000000480 0000063777
	@c-standard.l

1 
ANSI
 
C
 
gmm
, 
Lex
 
ecifiti


2 
In
 1985, 
Jeff
 
L
 
published
 
this
 
Lex
 
ecifiti
 
togh
 
wh
 
a
 
Yacc
 
gmm
 
the
 
A
 30, 1985 
ANSI
 
C
 
d
. 
Tom
 
Stockfisch
 
poed
 
bh
 
to
 
t
.
sours
 

 1987; 
th
 
ig
, 
as
 
mtied
 ith
sw

quei
 17.25 
of
h
comp
.
ng
.
c
 
FAQ
, 
n
 
be
 
p
'ed from ftp.uu.net, file usenet/net.sources/ansi.c.grammar.Z.

3 
I
 
nd
 
to
 
kp
 
this
 
vsi
 
as
 
o

the
 
cut
 
C
 
Sndd
 
gmm

possib
; 

 
t
 
me
 
know
 
you
 
discov
 
discs
.

5 
Jua
 
Deg
, 1995

10 
wle
 \
n


11 
D
 [0-9]

12 
L
 [
a
-
zA
-
Z_
]

13 
H
 [
a
-
fA
-
F0
-9]

14 
E
 [
Ee
][+-]?{
D
}+

15 
FS
 (
f
|
F
|
l
|
L
)

16 
IS
 (
u
|
U
|
l
|
L
)*

19 
	~<dio.h
>

20 
	~"y.b.h
"

21 
	glo
 = 0;

22 
id
[128];

23 
dump
;

24 
i_tydef
;

25 
i_ru__uni
;

26 
cou
();

27 
	$t_rc_uni
()

29 
i_ru__uni
 = 1;

30  
i_ru__uni
;

31 
	}
}

36 %% /* 
	$yyx
 */

37 {
wle
} { 
lo
 ++; 
	`cou
(); }

38 "/*" { 
	`commt
(); }

39 "dio.h" { 
	`cou
();  (
FILENAME
); }

40 "#ude" { 
	`hd
(); }

41 "auto" { 
	`cou
(); (
AUTO
); }

42 "bak" { 
	`cou
(); (
BREAK
); }

43 "" { 
	`cou
(); (
CASE
); }

44 "ch" { 
	`cou
(); (
CHAR
); }

45 "cڡ" { 
	`cou
(); (
CONST
); }

46 "ctue" { 
	`cou
(); (
CONTINUE
); }

47 "deu" { 
	`cou
(); (
DEFAULT
); }

48 "do" { 
	`cou
(); (
DO
); }

49 "doub" { 
	`cou
(); (
DOUBLE
); }

50 "" { 
	`cou
(); (
ELSE
); }

51 "um" { 
	`cou
(); (
ENUM
); }

52 "ex" { 
	`cou
(); (
EXTERN
); }

53 "t" { 
	`cou
(); (
FLOAT
); }

54 "f" { 
	`cou
(); (
FOR
); }

55 "go" { 
	`cou
(); (
GOTO
); }

56 "if" { 
	`cou
(); (
IF
); }

57 "t" { 
	`cou
(); (
INT
); }

58 "lg" { 
	`cou
(); (
LONG
); }

59 "gi" { 
	`cou
(); (
REGISTER
); }

60 "tu" { 
	`cou
(); (
RETURN
); }

61 "sht" { 
	`cou
(); (
SHORT
); }

62 "sigd" { 
	`cou
(); (
SIGNED
); }

63 "sizeof" { 
	`cou
(); (
SIZEOF
); }

64 "ic" { 
	`cou
(); (
STATIC
); }

65 "ru" { 
	`cou
(); (
STRUCT
); }

66 "swch" { 
	`cou
(); (
SWITCH
); }

67 "tydef" { 
	`cou
(); (
TYPEDEF
); }

68 "uni" { 
	`cou
(); (
UNION
); }

69 "unsigd" { 
	`cou
(); (
UNSIGNED
); }

70 "void" { 
	`cou
(); (
VOID
); }

71 "vީe" { 
	`cou
(); (
VOLATILE
); }

72 "whe" { 
	`cou
(); (
WHILE
); }

74 {
L
}({L}|{
D
})* { 
	`cou
(); (
	`check_ty
()); }

76 0[
xX
]{
H
}+{
IS
}? { 
	`cou
(); (
CONSTANT
); }

77 0{
D
}+{
IS
}? { 
	`cou
(); (
CONSTANT
); }

78 {
D
}+{
IS
}? { 
	`cou
(); (
CONSTANT
); }

79 
L
?'(\\.|[^\\'])+' { count();eturn(CONSTANT); }

81 {
D
}+{
E
}{
FS
}? { 
	`cou
(); (
CONSTANT
); }

82 {
D
}*"."{D}+({
E
})?{
FS
}? { 
	`cou
(); (
CONSTANT
); }

83 {
D
}+"."{D}*({
E
})?{
FS
}? { 
	`cou
(); (
CONSTANT
); }

85 
L
?\"(\\.|[^\\"])*\" { count();eturn(STRING_LITERAL); }

87 "..." { 
	`cou
(); (
ELLIPSIS
); }

88 ">>=" { 
	`cou
(); (
RIGHT_ASSIGN
); }

89 "<<=" { 
	`cou
(); (
LEFT_ASSIGN
); }

90 "+=" { 
	`cou
(); (
ADD_ASSIGN
); }

91 "-=" { 
	`cou
(); (
SUB_ASSIGN
); }

92 "*=" { 
	`cou
(); (
MUL_ASSIGN
); }

93 "/=" { 
	`cou
(); (
DIV_ASSIGN
); }

94 "%=" { 
	`cou
(); (
MOD_ASSIGN
); }

95 "&=" { 
	`cou
(); (
AND_ASSIGN
); }

96 "^=" { 
	`cou
(); (
XOR_ASSIGN
); }

97 "|=" { 
	`cou
(); (
OR_ASSIGN
); }

98 ">>" { 
	`cou
(); (
RIGHT_OP
); }

99 "<<" { 
	`cou
(); (
LEFT_OP
); }

100 "++" { 
	`cou
(); (
INC_OP
); }

101 "--" { 
	`cou
(); (
DEC_OP
); }

102 "->" { 
	`cou
(); (
PTR_OP
); }

103 "&&" { 
	`cou
(); (
AND_OP
); }

104 "||" { 
	`cou
(); (
OR_OP
); }

105 "<=" { 
	`cou
(); (
LE_OP
); }

106 ">=" { 
	`cou
(); (
GE_OP
); }

107 "==" { 
	`cou
(); (
EQ_OP
); }

108 "!=" { 
	`cou
(); (
NE_OP
); }

109 ";" { 
	`cou
(); (';'); }

110 ("{"|"<%"{ 
	`cou
(); ('{'); }

111 ("}"|"%>"{ 
	`cou
(); ('}'); }

112 "," { 
	`cou
(); (','); }

113 ":" { 
	`cou
(); (':'); }

114 "=" { 
	`cou
(); ('='); }

115 "(" { 
	`cou
(); ('('); }

116 ")" { 
	`cou
(); (')'); }

117 ("["|"<:"{ 
	`cou
(); ('['); }

118 ("]"|":>"{ 
	`cou
(); (']'); }

119 "." { 
	`cou
(); ('.'); }

120 "&" { 
	`cou
(); ('&'); }

121 "!" { 
	`cou
(); ('!'); }

122 "~" { 
	`cou
(); ('~'); }

123 "-" { 
	`cou
(); ('-'); }

124 "+" { 
	`cou
(); ('+'); }

125 "*" { 
	`cou
(); ('*'); }

126 "/" { 
	`cou
(); ('/'); }

127 "%" { 
	`cou
(); ('%'); }

128 "<" { 
	`cou
(); ('<'); }

129 ">" { 
	`cou
(); ('>'); }

130 "^" { 
	`cou
(); ('^'); }

131 "|" { 
	`cou
(); ('|'); }

132 "?" { 
	`cou
(); ('?'); }

135 [ \
t
\
v
\
n
\
f
] { 
	`cou
(); }

138 
	}
%%

140 
	$yywp
()

143 
	}
}

145 
	$
()

147 
c
;

149 (
c
 = 
	`put
()) != '\n')

150 
	`putch
 (
c
);

151 
	}
}

153 
	$hd
()

155 
c
;

156 
	`tf
 ("%s", 
yyxt
);

157 (
c
 = 
	`put
()) != '\n' && c != 0)

158 
	`putch
(
c
);

159 i(
c
 = '\n'); 
	`putch
 (c);

160 
	}
}

163 
	$commt
()

165 
c
, 
c1
;

167 
	`puts
(
yyxt
);

168 
lo
:

169 (
c
 = 
	`put
()) != '*' && c != 0)

170 
	`putch
(
c
);

172 i((
c1
 = 
	`put
()!'/' && 
c
 != 0)

174 
	`uut
(
c1
);

175 
lo
;

177 i(
c
 ='*' && 
c1
 == '/') {

178 
	`putch
 (
c
);

181 i(
c
 != 0)

182 
	`putch
(
c1
);

183 
	}
}

186 
	gcumn
 = 0;

188 
	$cou
()

190 
i
;

192 
i
 = 0; 
yyxt
[i] != '\0'; i++)

193 i(
yyxt
[
i
] == '\n')

194 
cumn
 = 0;

195 i(
yyxt
[
i
] == '\t')

196 
cumn
 += 8 - (column % 8);

198 
cumn
++;

200 
ECHO
;

201 
	}
}

203 
id
[128];

204 
	$check_ty
()

218 
	`rtf
 (
id
, "%s", 
yyxt
);

219 i(
dump
) {

221 
dump
 = 0;

224 
	`tf
 ("<s(%d)>", 
i_ru__uni
);

225 (
IDENTIFIER
);

226 
	}
}

	@cl-standard.tab.c

1 
	#YY_r_h_uded


	)

38 #i
defed

_MSDOS
 ) || defed(
MSDOS
|| defed(
__MSDOS__
)

39 
	#__MSDOS_AND_ALIKE


	)

42 #i
defed
(
_WINDOWS
&& defed(
_MSC_VER
)

43 
	#__HAVE_NO_ALLOCA


	)

44 
	#__MSDOS_AND_ALIKE


	)

47 #ide
lo


48 #i
defed

__GNUC__
)

49 
	#lo
 
__but_lo


	)

51 #i(!
defed
 (
__STDC__
&& defed (
c
)|| defed (
__c__
|| defed (
__c
|| defed (
__sgi
)

52 
	~<lo.h
>

54 #i
defed
 (
__MSDOS_AND_ALIKE
)

55 
	~<mloc.h
>

56 #ide
__TURBOC__


58 
	#lo
 
_lo


	)

61 #i
defed
(
_AIX
)

63 #agm
lo


64 
	~<mloc.h
>

66 #i
defed
(
__hpux
)

67 #ifde
__lulus


69 *
lo
 ();

72 *
lo
 ();

78 #ifde
c_ulus


79 #ide
__lulus


80 
	#__lulus


	)

84 #ifde
__lulus


85 #ide
YY_USE_CLASS


89 #ide
__STDC__


90 cڡ

	)

92 #ifde
YY_USE_CLASS


97 
	~<dio.h
>

98 
	#YYBISON
 1

	)

104 
	gi_tydef
 = 0;

105 
	gi_ru__uni
 = 0;

110 
	#YY_r_BISON
 1

	)

112 #ide
YY_r_COMPATIBILITY


113 #ide
YY_USE_CLASS


114 
	#YY_r_COMPATIBILITY
 1

	)

116 
	#YY_r_COMPATIBILITY
 0

	)

120 #i
YY_r_COMPATIBILITY
 != 0

122 #ifde
YYLTYPE


123 #ide
YY_r_LTYPE


124 
	#YY_r_LTYPE
 
YYLTYPE


	)

129 #ide
YY_r_STYPE


130 
	#YY_r_STYPE
 
YYSTYPE


	)

133 #ifde
YYDEBUG


134 #ide
YY_r_DEBUG


135 
	#YY_r_DEBUG
 
YYDEBUG


	)

140 #ide
YY_r_USE_GOTO


141 
	#YY_r_USE_GOTO
 1

	)

146 #ide
YY_r_USE_GOTO


147 
	#YY_r_USE_GOTO
 0

	)

150 #ide
YY_r_PURE


161 #ide
YY_USE_CLASS


162 #ide
YYSTYPE


163 
	#YYSTYPE
 

	)

164 
	#YYSTYPE_IS_TRIVIAL
 1

	)

170 #ide
YY_r_DEBUG


179 #ide
YY_r_LSP_NEEDED


190 #ifde
YY_r_LSP_NEEDED


191 #ide
YY_r_LTYPE


192 #ide
BISON_YYLTYPE_ISDECLARED


193 
	#BISON_YYLTYPE_ISDECLARED


	)

195 
	syyy


197 
	mtimeamp
;

198 
	mf_le
;

199 
	mf_cumn
;

200 
	mϡ_le
;

201 
	mϡ_cumn
;

202 *
	mxt
;

204 
	tyyy
;

207 
	#YY_r_LTYPE
 
yyy


	)

215 #ide
YY_r_STYPE


216 
	#YY_r_STYPE
 

	)

219 #ide
YY_r_PARSE


220 
	#YY_r_PARSE
 
yyr


	)

222 #ide
YY_r_LEX


223 
	#YY_r_LEX
 
yyx


	)

225 #ide
YY_r_LVAL


226 
	#YY_r_LVAL
 
yylv


	)

228 #ide
YY_r_LLOC


229 
	#YY_r_LLOC
 
yyoc


	)

231 #ide
YY_r_CHAR


232 
	#YY_r_CHAR
 
yych


	)

234 #ide
YY_r_NERRS


235 
	#YY_r_NERRS
 
yyüs


	)

237 #ide
YY_r_DEBUG_FLAG


238 
	#YY_r_DEBUG_FLAG
 
yydebug


	)

240 #ide
YY_r_ERROR


241 
	#YY_r_ERROR
 
yyr


	)

244 #ide
YY_r_PARSE_PARAM


245 #ide
YY_USE_CLASS


246 #ifde
YYPARSE_PARAM


247 
	#YY_r_PARSE_PARAM
 * 
YYPARSE_PARAM


	)

249 #ide
__STDC__


250 #ide
__lulus


251 
	#YY_r_PARSE_PARAM


	)

256 #ide
YY_r_PARSE_PARAM


257 
	#YY_r_PARSE_PARAM
 

	)

261 #i
YY_r_COMPATIBILITY
 != 0

263 #ifde
YY_r_LTYPE


264 #ide
YYLTYPE


265 
	#YYLTYPE
 
YY_r_LTYPE


	)

278 #ifde
YY_r_PURE


279 #ide
YYPURE


280 
	#YYPURE
 
YY_r_PURE


	)

284 #ifde
YY_r_DEBUG


285 #ide
YYDEBUG


286 
	#YYDEBUG
 
YY_r_DEBUG


	)

290 #ide
YY_r_ERROR_VERBOSE


291 #ifde
YYERROR_VERBOSE


292 
	#YY_r_ERROR_VERBOSE
 
YYERROR_VERBOSE


	)

296 #ide
YY_r_LSP_NEEDED


297 #ifde
YYLSP_NEEDED


298 
	#YY_r_LSP_NEEDED
 
YYLSP_NEEDED


	)

304 #ide
YY_USE_CLASS


308 
	#IDENTIFIER
 258

	)

309 
	#CONSTANT
 259

	)

310 
	#STRING_LITERAL
 260

	)

311 
	#SIZEOF
 261

	)

312 
	#PTR_OP
 262

	)

313 
	#INC_OP
 263

	)

314 
	#DEC_OP
 264

	)

315 
	#LEFT_OP
 265

	)

316 
	#RIGHT_OP
 266

	)

317 
	#LE_OP
 267

	)

318 
	#GE_OP
 268

	)

319 
	#EQ_OP
 269

	)

320 
	#NE_OP
 270

	)

321 
	#AND_OP
 271

	)

322 
	#OR_OP
 272

	)

323 
	#MUL_ASSIGN
 273

	)

324 
	#DIV_ASSIGN
 274

	)

325 
	#MOD_ASSIGN
 275

	)

326 
	#ADD_ASSIGN
 276

	)

327 
	#SUB_ASSIGN
 277

	)

328 
	#LEFT_ASSIGN
 278

	)

329 
	#RIGHT_ASSIGN
 279

	)

330 
	#AND_ASSIGN
 280

	)

331 
	#XOR_ASSIGN
 281

	)

332 
	#OR_ASSIGN
 282

	)

333 
	#TYPE_NAME
 283

	)

334 
	#TYPEDEF
 284

	)

335 
	#EXTERN
 285

	)

336 
	#STATIC
 286

	)

337 
	#AUTO
 287

	)

338 
	#REGISTER
 288

	)

339 
	#CHAR
 289

	)

340 
	#SHORT
 290

	)

341 
	#INT
 291

	)

342 
	#LONG
 292

	)

343 
	#SIGNED
 293

	)

344 
	#UNSIGNED
 294

	)

345 
	#FLOAT
 295

	)

346 
	#DOUBLE
 296

	)

347 
	#CONST
 297

	)

348 
	#VOLATILE
 298

	)

349 
	#VOID
 299

	)

350 
	#STRUCT
 300

	)

351 
	#UNION
 301

	)

352 
	#ENUM
 302

	)

353 
	#ELLIPSIS
 303

	)

354 
	#CASE
 304

	)

355 
	#DEFAULT
 305

	)

356 
	#IF
 306

	)

357 
	#ELSE
 307

	)

358 
	#SWITCH
 308

	)

359 
	#WHILE
 309

	)

360 
	#DO
 310

	)

361 
	#FOR
 311

	)

362 
	#GOTO
 312

	)

363 
	#CONTINUE
 313

	)

364 
	#BREAK
 314

	)

365 
	#RETURN
 315

	)

372 #ide
YY_r_CLASS


373 
	#YY_r_CLASS
 
r


	)

375 #ide
YY_r_INHERIT


376 
	#YY_r_INHERIT


	)

378 #ide
YY_r_MEMBERS


379 
	#YY_r_MEMBERS


	)

381 #ide
YY_r_LEX_BODY


382 
	#YY_r_LEX_BODY


	)

384 #ide
YY_r_ERROR_BODY


385 
	#YY_r_ERROR_BODY


	)

387 #ide
YY_r_CONSTRUCTOR_PARAM


388 
	#YY_r_CONSTRUCTOR_PARAM


	)

390 #ide
YY_r_CONSTRUCTOR_CODE


391 
	#YY_r_CONSTRUCTOR_CODE


	)

393 #ide
YY_r_CONSTRUCTOR_INIT


394 
	#YY_r_CONSTRUCTOR_INIT


	)

397 #ide
YY_r_USE_CONST_TOKEN


398 
	#YY_r_USE_CONST_TOKEN
 0

	)

402 #i
YY_r_USE_CONST_TOKEN
 != 0

403 #ide
YY_r_ENUM_TOKEN


404 
	#YY_r_ENUM_TOKEN
 
yy_r_um_tok


	)

408 as
	cYY_r_CLASS
 
	mYY_r_INHERIT


410 
	mpublic
:

411 #i
YY_r_USE_CONST_TOKEN
 != 0

415 cڡ 
IDENTIFIER
;

416 cڡ 
	mCONSTANT
;

417 cڡ 
	mSTRING_LITERAL
;

418 cڡ 
	mSIZEOF
;

419 cڡ 
	mPTR_OP
;

420 cڡ 
	mINC_OP
;

421 cڡ 
	mDEC_OP
;

422 cڡ 
	mLEFT_OP
;

423 cڡ 
	mRIGHT_OP
;

424 cڡ 
	mLE_OP
;

425 cڡ 
	mGE_OP
;

426 cڡ 
	mEQ_OP
;

427 cڡ 
	mNE_OP
;

428 cڡ 
	mAND_OP
;

429 cڡ 
	mOR_OP
;

430 cڡ 
	mMUL_ASSIGN
;

431 cڡ 
	mDIV_ASSIGN
;

432 cڡ 
	mMOD_ASSIGN
;

433 cڡ 
	mADD_ASSIGN
;

434 cڡ 
	mSUB_ASSIGN
;

435 cڡ 
	mLEFT_ASSIGN
;

436 cڡ 
	mRIGHT_ASSIGN
;

437 cڡ 
	mAND_ASSIGN
;

438 cڡ 
	mXOR_ASSIGN
;

439 cڡ 
	mOR_ASSIGN
;

440 cڡ 
	mTYPE_NAME
;

441 cڡ 
	mTYPEDEF
;

442 cڡ 
	mEXTERN
;

443 cڡ 
	mSTATIC
;

444 cڡ 
	mAUTO
;

445 cڡ 
	mREGISTER
;

446 cڡ 
	mCHAR
;

447 cڡ 
	mSHORT
;

448 cڡ 
	mINT
;

449 cڡ 
	mLONG
;

450 cڡ 
	mSIGNED
;

451 cڡ 
	mUNSIGNED
;

452 cڡ 
	mFLOAT
;

453 cڡ 
	mDOUBLE
;

454 cڡ 
	mCONST
;

455 cڡ 
	mVOLATILE
;

456 cڡ 
	mVOID
;

457 cڡ 
	mSTRUCT
;

458 cڡ 
	mUNION
;

459 cڡ 
	mENUM
;

460 cڡ 
	mELLIPSIS
;

461 cڡ 
	mCASE
;

462 cڡ 
	mDEFAULT
;

463 cڡ 
	mIF
;

464 cڡ 
	mELSE
;

465 cڡ 
	mSWITCH
;

466 cڡ 
	mWHILE
;

467 cڡ 
	mDO
;

468 cڡ 
	mFOR
;

469 cڡ 
	mGOTO
;

470 cڡ 
	mCONTINUE
;

471 cڡ 
	mBREAK
;

472 cڡ 
	mRETURN
;

478 
	eYY_r_ENUM_TOKEN
 { 
	mYY_r_NULL_TOKEN
=0

481 ,
	mIDENTIFIER
=258

482 ,
	mCONSTANT
=259

483 ,
	mSTRING_LITERAL
=260

484 ,
	mSIZEOF
=261

485 ,
	mPTR_OP
=262

486 ,
	mINC_OP
=263

487 ,
	mDEC_OP
=264

488 ,
	mLEFT_OP
=265

489 ,
	mRIGHT_OP
=266

490 ,
	mLE_OP
=267

491 ,
	mGE_OP
=268

492 ,
	mEQ_OP
=269

493 ,
	mNE_OP
=270

494 ,
	mAND_OP
=271

495 ,
	mOR_OP
=272

496 ,
	mMUL_ASSIGN
=273

497 ,
	mDIV_ASSIGN
=274

498 ,
	mMOD_ASSIGN
=275

499 ,
	mADD_ASSIGN
=276

500 ,
	mSUB_ASSIGN
=277

501 ,
	mLEFT_ASSIGN
=278

502 ,
	mRIGHT_ASSIGN
=279

503 ,
	mAND_ASSIGN
=280

504 ,
	mXOR_ASSIGN
=281

505 ,
	mOR_ASSIGN
=282

506 ,
	mTYPE_NAME
=283

507 ,
	mTYPEDEF
=284

508 ,
	mEXTERN
=285

509 ,
	mSTATIC
=286

510 ,
	mAUTO
=287

511 ,
	mREGISTER
=288

512 ,
	mCHAR
=289

513 ,
	mSHORT
=290

514 ,
	mINT
=291

515 ,
	mLONG
=292

516 ,
	mSIGNED
=293

517 ,
	mUNSIGNED
=294

518 ,
	mFLOAT
=295

519 ,
	mDOUBLE
=296

520 ,
	mCONST
=297

521 ,
	mVOLATILE
=298

522 ,
	mVOID
=299

523 ,
	mSTRUCT
=300

524 ,
	mUNION
=301

525 ,
	mENUM
=302

526 ,
	mELLIPSIS
=303

527 ,
	mCASE
=304

528 ,
	mDEFAULT
=305

529 ,
	mIF
=306

530 ,
	mELSE
=307

531 ,
	mSWITCH
=308

532 ,
	mWHILE
=309

533 ,
	mDO
=310

534 ,
	mFOR
=311

535 ,
	mGOTO
=312

536 ,
	mCONTINUE
=313

537 ,
	mBREAK
=314

538 ,
	mRETURN
=315

545 
	gpublic
:

546 
YY_r_PARSE
 (
YY_r_PARSE_PARAM
);

547 
vtu
 
	$YY_r_ERROR
(*
msg

YY_r_ERROR_BODY
;

548 #ifde
YY_r_PURE


549 #ifde
YY_r_LSP_NEEDED


550 
vtu
 
	$YY_r_LEX
 (
YY_r_STYPE
 *
YY_r_LVAL
,
YY_r_LTYPE
 *
YY_r_LLOC

YY_r_LEX_BODY
;

552 
vtu
 
	$YY_r_LEX
 (
YY_r_STYPE
 *
YY_r_LVAL

YY_r_LEX_BODY
;

555 
vtu
 
	$YY_r_LEX
(
YY_r_LEX_BODY
;

556 
YY_r_STYPE
 
YY_r_LVAL
;

557 #ifde
YY_r_LSP_NEEDED


558 
YY_r_LTYPE
 
YY_r_LLOC
;

560 
YY_r_NERRS
;

561 
YY_r_CHAR
;

563 #i
YY_r_DEBUG
 != 0

564 
YY_r_DEBUG_FLAG
;

566 
public
:

567 
	`YY_r_CLASS
(
YY_r_CONSTRUCTOR_PARAM
);

568 
public
:

569 
YY_r_MEMBERS


570 
	}
};

572 #i
YY_r_USE_CONST_TOKEN
 != 0

575 cڡ 
	gYY_r_CLASS
::
IDENTIFIER
=258;

576 cڡ 
	gYY_r_CLASS
::
CONSTANT
=259;

577 cڡ 
	gYY_r_CLASS
::
STRING_LITERAL
=260;

578 cڡ 
	gYY_r_CLASS
::
SIZEOF
=261;

579 cڡ 
	gYY_r_CLASS
::
PTR_OP
=262;

580 cڡ 
	gYY_r_CLASS
::
INC_OP
=263;

581 cڡ 
	gYY_r_CLASS
::
DEC_OP
=264;

582 cڡ 
	gYY_r_CLASS
::
LEFT_OP
=265;

583 cڡ 
	gYY_r_CLASS
::
RIGHT_OP
=266;

584 cڡ 
	gYY_r_CLASS
::
LE_OP
=267;

585 cڡ 
	gYY_r_CLASS
::
GE_OP
=268;

586 cڡ 
	gYY_r_CLASS
::
EQ_OP
=269;

587 cڡ 
	gYY_r_CLASS
::
NE_OP
=270;

588 cڡ 
	gYY_r_CLASS
::
AND_OP
=271;

589 cڡ 
	gYY_r_CLASS
::
OR_OP
=272;

590 cڡ 
	gYY_r_CLASS
::
MUL_ASSIGN
=273;

591 cڡ 
	gYY_r_CLASS
::
DIV_ASSIGN
=274;

592 cڡ 
	gYY_r_CLASS
::
MOD_ASSIGN
=275;

593 cڡ 
	gYY_r_CLASS
::
ADD_ASSIGN
=276;

594 cڡ 
	gYY_r_CLASS
::
SUB_ASSIGN
=277;

595 cڡ 
	gYY_r_CLASS
::
LEFT_ASSIGN
=278;

596 cڡ 
	gYY_r_CLASS
::
RIGHT_ASSIGN
=279;

597 cڡ 
	gYY_r_CLASS
::
AND_ASSIGN
=280;

598 cڡ 
	gYY_r_CLASS
::
XOR_ASSIGN
=281;

599 cڡ 
	gYY_r_CLASS
::
OR_ASSIGN
=282;

600 cڡ 
	gYY_r_CLASS
::
TYPE_NAME
=283;

601 cڡ 
	gYY_r_CLASS
::
TYPEDEF
=284;

602 cڡ 
	gYY_r_CLASS
::
EXTERN
=285;

603 cڡ 
	gYY_r_CLASS
::
STATIC
=286;

604 cڡ 
	gYY_r_CLASS
::
AUTO
=287;

605 cڡ 
	gYY_r_CLASS
::
REGISTER
=288;

606 cڡ 
	gYY_r_CLASS
::
CHAR
=289;

607 cڡ 
	gYY_r_CLASS
::
SHORT
=290;

608 cڡ 
	gYY_r_CLASS
::
INT
=291;

609 cڡ 
	gYY_r_CLASS
::
LONG
=292;

610 cڡ 
	gYY_r_CLASS
::
SIGNED
=293;

611 cڡ 
	gYY_r_CLASS
::
UNSIGNED
=294;

612 cڡ 
	gYY_r_CLASS
::
FLOAT
=295;

613 cڡ 
	gYY_r_CLASS
::
DOUBLE
=296;

614 cڡ 
	gYY_r_CLASS
::
CONST
=297;

615 cڡ 
	gYY_r_CLASS
::
VOLATILE
=298;

616 cڡ 
	gYY_r_CLASS
::
VOID
=299;

617 cڡ 
	gYY_r_CLASS
::
STRUCT
=300;

618 cڡ 
	gYY_r_CLASS
::
UNION
=301;

619 cڡ 
	gYY_r_CLASS
::
ENUM
=302;

620 cڡ 
	gYY_r_CLASS
::
ELLIPSIS
=303;

621 cڡ 
	gYY_r_CLASS
::
CASE
=304;

622 cڡ 
	gYY_r_CLASS
::
DEFAULT
=305;

623 cڡ 
	gYY_r_CLASS
::
IF
=306;

624 cڡ 
	gYY_r_CLASS
::
ELSE
=307;

625 cڡ 
	gYY_r_CLASS
::
SWITCH
=308;

626 cڡ 
	gYY_r_CLASS
::
WHILE
=309;

627 cڡ 
	gYY_r_CLASS
::
DO
=310;

628 cڡ 
	gYY_r_CLASS
::
FOR
=311;

629 cڡ 
	gYY_r_CLASS
::
GOTO
=312;

630 cڡ 
	gYY_r_CLASS
::
CONTINUE
=313;

631 cڡ 
	gYY_r_CLASS
::
BREAK
=314;

632 cڡ 
	gYY_r_CLASS
::
RETURN
=315;

639 
	gYY_r_CLASS
::
	$YY_r_CLASS
(
YY_r_CONSTRUCTOR_PARAM

YY_r_CONSTRUCTOR_INIT


641 #i
YY_r_DEBUG
 != 0

642 
YY_r_DEBUG_FLAG
=0;

644 
YY_r_CONSTRUCTOR_CODE
;

645 
	}
};

651 
	#YYFINAL
 350

	)

652 
	#YYFLAG
 -32768

	)

653 
	#YYNTBASE
 85

	)

655 
	#YYTRANSLATE
(
x
(()(x<315 ? 
yye
[x] : 148)

	)

657 cڡ 
	gyye
[] = { 0,

692 #i
YY_r_DEBUG
 != 0

693 cڡ 
	gyyhs
[] = { 0,

718 cڡ 
	gyyrhs
[] = { 3,

789 #i(
YY_r_DEBUG
 !0|| 
defed
(
YY_r_ERROR_VERBOSE
)

790 cڡ 
	gyye
[] = { 0,

815 cڡ * cڡ 
	gyyame
[] = { "$","error","$illegal.","IDENTIFIER",

843 cڡ 
	gyyr1
[] = { 0,

868 cڡ 
	gyyr2
[] = { 0,

893 cڡ 
	gyyde
[] = { 0,

931 cڡ 
	gyydefgo
[] = { 106,

941 cڡ 
	gyy
[] = { 937,

979 cڡ 
	gyypgo
[] = {-32768,

990 
	#YYLAST
 1308

	)

993 cڡ 
	gyyb
[] = { 25,

1127 cڡ 
	gyycheck
[] = { 0,

1276 #i
YY_r_USE_GOTO
 != 0

1284 
	#YYGOTO
(
lb
{
yy_goe
b;;}

	)

1285 
	#YYBEGINGOTO
 
yy_bs
 
yy_goe
=
yygot
; \

1286 ;;
yy_goe
{ 
yygot
: {

	)

1287 
	#YYLABEL
(
lb
} lb: {

	)

1288 
	#YYENDGOTO
 } }

	)

1289 
	#YYBEGINDECLARELABEL
 
	eyy_bs
 {
yygot


	)

1290 
	#YYDECLARELABEL
(
lb
,
	)
lb

1291 
	#YYENDDECLARELABEL
 };

	)

1294 
	#YYGOTO
(
lb

	)
lb

1295 
	#YYBEGINGOTO


	)

1296 
	#YYLABEL
(
lb
lb:

	)

1297 
	#YYENDGOTO


	)

1298 
	#YYBEGINDECLARELABEL


	)

1299 
	#YYDECLARELABEL
(
lb
)

	)

1300 
	#YYENDDECLARELABEL


	)

1303 
YYBEGINDECLARELABEL


1304 
	$YYDECLARELABEL
(
yywe
)

1305 
	$YYDECLARELABEL
(
yybackup
)

1307 
	$YYDECLARELABEL
(
yydeu
)

1308 
	$YYDECLARELABEL
(
yydu
)

1309 
	$YYDECLARELABEL
(
yyab
)

1310 
	$YYDECLARELABEL
(
yyab1
)

1311 
	$YYDECLARELABEL
(
yyrdeu
)

1312 
	$YYDECLARELABEL
(
yy
)

1313 
	$YYDECLARELABEL
(
yyrhd
)

1314 
YYENDDECLARELABEL


1317 #ifde
__HAVE_NO_ALLOCA


1318 
	$__lo__r
(*
r
,*
f
)

1319 {if(
r
!=
f

	`
(ptr);

1320  0;
	}
}

1322 
	#__ALLOCA_lo
(
size

	`mloc
(size)

	)

1323 
	#__ALLOCA_
(
r
,
f

	`__lo__r
((*,(*ef)

	)

1325 #ifde
YY_r_LSP_NEEDED


1326 
	#__ALLOCA_tu
(
num
) \

1327 d{ 
	`__ALLOCA_
(
yyss
,
yys
)+\

1328 
	`__ALLOCA_
(
yyvs
,
yyv
)+\

1329 
	`__ALLOCA_
(
yyls
,
yyl
)+\

1330 (
num
)); } 0)

	)

1332 
	#__ALLOCA_tu
(
num
) \

1333 d{ 
	`__ALLOCA_
(
yyss
,
yys
)+\

1334 
	`__ALLOCA_
(
yyvs
,
yyv
)+\

1335 (
num
)); } 0)

	)

1338 
	#__ALLOCA_tu
(
num
d{ um); } 0)

	)

1339 
	#__ALLOCA_lo
(
size

	`lo
(size)

	)

1340 
	#__ALLOCA_
(
r
,
f
)

	)

1345 
	#yyrok
 (
yyrus
 = 0)

	)

1346 
	#yyr
 (
YY_r_CHAR
 = 
YYEMPTY
)

	)

1347 
	#YYEMPTY
 -2

	)

1348 
	#YYEOF
 0

	)

1349 
	#YYACCEPT
 
	`__ALLOCA_tu
(0)

	)

1350 
	#YYABORT
 
	`__ALLOCA_tu
(1)

	)

1351 
	#YYERROR
 
	`YYGOTO
(
yyab1
)

	)

1356 
	#YYFAIL
 
	`YYGOTO
(
yyab
)

	)

1357 
	#YYRECOVERING
((!!
yyrus
)

	)

1358 
	#YYBACKUP
(
tok
, 
vue
) \

1360 i(
YY_r_CHAR
 =
YYEMPTY
 && 
yyn
 == 1) \

1361 { 
YY_r_CHAR
 = (
tok
), 
YY_r_LVAL
 = (
vue
); \

1362 
yych1
 = 
	`YYTRANSLATE
 (
YY_r_CHAR
); \

1363 
YYPOPSTACK
; \

1364 
	`YYGOTO
(
yybackup
); \

1367 { 
	`YY_r_ERROR
 ("syax: cn back up"); 
YYERROR
; } \

1368 0)

	)

1370 
	#YYTERROR
 1

	)

1371 
	#YYERRCODE
 256

	)

1373 #ide
YY_r_PURE


1375 
	#YYLEX
 
	`YY_r_LEX
()

	)

1376 #ide
YY_USE_CLASS


1378 
	gYY_r_CHAR
;

1379 
YY_r_STYPE
 
	gYY_r_LVAL
;

1381 
	gYY_r_NERRS
;

1382 #ifde
YY_r_LSP_NEEDED


1383 
YY_r_LTYPE
 
	gYY_r_LLOC
;

1391 #ifde
YY_r_LSP_NEEDED


1392 
	#YYLEX
 
	`YY_r_LEX
(&
YY_r_LVAL
, &
YY_r_LLOC
)

	)

1394 
	#YYLEX
 
	`YY_r_LEX
(&
YY_r_LVAL
)

	)

1397 #ide
YY_USE_CLASS


1398 #i
YY_r_DEBUG
 != 0

1399 
	gYY_r_DEBUG_FLAG
;

1409 #ide
YYINITDEPTH


1410 
	#YYINITDEPTH
 200

	)

1416 #i
YYMAXDEPTH
 == 0

1417 #unde
YYMAXDEPTH


1420 #ide
YYMAXDEPTH


1421 
	#YYMAXDEPTH
 10000

	)

1425 #i
__GNUC__
 > 1

1426 
	#__yy_bcy
(
FROM
,
TO
,
COUNT

	`__but_memy
(TO,FROM,COUNT)

	)

1432 #ifde
__lulus


1433 
	$__yy_bcy
 (*
om
, *
to
, 
cou
)

1435 #ifde
__STDC__


1436 
	$__yy_bcy
 (*
om
, *
to
, 
cou
)

1438 
	$__yy_bcy
 (
om
, 
to
, 
cou
)

1439 *
om
;

1440 *
to
;

1441 
cou
;

1445 *
f
 = 
om
;

1446 *
t
 = 
to
;

1447 
i
 = 
cou
;

1449 
i
-- > 0)

1450 *
t
++ = *
f
++;

1451 
	}
}

1456 #ifde
YY_USE_CLASS


1457 
	gYY_r_CLASS
::

1459 
	$YY_r_PARSE
(
YY_r_PARSE_PARAM
)

1460 #ide
__STDC__


1461 #ide
__lulus


1462 #ide
YY_USE_CLASS


1464 
YY_r_PARSE_PARAM_DEF


1469 
yye
;

1470 
yyn
;

1471 *
yys
;

1472 
YY_r_STYPE
 *
yyv
;

1473 
yyrus
;

1474 
yych1
=0;

1476 
yys
[
YYINITDEPTH
];

1477 
YY_r_STYPE
 
yyv
[
YYINITDEPTH
];

1479 *
yyss
 = 
yys
;

1480 
YY_r_STYPE
 *
yyvs
 = 
yyv
;

1482 #ifde
YY_r_LSP_NEEDED


1483 
YY_r_LTYPE
 
yyl
[
YYINITDEPTH
];

1484 
YY_r_LTYPE
 *
yyls
 = 
yyl
;

1485 
YY_r_LTYPE
 *
yyl
;

1487 
	#YYPOPSTACK
 (
yyv
--, 
yys
--, 
yyl
--)

	)

1489 
	#YYPOPSTACK
 (
yyv
--, 
yys
--)

	)

1492 
yyacksize
 = 
YYINITDEPTH
;

1494 #ifde
YY_r_PURE


1495 
YY_r_CHAR
;

1496 
YY_r_STYPE
 
YY_r_LVAL
;

1497 
YY_r_NERRS
;

1498 #ifde
YY_r_LSP_NEEDED


1499 
YY_r_LTYPE
 
YY_r_LLOC
;

1503 
YY_r_STYPE
 
yyv
;

1507 
yyn
;

1509 
YYBEGINGOTO


1511 #i
YY_r_DEBUG
 != 0

1512 i(
YY_r_DEBUG_FLAG
)

1513 
	`rtf
(
dr
, "Startingarse\n");

1515 
yye
 = 0;

1516 
yyrus
 = 0;

1517 
YY_r_NERRS
 = 0;

1518 
YY_r_CHAR
 = 
YYEMPTY
;

1525 
yys
 = 
yyss
 - 1;

1526 
yyv
 = 
yyvs
;

1527 #ifde
YY_r_LSP_NEEDED


1528 
yyl
 = 
yyls
;

1534 
	`YYLABEL
(
yywe
)

1536 *++
yys
 = 
yye
;

1538 i(
yys
 >
yyss
 + 
yyacksize
 - 1)

1542 
YY_r_STYPE
 *
yyvs1
 = 
yyvs
;

1543 *
yyss1
 = 
yyss
;

1544 #ifde
YY_r_LSP_NEEDED


1545 
YY_r_LTYPE
 *
yyls1
 = 
yyls
;

1549 
size
 = 
yys
 - 
yyss
 + 1;

1551 #ifde
yyovow


1554 #ifde
YY_r_LSP_NEEDED


1557 
	`yyovow
("parser stack overflow",

1558 &
yyss1
, 
size
 *  (*
yys
),

1559 &
yyvs1
, 
size
 *  (*
yyv
),

1560 &
yyls1
, 
size
 *  (*
yyl
),

1561 &
yyacksize
);

1563 
	`yyovow
("parser stack overflow",

1564 &
yyss1
, 
size
 *  (*
yys
),

1565 &
yyvs1
, 
size
 *  (*
yyv
),

1566 &
yyacksize
);

1569 
yyss
 = 
yyss1
; 
yyvs
 = 
yyvs1
;

1570 #ifde
YY_r_LSP_NEEDED


1571 
yyls
 = 
yyls1
;

1575 i(
yyacksize
 >
YYMAXDEPTH
)

1577 
	`YY_r_ERROR
("parser stack overflow");

1578 
	`__ALLOCA_tu
(2);

1580 
yyacksize
 *= 2;

1581 i(
yyacksize
 > 
YYMAXDEPTH
)

1582 
yyacksize
 = 
YYMAXDEPTH
;

1583 
yyss
 = (*
	`__ALLOCA_lo
 (
yyacksize
 *  (*
yys
));

1584 
	`__yy_bcy
 ((*)
yyss1
, (*)
yyss
, 
size
 *  (*
yys
));

1585 
	`__ALLOCA_
(
yyss1
,
yys
);

1586 
yyvs
 = (
YY_r_STYPE
 *
	`__ALLOCA_lo
 (
yyacksize
 *  (*
yyv
));

1587 
	`__yy_bcy
 ((*)
yyvs1
, (*)
yyvs
, 
size
 *  (*
yyv
));

1588 
	`__ALLOCA_
(
yyvs1
,
yyv
);

1589 #ifde
YY_r_LSP_NEEDED


1590 
yyls
 = (
YY_r_LTYPE
 *
	`__ALLOCA_lo
 (
yyacksize
 *  (*
yyl
));

1591 
	`__yy_bcy
 ((*)
yyls1
, (*)
yyls
, 
size
 *  (*
yyl
));

1592 
	`__ALLOCA_
(
yyls1
,
yyl
);

1596 
yys
 = 
yyss
 + 
size
 - 1;

1597 
yyv
 = 
yyvs
 + 
size
 - 1;

1598 #ifde
YY_r_LSP_NEEDED


1599 
yyl
 = 
yyls
 + 
size
 - 1;

1602 #i
YY_r_DEBUG
 != 0

1603 i(
YY_r_DEBUG_FLAG
)

1604 
	`rtf
(
dr
, "Sck sizd%d\n", 
yyacksize
);

1607 i(
yys
 >
yyss
 + 
yyacksize
 - 1)

1608 
YYABORT
;

1611 #i
YY_r_DEBUG
 != 0

1612 i(
YY_r_DEBUG_FLAG
)

1613 
	`rtf
(
dr
, "Eg s %d\n", 
yye
);

1616 
	`YYGOTO
(
yybackup
);

1617 
	`YYLABEL
(
yybackup
)

1625 
yyn
 = 
yy
[
yye
];

1626 i(
yyn
 =
YYFLAG
)

1627 
	`YYGOTO
(
yydeu
);

1634 i(
YY_r_CHAR
 =
YYEMPTY
)

1636 #i
YY_r_DEBUG
 != 0

1637 i(
YY_r_DEBUG_FLAG
)

1638 
	`rtf
(
dr
, "Readingoken: ");

1640 
YY_r_CHAR
 = 
YYLEX
;

1645 i(
YY_r_CHAR
 <= 0)

1647 
yych1
 = 0;

1648 
YY_r_CHAR
 = 
YYEOF
;

1650 #i
YY_r_DEBUG
 != 0

1651 i(
YY_r_DEBUG_FLAG
)

1652 
	`rtf
(
dr
, "Nowtnd of input.\n");

1657 
yych1
 = 
	`YYTRANSLATE
(
YY_r_CHAR
);

1659 #i
YY_r_DEBUG
 != 0

1660 i(
YY_r_DEBUG_FLAG
)

1662 
	`rtf
 (
dr
, "Nextok i%d (%s", 
YY_r_CHAR
, 
yyame
[
yych1
]);

1665 #ifde
YYPRINT


1666 
	`YYPRINT
 (
dr
, 
YY_r_CHAR
, 
YY_r_LVAL
);

1668 
	`rtf
 (
dr
, ")\n");

1673 
yyn
 +
yych1
;

1674 i(
yyn
 < 0 || yy> 
YYLAST
 || 
yycheck
[yyn] !
yych1
)

1675 
	`YYGOTO
(
yydeu
);

1677 
yyn
 = 
yyb
[yyn];

1686 i(
yyn
 < 0)

1688 i(
yyn
 =
YYFLAG
)

1689 
	`YYGOTO
(
yyab
);

1690 
yyn
 = -yyn;

1691 
	`YYGOTO
(
yydu
);

1693 i(
yyn
 == 0)

1694 
	`YYGOTO
(
yyab
);

1696 i(
yyn
 =
YYFINAL
)

1697 
YYACCEPT
;

1701 #i
YY_r_DEBUG
 != 0

1702 i(
YY_r_DEBUG_FLAG
)

1703 
	`rtf
(
dr
, "Shigok %d (%s), ", 
YY_r_CHAR
, 
yyame
[
yych1
]);

1707 i(
YY_r_CHAR
 !
YYEOF
)

1708 
YY_r_CHAR
 = 
YYEMPTY
;

1710 *++
yyv
 = 
YY_r_LVAL
;

1711 #ifde
YY_r_LSP_NEEDED


1712 *++
yyl
 = 
YY_r_LLOC
;

1716 i(
yyrus
) yyerrstatus--;

1718 
yye
 = 
yyn
;

1719 
	`YYGOTO
(
yywe
);

1722 
	`YYLABEL
(
yydeu
)

1724 
yyn
 = 
yyde
[
yye
];

1725 i(
yyn
 == 0)

1726 
	`YYGOTO
(
yyab
);

1729 
	`YYLABEL
(
yydu
)

1730 
yyn
 = 
yyr2
[
yyn
];

1731 i(
yyn
 > 0)

1732 
yyv
 = 
yyv
[1-
yyn
];

1734 #i
YY_r_DEBUG
 != 0

1735 i(
YY_r_DEBUG_FLAG
)

1737 
i
;

1739 
	`rtf
 (
dr
, "Reducing viaule %d (line %d), ",

1740 
yyn
, 
yye
[yyn]);

1743 
i
 = 
yyhs
[
yyn
]; 
yyrhs
[i] > 0; i++)

1744 
	`rtf
 (
dr
, "%", 
yyame
[
yyrhs
[
i
]]);

1745 
	`rtf
 (
dr
, " -> %s\n", 
yyame
[
yyr1
[
yyn
]]);

1752 
yyn
) {

1756 { 
	`tf
 ("$$$$$"); ;

1762 
yyv
 -
yyn
;

1763 
yys
 -
yyn
;

1764 #ifde
YY_r_LSP_NEEDED


1765 
yyl
 -
yyn
;

1768 #i
YY_r_DEBUG
 != 0

1769 i(
YY_r_DEBUG_FLAG
)

1771 *
s1
 = 
yyss
 - 1;

1772 
	`rtf
 (
dr
, "state stackow");

1773 
s1
 !
yys
)

1774 
	`rtf
 (
dr
, " %d", *++
s1
);

1775 
	`rtf
 (
dr
, "\n");

1779 *++
yyv
 = 
yyv
;

1781 #ifde
YY_r_LSP_NEEDED


1782 
yyl
++;

1783 i(
yyn
 == 0)

1785 
yyl
->
f_le
 = 
YY_r_LLOC
.first_line;

1786 
yyl
->
f_cumn
 = 
YY_r_LLOC
.first_column;

1787 
yyl
->
ϡ_le
 = (yylsp-1)->last_line;

1788 
yyl
->
ϡ_cumn
 = (yylsp-1)->last_column;

1789 
yyl
->
xt
 = 0;

1793 
yyl
->
ϡ_le
 = (yyl+
yyn
-1)->last_line;

1794 
yyl
->
ϡ_cumn
 = (yyl+
yyn
-1)->last_column;

1803 
yyn
 = 
yyr1
[yyn];

1805 
yye
 = 
yypgo
[
yyn
 - 
YYNTBASE
] + *
yys
;

1806 i(
yye
 >0 && yy<
YYLAST
 && 
yycheck
[yye] =*
yys
)

1807 
yye
 = 
yyb
[yystate];

1809 
yye
 = 
yydefgo
[
yyn
 - 
YYNTBASE
];

1811 
	`YYGOTO
(
yywe
);

1813 
	`YYLABEL
(
yyab
)

1815 i(! 
yyrus
)

1818 ++
YY_r_NERRS
;

1820 #ifde
YY_r_ERROR_VERBOSE


1821 
yyn
 = 
yy
[
yye
];

1823 i(
yyn
 > 
YYFLAG
 && yy< 
YYLAST
)

1825 
size
 = 0;

1826 *
msg
;

1827 
x
, 
cou
;

1829 
cou
 = 0;

1831 
x
 = (
yyn
 < 0 ? -yyn : 0);

1832 
x
 < ((
yyame
) / (*)); x++)

1833 i(
yycheck
[
x
 + 
yyn
] == x)

1834 
size
 +
	`
(
yyame
[
x
]+ 15, 
cou
++;

1835 
msg
 = (*
	`mloc
(
size
 + 15);

1836 i(
msg
 != 0)

1838 
	`ry
(
msg
, "parserror");

1840 i(
cou
 < 5)

1842 
cou
 = 0;

1843 
x
 = (
yyn
 < 0 ? -yyn : 0);

1844 
x
 < ((
yyame
) / (*)); x++)

1845 i(
yycheck
[
x
 + 
yyn
] == x)

1847 
	`rt
(
msg
, 
cou
 == 0 ? ",xpecting `" : " or `");

1848 
	`rt
(
msg
, 
yyame
[
x
]);

1849 
	`rt
(
msg
, "'");

1850 
cou
++;

1853 
	`YY_r_ERROR
(
msg
);

1854 
	`
(
msg
);

1857 
	`YY_r_ERROR
 ("parserror;lso virtual memoryxceeded");

1861 
	`YY_r_ERROR
("parserror");

1864 
	`YYGOTO
(
yyab1
);

1865 
	`YYLABEL
(
yyab1
)

1867 i(
yyrus
 == 3)

1872 i(
YY_r_CHAR
 =
YYEOF
)

1873 
YYABORT
;

1875 #i
YY_r_DEBUG
 != 0

1876 i(
YY_r_DEBUG_FLAG
)

1877 
	`rtf
(
dr
, "Disrdgok %d (%s).\n", 
YY_r_CHAR
, 
yyame
[
yych1
]);

1880 
YY_r_CHAR
 = 
YYEMPTY
;

1886 
yyrus
 = 3;

1888 
	`YYGOTO
(
yyrhd
);

1890 
	`YYLABEL
(
yyrdeu
)

1895 
yyn
 = 
yyde
[
yye
];

1896 i(
yyn

	`YYGOTO
(
yydeu
);

1899 
	`YYLABEL
(
yy
)

1901 i(
yys
 =
yyss

YYABORT
;

1902 
yyv
--;

1903 
yye
 = *--
yys
;

1904 #ifde
YY_r_LSP_NEEDED


1905 
yyl
--;

1908 #i
YY_r_DEBUG
 != 0

1909 i(
YY_r_DEBUG_FLAG
)

1911 *
s1
 = 
yyss
 - 1;

1912 
	`rtf
 (
dr
, "Error: state stackow");

1913 
s1
 !
yys
)

1914 
	`rtf
 (
dr
, " %d", *++
s1
);

1915 
	`rtf
 (
dr
, "\n");

1919 
	`YYLABEL
(
yyrhd
)

1921 
yyn
 = 
yy
[
yye
];

1922 i(
yyn
 =
YYFLAG
)

1923 
	`YYGOTO
(
yyrdeu
);

1925 
yyn
 +
YYTERROR
;

1926 i(
yyn
 < 0 || yy> 
YYLAST
 || 
yycheck
[yyn] !
YYTERROR
)

1927 
	`YYGOTO
(
yyrdeu
);

1929 
yyn
 = 
yyb
[yyn];

1930 i(
yyn
 < 0)

1932 i(
yyn
 =
YYFLAG
)

1933 
	`YYGOTO
(
yy
);

1934 
yyn
 = -yyn;

1935 
	`YYGOTO
(
yydu
);

1937 i(
yyn
 == 0)

1938 
	`YYGOTO
(
yy
);

1940 i(
yyn
 =
YYFINAL
)

1941 
YYACCEPT
;

1943 #i
YY_r_DEBUG
 != 0

1944 i(
YY_r_DEBUG_FLAG
)

1945 
	`rtf
(
dr
, "Shiftingrroroken, ");

1948 *++
yyv
 = 
YY_r_LVAL
;

1949 #ifde
YY_r_LSP_NEEDED


1950 *++
yyl
 = 
YY_r_LLOC
;

1953 
yye
 = 
yyn
;

1954 
	`YYGOTO
(
yywe
);

1956 
YYENDGOTO


1957 
	}
}

1964 
	~<dio.h
>

1966 
yyxt
[];

1967 
cumn
;

1969 
	$yyr
(
s
)

1970 *
s
;

1972 
	`fush
(
dout
);

1973 
	`tf
("\n%*s\n%*s\n", 
cumn
, "^", cumn, 
s
);

1974 
	}
}

	@cl-standard.tab.h

1 #ide
YY_r_h_uded


2 
	#YY_r_h_uded


	)

7 #ifde
c_ulus


8 #ide
__lulus


9 
	#__lulus


	)

18 #ide
YY_r_COMPATIBILITY


19 #ide
YY_USE_CLASS


20 
	#YY_r_COMPATIBILITY
 1

	)

22 
	#YY_r_COMPATIBILITY
 0

	)

26 #i
YY_r_COMPATIBILITY
 != 0

28 #ifde
YYLTYPE


29 #ide
YY_r_LTYPE


30 
	#YY_r_LTYPE
 
YYLTYPE


	)

36 #ide
YY_r_STYPE


37 
	#YY_r_STYPE
 
YYSTYPE


	)

42 #ifde
YYDEBUG


43 #ide
YY_r_DEBUG


44 
	#YY_r_DEBUG
 
YYDEBUG


	)

50 #ide
YY_r_USE_GOTO


51 
	#YY_r_USE_GOTO
 1

	)

56 #ide
YY_r_USE_GOTO


57 
	#YY_r_USE_GOTO
 0

	)

60 #ide
YY_r_PURE


70 #ide
YY_USE_CLASS


71 #ide
YYSTYPE


72 
	#YYSTYPE
 

	)

73 
	#YYSTYPE_IS_TRIVIAL
 1

	)

80 #ide
YY_r_DEBUG


88 #ide
YY_r_LSP_NEEDED


97 #ifde
YY_r_LSP_NEEDED


98 #ide
YY_r_LTYPE


99 #ide
BISON_YYLTYPE_ISDECLARED


100 
	#BISON_YYLTYPE_ISDECLARED


	)

102 
	syyy


104 
	mtimeamp
;

105 
	mf_le
;

106 
	mf_cumn
;

107 
	mϡ_le
;

108 
	mϡ_cumn
;

109 *
	mxt
;

111 
	tyyy
;

114 
	#YY_r_LTYPE
 
yyy


	)

119 #ide
YY_r_STYPE


120 
	#YY_r_STYPE
 

	)

124 #ide
YY_r_PARSE


125 
	#YY_r_PARSE
 
yyr


	)

128 #ide
YY_r_LEX


129 
	#YY_r_LEX
 
yyx


	)

132 #ide
YY_r_LVAL


133 
	#YY_r_LVAL
 
yylv


	)

136 #ide
YY_r_LLOC


137 
	#YY_r_LLOC
 
yyoc


	)

140 #ide
YY_r_CHAR


141 
	#YY_r_CHAR
 
yych


	)

144 #ide
YY_r_NERRS


145 
	#YY_r_NERRS
 
yyüs


	)

148 #ide
YY_r_DEBUG_FLAG


149 
	#YY_r_DEBUG_FLAG
 
yydebug


	)

152 #ide
YY_r_ERROR


153 
	#YY_r_ERROR
 
yyr


	)

156 #ide
YY_r_PARSE_PARAM


157 #ide
__STDC__


158 #ide
__lulus


159 #ide
YY_USE_CLASS


160 
	#YY_r_PARSE_PARAM


	)

161 #ide
YY_r_PARSE_PARAM_DEF


162 
	#YY_r_PARSE_PARAM_DEF


	)

167 #ide
YY_r_PARSE_PARAM


168 
	#YY_r_PARSE_PARAM
 

	)

173 #ide
YY_USE_CLASS


175 #ide
YY_r_PURE


176 #ide
yylv


177 
YY_r_STYPE
 
YY_r_LVAL
;

179 #i
yylv
 !
YY_r_LVAL


180 
YY_r_STYPE
 
YY_r_LVAL
;

189 
	#IDENTIFIER
 258

	)

190 
	#CONSTANT
 259

	)

191 
	#STRING_LITERAL
 260

	)

192 
	#SIZEOF
 261

	)

193 
	#PTR_OP
 262

	)

194 
	#INC_OP
 263

	)

195 
	#DEC_OP
 264

	)

196 
	#LEFT_OP
 265

	)

197 
	#RIGHT_OP
 266

	)

198 
	#LE_OP
 267

	)

199 
	#GE_OP
 268

	)

200 
	#EQ_OP
 269

	)

201 
	#NE_OP
 270

	)

202 
	#AND_OP
 271

	)

203 
	#OR_OP
 272

	)

204 
	#MUL_ASSIGN
 273

	)

205 
	#DIV_ASSIGN
 274

	)

206 
	#MOD_ASSIGN
 275

	)

207 
	#ADD_ASSIGN
 276

	)

208 
	#SUB_ASSIGN
 277

	)

209 
	#LEFT_ASSIGN
 278

	)

210 
	#RIGHT_ASSIGN
 279

	)

211 
	#AND_ASSIGN
 280

	)

212 
	#XOR_ASSIGN
 281

	)

213 
	#OR_ASSIGN
 282

	)

214 
	#TYPE_NAME
 283

	)

215 
	#TYPEDEF
 284

	)

216 
	#EXTERN
 285

	)

217 
	#STATIC
 286

	)

218 
	#AUTO
 287

	)

219 
	#REGISTER
 288

	)

220 
	#CHAR
 289

	)

221 
	#SHORT
 290

	)

222 
	#INT
 291

	)

223 
	#LONG
 292

	)

224 
	#SIGNED
 293

	)

225 
	#UNSIGNED
 294

	)

226 
	#FLOAT
 295

	)

227 
	#DOUBLE
 296

	)

228 
	#CONST
 297

	)

229 
	#VOLATILE
 298

	)

230 
	#VOID
 299

	)

231 
	#STRUCT
 300

	)

232 
	#UNION
 301

	)

233 
	#ENUM
 302

	)

234 
	#ELLIPSIS
 303

	)

235 
	#CASE
 304

	)

236 
	#DEFAULT
 305

	)

237 
	#IF
 306

	)

238 
	#ELSE
 307

	)

239 
	#SWITCH
 308

	)

240 
	#WHILE
 309

	)

241 
	#DO
 310

	)

242 
	#FOR
 311

	)

243 
	#GOTO
 312

	)

244 
	#CONTINUE
 313

	)

245 
	#BREAK
 314

	)

246 
	#RETURN
 315

	)

253 #ide
YY_r_CLASS


254 
	#YY_r_CLASS
 
r


	)

257 #ide
YY_r_INHERIT


258 
	#YY_r_INHERIT


	)

261 #ide
YY_r_MEMBERS


262 
	#YY_r_MEMBERS


	)

265 #ide
YY_r_LEX_BODY


266 
	#YY_r_LEX_BODY


	)

269 #ide
YY_r_ERROR_BODY


270 
	#YY_r_ERROR_BODY


	)

273 #ide
YY_r_CONSTRUCTOR_PARAM


274 
	#YY_r_CONSTRUCTOR_PARAM


	)

277 #ide
YY_r_USE_CONST_TOKEN


278 
	#YY_r_USE_CONST_TOKEN
 0

	)

282 #i
YY_r_USE_CONST_TOKEN
 != 0

283 #ide
YY_r_ENUM_TOKEN


284 
	#YY_r_ENUM_TOKEN
 
yy_r_um_tok


	)

288 as
	cYY_r_CLASS
 
	mYY_r_INHERIT


290 
	mpublic
:

291 #i
YY_r_USE_CONST_TOKEN
 != 0

295 cڡ 
IDENTIFIER
;

296 cڡ 
	mCONSTANT
;

297 cڡ 
	mSTRING_LITERAL
;

298 cڡ 
	mSIZEOF
;

299 cڡ 
	mPTR_OP
;

300 cڡ 
	mINC_OP
;

301 cڡ 
	mDEC_OP
;

302 cڡ 
	mLEFT_OP
;

303 cڡ 
	mRIGHT_OP
;

304 cڡ 
	mLE_OP
;

305 cڡ 
	mGE_OP
;

306 cڡ 
	mEQ_OP
;

307 cڡ 
	mNE_OP
;

308 cڡ 
	mAND_OP
;

309 cڡ 
	mOR_OP
;

310 cڡ 
	mMUL_ASSIGN
;

311 cڡ 
	mDIV_ASSIGN
;

312 cڡ 
	mMOD_ASSIGN
;

313 cڡ 
	mADD_ASSIGN
;

314 cڡ 
	mSUB_ASSIGN
;

315 cڡ 
	mLEFT_ASSIGN
;

316 cڡ 
	mRIGHT_ASSIGN
;

317 cڡ 
	mAND_ASSIGN
;

318 cڡ 
	mXOR_ASSIGN
;

319 cڡ 
	mOR_ASSIGN
;

320 cڡ 
	mTYPE_NAME
;

321 cڡ 
	mTYPEDEF
;

322 cڡ 
	mEXTERN
;

323 cڡ 
	mSTATIC
;

324 cڡ 
	mAUTO
;

325 cڡ 
	mREGISTER
;

326 cڡ 
	mCHAR
;

327 cڡ 
	mSHORT
;

328 cڡ 
	mINT
;

329 cڡ 
	mLONG
;

330 cڡ 
	mSIGNED
;

331 cڡ 
	mUNSIGNED
;

332 cڡ 
	mFLOAT
;

333 cڡ 
	mDOUBLE
;

334 cڡ 
	mCONST
;

335 cڡ 
	mVOLATILE
;

336 cڡ 
	mVOID
;

337 cڡ 
	mSTRUCT
;

338 cڡ 
	mUNION
;

339 cڡ 
	mENUM
;

340 cڡ 
	mELLIPSIS
;

341 cڡ 
	mCASE
;

342 cڡ 
	mDEFAULT
;

343 cڡ 
	mIF
;

344 cڡ 
	mELSE
;

345 cڡ 
	mSWITCH
;

346 cڡ 
	mWHILE
;

347 cڡ 
	mDO
;

348 cڡ 
	mFOR
;

349 cڡ 
	mGOTO
;

350 cڡ 
	mCONTINUE
;

351 cڡ 
	mBREAK
;

352 cڡ 
	mRETURN
;

358 
	eYY_r_ENUM_TOKEN
 { 
	mYY_r_NULL_TOKEN
=0

361 ,
	mIDENTIFIER
=258

362 ,
	mCONSTANT
=259

363 ,
	mSTRING_LITERAL
=260

364 ,
	mSIZEOF
=261

365 ,
	mPTR_OP
=262

366 ,
	mINC_OP
=263

367 ,
	mDEC_OP
=264

368 ,
	mLEFT_OP
=265

369 ,
	mRIGHT_OP
=266

370 ,
	mLE_OP
=267

371 ,
	mGE_OP
=268

372 ,
	mEQ_OP
=269

373 ,
	mNE_OP
=270

374 ,
	mAND_OP
=271

375 ,
	mOR_OP
=272

376 ,
	mMUL_ASSIGN
=273

377 ,
	mDIV_ASSIGN
=274

378 ,
	mMOD_ASSIGN
=275

379 ,
	mADD_ASSIGN
=276

380 ,
	mSUB_ASSIGN
=277

381 ,
	mLEFT_ASSIGN
=278

382 ,
	mRIGHT_ASSIGN
=279

383 ,
	mAND_ASSIGN
=280

384 ,
	mXOR_ASSIGN
=281

385 ,
	mOR_ASSIGN
=282

386 ,
	mTYPE_NAME
=283

387 ,
	mTYPEDEF
=284

388 ,
	mEXTERN
=285

389 ,
	mSTATIC
=286

390 ,
	mAUTO
=287

391 ,
	mREGISTER
=288

392 ,
	mCHAR
=289

393 ,
	mSHORT
=290

394 ,
	mINT
=291

395 ,
	mLONG
=292

396 ,
	mSIGNED
=293

397 ,
	mUNSIGNED
=294

398 ,
	mFLOAT
=295

399 ,
	mDOUBLE
=296

400 ,
	mCONST
=297

401 ,
	mVOLATILE
=298

402 ,
	mVOID
=299

403 ,
	mSTRUCT
=300

404 ,
	mUNION
=301

405 ,
	mENUM
=302

406 ,
	mELLIPSIS
=303

407 ,
	mCASE
=304

408 ,
	mDEFAULT
=305

409 ,
	mIF
=306

410 ,
	mELSE
=307

411 ,
	mSWITCH
=308

412 ,
	mWHILE
=309

413 ,
	mDO
=310

414 ,
	mFOR
=311

415 ,
	mGOTO
=312

416 ,
	mCONTINUE
=313

417 ,
	mBREAK
=314

418 ,
	mRETURN
=315

425 
	gpublic
:

426 
YY_r_PARSE
(
YY_r_PARSE_PARAM
);

427 
vtu
 
	$YY_r_ERROR
(*
msg

YY_r_ERROR_BODY
;

428 #ifde
YY_r_PURE


429 #ifde
YY_r_LSP_NEEDED


430 
vtu
 
	$YY_r_LEX
(
YY_r_STYPE
 *
YY_r_LVAL
,
YY_r_LTYPE
 *
YY_r_LLOC

YY_r_LEX_BODY
;

432 
vtu
 
	$YY_r_LEX
(
YY_r_STYPE
 *
YY_r_LVAL

YY_r_LEX_BODY
;

435 
vtu
 
	$YY_r_LEX
(
YY_r_LEX_BODY
;

436 
YY_r_STYPE
 
YY_r_LVAL
;

437 #ifde
YY_r_LSP_NEEDED


438 
YY_r_LTYPE
 
YY_r_LLOC
;

440 
YY_r_NERRS
;

441 
YY_r_CHAR
;

443 #i
YY_r_DEBUG
 != 0

444 
public
:

445 
YY_r_DEBUG_FLAG
;

447 
public
:

448 
	`YY_r_CLASS
(
YY_r_CONSTRUCTOR_PARAM
);

449 
public
:

450 
YY_r_MEMBERS


451 
	}
};

456 #i
YY_r_COMPATIBILITY
 != 0

463 #ide
YYLTYPE


464 
	#YYLTYPE
 
YY_r_LTYPE


	)

466 #ide
YYDEBUG


467 #ifde
YY_r_DEBUG


468 
	#YYDEBUG
 
YY_r_DEBUG


	)

	@cl-standard.y

8 
	#YYDEBUG
 1

	)

9 
yydebug
;

10 
lo
;

11 
cumn
;

13 
	gid
[128];

14 
	gi_tydef
 = 0;

15 
	gi_ru__uni
 = 0;

16 
	gdump
 = 0;

18 
	$ydef
()

20 
i_tydef
 = 1;

21  
i_tydef
;

22 
	}
}

24 
	$t__ru
 ()

26 
yydebug
 = 1;

27 
i_ru__uni
 = 1;

28 
	}
}

29 
	$r__ru
 ()

31 
i_ru__uni
 = 0;

32 
yydebug
 = 0;

33 
	}
}

37 %
tok
 
INCLUDE_FLAG
 
LINE
 
FILENAME


38 %
tok
 
IDENTIFIER
 
CONSTANT
 
STRING_LITERAL
 
SIZEOF


39 %
tok
 
PTR_OP
 
INC_OP
 
DEC_OP
 
LEFT_OP
 
RIGHT_OP
 
LE_OP
 
GE_OP
 
EQ_OP
 
NE_OP


40 %
tok
 
AND_OP
 
OR_OP
 
MUL_ASSIGN
 
DIV_ASSIGN
 
MOD_ASSIGN
 
ADD_ASSIGN


41 %
tok
 
SUB_ASSIGN
 
LEFT_ASSIGN
 
RIGHT_ASSIGN
 
AND_ASSIGN


42 %
tok
 
XOR_ASSIGN
 
OR_ASSIGN
 
TYPE_NAME


44 %
tok
 
TYPEDEF
 
EXTERN
 
STATIC
 
AUTO
 
REGISTER


45 %
tok
 
CHAR
 
SHORT
 
INT
 
LONG
 
SIGNED
 
UNSIGNED
 
FLOAT
 
DOUBLE
 
CONST
 
VOLATILE
 
VOID


46 %
tok
 
STRUCT
 
UNION
 
ENUM
 
ELLIPSIS


48 %
tok
 
CASE
 
DEFAULT
 
IF
 
ELSE
 
SWITCH
 
WHILE
 
DO
 
FOR
 
GOTO
 
CONTINUE
 
BREAK
 
RETURN


50 %
t
 
i_un


51 %% /* 
	$yyr
 */ 
	`yyx
()

53 
imy_exessi


54 : 
IDENTIFIER


55 | 
CONSTANT


56 | 
STRING_LITERAL


57 | '(' 
exessi
 ')'

60 
ross_ude_hd_fe


61 : 
INCLUDE_FLAG


67 
pofix_exessi


68 : 
imy_exessi


69 | 
pofix_exessi
 '[' 
exessi
 ']'

70 | 
pofix_exessi
 '(' ')'

71 | 
pofix_exessi
 '(' 
gumt_exessi_li
 ')'

72 | 
pofix_exessi
 '.' 
IDENTIFIER


73 | 
pofix_exessi
 
PTR_OP
 
IDENTIFIER


74 | 
pofix_exessi
 
INC_OP


75 | 
pofix_exessi
 
DEC_OP


78 
gumt_exessi_li


79 : 
assignmt_exessi


80 | 
gumt_exessi_li
 ',' 
assignmt_exessi


83 
ury_exessi


84 : 
pofix_exessi


85 | 
INC_OP
 
ury_exessi


86 | 
DEC_OP
 
ury_exessi


87 | 
ury_ݔ
 
_exessi


88 | 
SIZEOF
 
ury_exessi


89 | 
SIZEOF
 '(' 
ty_me
 ')'

92 
ury_ݔ


101 
_exessi


102 : 
ury_exessi


103 | '(' 
ty_me
 ')' 
_exessi


106 
muɝlitive_exessi


107 : 
_exessi


108 | 
muɝlitive_exessi
 '*' 
_exessi


109 | 
muɝlitive_exessi
 '/' 
_exessi


110 | 
muɝlitive_exessi
 '%' 
_exessi


113 
addive_exessi


114 : 
muɝlitive_exessi


115 | 
addive_exessi
 '+' 
muɝlitive_exessi


116 | 
addive_exessi
 '-' 
muɝlitive_exessi


119 
shi_exessi


120 : 
addive_exessi


121 | 
shi_exessi
 
LEFT_OP
 
addive_exessi


122 | 
shi_exessi
 
RIGHT_OP
 
addive_exessi


125 
tiڮ_exessi


126 : 
shi_exessi


127 | 
tiڮ_exessi
 '<' 
shi_exessi


128 | 
tiڮ_exessi
 '>' 
shi_exessi


129 | 
tiڮ_exessi
 
LE_OP
 
shi_exessi


130 | 
tiڮ_exessi
 
GE_OP
 
shi_exessi


133 
equy_exessi


134 : 
tiڮ_exessi


135 | 
equy_exessi
 
EQ_OP
 
tiڮ_exessi


136 | 
equy_exessi
 
NE_OP
 
tiڮ_exessi


139 
d_exessi


140 : 
equy_exessi


141 | 
d_exessi
 '&' 
equy_exessi


144 
exusive__exessi


145 : 
d_exessi


146 | 
exusive__exessi
 '^' 
d_exessi


149 
usive__exessi


150 : 
exusive__exessi


151 | 
usive__exessi
 '|' 
exusive__exessi


154 
logil_d_exessi


155 : 
usive__exessi


156 | 
logil_d_exessi
 
AND_OP
 
usive__exessi


159 
logil__exessi


160 : 
logil_d_exessi


161 | 
logil__exessi
 
OR_OP
 
logil_d_exessi


164 
cdiڮ_exessi


165 : 
logil__exessi


166 | 
logil__exessi
 '?' 
exessi
 ':' 
cdiڮ_exessi


169 
assignmt_exessi


170 : 
cdiڮ_exessi


171 | 
ury_exessi
 
assignmt_ݔ
 
assignmt_exessi


174 
assignmt_ݔ


176 | 
MUL_ASSIGN


177 | 
DIV_ASSIGN


178 | 
MOD_ASSIGN


179 | 
ADD_ASSIGN


180 | 
SUB_ASSIGN


181 | 
LEFT_ASSIGN


182 | 
RIGHT_ASSIGN


183 | 
AND_ASSIGN


184 | 
XOR_ASSIGN


185 | 
OR_ASSIGN


188 
exessi


189 : 
assignmt_exessi


190 | 
exessi
 ',' 
assignmt_exessi


193 
cڡt_exessi


194 : 
cdiڮ_exessi


197 
dei


198 : 
dei_ecifrs
 ';'

199 | 
dei_ecifrs
 
_de_li
 ';' { \

200 i(
i_tydef
) {

201 
	`tf
 ("[[%s]]", 
id
); 
i_tydef
=0;

202 
	`__tydef
 (
id
, 
lo
, 
cumn
);

207 
dei_ecifrs


208 : 
age_ass_ecifr


209 | 
age_ass_ecifr
 
dei_ecifrs


210 | 
ty_ecifr


211 | 
ty_ecifr
 
dei_ecifrs


212 | 
ty_quifr


213 | 
ty_quifr
 
dei_ecifrs


216 
_de_li


217 : 
_de


218 | 
_de_li
 ',' 
_de


221 
_de


222 : 
de
 { 
	`tf
 ("(D1:%s:%d)", 
id
,
i_tydef
); }

223 | 
de
 { 
	`tf
 ("(D2)"); } '=' 
liz


226 
age_ass_ecifr


227 : 
TYPEDEF
 { 
	`ydef
(); }

228 | 
EXTERN


229 | 
STATIC


230 | 
AUTO


231 | 
REGISTER


234 
ty_ecifr


235 : 
VOID


236 | 
CHAR


237 | 
SHORT


238 | 
INT


239 | 
LONG


240 | 
FLOAT


241 | 
DOUBLE


242 | 
SIGNED


243 | 
UNSIGNED


244 | 
ru__uni_ecifr


245 | 
um_ecifr


246 | 
TYPE_NAME


249 
ru__uni_ecifr


250 : 
ru__uni
 
IDENTIFIER
 '{' 
ru_dei_li
 '}' { 
	`r__ru
(); }

251 | 
ru__uni
 '{' 
ru_dei_li
 '}' { 
	`r__ru
(); }

252 | 
ru__uni
 
IDENTIFIER
 { 
	`r__ru
(); }

255 
ru__uni


256 : 
STRUCT
 { 
	`t__ru
(); }

257 | 
UNION
 { 
	`t__ru
(); }

260 
ru_dei_li


261 : 
ru_dei


262 | 
ru_dei_li
 
ru_dei


265 
ru_dei


266 : 
ecifr_quifr_li
 
ru_de_li
 ';'

269 
ecifr_quifr_li


270 : 
ty_ecifr
 
ecifr_quifr_li


271 | 
ty_ecifr


272 | 
ty_quifr
 
ecifr_quifr_li


273 | 
ty_quifr


276 
ru_de_li


277 : 
ru_de


278 | 
ru_de_li
 ',' 
ru_de


281 
ru_de


282 : 
de


283 | ':' 
cڡt_exessi


284 | 
de
 ':' 
cڡt_exessi


287 
um_ecifr


288 : 
ENUM
 '{' 
um_li
 '}'

289 | 
ENUM
 
IDENTIFIER
 '{' 
um_li
 '}'

290 | 
ENUM
 
IDENTIFIER


293 
um_li


294 : 
um


295 | 
um_li
 ',' 
um


298 
um


299 : 
IDENTIFIER


300 | 
IDENTIFIER
 '=' 
cڡt_exessi


303 
ty_quifr


304 : 
CONST


305 | 
VOLATILE


308 
de


309 : 
por
 
de_de


310 | 
de_de


316 
de_de


317 : 
IDENTIFIER


318 | '(' 
de
 ')'

319 | 
de_de
 '[' 
cڡt_exessi
 ']'

320 | 
de_de
 '[' ']'

321 | 
de_de
 '(' 
m_ty_li
 ')'

322 | 
de_de
 '(' 
idtifr_li
 ')'

323 | 
de_de
 '(' ')'

326 
por


328 | '*' 
ty_quifr_li


329 | '*' 
por


330 | '*' 
ty_quifr_li
 
por


333 
ty_quifr_li


334 : 
ty_quifr


335 | 
ty_quifr_li
 
ty_quifr


339 
m_ty_li


340 : 
m_li


341 | 
m_li
 ',' 
ELLIPSIS


344 
m_li


345 : 
m_dei


346 | 
m_li
 ',' 
m_dei


349 
m_dei


350 : 
dei_ecifrs
 
de


351 | 
dei_ecifrs
 
ab_de


352 | 
dei_ecifrs


355 
idtifr_li


356 : 
IDENTIFIER


357 | 
idtifr_li
 ',' 
IDENTIFIER


360 
ty_me


361 : 
ecifr_quifr_li


362 | 
ecifr_quifr_li
 
ab_de


365 
ab_de


366 : 
por


367 | 
de_ab_de


368 | 
por
 
de_ab_de


371 
de_ab_de


372 : '(' 
ab_de
 ')'

374 | '[' 
cڡt_exessi
 ']'

375 | 
de_ab_de
 '[' ']'

376 | 
de_ab_de
 '[' 
cڡt_exessi
 ']'

378 | '(' 
m_ty_li
 ')'

379 | 
de_ab_de
 '(' ')'

380 | 
de_ab_de
 '(' 
m_ty_li
 ')'

383 
liz


384 : 
assignmt_exessi


385 | '{' 
liz_li
 '}'

386 | '{' 
liz_li
 ',' '}'

389 
liz_li


390 : 
liz


391 | 
liz_li
 ',' 
liz


394 
emt


395 : 
bed_emt


396 | 
compound_emt


397 | 
exessi_emt


398 | 
i_emt


399 | 
i_emt


400 | 
jump_emt


403 
bed_emt


404 : 
IDENTIFIER
 ':' 
emt


405 | 
CASE
 
cڡt_exessi
 ':' 
emt


406 | 
DEFAULT
 ':' 
emt


409 
compound_emt


411 | '{' 
emt_li
 '}'

412 | '{' 
dei_li
 '}'

413 | '{' 
dei_li
 
emt_li
 '}'

416 
dei_li


417 : 
dei


418 | 
dei_li
 
dei


421 
emt_li


422 : 
emt


423 | 
emt_li
 
emt


426 
exessi_emt


428 | 
exessi
 ';'

431 
i_emt


432 : 
IF
 '(' 
exessi
 ')' 
emt


433 | 
IF
 '(' 
exessi
 ')' 
emt
 
ELSE
 statement

434 | 
SWITCH
 '(' 
exessi
 ')' 
emt


437 
i_emt


438 : 
WHILE
 '(' 
exessi
 ')' 
emt


439 | 
DO
 
emt
 
WHILE
 '(' 
exessi
 ')' ';'

440 | 
FOR
 '(' 
exessi_emt
xessi_em')' 
emt


441 | 
FOR
 '(' 
exessi_emt
xessi_em
exessi
 ')' 
emt


444 
jump_emt


445 : 
GOTO
 
IDENTIFIER
 ';'

446 | 
CONTINUE
 ';'

447 | 
BREAK
 ';'

448 | 
RETURN
 ';'

449 | 
RETURN
 
exessi
 ';'

452 
i_un


453 : 
ex_dei


454 | 
i_un
 
ex_dei


455 | 
ross_ude_hd_fe


456 | 
i_un
 
ross_ude_hd_fe


459 
ex_dei


460 : 
funi_defi


461 | 
dei


464 
funi_defi


465 : 
dei_ecifrs
 
de
 
dei_li
 
compound_emt


466 | 
dei_ecifrs
 
de
 
compound_emt


467 | 
de
 
dei_li
 
compound_emt


468 | 
de
 
compound_emt


471 
	}
%%

472 
	~<dio.h
>

474 
cumn
;

476 
	$yyr
(
s
)

477 *
s
;

479 
	`fush
(
dout
);

480 
	`tf
("\n%*s\n%*s\n", 
cumn
, "^", cumn, 
s
);

481 
	}
}

483 
	$ma
 ()

485 
yydebug
 = 0;

486 
	`yyr
();

487 
	}
}

	@hello.c

1 
	~<dio.h
>

2 
	~<rg.h
>

8 
	sudt
 {

9 
	mage
;

10 
	mme
[16];

11 } 
	tudt
;

13 
	tmyt
;

15 
	$ma
 (
gc
, ** 
gv
)

17 
ock
;

18 
ii
 = 0;

19 cڡ 
iii
;

20 
kk
;

22 
	sock
 {

23 
i
;

24 
c
;

25 }
ock
;

26 
age
 = 0;

28 
	`tf
 ("Hello world\n");

31 
	}
}

	@symtab.c

11 
	~<dio.h
>

12 
	~<dlib.h
>

13 
	~<rg.h
>

14 
	~"symb.h
"

17 
	#SIZE
 211

	)

22 
	#SHIFT
 4

	)

26 
	$hash
(*
key
)

28 
mp
 = 0;

29 
i
 = 0;

30 
key
[
i
] != '\0') {

31 
mp
 = (em<< 
SHIFT
+ 
key
[
i
]% 
SIZE
;

32 ++
i
;

34  
mp
;

35 
	}
}

42 
	sLeLiRec
 {

43 
	mlo
;

44 
LeLiRec
 *
	mxt
;

45 } *
	tLeLi
;

52 
	sBuckLiRec
 {

53 
	mme
[126];

54 
LeLi
 
	mles
;

55 
	mmemloc
;

56 
BuckLiRec
 *
	mxt
;

57 
	mfunc
[126];

58 
	mdty
;

59 } *
	tBuckLi
;

62 
	gved_func_me
 [1024];

65 
BuckLi
 
	ghashTab
[
SIZE
];

66 
BuckLi
 
	gtydefNameTab
[
SIZE
];

74 
	$__id
 (*
me
, 
lo
, 
loc
)

76 
h
 = 
	`hash
(
me
);

77 
BuckLi
 
l
 = 
hashTab
[
h
];

79 (
l
 !
NULL
)

81 (
	`rcmp
(
me
, 
l
->name) != 0) ||

82 (
	`rcmp
(
ved_func_me
, 
l
->
func
) != 0)

86 
l
 =->
xt
;

88 i(
l
 =
NULL
) {

89 
l
 = (
BuckLi

	`mloc
((
BuckLiRec
));

90 i(!
l
) {

91 
	`tf
 ("st_insert: malloc failed");

94 
l
->
me
 =ame;

96 
	`rtf
 (
l
->
me
, "%s",ame);

98 
l
->
les
 = (
LeLi

	`mloc
((
LeLiRec
));

99 i(!(
l
->
les
)) {

100 
	`tf
 ("st_insert: malloc failed,->lines");

102 
l
->
les
->
lo
 =ineno;

103 
l
->
memloc
 = 
loc
;

104 
l
->
les
->
xt
 = 
NULL
;

105 
l
->
dty
 = 1;

106 
	`rtf
 (
l
->
func
, "%s", 
ved_func_me
);

107 
l
->
xt
 = 
hashTab
[
h
];

108 
hashTab
[
h
] = 
l
;

110 
LeLi
 
t
 = 
l
->
les
;

111 
t
->
xt
 !
NULL
)

112 
t
 =->
xt
;

113 
t
->
xt
 = (
LeLi

	`mloc
((
LeLiRec
));

114 i(!(
t
->
xt
)) {

115 
	`tf
 ("st_insert: malloc failed,->next");

117 
t
->
xt
->
lo
 =ineno;

118 
t
->
xt
->x
NULL
;

120 
	}
}

124 
	$__tydef
 (*
me
, 
lo
, 
loc
)

126 
h
 = 
	`hash
(
me
);

127 
BuckLi
 
l
 = 
tydefNameTab
[
h
];

129 (
l
 !
NULL
)

131 (
	`rcmp
(
me
, 
l
->name) != 0) ||

132 (
	`rcmp
(
ved_func_me
, 
l
->
func
) != 0)

136 
l
 =->
xt
;

138 i(
l
 =
NULL
) {

139 
l
 = (
BuckLi

	`mloc
((
BuckLiRec
));

140 i(!(
l
)) {

141 
	`tf
 ("st_insert_typedef: malloc failed,");

144 
l
->
me
 =ame;

146 
	`rtf
 (
l
->
me
, "%s",ame);

148 
l
->
les
 = (
LeLi

	`mloc
((
LeLiRec
));

149 i(!(
l
->
les
)) {

150 
	`tf
 ("st_insert_typedef: malloc failed,->lines");

152 
l
->
les
->
lo
 =ineno;

153 
l
->
memloc
 = 
loc
;

154 
l
->
les
->
xt
 = 
NULL
;

155 
l
->
dty
 = 1;

156 
	`rtf
 (
l
->
func
, "%s", 
ved_func_me
);

157 
l
->
xt
 = 
tydefNameTab
[
h
];

158 
tydefNameTab
[
h
] = 
l
;

160 
LeLi
 
t
 = 
l
->
les
;

161 
t
->
xt
 !
NULL
)

162 
t
 =->
xt
;

163 
t
->
xt
 = (
LeLi

	`mloc
((
LeLiRec
));

164 i(!(
l
->
xt
)) {

165 
	`tf
 ("st_insert_typedef: malloc failed,->next");

167 
t
->
xt
->
lo
 =ineno;

168 
t
->
xt
->x
NULL
;

170 
	}
}

181 
	gBuckLi


183 
	$_lookup
(*
me
)

185 
h
 = 
	`hash
(
me
);

186 
BuckLi
 
l
 = 
hashTab
[
h
];

188 (
l
 !
NULL
)

189 && ((
	`rcmp
(
me
, 
l
->name) != 0) ||

190 ((
	`rcmp
(
ved_func_me
, 
l
->
func
) != 0))))

192 
l
 =->
xt
;

194 i(
l
 =
NULL
)

198  
NULL
;

202  
l
->
memloc
;

204  
l
;

206 
	}
}

209 
BuckLi


210 
	$_lookup_tydef
(*
me
)

212 
h
 = 
	`hash
(
me
);

213 
BuckLi
 
l
 = 
tydefNameTab
[
h
];

215 (
l
 !
NULL
)

216 && ((
	`rcmp
(
me
, 
l
->name) != 0)))

218 
l
 =->
xt
;

220 i(
l
 =
NULL
)

221  
NULL
;

223  
l
;

224 
	}
}

234 
	$tSymTab
(
FILE
 * 
lig
)

236 
i
;

237 
	`rtf
(
lig
, "Variable Name Location Domain Line Numbers\n");

238 
	`rtf
(
lig
, "-------------- -------- -------------- ------------\n");

239 
i
 = 0; i < 
SIZE
; ++i) {

240 i(
hashTab
[
i
] !
NULL
) {

241 
BuckLi
 
l
 = 
hashTab
[
i
];

242 
l
 !
NULL
) {

243 
LeLi
 
t
 = 
l
->
les
;

244 
	`rtf
(
lig
, "%+14", 
l
->
me
);

245 
	`rtf
(
lig
, "%+8d ", 
l
->
memloc
);

246 
	`rtf
(
lig
, "%+14", 
l
->
func
);

247 
t
 !
NULL
) {

248 
	`rtf
(
lig
, "%+12d ", 
t
->
lo
);

249 
t
 =->
xt
;

251 
	`rtf
(
lig
, "\n");

252 
l
 =->
xt
;

256 
	}
}

261 
	$tTydefTab
(
FILE
 * 
lig
)

263 
i
;

264 
	`rtf
(
lig
, "Typedef Name Location Domain Line Numbers\n");

265 
	`rtf
(
lig
, "-------------- -------- -------------- ------------\n");

266 
i
 = 0; i < 
SIZE
; ++i) {

267 i(
tydefNameTab
[
i
] !
NULL
) {

268 
BuckLi
 
l
 = 
tydefNameTab
[
i
];

269 
l
 !
NULL
) {

270 
LeLi
 
t
 = 
l
->
les
;

271 
	`rtf
(
lig
, "%+14", 
l
->
me
);

272 
	`rtf
(
lig
, "%+8d ", 
l
->
memloc
);

273 
	`rtf
(
lig
, "%+14", 
l
->
func
);

274 
t
 !
NULL
) {

275 
	`rtf
(
lig
, "%+12d ", 
t
->
lo
);

276 
t
 =->
xt
;

278 
	`rtf
(
lig
, "\n");

279 
l
 =->
xt
;

283 
	}
}

286 
	$a_b
 ()

288 
i
 = 0;

289 
BuckLi
 
b1
 = 
NULL
, 
b2
 = NULL;

290 
LeLi
 
l1
 = 
NULL
, 
l2
 = NULL;

292 
i
 = 0; i < 
SIZE
; i ++) {

293 
b1
 = 
hashTab
[
i
];

294 
b1
 !
NULL
) {

295 i(
NULL
 !
b1
->
xt
)

297 
b2
 = 
b1
->
xt
;

299 
b2
 = 
NULL
;

305 
l1
 = 
b1
->
les
;

308 i(
NULL
 =
l1
) {

309 
buck
;

311 i(
NULL
 !
l1
->
xt
)

313 
l2
 = 
l1
->
xt
;

315 
l2
 = 
NULL
;

317 
	`
 (
l1
);

318 
l1
 = 
l2
;

321 
buck
:

322 
	`
 (
b1
);

323 
b1
 = 
b2
;

327 
	}
}

331 
	$a_tydef_b
 ()

333 
i
 = 0;

334 
BuckLi
 
b1
 = 
NULL
, 
b2
 = NULL;

335 
LeLi
 
l1
 = 
NULL
, 
l2
 = NULL;

337 
i
 = 0; i < 
SIZE
; i ++) {

338 
b1
 = 
tydefNameTab
[
i
];

339 
b1
 !
NULL
) {

340 i(
NULL
 !
b1
->
xt
)

342 
b2
 = 
b1
->
xt
;

344 
b2
 = 
NULL
;

350 
l1
 = 
b1
->
les
;

353 i(
NULL
 =
l1
) {

354 
buck
;

356 i(
NULL
 !
l1
->
xt
)

358 
l2
 = 
l1
->
xt
;

360 
l2
 = 
NULL
;

362 
	`
 (
l1
);

363 
l1
 = 
l2
;

366 
buck
:

367 
	`
 (
b1
);

368 
b1
 = 
b2
;

372 
	}
}

377 
	$t_
 ()

379 
FILE
 * 

;

380 

 = 
	`fݒ
 ("st.sym", "w+");

381 
	`tSymTab
 (

);

382 
	`rtf
 (

, "\n");

383 
	`tTydefTab
 (

);

384 
	`fo
 (

);

385 
	}
}

	@symtab.h

9 #ide
_SYMTAB_H_


10 
	#_SYMTAB_H_


	)

12 
	~"dio.h
"

19 
__id
* 
me
, 
lo
, 
loc
 );

20 
__tydef
(*
me
, 
lo
, 
loc
);

30 
tSymTab
(
FILE
 * 
lig
);

31 
tTydefTab
(
FILE
 * 
lig
);

32 
a_b
 ();

33 
a_tydef_b
 ();

34 
t_
 ();

36 
	sLeLiRec
 {

37 
	mlo
;

38 
LeLiRec
 *
	mxt
;

39 } *
	tLeLi
;

40 
	sBuckLiRec
 {

41 
	mme
[126];

42 
LeLi
 
	mles
;

43 
	mmemloc
;

44 
BuckLiRec
 *
	mxt
;

45 
	mfunc
[126];

46 
	mdty
;

47 } *
	tBuckLi
;

49 
BuckLi
 
_lookup
 ( * 
me
 );

50 
BuckLi
 
_lookup_tydef
(*
me
);

52 
_um
;

	@test.c

1 #"
klsjdkjlksdjf
"

2 
	gi
 = 0;

3 
	tmyage
;

4 
	gj
 = 0;

	@y.tab.h

1 #ide
YY_r_h_uded


2 
	#YY_r_h_uded


	)

7 #ifde
c_ulus


8 #ide
__lulus


9 
	#__lulus


	)

18 #ide
YY_r_COMPATIBILITY


19 #ide
YY_USE_CLASS


20 
	#YY_r_COMPATIBILITY
 1

	)

22 
	#YY_r_COMPATIBILITY
 0

	)

26 #i
YY_r_COMPATIBILITY
 != 0

28 #ifde
YYLTYPE


29 #ide
YY_r_LTYPE


30 
	#YY_r_LTYPE
 
YYLTYPE


	)

36 #ide
YY_r_STYPE


37 
	#YY_r_STYPE
 
YYSTYPE


	)

42 #ifde
YYDEBUG


43 #ide
YY_r_DEBUG


44 
	#YY_r_DEBUG
 
YYDEBUG


	)

50 #ide
YY_r_USE_GOTO


51 
	#YY_r_USE_GOTO
 1

	)

56 #ide
YY_r_USE_GOTO


57 
	#YY_r_USE_GOTO
 0

	)

60 #ide
YY_r_PURE


70 #ide
YY_USE_CLASS


71 #ide
YYSTYPE


72 
	#YYSTYPE
 

	)

73 
	#YYSTYPE_IS_TRIVIAL
 1

	)

80 #ide
YY_r_DEBUG


88 #ide
YY_r_LSP_NEEDED


97 #ifde
YY_r_LSP_NEEDED


98 #ide
YY_r_LTYPE


99 #ide
BISON_YYLTYPE_ISDECLARED


100 
	#BISON_YYLTYPE_ISDECLARED


	)

102 
	syyy


104 
	mtimeamp
;

105 
	mf_le
;

106 
	mf_cumn
;

107 
	mϡ_le
;

108 
	mϡ_cumn
;

109 *
	mxt
;

111 
	tyyy
;

114 
	#YY_r_LTYPE
 
yyy


	)

119 #ide
YY_r_STYPE


120 
	#YY_r_STYPE
 

	)

124 #ide
YY_r_PARSE


125 
	#YY_r_PARSE
 
yyr


	)

128 #ide
YY_r_LEX


129 
	#YY_r_LEX
 
yyx


	)

132 #ide
YY_r_LVAL


133 
	#YY_r_LVAL
 
yylv


	)

136 #ide
YY_r_LLOC


137 
	#YY_r_LLOC
 
yyoc


	)

140 #ide
YY_r_CHAR


141 
	#YY_r_CHAR
 
yych


	)

144 #ide
YY_r_NERRS


145 
	#YY_r_NERRS
 
yyüs


	)

148 #ide
YY_r_DEBUG_FLAG


149 
	#YY_r_DEBUG_FLAG
 
yydebug


	)

152 #ide
YY_r_ERROR


153 
	#YY_r_ERROR
 
yyr


	)

156 #ide
YY_r_PARSE_PARAM


157 #ide
__STDC__


158 #ide
__lulus


159 #ide
YY_USE_CLASS


160 
	#YY_r_PARSE_PARAM


	)

161 #ide
YY_r_PARSE_PARAM_DEF


162 
	#YY_r_PARSE_PARAM_DEF


	)

167 #ide
YY_r_PARSE_PARAM


168 
	#YY_r_PARSE_PARAM
 

	)

173 #ide
YY_USE_CLASS


175 #ide
YY_r_PURE


176 #ide
yylv


177 
YY_r_STYPE
 
YY_r_LVAL
;

179 #i
yylv
 !
YY_r_LVAL


180 
YY_r_STYPE
 
YY_r_LVAL
;

189 
	#INCLUDE_FLAG
 258

	)

190 
	#LINE
 259

	)

191 
	#FILENAME
 260

	)

192 
	#IDENTIFIER
 261

	)

193 
	#CONSTANT
 262

	)

194 
	#STRING_LITERAL
 263

	)

195 
	#SIZEOF
 264

	)

196 
	#PTR_OP
 265

	)

197 
	#INC_OP
 266

	)

198 
	#DEC_OP
 267

	)

199 
	#LEFT_OP
 268

	)

200 
	#RIGHT_OP
 269

	)

201 
	#LE_OP
 270

	)

202 
	#GE_OP
 271

	)

203 
	#EQ_OP
 272

	)

204 
	#NE_OP
 273

	)

205 
	#AND_OP
 274

	)

206 
	#OR_OP
 275

	)

207 
	#MUL_ASSIGN
 276

	)

208 
	#DIV_ASSIGN
 277

	)

209 
	#MOD_ASSIGN
 278

	)

210 
	#ADD_ASSIGN
 279

	)

211 
	#SUB_ASSIGN
 280

	)

212 
	#LEFT_ASSIGN
 281

	)

213 
	#RIGHT_ASSIGN
 282

	)

214 
	#AND_ASSIGN
 283

	)

215 
	#XOR_ASSIGN
 284

	)

216 
	#OR_ASSIGN
 285

	)

217 
	#TYPE_NAME
 286

	)

218 
	#TYPEDEF
 287

	)

219 
	#EXTERN
 288

	)

220 
	#STATIC
 289

	)

221 
	#AUTO
 290

	)

222 
	#REGISTER
 291

	)

223 
	#CHAR
 292

	)

224 
	#SHORT
 293

	)

225 
	#INT
 294

	)

226 
	#LONG
 295

	)

227 
	#SIGNED
 296

	)

228 
	#UNSIGNED
 297

	)

229 
	#FLOAT
 298

	)

230 
	#DOUBLE
 299

	)

231 
	#CONST
 300

	)

232 
	#VOLATILE
 301

	)

233 
	#VOID
 302

	)

234 
	#STRUCT
 303

	)

235 
	#UNION
 304

	)

236 
	#ENUM
 305

	)

237 
	#ELLIPSIS
 306

	)

238 
	#CASE
 307

	)

239 
	#DEFAULT
 308

	)

240 
	#IF
 309

	)

241 
	#ELSE
 310

	)

242 
	#SWITCH
 311

	)

243 
	#WHILE
 312

	)

244 
	#DO
 313

	)

245 
	#FOR
 314

	)

246 
	#GOTO
 315

	)

247 
	#CONTINUE
 316

	)

248 
	#BREAK
 317

	)

249 
	#RETURN
 318

	)

256 #ide
YY_r_CLASS


257 
	#YY_r_CLASS
 
r


	)

260 #ide
YY_r_INHERIT


261 
	#YY_r_INHERIT


	)

264 #ide
YY_r_MEMBERS


265 
	#YY_r_MEMBERS


	)

268 #ide
YY_r_LEX_BODY


269 
	#YY_r_LEX_BODY


	)

272 #ide
YY_r_ERROR_BODY


273 
	#YY_r_ERROR_BODY


	)

276 #ide
YY_r_CONSTRUCTOR_PARAM


277 
	#YY_r_CONSTRUCTOR_PARAM


	)

280 #ide
YY_r_USE_CONST_TOKEN


281 
	#YY_r_USE_CONST_TOKEN
 0

	)

285 #i
YY_r_USE_CONST_TOKEN
 != 0

286 #ide
YY_r_ENUM_TOKEN


287 
	#YY_r_ENUM_TOKEN
 
yy_r_um_tok


	)

291 as
	cYY_r_CLASS
 
	mYY_r_INHERIT


293 
	mpublic
:

294 #i
YY_r_USE_CONST_TOKEN
 != 0

298 cڡ 
INCLUDE_FLAG
;

299 cڡ 
	mLINE
;

300 cڡ 
	mFILENAME
;

301 cڡ 
	mIDENTIFIER
;

302 cڡ 
	mCONSTANT
;

303 cڡ 
	mSTRING_LITERAL
;

304 cڡ 
	mSIZEOF
;

305 cڡ 
	mPTR_OP
;

306 cڡ 
	mINC_OP
;

307 cڡ 
	mDEC_OP
;

308 cڡ 
	mLEFT_OP
;

309 cڡ 
	mRIGHT_OP
;

310 cڡ 
	mLE_OP
;

311 cڡ 
	mGE_OP
;

312 cڡ 
	mEQ_OP
;

313 cڡ 
	mNE_OP
;

314 cڡ 
	mAND_OP
;

315 cڡ 
	mOR_OP
;

316 cڡ 
	mMUL_ASSIGN
;

317 cڡ 
	mDIV_ASSIGN
;

318 cڡ 
	mMOD_ASSIGN
;

319 cڡ 
	mADD_ASSIGN
;

320 cڡ 
	mSUB_ASSIGN
;

321 cڡ 
	mLEFT_ASSIGN
;

322 cڡ 
	mRIGHT_ASSIGN
;

323 cڡ 
	mAND_ASSIGN
;

324 cڡ 
	mXOR_ASSIGN
;

325 cڡ 
	mOR_ASSIGN
;

326 cڡ 
	mTYPE_NAME
;

327 cڡ 
	mTYPEDEF
;

328 cڡ 
	mEXTERN
;

329 cڡ 
	mSTATIC
;

330 cڡ 
	mAUTO
;

331 cڡ 
	mREGISTER
;

332 cڡ 
	mCHAR
;

333 cڡ 
	mSHORT
;

334 cڡ 
	mINT
;

335 cڡ 
	mLONG
;

336 cڡ 
	mSIGNED
;

337 cڡ 
	mUNSIGNED
;

338 cڡ 
	mFLOAT
;

339 cڡ 
	mDOUBLE
;

340 cڡ 
	mCONST
;

341 cڡ 
	mVOLATILE
;

342 cڡ 
	mVOID
;

343 cڡ 
	mSTRUCT
;

344 cڡ 
	mUNION
;

345 cڡ 
	mENUM
;

346 cڡ 
	mELLIPSIS
;

347 cڡ 
	mCASE
;

348 cڡ 
	mDEFAULT
;

349 cڡ 
	mIF
;

350 cڡ 
	mELSE
;

351 cڡ 
	mSWITCH
;

352 cڡ 
	mWHILE
;

353 cڡ 
	mDO
;

354 cڡ 
	mFOR
;

355 cڡ 
	mGOTO
;

356 cڡ 
	mCONTINUE
;

357 cڡ 
	mBREAK
;

358 cڡ 
	mRETURN
;

364 
	eYY_r_ENUM_TOKEN
 { 
	mYY_r_NULL_TOKEN
=0

367 ,
	mINCLUDE_FLAG
=258

368 ,
	mLINE
=259

369 ,
	mFILENAME
=260

370 ,
	mIDENTIFIER
=261

371 ,
	mCONSTANT
=262

372 ,
	mSTRING_LITERAL
=263

373 ,
	mSIZEOF
=264

374 ,
	mPTR_OP
=265

375 ,
	mINC_OP
=266

376 ,
	mDEC_OP
=267

377 ,
	mLEFT_OP
=268

378 ,
	mRIGHT_OP
=269

379 ,
	mLE_OP
=270

380 ,
	mGE_OP
=271

381 ,
	mEQ_OP
=272

382 ,
	mNE_OP
=273

383 ,
	mAND_OP
=274

384 ,
	mOR_OP
=275

385 ,
	mMUL_ASSIGN
=276

386 ,
	mDIV_ASSIGN
=277

387 ,
	mMOD_ASSIGN
=278

388 ,
	mADD_ASSIGN
=279

389 ,
	mSUB_ASSIGN
=280

390 ,
	mLEFT_ASSIGN
=281

391 ,
	mRIGHT_ASSIGN
=282

392 ,
	mAND_ASSIGN
=283

393 ,
	mXOR_ASSIGN
=284

394 ,
	mOR_ASSIGN
=285

395 ,
	mTYPE_NAME
=286

396 ,
	mTYPEDEF
=287

397 ,
	mEXTERN
=288

398 ,
	mSTATIC
=289

399 ,
	mAUTO
=290

400 ,
	mREGISTER
=291

401 ,
	mCHAR
=292

402 ,
	mSHORT
=293

403 ,
	mINT
=294

404 ,
	mLONG
=295

405 ,
	mSIGNED
=296

406 ,
	mUNSIGNED
=297

407 ,
	mFLOAT
=298

408 ,
	mDOUBLE
=299

409 ,
	mCONST
=300

410 ,
	mVOLATILE
=301

411 ,
	mVOID
=302

412 ,
	mSTRUCT
=303

413 ,
	mUNION
=304

414 ,
	mENUM
=305

415 ,
	mELLIPSIS
=306

416 ,
	mCASE
=307

417 ,
	mDEFAULT
=308

418 ,
	mIF
=309

419 ,
	mELSE
=310

420 ,
	mSWITCH
=311

421 ,
	mWHILE
=312

422 ,
	mDO
=313

423 ,
	mFOR
=314

424 ,
	mGOTO
=315

425 ,
	mCONTINUE
=316

426 ,
	mBREAK
=317

427 ,
	mRETURN
=318

434 
	gpublic
:

435 
YY_r_PARSE
(
YY_r_PARSE_PARAM
);

436 
vtu
 
	$YY_r_ERROR
(*
msg

YY_r_ERROR_BODY
;

437 #ifde
YY_r_PURE


438 #ifde
YY_r_LSP_NEEDED


439 
vtu
 
	$YY_r_LEX
(
YY_r_STYPE
 *
YY_r_LVAL
,
YY_r_LTYPE
 *
YY_r_LLOC

YY_r_LEX_BODY
;

441 
vtu
 
	$YY_r_LEX
(
YY_r_STYPE
 *
YY_r_LVAL

YY_r_LEX_BODY
;

444 
vtu
 
	$YY_r_LEX
(
YY_r_LEX_BODY
;

445 
YY_r_STYPE
 
YY_r_LVAL
;

446 #ifde
YY_r_LSP_NEEDED


447 
YY_r_LTYPE
 
YY_r_LLOC
;

449 
YY_r_NERRS
;

450 
YY_r_CHAR
;

452 #i
YY_r_DEBUG
 != 0

453 
public
:

454 
YY_r_DEBUG_FLAG
;

456 
public
:

457 
	`YY_r_CLASS
(
YY_r_CONSTRUCTOR_PARAM
);

458 
public
:

459 
YY_r_MEMBERS


460 
	}
};

465 #i
YY_r_COMPATIBILITY
 != 0

472 #ide
YYLTYPE


473 
	#YYLTYPE
 
YY_r_LTYPE


	)

475 #ide
YYDEBUG


476 #ifde
YY_r_DEBUG


477 
	#YYDEBUG
 
YY_r_DEBUG


	)

	@
1
.
0
9
104
c-standard.l
cl-standard.tab.c
cl-standard.tab.h
cl-standard.y
hello.c
symtab.c
symtab.h
test.c
y.tab.h
