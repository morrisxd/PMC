cscope 15 $HOME/morrix-project-name/cl.tar/cl/std -q 0000000503 0000065847
	@c-standard.l

1 
ANSI
 
C
 
gmm
, 
Lex
 
ecifiti


2 
In
 1985, 
Jeff
 
L
 
published
 
this
 
Lex
 
ecifiti
 
togh
 
wh
 
a
 
Yacc
 
gmm
 
the
 
A
 30, 1985 
ANSI
 
C
 
d
. 
Tom
 
Stockfisch
 
poed
 
bh
 
to
 
t
.
sours
 

 1987; 
th
 
ig
, 
as
 
mtied
 ith
sw

quei
 17.25 
of
h
comp
.
ng
.
c
 
FAQ
, 
n
 
be
 
p
'ed from ftp.uu.net, file usenet/net.sources/ansi.c.grammar.Z.

3 
I
 
nd
 
to
 
kp
 
this
 
vsi
 
as
 
o

the
 
cut
 
C
 
Sndd
 
gmm

possib
; 

 
t
 
me
 
know
 
you
 
discov
 
discs
.

5 
Jua
 
Deg
, 1995

10 
ross
 #.*\
n


11 
wle
 \
n


12 
D
 [0-9]

13 
L
 [
a
-
zA
-
Z_
]

14 
H
 [
a
-
fA
-
F0
-9]

15 
E
 [
Ee
][+-]?{
D
}+

16 
FS
 (
f
|
F
|
l
|
L
)

17 
IS
 (
u
|
U
|
l
|
L
)*

20 
	~<dio.h
>

21 
	~"y.b.h
"

22 
	~"symb.h
"

24 
	glo
 = 1;

25 
o_to_ru__uni
;

26 
id
[128];

27 
dump
;

28 
i_side_su
;

29 
i_tydef
;

30 
i_ru__uni
;

31 
cou
();

32 
	$t_rc_uni
()

34 
i_ru__uni
 = 1;

35  
i_ru__uni
;

36 
	}
}

41 %% /* 
	$yyx
 */

42 {
wle
} { 
lo
++; 
	`cou
(); }

43 "/*" { 
	`commt
(); }

44 "dio.h" { 
	`cou
();  (
FILENAME
); }

45 "#ude" { 
	`hd
(); }

46 "__le" { 
	`cou
(); (
INLINE
); }

47 "le" { 
	`cou
(); }

48 "__ibu__ (acked))" {
	`cou
();}

49 "auto" { 
	`cou
(); (
AUTO
); }

50 "bak" { 
	`cou
(); (
BREAK
); }

51 "" { 
	`cou
(); (
CASE
); }

52 "ch" { 
	`cou
(); (
CHAR
); }

53 "cڡ" { 
	`cou
(); (
CONST
); }

54 "ctue" { 
	`cou
(); (
CONTINUE
); }

55 "deu" { 
	`cou
(); (
DEFAULT
); }

56 "do" { 
	`cou
(); (
DO
); }

57 "doub" { 
	`cou
(); (
DOUBLE
); }

58 "" { 
	`cou
(); (
ELSE
); }

59 "um" { 
	`cou
(); (
ENUM
); }

60 "ex" { 
	`cou
(); (
EXTERN
); }

61 "t" { 
	`cou
(); (
FLOAT
); }

62 "f" { 
	`cou
(); (
FOR
); }

63 "go" { 
	`cou
(); (
GOTO
); }

64 "if" { 
	`cou
(); (
IF
); }

65 "t" { 
	`cou
(); (
INT
); }

66 "lg" { 
	`cou
(); (
LONG
); }

67 "gi" { 
	`cou
(); (
REGISTER
); }

68 "tu" { 
	`cou
(); (
RETURN
); }

69 "sht" { 
	`cou
(); (
SHORT
); }

70 "sigd" { 
	`cou
(); (
SIGNED
); }

71 "sizeof" { 
	`cou
(); (
SIZEOF
); }

72 "ic" { 
	`cou
(); (
STATIC
); }

73 "ru" { 
	`cou
(); (
STRUCT
); }

74 "swch" { 
	`cou
(); (
SWITCH
); }

75 "tydef" { 
	`cou
(); (
TYPEDEF
); }

76 "uni" { 
	`cou
(); (
UNION
); }

77 "unsigd" { 
	`cou
(); (
UNSIGNED
); }

78 "void" { 
	`cou
(); (
VOID
); }

79 "vީe" { 
	`cou
(); (
VOLATILE
); }

80 "whe" { 
	`cou
(); (
WHILE
); }

82 {
L
}({L}|{
D
})* { 
	`cou
(); (
	`check_ty
()); }

84 0[
xX
]{
H
}+{
IS
}? { 
	`cou
(); (
CONSTANT
); }

85 0{
D
}+{
IS
}? { 
	`cou
(); (
CONSTANT
); }

86 {
D
}+{
IS
}? { 
	`cou
(); (
CONSTANT
); }

87 
L
?'(\\.|[^\\'])+' { count();eturn(CONSTANT); }

89 {
D
}+{
E
}{
FS
}? { 
	`cou
(); (
CONSTANT
); }

90 {
D
}*"."{D}+({
E
})?{
FS
}? { 
	`cou
(); (
CONSTANT
); }

91 {
D
}+"."{D}*({
E
})?{
FS
}? { 
	`cou
(); (
CONSTANT
); }

93 
L
?\"(\\.|[^\\"])*\" { count();eturn(STRING_LITERAL); }

95 "..." { 
	`cou
(); (
ELLIPSIS
); }

96 ">>=" { 
	`cou
(); (
RIGHT_ASSIGN
); }

97 "<<=" { 
	`cou
(); (
LEFT_ASSIGN
); }

98 "+=" { 
	`cou
(); (
ADD_ASSIGN
); }

99 "-=" { 
	`cou
(); (
SUB_ASSIGN
); }

100 "*=" { 
	`cou
(); (
MUL_ASSIGN
); }

101 "/=" { 
	`cou
(); (
DIV_ASSIGN
); }

102 "%=" { 
	`cou
(); (
MOD_ASSIGN
); }

103 "&=" { 
	`cou
(); (
AND_ASSIGN
); }

104 "^=" { 
	`cou
(); (
XOR_ASSIGN
); }

105 "|=" { 
	`cou
(); (
OR_ASSIGN
); }

106 ">>" { 
	`cou
(); (
RIGHT_OP
); }

107 "<<" { 
	`cou
(); (
LEFT_OP
); }

108 "++" { 
	`cou
(); (
INC_OP
); }

109 "--" { 
	`cou
(); (
DEC_OP
); }

110 "->" { 
	`cou
(); (
PTR_OP
); }

111 "&&" { 
	`cou
(); (
AND_OP
); }

112 "||" { 
	`cou
(); (
OR_OP
); }

113 "<=" { 
	`cou
(); (
LE_OP
); }

114 ">=" { 
	`cou
(); (
GE_OP
); }

115 "==" { 
	`cou
(); (
EQ_OP
); }

116 "!=" { 
	`cou
(); (
NE_OP
); }

117 ";" { 
	`cou
(); (';'); }

118 ("{"|"<%"{ 
	`cou
(); ('{'); }

119 ("}"|"%>"{ 
	`cou
(); ('}'); }

120 "," { 
	`cou
(); (','); }

121 ":" { 
	`cou
(); (':'); }

122 "=" { 
	`cou
(); ('='); }

123 "(" { 
	`cou
(); ('('); }

124 ")" { 
	`cou
(); (')'); }

125 ("["|"<:"{ 
	`cou
(); ('['); }

126 ("]"|":>"{ 
	`cou
(); (']'); }

127 "." { 
	`cou
(); ('.'); }

128 "&" { 
	`cou
(); ('&'); }

129 "!" { 
	`cou
(); ('!'); }

130 "~" { 
	`cou
(); ('~'); }

131 "-" { 
	`cou
(); ('-'); }

132 "+" { 
	`cou
(); ('+'); }

133 "*" { 
	`cou
(); ('*'); }

134 "/" { 
	`cou
(); ('/'); }

135 "%" { 
	`cou
(); ('%'); }

136 "<" { 
	`cou
(); ('<'); }

137 ">" { 
	`cou
(); ('>'); }

138 "^" { 
	`cou
(); ('^'); }

139 "|" { 
	`cou
(); ('|'); }

140 "?" { 
	`cou
(); ('?'); }

143 [ \
t
\
v
\
n
\
f
] { 
	`cou
(); }

146 
	}
%%

148 
	$yywp
()

151 
	}
}

154 
	$hd
()

156 
c
;

157 
	`tf
 ("%s", 
yyxt
);

158 (
c
 = 
	`put
()) != '\n' && c != 0)

159 
	`putch
(
c
);

160 i(
c
 == '\n') {

161 
	`putch
 (
c
);

162 
lo
 ++;

165 
	}
}

168 
	$commt
()

170 
c
, 
c1
;

172 
	`tf
("%s", 
yyxt
);

173 
lo
:

174 (
c
 = 
	`put
()) != '*' && c != 0)

176 
	`putch
(
c
);

177 i(
c
 == '\n') {

178 
lo
++;

182 i(
c
 ='*'
	`putch
 (c);

184 i((
c1
 = 
	`put
()!'/' && 
c
 != 0)

186 
	`uut
(
c1
);

187 
lo
;

190 i(
c
 != 0)

191 
	`putch
(
c1
);

192 
	}
}

195 
	gcumn
 = 0;

197 
	$cou
()

199 
i
;

201 
i
 = 0; 
yyxt
[i] != '\0'; i++)

202 i(
yyxt
[
i
] == '\n')

203 
cumn
 = 0;

204 i(
yyxt
[
i
] == '\t')

205 
cumn
 += 8 - (column % 8);

207 
cumn
++;

209 
ECHO
;

210 
	}
}

212 
id
[128];

213 
	$check_ty
()

227 
BuckLi
 
p
;

229 
	`rtf
 (
id
, "%s", 
yyxt
);

230 
	`tf
 ("<s(%d)(%d)(%d)>", 
i_ru__uni
, 
i_side_su
, 
o_to_ru__uni
);

232 i(
p
 = 
	`_lookup_tydef
(
id
))

234 i(
o_to_ru__uni
) {

235  
IDENTIFIER
;

238 i(
i_ru__uni
 && (!
i_side_su
)) {

239 
	`tf
("[I]");

240  
IDENTIFIER
;

242 
	`tf
("[T]");

243  (
TYPE_NAME
);

247 i(
dump
) {

249 
dump
 = 0;

252 
	`tf
("[&]");

253 (
IDENTIFIER
);

254 
	}
}

	@cl-standard.tab.c

1 
	#YY_r_h_uded


	)

38 #i
defed

_MSDOS
 ) || defed(
MSDOS
|| defed(
__MSDOS__
)

39 
	#__MSDOS_AND_ALIKE


	)

42 #i
defed
(
_WINDOWS
&& defed(
_MSC_VER
)

43 
	#__HAVE_NO_ALLOCA


	)

44 
	#__MSDOS_AND_ALIKE


	)

47 #ide
lo


48 #i
defed

__GNUC__
)

49 
	#lo
 
__but_lo


	)

51 #i(!
defed
 (
__STDC__
&& defed (
c
)|| defed (
__c__
|| defed (
__c
|| defed (
__sgi
)

52 
	~<lo.h
>

54 #i
defed
 (
__MSDOS_AND_ALIKE
)

55 
	~<mloc.h
>

56 #ide
__TURBOC__


58 
	#lo
 
_lo


	)

61 #i
defed
(
_AIX
)

63 #agm
lo


64 
	~<mloc.h
>

66 #i
defed
(
__hpux
)

67 #ifde
__lulus


69 *
lo
 ();

72 *
lo
 ();

78 #ifde
c_ulus


79 #ide
__lulus


80 
	#__lulus


	)

84 #ifde
__lulus


85 #ide
YY_USE_CLASS


89 #ide
__STDC__


90 cڡ

	)

92 #ifde
YY_USE_CLASS


97 
	~<dio.h
>

98 
	#YYBISON
 1

	)

104 
	gi_tydef
 = 0;

105 
	gi_ru__uni
 = 0;

110 
	#YY_r_BISON
 1

	)

112 #ide
YY_r_COMPATIBILITY


113 #ide
YY_USE_CLASS


114 
	#YY_r_COMPATIBILITY
 1

	)

116 
	#YY_r_COMPATIBILITY
 0

	)

120 #i
YY_r_COMPATIBILITY
 != 0

122 #ifde
YYLTYPE


123 #ide
YY_r_LTYPE


124 
	#YY_r_LTYPE
 
YYLTYPE


	)

129 #ide
YY_r_STYPE


130 
	#YY_r_STYPE
 
YYSTYPE


	)

133 #ifde
YYDEBUG


134 #ide
YY_r_DEBUG


135 
	#YY_r_DEBUG
 
YYDEBUG


	)

140 #ide
YY_r_USE_GOTO


141 
	#YY_r_USE_GOTO
 1

	)

146 #ide
YY_r_USE_GOTO


147 
	#YY_r_USE_GOTO
 0

	)

150 #ide
YY_r_PURE


161 #ide
YY_USE_CLASS


162 #ide
YYSTYPE


163 
	#YYSTYPE
 

	)

164 
	#YYSTYPE_IS_TRIVIAL
 1

	)

170 #ide
YY_r_DEBUG


179 #ide
YY_r_LSP_NEEDED


190 #ifde
YY_r_LSP_NEEDED


191 #ide
YY_r_LTYPE


192 #ide
BISON_YYLTYPE_ISDECLARED


193 
	#BISON_YYLTYPE_ISDECLARED


	)

195 
	syyy


197 
	mtimeamp
;

198 
	mf_le
;

199 
	mf_cumn
;

200 
	mϡ_le
;

201 
	mϡ_cumn
;

202 *
	mxt
;

204 
	tyyy
;

207 
	#YY_r_LTYPE
 
yyy


	)

215 #ide
YY_r_STYPE


216 
	#YY_r_STYPE
 

	)

219 #ide
YY_r_PARSE


220 
	#YY_r_PARSE
 
yyr


	)

222 #ide
YY_r_LEX


223 
	#YY_r_LEX
 
yyx


	)

225 #ide
YY_r_LVAL


226 
	#YY_r_LVAL
 
yylv


	)

228 #ide
YY_r_LLOC


229 
	#YY_r_LLOC
 
yyoc


	)

231 #ide
YY_r_CHAR


232 
	#YY_r_CHAR
 
yych


	)

234 #ide
YY_r_NERRS


235 
	#YY_r_NERRS
 
yyüs


	)

237 #ide
YY_r_DEBUG_FLAG


238 
	#YY_r_DEBUG_FLAG
 
yydebug


	)

240 #ide
YY_r_ERROR


241 
	#YY_r_ERROR
 
yyr


	)

244 #ide
YY_r_PARSE_PARAM


245 #ide
YY_USE_CLASS


246 #ifde
YYPARSE_PARAM


247 
	#YY_r_PARSE_PARAM
 * 
YYPARSE_PARAM


	)

249 #ide
__STDC__


250 #ide
__lulus


251 
	#YY_r_PARSE_PARAM


	)

256 #ide
YY_r_PARSE_PARAM


257 
	#YY_r_PARSE_PARAM
 

	)

261 #i
YY_r_COMPATIBILITY
 != 0

263 #ifde
YY_r_LTYPE


264 #ide
YYLTYPE


265 
	#YYLTYPE
 
YY_r_LTYPE


	)

278 #ifde
YY_r_PURE


279 #ide
YYPURE


280 
	#YYPURE
 
YY_r_PURE


	)

284 #ifde
YY_r_DEBUG


285 #ide
YYDEBUG


286 
	#YYDEBUG
 
YY_r_DEBUG


	)

290 #ide
YY_r_ERROR_VERBOSE


291 #ifde
YYERROR_VERBOSE


292 
	#YY_r_ERROR_VERBOSE
 
YYERROR_VERBOSE


	)

296 #ide
YY_r_LSP_NEEDED


297 #ifde
YYLSP_NEEDED


298 
	#YY_r_LSP_NEEDED
 
YYLSP_NEEDED


	)

304 #ide
YY_USE_CLASS


308 
	#IDENTIFIER
 258

	)

309 
	#CONSTANT
 259

	)

310 
	#STRING_LITERAL
 260

	)

311 
	#SIZEOF
 261

	)

312 
	#PTR_OP
 262

	)

313 
	#INC_OP
 263

	)

314 
	#DEC_OP
 264

	)

315 
	#LEFT_OP
 265

	)

316 
	#RIGHT_OP
 266

	)

317 
	#LE_OP
 267

	)

318 
	#GE_OP
 268

	)

319 
	#EQ_OP
 269

	)

320 
	#NE_OP
 270

	)

321 
	#AND_OP
 271

	)

322 
	#OR_OP
 272

	)

323 
	#MUL_ASSIGN
 273

	)

324 
	#DIV_ASSIGN
 274

	)

325 
	#MOD_ASSIGN
 275

	)

326 
	#ADD_ASSIGN
 276

	)

327 
	#SUB_ASSIGN
 277

	)

328 
	#LEFT_ASSIGN
 278

	)

329 
	#RIGHT_ASSIGN
 279

	)

330 
	#AND_ASSIGN
 280

	)

331 
	#XOR_ASSIGN
 281

	)

332 
	#OR_ASSIGN
 282

	)

333 
	#TYPE_NAME
 283

	)

334 
	#TYPEDEF
 284

	)

335 
	#EXTERN
 285

	)

336 
	#STATIC
 286

	)

337 
	#AUTO
 287

	)

338 
	#REGISTER
 288

	)

339 
	#CHAR
 289

	)

340 
	#SHORT
 290

	)

341 
	#INT
 291

	)

342 
	#LONG
 292

	)

343 
	#SIGNED
 293

	)

344 
	#UNSIGNED
 294

	)

345 
	#FLOAT
 295

	)

346 
	#DOUBLE
 296

	)

347 
	#CONST
 297

	)

348 
	#VOLATILE
 298

	)

349 
	#VOID
 299

	)

350 
	#STRUCT
 300

	)

351 
	#UNION
 301

	)

352 
	#ENUM
 302

	)

353 
	#ELLIPSIS
 303

	)

354 
	#CASE
 304

	)

355 
	#DEFAULT
 305

	)

356 
	#IF
 306

	)

357 
	#ELSE
 307

	)

358 
	#SWITCH
 308

	)

359 
	#WHILE
 309

	)

360 
	#DO
 310

	)

361 
	#FOR
 311

	)

362 
	#GOTO
 312

	)

363 
	#CONTINUE
 313

	)

364 
	#BREAK
 314

	)

365 
	#RETURN
 315

	)

372 #ide
YY_r_CLASS


373 
	#YY_r_CLASS
 
r


	)

375 #ide
YY_r_INHERIT


376 
	#YY_r_INHERIT


	)

378 #ide
YY_r_MEMBERS


379 
	#YY_r_MEMBERS


	)

381 #ide
YY_r_LEX_BODY


382 
	#YY_r_LEX_BODY


	)

384 #ide
YY_r_ERROR_BODY


385 
	#YY_r_ERROR_BODY


	)

387 #ide
YY_r_CONSTRUCTOR_PARAM


388 
	#YY_r_CONSTRUCTOR_PARAM


	)

390 #ide
YY_r_CONSTRUCTOR_CODE


391 
	#YY_r_CONSTRUCTOR_CODE


	)

393 #ide
YY_r_CONSTRUCTOR_INIT


394 
	#YY_r_CONSTRUCTOR_INIT


	)

397 #ide
YY_r_USE_CONST_TOKEN


398 
	#YY_r_USE_CONST_TOKEN
 0

	)

402 #i
YY_r_USE_CONST_TOKEN
 != 0

403 #ide
YY_r_ENUM_TOKEN


404 
	#YY_r_ENUM_TOKEN
 
yy_r_um_tok


	)

408 as
	cYY_r_CLASS
 
	mYY_r_INHERIT


410 
	mpublic
:

411 #i
YY_r_USE_CONST_TOKEN
 != 0

415 cڡ 
IDENTIFIER
;

416 cڡ 
	mCONSTANT
;

417 cڡ 
	mSTRING_LITERAL
;

418 cڡ 
	mSIZEOF
;

419 cڡ 
	mPTR_OP
;

420 cڡ 
	mINC_OP
;

421 cڡ 
	mDEC_OP
;

422 cڡ 
	mLEFT_OP
;

423 cڡ 
	mRIGHT_OP
;

424 cڡ 
	mLE_OP
;

425 cڡ 
	mGE_OP
;

426 cڡ 
	mEQ_OP
;

427 cڡ 
	mNE_OP
;

428 cڡ 
	mAND_OP
;

429 cڡ 
	mOR_OP
;

430 cڡ 
	mMUL_ASSIGN
;

431 cڡ 
	mDIV_ASSIGN
;

432 cڡ 
	mMOD_ASSIGN
;

433 cڡ 
	mADD_ASSIGN
;

434 cڡ 
	mSUB_ASSIGN
;

435 cڡ 
	mLEFT_ASSIGN
;

436 cڡ 
	mRIGHT_ASSIGN
;

437 cڡ 
	mAND_ASSIGN
;

438 cڡ 
	mXOR_ASSIGN
;

439 cڡ 
	mOR_ASSIGN
;

440 cڡ 
	mTYPE_NAME
;

441 cڡ 
	mTYPEDEF
;

442 cڡ 
	mEXTERN
;

443 cڡ 
	mSTATIC
;

444 cڡ 
	mAUTO
;

445 cڡ 
	mREGISTER
;

446 cڡ 
	mCHAR
;

447 cڡ 
	mSHORT
;

448 cڡ 
	mINT
;

449 cڡ 
	mLONG
;

450 cڡ 
	mSIGNED
;

451 cڡ 
	mUNSIGNED
;

452 cڡ 
	mFLOAT
;

453 cڡ 
	mDOUBLE
;

454 cڡ 
	mCONST
;

455 cڡ 
	mVOLATILE
;

456 cڡ 
	mVOID
;

457 cڡ 
	mSTRUCT
;

458 cڡ 
	mUNION
;

459 cڡ 
	mENUM
;

460 cڡ 
	mELLIPSIS
;

461 cڡ 
	mCASE
;

462 cڡ 
	mDEFAULT
;

463 cڡ 
	mIF
;

464 cڡ 
	mELSE
;

465 cڡ 
	mSWITCH
;

466 cڡ 
	mWHILE
;

467 cڡ 
	mDO
;

468 cڡ 
	mFOR
;

469 cڡ 
	mGOTO
;

470 cڡ 
	mCONTINUE
;

471 cڡ 
	mBREAK
;

472 cڡ 
	mRETURN
;

478 
	eYY_r_ENUM_TOKEN
 { 
	mYY_r_NULL_TOKEN
=0

481 ,
	mIDENTIFIER
=258

482 ,
	mCONSTANT
=259

483 ,
	mSTRING_LITERAL
=260

484 ,
	mSIZEOF
=261

485 ,
	mPTR_OP
=262

486 ,
	mINC_OP
=263

487 ,
	mDEC_OP
=264

488 ,
	mLEFT_OP
=265

489 ,
	mRIGHT_OP
=266

490 ,
	mLE_OP
=267

491 ,
	mGE_OP
=268

492 ,
	mEQ_OP
=269

493 ,
	mNE_OP
=270

494 ,
	mAND_OP
=271

495 ,
	mOR_OP
=272

496 ,
	mMUL_ASSIGN
=273

497 ,
	mDIV_ASSIGN
=274

498 ,
	mMOD_ASSIGN
=275

499 ,
	mADD_ASSIGN
=276

500 ,
	mSUB_ASSIGN
=277

501 ,
	mLEFT_ASSIGN
=278

502 ,
	mRIGHT_ASSIGN
=279

503 ,
	mAND_ASSIGN
=280

504 ,
	mXOR_ASSIGN
=281

505 ,
	mOR_ASSIGN
=282

506 ,
	mTYPE_NAME
=283

507 ,
	mTYPEDEF
=284

508 ,
	mEXTERN
=285

509 ,
	mSTATIC
=286

510 ,
	mAUTO
=287

511 ,
	mREGISTER
=288

512 ,
	mCHAR
=289

513 ,
	mSHORT
=290

514 ,
	mINT
=291

515 ,
	mLONG
=292

516 ,
	mSIGNED
=293

517 ,
	mUNSIGNED
=294

518 ,
	mFLOAT
=295

519 ,
	mDOUBLE
=296

520 ,
	mCONST
=297

521 ,
	mVOLATILE
=298

522 ,
	mVOID
=299

523 ,
	mSTRUCT
=300

524 ,
	mUNION
=301

525 ,
	mENUM
=302

526 ,
	mELLIPSIS
=303

527 ,
	mCASE
=304

528 ,
	mDEFAULT
=305

529 ,
	mIF
=306

530 ,
	mELSE
=307

531 ,
	mSWITCH
=308

532 ,
	mWHILE
=309

533 ,
	mDO
=310

534 ,
	mFOR
=311

535 ,
	mGOTO
=312

536 ,
	mCONTINUE
=313

537 ,
	mBREAK
=314

538 ,
	mRETURN
=315

545 
	gpublic
:

546 
YY_r_PARSE
 (
YY_r_PARSE_PARAM
);

547 
vtu
 
	$YY_r_ERROR
(*
msg

YY_r_ERROR_BODY
;

548 #ifde
YY_r_PURE


549 #ifde
YY_r_LSP_NEEDED


550 
vtu
 
	$YY_r_LEX
 (
YY_r_STYPE
 *
YY_r_LVAL
,
YY_r_LTYPE
 *
YY_r_LLOC

YY_r_LEX_BODY
;

552 
vtu
 
	$YY_r_LEX
 (
YY_r_STYPE
 *
YY_r_LVAL

YY_r_LEX_BODY
;

555 
vtu
 
	$YY_r_LEX
(
YY_r_LEX_BODY
;

556 
YY_r_STYPE
 
YY_r_LVAL
;

557 #ifde
YY_r_LSP_NEEDED


558 
YY_r_LTYPE
 
YY_r_LLOC
;

560 
YY_r_NERRS
;

561 
YY_r_CHAR
;

563 #i
YY_r_DEBUG
 != 0

564 
YY_r_DEBUG_FLAG
;

566 
public
:

567 
	`YY_r_CLASS
(
YY_r_CONSTRUCTOR_PARAM
);

568 
public
:

569 
YY_r_MEMBERS


570 
	}
};

572 #i
YY_r_USE_CONST_TOKEN
 != 0

575 cڡ 
	gYY_r_CLASS
::
IDENTIFIER
=258;

576 cڡ 
	gYY_r_CLASS
::
CONSTANT
=259;

577 cڡ 
	gYY_r_CLASS
::
STRING_LITERAL
=260;

578 cڡ 
	gYY_r_CLASS
::
SIZEOF
=261;

579 cڡ 
	gYY_r_CLASS
::
PTR_OP
=262;

580 cڡ 
	gYY_r_CLASS
::
INC_OP
=263;

581 cڡ 
	gYY_r_CLASS
::
DEC_OP
=264;

582 cڡ 
	gYY_r_CLASS
::
LEFT_OP
=265;

583 cڡ 
	gYY_r_CLASS
::
RIGHT_OP
=266;

584 cڡ 
	gYY_r_CLASS
::
LE_OP
=267;

585 cڡ 
	gYY_r_CLASS
::
GE_OP
=268;

586 cڡ 
	gYY_r_CLASS
::
EQ_OP
=269;

587 cڡ 
	gYY_r_CLASS
::
NE_OP
=270;

588 cڡ 
	gYY_r_CLASS
::
AND_OP
=271;

589 cڡ 
	gYY_r_CLASS
::
OR_OP
=272;

590 cڡ 
	gYY_r_CLASS
::
MUL_ASSIGN
=273;

591 cڡ 
	gYY_r_CLASS
::
DIV_ASSIGN
=274;

592 cڡ 
	gYY_r_CLASS
::
MOD_ASSIGN
=275;

593 cڡ 
	gYY_r_CLASS
::
ADD_ASSIGN
=276;

594 cڡ 
	gYY_r_CLASS
::
SUB_ASSIGN
=277;

595 cڡ 
	gYY_r_CLASS
::
LEFT_ASSIGN
=278;

596 cڡ 
	gYY_r_CLASS
::
RIGHT_ASSIGN
=279;

597 cڡ 
	gYY_r_CLASS
::
AND_ASSIGN
=280;

598 cڡ 
	gYY_r_CLASS
::
XOR_ASSIGN
=281;

599 cڡ 
	gYY_r_CLASS
::
OR_ASSIGN
=282;

600 cڡ 
	gYY_r_CLASS
::
TYPE_NAME
=283;

601 cڡ 
	gYY_r_CLASS
::
TYPEDEF
=284;

602 cڡ 
	gYY_r_CLASS
::
EXTERN
=285;

603 cڡ 
	gYY_r_CLASS
::
STATIC
=286;

604 cڡ 
	gYY_r_CLASS
::
AUTO
=287;

605 cڡ 
	gYY_r_CLASS
::
REGISTER
=288;

606 cڡ 
	gYY_r_CLASS
::
CHAR
=289;

607 cڡ 
	gYY_r_CLASS
::
SHORT
=290;

608 cڡ 
	gYY_r_CLASS
::
INT
=291;

609 cڡ 
	gYY_r_CLASS
::
LONG
=292;

610 cڡ 
	gYY_r_CLASS
::
SIGNED
=293;

611 cڡ 
	gYY_r_CLASS
::
UNSIGNED
=294;

612 cڡ 
	gYY_r_CLASS
::
FLOAT
=295;

613 cڡ 
	gYY_r_CLASS
::
DOUBLE
=296;

614 cڡ 
	gYY_r_CLASS
::
CONST
=297;

615 cڡ 
	gYY_r_CLASS
::
VOLATILE
=298;

616 cڡ 
	gYY_r_CLASS
::
VOID
=299;

617 cڡ 
	gYY_r_CLASS
::
STRUCT
=300;

618 cڡ 
	gYY_r_CLASS
::
UNION
=301;

619 cڡ 
	gYY_r_CLASS
::
ENUM
=302;

620 cڡ 
	gYY_r_CLASS
::
ELLIPSIS
=303;

621 cڡ 
	gYY_r_CLASS
::
CASE
=304;

622 cڡ 
	gYY_r_CLASS
::
DEFAULT
=305;

623 cڡ 
	gYY_r_CLASS
::
IF
=306;

624 cڡ 
	gYY_r_CLASS
::
ELSE
=307;

625 cڡ 
	gYY_r_CLASS
::
SWITCH
=308;

626 cڡ 
	gYY_r_CLASS
::
WHILE
=309;

627 cڡ 
	gYY_r_CLASS
::
DO
=310;

628 cڡ 
	gYY_r_CLASS
::
FOR
=311;

629 cڡ 
	gYY_r_CLASS
::
GOTO
=312;

630 cڡ 
	gYY_r_CLASS
::
CONTINUE
=313;

631 cڡ 
	gYY_r_CLASS
::
BREAK
=314;

632 cڡ 
	gYY_r_CLASS
::
RETURN
=315;

639 
	gYY_r_CLASS
::
	$YY_r_CLASS
(
YY_r_CONSTRUCTOR_PARAM

YY_r_CONSTRUCTOR_INIT


641 #i
YY_r_DEBUG
 != 0

642 
YY_r_DEBUG_FLAG
=0;

644 
YY_r_CONSTRUCTOR_CODE
;

645 
	}
};

651 
	#YYFINAL
 350

	)

652 
	#YYFLAG
 -32768

	)

653 
	#YYNTBASE
 85

	)

655 
	#YYTRANSLATE
(
x
(()(x<315 ? 
yye
[x] : 148)

	)

657 cڡ 
	gyye
[] = { 0,

692 #i
YY_r_DEBUG
 != 0

693 cڡ 
	gyyhs
[] = { 0,

718 cڡ 
	gyyrhs
[] = { 3,

789 #i(
YY_r_DEBUG
 !0|| 
defed
(
YY_r_ERROR_VERBOSE
)

790 cڡ 
	gyye
[] = { 0,

815 cڡ * cڡ 
	gyyame
[] = { "$","error","$illegal.","IDENTIFIER",

843 cڡ 
	gyyr1
[] = { 0,

868 cڡ 
	gyyr2
[] = { 0,

893 cڡ 
	gyyde
[] = { 0,

931 cڡ 
	gyydefgo
[] = { 106,

941 cڡ 
	gyy
[] = { 937,

979 cڡ 
	gyypgo
[] = {-32768,

990 
	#YYLAST
 1308

	)

993 cڡ 
	gyyb
[] = { 25,

1127 cڡ 
	gyycheck
[] = { 0,

1276 #i
YY_r_USE_GOTO
 != 0

1284 
	#YYGOTO
(
lb
{
yy_goe
b;;}

	)

1285 
	#YYBEGINGOTO
 
yy_bs
 
yy_goe
=
yygot
; \

1286 ;;
yy_goe
{ 
yygot
: {

	)

1287 
	#YYLABEL
(
lb
} lb: {

	)

1288 
	#YYENDGOTO
 } }

	)

1289 
	#YYBEGINDECLARELABEL
 
	eyy_bs
 {
yygot


	)

1290 
	#YYDECLARELABEL
(
lb
,
	)
lb

1291 
	#YYENDDECLARELABEL
 };

	)

1294 
	#YYGOTO
(
lb

	)
lb

1295 
	#YYBEGINGOTO


	)

1296 
	#YYLABEL
(
lb
lb:

	)

1297 
	#YYENDGOTO


	)

1298 
	#YYBEGINDECLARELABEL


	)

1299 
	#YYDECLARELABEL
(
lb
)

	)

1300 
	#YYENDDECLARELABEL


	)

1303 
YYBEGINDECLARELABEL


1304 
	$YYDECLARELABEL
(
yywe
)

1305 
	$YYDECLARELABEL
(
yybackup
)

1307 
	$YYDECLARELABEL
(
yydeu
)

1308 
	$YYDECLARELABEL
(
yydu
)

1309 
	$YYDECLARELABEL
(
yyab
)

1310 
	$YYDECLARELABEL
(
yyab1
)

1311 
	$YYDECLARELABEL
(
yyrdeu
)

1312 
	$YYDECLARELABEL
(
yy
)

1313 
	$YYDECLARELABEL
(
yyrhd
)

1314 
YYENDDECLARELABEL


1317 #ifde
__HAVE_NO_ALLOCA


1318 
	$__lo__r
(*
r
,*
f
)

1319 {if(
r
!=
f

	`
(ptr);

1320  0;
	}
}

1322 
	#__ALLOCA_lo
(
size

	`mloc
(size)

	)

1323 
	#__ALLOCA_
(
r
,
f

	`__lo__r
((*,(*ef)

	)

1325 #ifde
YY_r_LSP_NEEDED


1326 
	#__ALLOCA_tu
(
num
) \

1327 d{ 
	`__ALLOCA_
(
yyss
,
yys
)+\

1328 
	`__ALLOCA_
(
yyvs
,
yyv
)+\

1329 
	`__ALLOCA_
(
yyls
,
yyl
)+\

1330 (
num
)); } 0)

	)

1332 
	#__ALLOCA_tu
(
num
) \

1333 d{ 
	`__ALLOCA_
(
yyss
,
yys
)+\

1334 
	`__ALLOCA_
(
yyvs
,
yyv
)+\

1335 (
num
)); } 0)

	)

1338 
	#__ALLOCA_tu
(
num
d{ um); } 0)

	)

1339 
	#__ALLOCA_lo
(
size

	`lo
(size)

	)

1340 
	#__ALLOCA_
(
r
,
f
)

	)

1345 
	#yyrok
 (
yyrus
 = 0)

	)

1346 
	#yyr
 (
YY_r_CHAR
 = 
YYEMPTY
)

	)

1347 
	#YYEMPTY
 -2

	)

1348 
	#YYEOF
 0

	)

1349 
	#YYACCEPT
 
	`__ALLOCA_tu
(0)

	)

1350 
	#YYABORT
 
	`__ALLOCA_tu
(1)

	)

1351 
	#YYERROR
 
	`YYGOTO
(
yyab1
)

	)

1356 
	#YYFAIL
 
	`YYGOTO
(
yyab
)

	)

1357 
	#YYRECOVERING
((!!
yyrus
)

	)

1358 
	#YYBACKUP
(
tok
, 
vue
) \

1360 i(
YY_r_CHAR
 =
YYEMPTY
 && 
yyn
 == 1) \

1361 { 
YY_r_CHAR
 = (
tok
), 
YY_r_LVAL
 = (
vue
); \

1362 
yych1
 = 
	`YYTRANSLATE
 (
YY_r_CHAR
); \

1363 
YYPOPSTACK
; \

1364 
	`YYGOTO
(
yybackup
); \

1367 { 
	`YY_r_ERROR
 ("syax: cn back up"); 
YYERROR
; } \

1368 0)

	)

1370 
	#YYTERROR
 1

	)

1371 
	#YYERRCODE
 256

	)

1373 #ide
YY_r_PURE


1375 
	#YYLEX
 
	`YY_r_LEX
()

	)

1376 #ide
YY_USE_CLASS


1378 
	gYY_r_CHAR
;

1379 
YY_r_STYPE
 
	gYY_r_LVAL
;

1381 
	gYY_r_NERRS
;

1382 #ifde
YY_r_LSP_NEEDED


1383 
YY_r_LTYPE
 
	gYY_r_LLOC
;

1391 #ifde
YY_r_LSP_NEEDED


1392 
	#YYLEX
 
	`YY_r_LEX
(&
YY_r_LVAL
, &
YY_r_LLOC
)

	)

1394 
	#YYLEX
 
	`YY_r_LEX
(&
YY_r_LVAL
)

	)

1397 #ide
YY_USE_CLASS


1398 #i
YY_r_DEBUG
 != 0

1399 
	gYY_r_DEBUG_FLAG
;

1409 #ide
YYINITDEPTH


1410 
	#YYINITDEPTH
 200

	)

1416 #i
YYMAXDEPTH
 == 0

1417 #unde
YYMAXDEPTH


1420 #ide
YYMAXDEPTH


1421 
	#YYMAXDEPTH
 10000

	)

1425 #i
__GNUC__
 > 1

1426 
	#__yy_bcy
(
FROM
,
TO
,
COUNT

	`__but_memy
(TO,FROM,COUNT)

	)

1432 #ifde
__lulus


1433 
	$__yy_bcy
 (*
om
, *
to
, 
cou
)

1435 #ifde
__STDC__


1436 
	$__yy_bcy
 (*
om
, *
to
, 
cou
)

1438 
	$__yy_bcy
 (
om
, 
to
, 
cou
)

1439 *
om
;

1440 *
to
;

1441 
cou
;

1445 *
f
 = 
om
;

1446 *
t
 = 
to
;

1447 
i
 = 
cou
;

1449 
i
-- > 0)

1450 *
t
++ = *
f
++;

1451 
	}
}

1456 #ifde
YY_USE_CLASS


1457 
	gYY_r_CLASS
::

1459 
	$YY_r_PARSE
(
YY_r_PARSE_PARAM
)

1460 #ide
__STDC__


1461 #ide
__lulus


1462 #ide
YY_USE_CLASS


1464 
YY_r_PARSE_PARAM_DEF


1469 
yye
;

1470 
yyn
;

1471 *
yys
;

1472 
YY_r_STYPE
 *
yyv
;

1473 
yyrus
;

1474 
yych1
=0;

1476 
yys
[
YYINITDEPTH
];

1477 
YY_r_STYPE
 
yyv
[
YYINITDEPTH
];

1479 *
yyss
 = 
yys
;

1480 
YY_r_STYPE
 *
yyvs
 = 
yyv
;

1482 #ifde
YY_r_LSP_NEEDED


1483 
YY_r_LTYPE
 
yyl
[
YYINITDEPTH
];

1484 
YY_r_LTYPE
 *
yyls
 = 
yyl
;

1485 
YY_r_LTYPE
 *
yyl
;

1487 
	#YYPOPSTACK
 (
yyv
--, 
yys
--, 
yyl
--)

	)

1489 
	#YYPOPSTACK
 (
yyv
--, 
yys
--)

	)

1492 
yyacksize
 = 
YYINITDEPTH
;

1494 #ifde
YY_r_PURE


1495 
YY_r_CHAR
;

1496 
YY_r_STYPE
 
YY_r_LVAL
;

1497 
YY_r_NERRS
;

1498 #ifde
YY_r_LSP_NEEDED


1499 
YY_r_LTYPE
 
YY_r_LLOC
;

1503 
YY_r_STYPE
 
yyv
;

1507 
yyn
;

1509 
YYBEGINGOTO


1511 #i
YY_r_DEBUG
 != 0

1512 i(
YY_r_DEBUG_FLAG
)

1513 
	`rtf
(
dr
, "Startingarse\n");

1515 
yye
 = 0;

1516 
yyrus
 = 0;

1517 
YY_r_NERRS
 = 0;

1518 
YY_r_CHAR
 = 
YYEMPTY
;

1525 
yys
 = 
yyss
 - 1;

1526 
yyv
 = 
yyvs
;

1527 #ifde
YY_r_LSP_NEEDED


1528 
yyl
 = 
yyls
;

1534 
	`YYLABEL
(
yywe
)

1536 *++
yys
 = 
yye
;

1538 i(
yys
 >
yyss
 + 
yyacksize
 - 1)

1542 
YY_r_STYPE
 *
yyvs1
 = 
yyvs
;

1543 *
yyss1
 = 
yyss
;

1544 #ifde
YY_r_LSP_NEEDED


1545 
YY_r_LTYPE
 *
yyls1
 = 
yyls
;

1549 
size
 = 
yys
 - 
yyss
 + 1;

1551 #ifde
yyovow


1554 #ifde
YY_r_LSP_NEEDED


1557 
	`yyovow
("parser stack overflow",

1558 &
yyss1
, 
size
 *  (*
yys
),

1559 &
yyvs1
, 
size
 *  (*
yyv
),

1560 &
yyls1
, 
size
 *  (*
yyl
),

1561 &
yyacksize
);

1563 
	`yyovow
("parser stack overflow",

1564 &
yyss1
, 
size
 *  (*
yys
),

1565 &
yyvs1
, 
size
 *  (*
yyv
),

1566 &
yyacksize
);

1569 
yyss
 = 
yyss1
; 
yyvs
 = 
yyvs1
;

1570 #ifde
YY_r_LSP_NEEDED


1571 
yyls
 = 
yyls1
;

1575 i(
yyacksize
 >
YYMAXDEPTH
)

1577 
	`YY_r_ERROR
("parser stack overflow");

1578 
	`__ALLOCA_tu
(2);

1580 
yyacksize
 *= 2;

1581 i(
yyacksize
 > 
YYMAXDEPTH
)

1582 
yyacksize
 = 
YYMAXDEPTH
;

1583 
yyss
 = (*
	`__ALLOCA_lo
 (
yyacksize
 *  (*
yys
));

1584 
	`__yy_bcy
 ((*)
yyss1
, (*)
yyss
, 
size
 *  (*
yys
));

1585 
	`__ALLOCA_
(
yyss1
,
yys
);

1586 
yyvs
 = (
YY_r_STYPE
 *
	`__ALLOCA_lo
 (
yyacksize
 *  (*
yyv
));

1587 
	`__yy_bcy
 ((*)
yyvs1
, (*)
yyvs
, 
size
 *  (*
yyv
));

1588 
	`__ALLOCA_
(
yyvs1
,
yyv
);

1589 #ifde
YY_r_LSP_NEEDED


1590 
yyls
 = (
YY_r_LTYPE
 *
	`__ALLOCA_lo
 (
yyacksize
 *  (*
yyl
));

1591 
	`__yy_bcy
 ((*)
yyls1
, (*)
yyls
, 
size
 *  (*
yyl
));

1592 
	`__ALLOCA_
(
yyls1
,
yyl
);

1596 
yys
 = 
yyss
 + 
size
 - 1;

1597 
yyv
 = 
yyvs
 + 
size
 - 1;

1598 #ifde
YY_r_LSP_NEEDED


1599 
yyl
 = 
yyls
 + 
size
 - 1;

1602 #i
YY_r_DEBUG
 != 0

1603 i(
YY_r_DEBUG_FLAG
)

1604 
	`rtf
(
dr
, "Sck sizd%d\n", 
yyacksize
);

1607 i(
yys
 >
yyss
 + 
yyacksize
 - 1)

1608 
YYABORT
;

1611 #i
YY_r_DEBUG
 != 0

1612 i(
YY_r_DEBUG_FLAG
)

1613 
	`rtf
(
dr
, "Eg s %d\n", 
yye
);

1616 
	`YYGOTO
(
yybackup
);

1617 
	`YYLABEL
(
yybackup
)

1625 
yyn
 = 
yy
[
yye
];

1626 i(
yyn
 =
YYFLAG
)

1627 
	`YYGOTO
(
yydeu
);

1634 i(
YY_r_CHAR
 =
YYEMPTY
)

1636 #i
YY_r_DEBUG
 != 0

1637 i(
YY_r_DEBUG_FLAG
)

1638 
	`rtf
(
dr
, "Readingoken: ");

1640 
YY_r_CHAR
 = 
YYLEX
;

1645 i(
YY_r_CHAR
 <= 0)

1647 
yych1
 = 0;

1648 
YY_r_CHAR
 = 
YYEOF
;

1650 #i
YY_r_DEBUG
 != 0

1651 i(
YY_r_DEBUG_FLAG
)

1652 
	`rtf
(
dr
, "Nowtnd of input.\n");

1657 
yych1
 = 
	`YYTRANSLATE
(
YY_r_CHAR
);

1659 #i
YY_r_DEBUG
 != 0

1660 i(
YY_r_DEBUG_FLAG
)

1662 
	`rtf
 (
dr
, "Nextok i%d (%s", 
YY_r_CHAR
, 
yyame
[
yych1
]);

1665 #ifde
YYPRINT


1666 
	`YYPRINT
 (
dr
, 
YY_r_CHAR
, 
YY_r_LVAL
);

1668 
	`rtf
 (
dr
, ")\n");

1673 
yyn
 +
yych1
;

1674 i(
yyn
 < 0 || yy> 
YYLAST
 || 
yycheck
[yyn] !
yych1
)

1675 
	`YYGOTO
(
yydeu
);

1677 
yyn
 = 
yyb
[yyn];

1686 i(
yyn
 < 0)

1688 i(
yyn
 =
YYFLAG
)

1689 
	`YYGOTO
(
yyab
);

1690 
yyn
 = -yyn;

1691 
	`YYGOTO
(
yydu
);

1693 i(
yyn
 == 0)

1694 
	`YYGOTO
(
yyab
);

1696 i(
yyn
 =
YYFINAL
)

1697 
YYACCEPT
;

1701 #i
YY_r_DEBUG
 != 0

1702 i(
YY_r_DEBUG_FLAG
)

1703 
	`rtf
(
dr
, "Shigok %d (%s), ", 
YY_r_CHAR
, 
yyame
[
yych1
]);

1707 i(
YY_r_CHAR
 !
YYEOF
)

1708 
YY_r_CHAR
 = 
YYEMPTY
;

1710 *++
yyv
 = 
YY_r_LVAL
;

1711 #ifde
YY_r_LSP_NEEDED


1712 *++
yyl
 = 
YY_r_LLOC
;

1716 i(
yyrus
) yyerrstatus--;

1718 
yye
 = 
yyn
;

1719 
	`YYGOTO
(
yywe
);

1722 
	`YYLABEL
(
yydeu
)

1724 
yyn
 = 
yyde
[
yye
];

1725 i(
yyn
 == 0)

1726 
	`YYGOTO
(
yyab
);

1729 
	`YYLABEL
(
yydu
)

1730 
yyn
 = 
yyr2
[
yyn
];

1731 i(
yyn
 > 0)

1732 
yyv
 = 
yyv
[1-
yyn
];

1734 #i
YY_r_DEBUG
 != 0

1735 i(
YY_r_DEBUG_FLAG
)

1737 
i
;

1739 
	`rtf
 (
dr
, "Reducing viaule %d (line %d), ",

1740 
yyn
, 
yye
[yyn]);

1743 
i
 = 
yyhs
[
yyn
]; 
yyrhs
[i] > 0; i++)

1744 
	`rtf
 (
dr
, "%", 
yyame
[
yyrhs
[
i
]]);

1745 
	`rtf
 (
dr
, " -> %s\n", 
yyame
[
yyr1
[
yyn
]]);

1752 
yyn
) {

1756 { 
	`tf
 ("$$$$$"); ;

1762 
yyv
 -
yyn
;

1763 
yys
 -
yyn
;

1764 #ifde
YY_r_LSP_NEEDED


1765 
yyl
 -
yyn
;

1768 #i
YY_r_DEBUG
 != 0

1769 i(
YY_r_DEBUG_FLAG
)

1771 *
s1
 = 
yyss
 - 1;

1772 
	`rtf
 (
dr
, "state stackow");

1773 
s1
 !
yys
)

1774 
	`rtf
 (
dr
, " %d", *++
s1
);

1775 
	`rtf
 (
dr
, "\n");

1779 *++
yyv
 = 
yyv
;

1781 #ifde
YY_r_LSP_NEEDED


1782 
yyl
++;

1783 i(
yyn
 == 0)

1785 
yyl
->
f_le
 = 
YY_r_LLOC
.first_line;

1786 
yyl
->
f_cumn
 = 
YY_r_LLOC
.first_column;

1787 
yyl
->
ϡ_le
 = (yylsp-1)->last_line;

1788 
yyl
->
ϡ_cumn
 = (yylsp-1)->last_column;

1789 
yyl
->
xt
 = 0;

1793 
yyl
->
ϡ_le
 = (yyl+
yyn
-1)->last_line;

1794 
yyl
->
ϡ_cumn
 = (yyl+
yyn
-1)->last_column;

1803 
yyn
 = 
yyr1
[yyn];

1805 
yye
 = 
yypgo
[
yyn
 - 
YYNTBASE
] + *
yys
;

1806 i(
yye
 >0 && yy<
YYLAST
 && 
yycheck
[yye] =*
yys
)

1807 
yye
 = 
yyb
[yystate];

1809 
yye
 = 
yydefgo
[
yyn
 - 
YYNTBASE
];

1811 
	`YYGOTO
(
yywe
);

1813 
	`YYLABEL
(
yyab
)

1815 i(! 
yyrus
)

1818 ++
YY_r_NERRS
;

1820 #ifde
YY_r_ERROR_VERBOSE


1821 
yyn
 = 
yy
[
yye
];

1823 i(
yyn
 > 
YYFLAG
 && yy< 
YYLAST
)

1825 
size
 = 0;

1826 *
msg
;

1827 
x
, 
cou
;

1829 
cou
 = 0;

1831 
x
 = (
yyn
 < 0 ? -yyn : 0);

1832 
x
 < ((
yyame
) / (*)); x++)

1833 i(
yycheck
[
x
 + 
yyn
] == x)

1834 
size
 +
	`
(
yyame
[
x
]+ 15, 
cou
++;

1835 
msg
 = (*
	`mloc
(
size
 + 15);

1836 i(
msg
 != 0)

1838 
	`ry
(
msg
, "parserror");

1840 i(
cou
 < 5)

1842 
cou
 = 0;

1843 
x
 = (
yyn
 < 0 ? -yyn : 0);

1844 
x
 < ((
yyame
) / (*)); x++)

1845 i(
yycheck
[
x
 + 
yyn
] == x)

1847 
	`rt
(
msg
, 
cou
 == 0 ? ",xpecting `" : " or `");

1848 
	`rt
(
msg
, 
yyame
[
x
]);

1849 
	`rt
(
msg
, "'");

1850 
cou
++;

1853 
	`YY_r_ERROR
(
msg
);

1854 
	`
(
msg
);

1857 
	`YY_r_ERROR
 ("parserror;lso virtual memoryxceeded");

1861 
	`YY_r_ERROR
("parserror");

1864 
	`YYGOTO
(
yyab1
);

1865 
	`YYLABEL
(
yyab1
)

1867 i(
yyrus
 == 3)

1872 i(
YY_r_CHAR
 =
YYEOF
)

1873 
YYABORT
;

1875 #i
YY_r_DEBUG
 != 0

1876 i(
YY_r_DEBUG_FLAG
)

1877 
	`rtf
(
dr
, "Disrdgok %d (%s).\n", 
YY_r_CHAR
, 
yyame
[
yych1
]);

1880 
YY_r_CHAR
 = 
YYEMPTY
;

1886 
yyrus
 = 3;

1888 
	`YYGOTO
(
yyrhd
);

1890 
	`YYLABEL
(
yyrdeu
)

1895 
yyn
 = 
yyde
[
yye
];

1896 i(
yyn

	`YYGOTO
(
yydeu
);

1899 
	`YYLABEL
(
yy
)

1901 i(
yys
 =
yyss

YYABORT
;

1902 
yyv
--;

1903 
yye
 = *--
yys
;

1904 #ifde
YY_r_LSP_NEEDED


1905 
yyl
--;

1908 #i
YY_r_DEBUG
 != 0

1909 i(
YY_r_DEBUG_FLAG
)

1911 *
s1
 = 
yyss
 - 1;

1912 
	`rtf
 (
dr
, "Error: state stackow");

1913 
s1
 !
yys
)

1914 
	`rtf
 (
dr
, " %d", *++
s1
);

1915 
	`rtf
 (
dr
, "\n");

1919 
	`YYLABEL
(
yyrhd
)

1921 
yyn
 = 
yy
[
yye
];

1922 i(
yyn
 =
YYFLAG
)

1923 
	`YYGOTO
(
yyrdeu
);

1925 
yyn
 +
YYTERROR
;

1926 i(
yyn
 < 0 || yy> 
YYLAST
 || 
yycheck
[yyn] !
YYTERROR
)

1927 
	`YYGOTO
(
yyrdeu
);

1929 
yyn
 = 
yyb
[yyn];

1930 i(
yyn
 < 0)

1932 i(
yyn
 =
YYFLAG
)

1933 
	`YYGOTO
(
yy
);

1934 
yyn
 = -yyn;

1935 
	`YYGOTO
(
yydu
);

1937 i(
yyn
 == 0)

1938 
	`YYGOTO
(
yy
);

1940 i(
yyn
 =
YYFINAL
)

1941 
YYACCEPT
;

1943 #i
YY_r_DEBUG
 != 0

1944 i(
YY_r_DEBUG_FLAG
)

1945 
	`rtf
(
dr
, "Shiftingrroroken, ");

1948 *++
yyv
 = 
YY_r_LVAL
;

1949 #ifde
YY_r_LSP_NEEDED


1950 *++
yyl
 = 
YY_r_LLOC
;

1953 
yye
 = 
yyn
;

1954 
	`YYGOTO
(
yywe
);

1956 
YYENDGOTO


1957 
	}
}

1964 
	~<dio.h
>

1966 
yyxt
[];

1967 
cumn
;

1969 
	$yyr
(
s
)

1970 *
s
;

1972 
	`fush
(
dout
);

1973 
	`tf
("\n%*s\n%*s\n", 
cumn
, "^", cumn, 
s
);

1974 
	}
}

	@cl-standard.tab.h

1 #ide
YY_r_h_uded


2 
	#YY_r_h_uded


	)

7 #ifde
c_ulus


8 #ide
__lulus


9 
	#__lulus


	)

18 #ide
YY_r_COMPATIBILITY


19 #ide
YY_USE_CLASS


20 
	#YY_r_COMPATIBILITY
 1

	)

22 
	#YY_r_COMPATIBILITY
 0

	)

26 #i
YY_r_COMPATIBILITY
 != 0

28 #ifde
YYLTYPE


29 #ide
YY_r_LTYPE


30 
	#YY_r_LTYPE
 
YYLTYPE


	)

36 #ide
YY_r_STYPE


37 
	#YY_r_STYPE
 
YYSTYPE


	)

42 #ifde
YYDEBUG


43 #ide
YY_r_DEBUG


44 
	#YY_r_DEBUG
 
YYDEBUG


	)

50 #ide
YY_r_USE_GOTO


51 
	#YY_r_USE_GOTO
 1

	)

56 #ide
YY_r_USE_GOTO


57 
	#YY_r_USE_GOTO
 0

	)

60 #ide
YY_r_PURE


70 #ide
YY_USE_CLASS


71 #ide
YYSTYPE


72 
	#YYSTYPE
 

	)

73 
	#YYSTYPE_IS_TRIVIAL
 1

	)

80 #ide
YY_r_DEBUG


88 #ide
YY_r_LSP_NEEDED


97 #ifde
YY_r_LSP_NEEDED


98 #ide
YY_r_LTYPE


99 #ide
BISON_YYLTYPE_ISDECLARED


100 
	#BISON_YYLTYPE_ISDECLARED


	)

102 
	syyy


104 
	mtimeamp
;

105 
	mf_le
;

106 
	mf_cumn
;

107 
	mϡ_le
;

108 
	mϡ_cumn
;

109 *
	mxt
;

111 
	tyyy
;

114 
	#YY_r_LTYPE
 
yyy


	)

119 #ide
YY_r_STYPE


120 
	#YY_r_STYPE
 

	)

124 #ide
YY_r_PARSE


125 
	#YY_r_PARSE
 
yyr


	)

128 #ide
YY_r_LEX


129 
	#YY_r_LEX
 
yyx


	)

132 #ide
YY_r_LVAL


133 
	#YY_r_LVAL
 
yylv


	)

136 #ide
YY_r_LLOC


137 
	#YY_r_LLOC
 
yyoc


	)

140 #ide
YY_r_CHAR


141 
	#YY_r_CHAR
 
yych


	)

144 #ide
YY_r_NERRS


145 
	#YY_r_NERRS
 
yyüs


	)

148 #ide
YY_r_DEBUG_FLAG


149 
	#YY_r_DEBUG_FLAG
 
yydebug


	)

152 #ide
YY_r_ERROR


153 
	#YY_r_ERROR
 
yyr


	)

156 #ide
YY_r_PARSE_PARAM


157 #ide
__STDC__


158 #ide
__lulus


159 #ide
YY_USE_CLASS


160 
	#YY_r_PARSE_PARAM


	)

161 #ide
YY_r_PARSE_PARAM_DEF


162 
	#YY_r_PARSE_PARAM_DEF


	)

167 #ide
YY_r_PARSE_PARAM


168 
	#YY_r_PARSE_PARAM
 

	)

173 #ide
YY_USE_CLASS


175 #ide
YY_r_PURE


176 #ide
yylv


177 
YY_r_STYPE
 
YY_r_LVAL
;

179 #i
yylv
 !
YY_r_LVAL


180 
YY_r_STYPE
 
YY_r_LVAL
;

189 
	#IDENTIFIER
 258

	)

190 
	#CONSTANT
 259

	)

191 
	#STRING_LITERAL
 260

	)

192 
	#SIZEOF
 261

	)

193 
	#PTR_OP
 262

	)

194 
	#INC_OP
 263

	)

195 
	#DEC_OP
 264

	)

196 
	#LEFT_OP
 265

	)

197 
	#RIGHT_OP
 266

	)

198 
	#LE_OP
 267

	)

199 
	#GE_OP
 268

	)

200 
	#EQ_OP
 269

	)

201 
	#NE_OP
 270

	)

202 
	#AND_OP
 271

	)

203 
	#OR_OP
 272

	)

204 
	#MUL_ASSIGN
 273

	)

205 
	#DIV_ASSIGN
 274

	)

206 
	#MOD_ASSIGN
 275

	)

207 
	#ADD_ASSIGN
 276

	)

208 
	#SUB_ASSIGN
 277

	)

209 
	#LEFT_ASSIGN
 278

	)

210 
	#RIGHT_ASSIGN
 279

	)

211 
	#AND_ASSIGN
 280

	)

212 
	#XOR_ASSIGN
 281

	)

213 
	#OR_ASSIGN
 282

	)

214 
	#TYPE_NAME
 283

	)

215 
	#TYPEDEF
 284

	)

216 
	#EXTERN
 285

	)

217 
	#STATIC
 286

	)

218 
	#AUTO
 287

	)

219 
	#REGISTER
 288

	)

220 
	#CHAR
 289

	)

221 
	#SHORT
 290

	)

222 
	#INT
 291

	)

223 
	#LONG
 292

	)

224 
	#SIGNED
 293

	)

225 
	#UNSIGNED
 294

	)

226 
	#FLOAT
 295

	)

227 
	#DOUBLE
 296

	)

228 
	#CONST
 297

	)

229 
	#VOLATILE
 298

	)

230 
	#VOID
 299

	)

231 
	#STRUCT
 300

	)

232 
	#UNION
 301

	)

233 
	#ENUM
 302

	)

234 
	#ELLIPSIS
 303

	)

235 
	#CASE
 304

	)

236 
	#DEFAULT
 305

	)

237 
	#IF
 306

	)

238 
	#ELSE
 307

	)

239 
	#SWITCH
 308

	)

240 
	#WHILE
 309

	)

241 
	#DO
 310

	)

242 
	#FOR
 311

	)

243 
	#GOTO
 312

	)

244 
	#CONTINUE
 313

	)

245 
	#BREAK
 314

	)

246 
	#RETURN
 315

	)

253 #ide
YY_r_CLASS


254 
	#YY_r_CLASS
 
r


	)

257 #ide
YY_r_INHERIT


258 
	#YY_r_INHERIT


	)

261 #ide
YY_r_MEMBERS


262 
	#YY_r_MEMBERS


	)

265 #ide
YY_r_LEX_BODY


266 
	#YY_r_LEX_BODY


	)

269 #ide
YY_r_ERROR_BODY


270 
	#YY_r_ERROR_BODY


	)

273 #ide
YY_r_CONSTRUCTOR_PARAM


274 
	#YY_r_CONSTRUCTOR_PARAM


	)

277 #ide
YY_r_USE_CONST_TOKEN


278 
	#YY_r_USE_CONST_TOKEN
 0

	)

282 #i
YY_r_USE_CONST_TOKEN
 != 0

283 #ide
YY_r_ENUM_TOKEN


284 
	#YY_r_ENUM_TOKEN
 
yy_r_um_tok


	)

288 as
	cYY_r_CLASS
 
	mYY_r_INHERIT


290 
	mpublic
:

291 #i
YY_r_USE_CONST_TOKEN
 != 0

295 cڡ 
IDENTIFIER
;

296 cڡ 
	mCONSTANT
;

297 cڡ 
	mSTRING_LITERAL
;

298 cڡ 
	mSIZEOF
;

299 cڡ 
	mPTR_OP
;

300 cڡ 
	mINC_OP
;

301 cڡ 
	mDEC_OP
;

302 cڡ 
	mLEFT_OP
;

303 cڡ 
	mRIGHT_OP
;

304 cڡ 
	mLE_OP
;

305 cڡ 
	mGE_OP
;

306 cڡ 
	mEQ_OP
;

307 cڡ 
	mNE_OP
;

308 cڡ 
	mAND_OP
;

309 cڡ 
	mOR_OP
;

310 cڡ 
	mMUL_ASSIGN
;

311 cڡ 
	mDIV_ASSIGN
;

312 cڡ 
	mMOD_ASSIGN
;

313 cڡ 
	mADD_ASSIGN
;

314 cڡ 
	mSUB_ASSIGN
;

315 cڡ 
	mLEFT_ASSIGN
;

316 cڡ 
	mRIGHT_ASSIGN
;

317 cڡ 
	mAND_ASSIGN
;

318 cڡ 
	mXOR_ASSIGN
;

319 cڡ 
	mOR_ASSIGN
;

320 cڡ 
	mTYPE_NAME
;

321 cڡ 
	mTYPEDEF
;

322 cڡ 
	mEXTERN
;

323 cڡ 
	mSTATIC
;

324 cڡ 
	mAUTO
;

325 cڡ 
	mREGISTER
;

326 cڡ 
	mCHAR
;

327 cڡ 
	mSHORT
;

328 cڡ 
	mINT
;

329 cڡ 
	mLONG
;

330 cڡ 
	mSIGNED
;

331 cڡ 
	mUNSIGNED
;

332 cڡ 
	mFLOAT
;

333 cڡ 
	mDOUBLE
;

334 cڡ 
	mCONST
;

335 cڡ 
	mVOLATILE
;

336 cڡ 
	mVOID
;

337 cڡ 
	mSTRUCT
;

338 cڡ 
	mUNION
;

339 cڡ 
	mENUM
;

340 cڡ 
	mELLIPSIS
;

341 cڡ 
	mCASE
;

342 cڡ 
	mDEFAULT
;

343 cڡ 
	mIF
;

344 cڡ 
	mELSE
;

345 cڡ 
	mSWITCH
;

346 cڡ 
	mWHILE
;

347 cڡ 
	mDO
;

348 cڡ 
	mFOR
;

349 cڡ 
	mGOTO
;

350 cڡ 
	mCONTINUE
;

351 cڡ 
	mBREAK
;

352 cڡ 
	mRETURN
;

358 
	eYY_r_ENUM_TOKEN
 { 
	mYY_r_NULL_TOKEN
=0

361 ,
	mIDENTIFIER
=258

362 ,
	mCONSTANT
=259

363 ,
	mSTRING_LITERAL
=260

364 ,
	mSIZEOF
=261

365 ,
	mPTR_OP
=262

366 ,
	mINC_OP
=263

367 ,
	mDEC_OP
=264

368 ,
	mLEFT_OP
=265

369 ,
	mRIGHT_OP
=266

370 ,
	mLE_OP
=267

371 ,
	mGE_OP
=268

372 ,
	mEQ_OP
=269

373 ,
	mNE_OP
=270

374 ,
	mAND_OP
=271

375 ,
	mOR_OP
=272

376 ,
	mMUL_ASSIGN
=273

377 ,
	mDIV_ASSIGN
=274

378 ,
	mMOD_ASSIGN
=275

379 ,
	mADD_ASSIGN
=276

380 ,
	mSUB_ASSIGN
=277

381 ,
	mLEFT_ASSIGN
=278

382 ,
	mRIGHT_ASSIGN
=279

383 ,
	mAND_ASSIGN
=280

384 ,
	mXOR_ASSIGN
=281

385 ,
	mOR_ASSIGN
=282

386 ,
	mTYPE_NAME
=283

387 ,
	mTYPEDEF
=284

388 ,
	mEXTERN
=285

389 ,
	mSTATIC
=286

390 ,
	mAUTO
=287

391 ,
	mREGISTER
=288

392 ,
	mCHAR
=289

393 ,
	mSHORT
=290

394 ,
	mINT
=291

395 ,
	mLONG
=292

396 ,
	mSIGNED
=293

397 ,
	mUNSIGNED
=294

398 ,
	mFLOAT
=295

399 ,
	mDOUBLE
=296

400 ,
	mCONST
=297

401 ,
	mVOLATILE
=298

402 ,
	mVOID
=299

403 ,
	mSTRUCT
=300

404 ,
	mUNION
=301

405 ,
	mENUM
=302

406 ,
	mELLIPSIS
=303

407 ,
	mCASE
=304

408 ,
	mDEFAULT
=305

409 ,
	mIF
=306

410 ,
	mELSE
=307

411 ,
	mSWITCH
=308

412 ,
	mWHILE
=309

413 ,
	mDO
=310

414 ,
	mFOR
=311

415 ,
	mGOTO
=312

416 ,
	mCONTINUE
=313

417 ,
	mBREAK
=314

418 ,
	mRETURN
=315

425 
	gpublic
:

426 
YY_r_PARSE
(
YY_r_PARSE_PARAM
);

427 
vtu
 
	$YY_r_ERROR
(*
msg

YY_r_ERROR_BODY
;

428 #ifde
YY_r_PURE


429 #ifde
YY_r_LSP_NEEDED


430 
vtu
 
	$YY_r_LEX
(
YY_r_STYPE
 *
YY_r_LVAL
,
YY_r_LTYPE
 *
YY_r_LLOC

YY_r_LEX_BODY
;

432 
vtu
 
	$YY_r_LEX
(
YY_r_STYPE
 *
YY_r_LVAL

YY_r_LEX_BODY
;

435 
vtu
 
	$YY_r_LEX
(
YY_r_LEX_BODY
;

436 
YY_r_STYPE
 
YY_r_LVAL
;

437 #ifde
YY_r_LSP_NEEDED


438 
YY_r_LTYPE
 
YY_r_LLOC
;

440 
YY_r_NERRS
;

441 
YY_r_CHAR
;

443 #i
YY_r_DEBUG
 != 0

444 
public
:

445 
YY_r_DEBUG_FLAG
;

447 
public
:

448 
	`YY_r_CLASS
(
YY_r_CONSTRUCTOR_PARAM
);

449 
public
:

450 
YY_r_MEMBERS


451 
	}
};

456 #i
YY_r_COMPATIBILITY
 != 0

463 #ide
YYLTYPE


464 
	#YYLTYPE
 
YY_r_LTYPE


	)

466 #ide
YYDEBUG


467 #ifde
YY_r_DEBUG


468 
	#YYDEBUG
 
YY_r_DEBUG


	)

	@cl-standard.y

9 
	#YYDEBUG
 1

	)

10 
yydebug
;

11 
lo
;

12 
cumn
;

14 
	gid
[128];

15 
	gi_tydef
 = 0;

16 
	gi_side_su
 = 0;

17 
	gi_ru__uni
 = 0;

18 
	go_to_ru__uni
 = 0;

19 
	gdump
 = 0;

21 
	$ydef
()

23 
i_tydef
 = 1;

24  
i_tydef
;

25 
	}
}

27 
	$t__ru
 ()

29 
yydebug
 = 0;

30 
i_ru__uni
 ++;

31 
o_to_ru__uni
 = 1;

32 
	}
}

33 
	$r_o_to_ru__uni
()

35 
o_to_ru__uni
 = 0;

36 
	}
}

38 
	$r__ru
 ()

40 
i_ru__uni
 --;

41 
yydebug
 = 0;

42 
	}
}

46 %
tok
 
INCLUDE_FLAG
 
LINE
 
FILENAME
 
INLINE


47 %
tok
 
IDENTIFIER
 
CONSTANT
 
STRING_LITERAL
 
SIZEOF


48 %
tok
 
PTR_OP
 
INC_OP
 
DEC_OP
 
LEFT_OP
 
RIGHT_OP
 
LE_OP
 
GE_OP
 
EQ_OP
 
NE_OP


49 %
tok
 
AND_OP
 
OR_OP
 
MUL_ASSIGN
 
DIV_ASSIGN
 
MOD_ASSIGN
 
ADD_ASSIGN


50 %
tok
 
SUB_ASSIGN
 
LEFT_ASSIGN
 
RIGHT_ASSIGN
 
AND_ASSIGN


51 %
tok
 
XOR_ASSIGN
 
OR_ASSIGN
 
TYPE_NAME


53 %
tok
 
TYPEDEF
 
EXTERN
 
STATIC
 
AUTO
 
REGISTER


54 %
tok
 
CHAR
 
SHORT
 
INT
 
LONG
 
SIGNED
 
UNSIGNED
 
FLOAT
 
DOUBLE
 
CONST
 
VOLATILE
 
VOID


55 %
tok
 
STRUCT
 
UNION
 
ENUM
 
ELLIPSIS


57 %
tok
 
CASE
 
DEFAULT
 
IF
 
ELSE
 
SWITCH
 
WHILE
 
DO
 
FOR
 
GOTO
 
CONTINUE
 
BREAK
 
RETURN


59 %
t
 
i_un


60 %% /* 
	$yyr
 */ 
	`yyx
()

62 
imy_exessi


63 : 
IDENTIFIER


64 | 
CONSTANT


65 | 
STRING_LITERAL


66 | '(' 
exessi
 ')'

69 
ross_ude_hd_fe


70 : 
INCLUDE_FLAG


76 
pofix_exessi


77 : 
imy_exessi


78 | 
pofix_exessi
 '[' 
exessi
 ']'

79 | 
pofix_exessi
 '(' ')'

80 | 
pofix_exessi
 '(' 
gumt_exessi_li
 ')'

81 | 
pofix_exessi
 '.' 
IDENTIFIER


82 | 
pofix_exessi
 
PTR_OP
 
IDENTIFIER


83 | 
pofix_exessi
 
INC_OP


84 | 
pofix_exessi
 
DEC_OP


87 
gumt_exessi_li


88 : 
assignmt_exessi


89 | 
gumt_exessi_li
 ',' 
assignmt_exessi


92 
ury_exessi


93 : 
pofix_exessi


94 | 
INC_OP
 
ury_exessi


95 | 
DEC_OP
 
ury_exessi


96 | 
ury_ݔ
 
_exessi


97 | 
SIZEOF
 
ury_exessi


98 | 
SIZEOF
 '(' 
ty_me
 ')'

101 
ury_ݔ


110 
_exessi


111 : 
ury_exessi


112 | '(' 
ty_me
 ')' 
_exessi


115 
muɝlitive_exessi


116 : 
_exessi


117 | 
muɝlitive_exessi
 '*' 
_exessi


118 | 
muɝlitive_exessi
 '/' 
_exessi


119 | 
muɝlitive_exessi
 '%' 
_exessi


122 
addive_exessi


123 : 
muɝlitive_exessi


124 | 
addive_exessi
 '+' 
muɝlitive_exessi


125 | 
addive_exessi
 '-' 
muɝlitive_exessi


128 
shi_exessi


129 : 
addive_exessi


130 | 
shi_exessi
 
LEFT_OP
 
addive_exessi


131 | 
shi_exessi
 
RIGHT_OP
 
addive_exessi


134 
tiڮ_exessi


135 : 
shi_exessi


136 | 
tiڮ_exessi
 '<' 
shi_exessi


137 | 
tiڮ_exessi
 '>' 
shi_exessi


138 | 
tiڮ_exessi
 
LE_OP
 
shi_exessi


139 | 
tiڮ_exessi
 
GE_OP
 
shi_exessi


142 
equy_exessi


143 : 
tiڮ_exessi


144 | 
equy_exessi
 
EQ_OP
 
tiڮ_exessi


145 | 
equy_exessi
 
NE_OP
 
tiڮ_exessi


148 
d_exessi


149 : 
equy_exessi


150 | 
d_exessi
 '&' 
equy_exessi


153 
exusive__exessi


154 : 
d_exessi


155 | 
exusive__exessi
 '^' 
d_exessi


158 
usive__exessi


159 : 
exusive__exessi


160 | 
usive__exessi
 '|' 
exusive__exessi


163 
logil_d_exessi


164 : 
usive__exessi


165 | 
logil_d_exessi
 
AND_OP
 
usive__exessi


168 
logil__exessi


169 : 
logil_d_exessi


170 | 
logil__exessi
 
OR_OP
 
logil_d_exessi


173 
cdiڮ_exessi


174 : 
logil__exessi


175 | 
logil__exessi
 '?' 
exessi
 ':' 
cdiڮ_exessi


178 
assignmt_exessi


179 : 
cdiڮ_exessi


180 | 
ury_exessi
 
assignmt_ݔ
 
assignmt_exessi


183 
assignmt_ݔ


185 | 
MUL_ASSIGN


186 | 
DIV_ASSIGN


187 | 
MOD_ASSIGN


188 | 
ADD_ASSIGN


189 | 
SUB_ASSIGN


190 | 
LEFT_ASSIGN


191 | 
RIGHT_ASSIGN


192 | 
AND_ASSIGN


193 | 
XOR_ASSIGN


194 | 
OR_ASSIGN


197 
exessi


198 : 
assignmt_exessi


199 | 
exessi
 ',' 
assignmt_exessi


202 
cڡt_exessi


203 : 
cdiڮ_exessi


206 
dei


207 : 
dei_ecifrs
 ';'

208 | 
dei_ecifrs
 
_de_li
 ';' { \

209 i(
i_tydef
) {

210 
	`tf
 ("[[TYPENAME:%s]]", 
id
); 
i_tydef
=0;

211 
	`__tydef
 (
id
, 
lo
, 
cumn
);

216 
dei_ecifrs


217 : 
age_ass_ecifr


218 | 
age_ass_ecifr
 
dei_ecifrs


219 | 
ty_ecifr


220 | 
ty_ecifr
 
dei_ecifrs


221 | 
ty_quifr


222 | 
ty_quifr
 
dei_ecifrs


225 
_de_li


226 : 
_de


227 | 
_de_li
 ',' 
_de


230 
_de


231 : 
de
 { 
	`tf
 ("(D1:%s:%d)", 
id
,
i_tydef
); }

232 | 
de
 { 
	`tf
 ("(D2)"); } '=' 
liz


235 
age_ass_ecifr


236 : 
TYPEDEF
 { 
	`ydef
(); }

237 | 
EXTERN


238 | 
STATIC


239 | 
AUTO


240 | 
REGISTER


241 | 
INLINE


244 
ty_ecifr


245 : 
VOID


246 | 
CHAR


247 | 
SHORT


248 | 
INT


249 | 
LONG


250 | 
FLOAT


251 | 
DOUBLE


252 | 
SIGNED


253 | 
UNSIGNED


254 | 
ru__uni_ecifr


255 | 
um_ecifr


256 | 
TYPE_NAME


259 
ru__uni_ecifr


260 : 
ru__uni
 
IDENTIFIER
 {
	`r_o_to_ru__uni
(); } '{' {
i_side_su
=1; } 
ru_dei_li
 '}' { 
	`r__ru
(); i_inside_su = 0; }

261 | 
ru__uni
 '{' { 
	`r_o_to_ru__uni
(); 
i_side_su
=1;} 
ru_dei_li
 '}' { 
	`r__ru
(); i_inside_su=0;}

262 | 
ru__uni
 
IDENTIFIER
 { 
	`r_o_to_ru__uni
(); 
	`r__ru
(); }

265 
ru__uni


266 : 
STRUCT
 { 
	`t__ru
(); }

267 | 
UNION
 { 
	`t__ru
(); }

270 
ru_dei_li


271 : 
ru_dei


272 | 
ru_dei_li
 
ru_dei


275 
ru_dei


276 : 
ecifr_quifr_li
 
ru_de_li
 ';'

279 
ecifr_quifr_li


280 : 
ty_ecifr
 
ecifr_quifr_li


281 | 
ty_ecifr


282 | 
ty_quifr
 
ecifr_quifr_li


283 | 
ty_quifr


286 
ru_de_li


287 : 
ru_de


288 | 
ru_de_li
 ',' 
ru_de


291 
ru_de


292 : 
de


293 | ':' 
cڡt_exessi


294 | 
de
 ':' 
cڡt_exessi


297 
um_ecifr


298 : 
ENUM
 '{' 
um_li
 '}'

299 | 
ENUM
 '{' 
um_li
 ',' '}'

300 | 
ENUM
 
IDENTIFIER
 '{' 
um_li
 '}'

301 | 
ENUM
 
IDENTIFIER
 '{' 
um_li
 ',' '}'

302 | 
ENUM
 
IDENTIFIER


305 
um_li


306 : 
um


307 | 
um_li
 ',' 
um


311 
um


312 : 
IDENTIFIER


313 | 
IDENTIFIER
 '=' 
cڡt_exessi


316 
ty_quifr


317 : 
CONST


318 | 
VOLATILE


321 
de


322 : 
por
 
de_de


323 | 
de_de


329 
de_de


330 : 
IDENTIFIER


331 | '(' 
de
 ')' { \

332 i(
i_tydef
 && !
i_ru__uni
) {

333 
	`tf
("TYPENAME:FUNC:(%s)", 
id
);

334 
i_tydef
=0;

335 
	`__tydef
 (
id
, 
lo
, 
cumn
);

338 | 
de_de
 '[' 
cڡt_exessi
 ']'

339 | 
de_de
 '[' ']'

340 | 
de_de
 '(' 
m_ty_li
 ')'

341 | 
de_de
 '(' 
idtifr_li
 ')'

342 | 
de_de
 '(' ')'

345 
por


347 | '*' 
ty_quifr_li


348 | '*' 
por


349 | '*' 
ty_quifr_li
 
por


352 
ty_quifr_li


353 : 
ty_quifr


354 | 
ty_quifr_li
 
ty_quifr


358 
m_ty_li


359 : 
m_li


360 | 
m_li
 ',' 
ELLIPSIS


363 
m_li


364 : 
m_dei


365 | 
m_li
 ',' 
m_dei


368 
m_dei


369 : 
dei_ecifrs
 
de


370 | 
dei_ecifrs
 
ab_de


371 | 
dei_ecifrs


374 
idtifr_li


375 : 
IDENTIFIER


376 | 
idtifr_li
 ',' 
IDENTIFIER


379 
ty_me


380 : 
ecifr_quifr_li


381 | 
ecifr_quifr_li
 
ab_de


384 
ab_de


385 : 
por


386 | 
de_ab_de


387 | 
por
 
de_ab_de


390 
de_ab_de


391 : '(' 
ab_de
 ')'

393 | '[' 
cڡt_exessi
 ']'

394 | 
de_ab_de
 '[' ']'

395 | 
de_ab_de
 '[' 
cڡt_exessi
 ']'

397 | '(' 
m_ty_li
 ')'

398 | 
de_ab_de
 '(' ')'

399 | 
de_ab_de
 '(' 
m_ty_li
 ')'

402 
liz


403 : 
assignmt_exessi


404 | '{' 
liz_li
 '}'

405 | '{' 
liz_li
 ',' '}'

408 
liz_li


409 : 
liz


410 | 
liz_li
 ',' 
liz


413 
emt


414 : 
bed_emt


415 | 
compound_emt


416 | 
exessi_emt


417 | 
i_emt


418 | 
i_emt


419 | 
jump_emt


422 
bed_emt


423 : 
IDENTIFIER
 ':' 
emt


424 | 
CASE
 
cڡt_exessi
 ':' 
emt


425 | 
DEFAULT
 ':' 
emt


428 
compound_emt


430 | '{' 
emt_li
 '}'

431 | '{' 
dei_li
 '}'

432 | '{' 
dei_li
 
emt_li
 '}'

435 
dei_li


436 : 
dei


437 | 
dei_li
 
dei


440 
emt_li


441 : 
emt


442 | 
emt_li
 
emt


445 
exessi_emt


447 | 
exessi
 ';'

450 
i_emt


451 : 
IF
 '(' 
exessi
 ')' 
emt


452 | 
IF
 '(' 
exessi
 ')' 
emt
 
ELSE
 statement

453 | 
SWITCH
 '(' 
exessi
 ')' 
emt


456 
i_emt


457 : 
WHILE
 '(' 
exessi
 ')' 
emt


458 | 
DO
 
emt
 
WHILE
 '(' 
exessi
 ')' ';'

459 | 
FOR
 '(' 
exessi_emt
xessi_em')' 
emt


460 | 
FOR
 '(' 
exessi_emt
xessi_em
exessi
 ')' 
emt


463 
jump_emt


464 : 
GOTO
 
IDENTIFIER
 ';'

465 | 
CONTINUE
 ';'

466 | 
BREAK
 ';'

467 | 
RETURN
 ';'

468 | 
RETURN
 
exessi
 ';'

471 
i_un


472 : 
ex_dei


473 | 
i_un
 
ex_dei


474 | 
ross_ude_hd_fe


475 | 
i_un
 
ross_ude_hd_fe


478 
ex_dei


479 : 
funi_defi


480 | 
dei


483 
funi_defi


484 : 
dei_ecifrs
 
de
 
dei_li
 
compound_emt


485 | 
dei_ecifrs
 
de
 
compound_emt


486 | 
de
 
dei_li
 
compound_emt


487 | 
de
 
compound_emt


490 
	}
%%

491 
	~<dio.h
>

493 
cumn
;

495 
	$yyr
(
s
)

496 *
s
;

498 
	`fush
(
dout
);

499 
	`tf
("\n%*s\n%*e(%d):cumn(%d):symb(%s)\n", 
cumn
, "^", cumn, 
s
, 
lo
, cumn, 
id
);

500 
	`tf
("i_tydef(%d)i_ru__uni(%d)i_side_su(%d)dump(%d)yylv(%d)o(%d)\n", 
i_tydef
, 
i_ru__uni
, 
i_side_su
, 
dump
, 
yylv
, 
o_to_ru__uni
);

501 
	}
}

503 
	$ma
 ()

505 
yydebug
 = 0;

506 
	`yyr
();

507 
	`t_
();

508 
	`a_b
();

509 
	`a_tydef_b
();

510 
	}
}

	@hello.c

1 
	~<dio.h
>

2 
	~<rg.h
>

9 
	mhlo1
,

10 
	mwd1
,

11 } 
	tLED_ST1
;

14 
__le
 cڡ *
	$CTD_SE
(
code
)

16 
i
;

17 
	}
}

18 
	sudt_fo
 {

19 
	mme
[128];

20 
	mage
;

21 
	msce
;

22 
udt_fo
 *
	mp
;

25 
	sudt
 {

26 
	mage
;

27 
	mme
[16];

28 } 
	tudt
;

30 
	tmyt
;

32 
	$ma
 (
gc
, ** 
gv
)

34 
ock
;

35 
ii
 = 0;

36 cڡ 
iii
;

37 
kk
;

38 
myt
 
iiii
;

39 
udt
 
sss
;

41 
	sock
 {

42 
i
;

43 
c
;

44 }
ock
;

45 
age
 = 0;

47 
	`tf
 ("Hello world\n(%*s)\n", 60, "fuck");

48 
	`tf
 ("(%*s)\n", 60, "fiiiiiiiiiiiiiiiiuck");

51 
	}
}

53 (
	tmyfunc
)(
	ti
, 
	tc
);

54 
t_evt
 
	tt_evt
;

55 
	st_evt
 {

56 
a
;

57 }
	tkkk
;

59 
	$f
()

61 
kkk
 
mykkk
;

62 
	`tf
 ("sigh");

64 
	}
}

66 
mys
 
	tmys
;

67 
	smys
 {

68 
mys
 *
	mpNext
;

69 
	smyss
 {

70 
	mn
;

71 
	mcc
;

72 }
	mdddddddd
;

73 
kkk
 
	mn
;

	@symtab.c

11 
	~<dio.h
>

12 
	~<dlib.h
>

13 
	~<rg.h
>

14 
	~"symb.h
"

17 
	#SIZE
 211

	)

22 
	#SHIFT
 4

	)

26 
	$hash
(*
key
)

28 
mp
 = 0;

29 
i
 = 0;

30 
key
[
i
] != '\0') {

31 
mp
 = (em<< 
SHIFT
+ 
key
[
i
]% 
SIZE
;

32 ++
i
;

34  
mp
;

35 
	}
}

42 
	sLeLiRec
 {

43 
	mlo
;

44 
LeLiRec
 *
	mxt
;

45 } *
	tLeLi
;

52 
	sBuckLiRec
 {

53 
	mme
[126];

54 
LeLi
 
	mles
;

55 
	mmemloc
;

56 
BuckLiRec
 *
	mxt
;

57 
	mfunc
[126];

58 
	mdty
;

59 } *
	tBuckLi
;

62 
	gved_func_me
 [1024];

65 
BuckLi
 
	ghashTab
[
SIZE
];

66 
BuckLi
 
	gtydefNameTab
[
SIZE
];

74 
	$__id
 (*
me
, 
lo
, 
loc
)

76 
h
 = 
	`hash
(
me
);

77 
BuckLi
 
l
 = 
hashTab
[
h
];

79 (
l
 !
NULL
)

81 (
	`rcmp
(
me
, 
l
->name) != 0) ||

82 (
	`rcmp
(
ved_func_me
, 
l
->
func
) != 0)

86 
l
 =->
xt
;

88 i(
l
 =
NULL
) {

89 
l
 = (
BuckLi

	`mloc
((
BuckLiRec
));

90 i(!
l
) {

91 
	`tf
 ("st_insert: malloc failed");

94 
l
->
me
 =ame;

96 
	`rtf
 (
l
->
me
, "%s",ame);

98 
l
->
les
 = (
LeLi

	`mloc
((
LeLiRec
));

99 i(!(
l
->
les
)) {

100 
	`tf
 ("st_insert: malloc failed,->lines");

102 
l
->
les
->
lo
 =ineno;

103 
l
->
memloc
 = 
loc
;

104 
l
->
les
->
xt
 = 
NULL
;

105 
l
->
dty
 = 1;

106 
	`rtf
 (
l
->
func
, "%s", 
ved_func_me
);

107 
l
->
xt
 = 
hashTab
[
h
];

108 
hashTab
[
h
] = 
l
;

110 
LeLi
 
t
 = 
l
->
les
;

111 
t
->
xt
 !
NULL
)

112 
t
 =->
xt
;

113 
t
->
xt
 = (
LeLi

	`mloc
((
LeLiRec
));

114 i(!(
t
->
xt
)) {

115 
	`tf
 ("st_insert: malloc failed,->next");

117 
t
->
xt
->
lo
 =ineno;

118 
t
->
xt
->x
NULL
;

120 
	}
}

124 
	$__tydef
 (*
me
, 
lo
, 
loc
)

126 
h
 = 
	`hash
(
me
);

127 
BuckLi
 
l
 = 
tydefNameTab
[
h
];

129 (
l
 !
NULL
)

131 (
	`rcmp
(
me
, 
l
->name) != 0) ||

132 (
	`rcmp
(
ved_func_me
, 
l
->
func
) != 0)

136 
l
 =->
xt
;

138 i(
l
 =
NULL
) {

139 
l
 = (
BuckLi

	`mloc
((
BuckLiRec
));

140 i(!(
l
)) {

141 
	`tf
 ("st_insert_typedef: malloc failed,");

144 
l
->
me
 =ame;

146 
	`rtf
 (
l
->
me
, "%s",ame);

148 
l
->
les
 = (
LeLi

	`mloc
((
LeLiRec
));

149 i(!(
l
->
les
)) {

150 
	`tf
 ("st_insert_typedef: malloc failed,->lines");

152 
l
->
les
->
lo
 =ineno;

153 
l
->
memloc
 = 
loc
;

154 
l
->
les
->
xt
 = 
NULL
;

155 
l
->
dty
 = 1;

156 
	`rtf
 (
l
->
func
, "%s", 
ved_func_me
);

157 
l
->
xt
 = 
tydefNameTab
[
h
];

158 
tydefNameTab
[
h
] = 
l
;

160 
LeLi
 
t
 = 
l
->
les
;

161 
t
->
xt
 !
NULL
)

162 
t
 =->
xt
;

163 
t
->
xt
 = (
LeLi

	`mloc
((
LeLiRec
));

164 i(!(
l
->
xt
)) {

165 
	`tf
 ("st_insert_typedef: malloc failed,->next");

167 
t
->
xt
->
lo
 =ineno;

168 
t
->
xt
->x
NULL
;

170 
	}
}

181 
	gBuckLi


183 
	$_lookup
(*
me
)

185 
h
 = 
	`hash
(
me
);

186 
BuckLi
 
l
 = 
hashTab
[
h
];

188 (
l
 !
NULL
)

189 && ((
	`rcmp
(
me
, 
l
->name) != 0) ||

190 ((
	`rcmp
(
ved_func_me
, 
l
->
func
) != 0))))

192 
l
 =->
xt
;

194 i(
l
 =
NULL
)

198  
NULL
;

202  
l
->
memloc
;

204  
l
;

206 
	}
}

209 
BuckLi


210 
	$_lookup_tydef
(*
me
)

212 
h
 = 
	`hash
(
me
);

213 
BuckLi
 
l
 = 
tydefNameTab
[
h
];

215 (
l
 !
NULL
)

216 && ((
	`rcmp
(
me
, 
l
->name) != 0)))

218 
l
 =->
xt
;

220 i(
l
 =
NULL
)

221  
NULL
;

223  
l
;

224 
	}
}

234 
	$tSymTab
(
FILE
 * 
lig
)

236 
i
;

237 
	`rtf
(
lig
, "Variable Name Location Domain Line Numbers\n");

238 
	`rtf
(
lig
, "-------------- -------- -------------- ------------\n");

239 
i
 = 0; i < 
SIZE
; ++i) {

240 i(
hashTab
[
i
] !
NULL
) {

241 
BuckLi
 
l
 = 
hashTab
[
i
];

242 
l
 !
NULL
) {

243 
LeLi
 
t
 = 
l
->
les
;

244 
	`rtf
(
lig
, "%+14", 
l
->
me
);

245 
	`rtf
(
lig
, "%+8d ", 
l
->
memloc
);

246 
	`rtf
(
lig
, "%+14", 
l
->
func
);

247 
t
 !
NULL
) {

248 
	`rtf
(
lig
, "%+12d ", 
t
->
lo
);

249 
t
 =->
xt
;

251 
	`rtf
(
lig
, "\n");

252 
l
 =->
xt
;

256 
	}
}

261 
	$tTydefTab
(
FILE
 * 
lig
)

263 
i
;

264 
	`rtf
(
lig
, "Typedef Name Location Domain Line Numbers\n");

265 
	`rtf
(
lig
, "------------------------------ -------- -------------- ------------\n");

266 
i
 = 0; i < 
SIZE
; ++i) {

267 i(
tydefNameTab
[
i
] !
NULL
) {

268 
BuckLi
 
l
 = 
tydefNameTab
[
i
];

269 
l
 !
NULL
) {

270 
LeLi
 
t
 = 
l
->
les
;

271 
	`rtf
(
lig
, "%+29", 
l
->
me
);

272 
	`rtf
(
lig
, "%+8d ", 
l
->
memloc
);

273 
	`rtf
(
lig
, "%+14", 
l
->
func
);

274 
t
 !
NULL
) {

275 
	`rtf
(
lig
, "%+12d ", 
t
->
lo
);

276 
t
 =->
xt
;

278 
	`rtf
(
lig
, "\n");

279 
l
 =->
xt
;

283 
	}
}

286 
	$a_b
 ()

288 
i
 = 0;

289 
BuckLi
 
b1
 = 
NULL
, 
b2
 = NULL;

290 
LeLi
 
l1
 = 
NULL
, 
l2
 = NULL;

292 
i
 = 0; i < 
SIZE
; i ++) {

293 
b1
 = 
hashTab
[
i
];

294 
b1
 !
NULL
) {

295 i(
NULL
 !
b1
->
xt
)

297 
b2
 = 
b1
->
xt
;

299 
b2
 = 
NULL
;

305 
l1
 = 
b1
->
les
;

308 i(
NULL
 =
l1
) {

309 
buck
;

311 i(
NULL
 !
l1
->
xt
)

313 
l2
 = 
l1
->
xt
;

315 
l2
 = 
NULL
;

317 
	`
 (
l1
);

318 
l1
 = 
l2
;

321 
buck
:

322 
	`
 (
b1
);

323 
b1
 = 
b2
;

327 
	}
}

331 
	$a_tydef_b
 ()

333 
i
 = 0;

334 
BuckLi
 
b1
 = 
NULL
, 
b2
 = NULL;

335 
LeLi
 
l1
 = 
NULL
, 
l2
 = NULL;

337 
i
 = 0; i < 
SIZE
; i ++) {

338 
b1
 = 
tydefNameTab
[
i
];

339 
b1
 !
NULL
) {

340 i(
NULL
 !
b1
->
xt
)

342 
b2
 = 
b1
->
xt
;

344 
b2
 = 
NULL
;

350 
l1
 = 
b1
->
les
;

353 i(
NULL
 =
l1
) {

354 
buck
;

356 i(
NULL
 !
l1
->
xt
)

358 
l2
 = 
l1
->
xt
;

360 
l2
 = 
NULL
;

362 
	`
 (
l1
);

363 
l1
 = 
l2
;

366 
buck
:

367 
	`
 (
b1
);

368 
b1
 = 
b2
;

372 
	}
}

377 
	$t_
 ()

379 
FILE
 * 

;

380 

 = 
	`fݒ
 ("st.sym", "w+");

381 
	`tSymTab
 (

);

382 
	`rtf
 (

, "\n");

383 
	`tTydefTab
 (

);

384 
	`fo
 (

);

385 
	}
}

	@symtab.h

9 #ide
_SYMTAB_H_


10 
	#_SYMTAB_H_


	)

12 
	~"dio.h
"

19 
__id
* 
me
, 
lo
, 
loc
 );

20 
__tydef
(*
me
, 
lo
, 
loc
);

30 
tSymTab
(
FILE
 * 
lig
);

31 
tTydefTab
(
FILE
 * 
lig
);

32 
a_b
 ();

33 
a_tydef_b
 ();

34 
t_
 ();

36 
	sLeLiRec
 {

37 
	mlo
;

38 
LeLiRec
 *
	mxt
;

39 } *
	tLeLi
;

40 
	sBuckLiRec
 {

41 
	mme
[126];

42 
LeLi
 
	mles
;

43 
	mmemloc
;

44 
BuckLiRec
 *
	mxt
;

45 
	mfunc
[126];

46 
	mdty
;

47 } *
	tBuckLi
;

49 
BuckLi
 
_lookup
 ( * 
me
 );

50 
BuckLi
 
_lookup_tydef
(*
me
);

52 
_um
;

	@test.c

1 #"
klsjdkjlksdjf
"

2 
	gi
 = 0;

3 
	tmyage
;

4 
	gj
 = 0;

	@y.tab.h

1 #ide
YY_r_h_uded


2 
	#YY_r_h_uded


	)

7 #ifde
c_ulus


8 #ide
__lulus


9 
	#__lulus


	)

18 #ide
YY_r_COMPATIBILITY


19 #ide
YY_USE_CLASS


20 
	#YY_r_COMPATIBILITY
 1

	)

22 
	#YY_r_COMPATIBILITY
 0

	)

26 #i
YY_r_COMPATIBILITY
 != 0

28 #ifde
YYLTYPE


29 #ide
YY_r_LTYPE


30 
	#YY_r_LTYPE
 
YYLTYPE


	)

36 #ide
YY_r_STYPE


37 
	#YY_r_STYPE
 
YYSTYPE


	)

42 #ifde
YYDEBUG


43 #ide
YY_r_DEBUG


44 
	#YY_r_DEBUG
 
YYDEBUG


	)

50 #ide
YY_r_USE_GOTO


51 
	#YY_r_USE_GOTO
 1

	)

56 #ide
YY_r_USE_GOTO


57 
	#YY_r_USE_GOTO
 0

	)

60 #ide
YY_r_PURE


70 #ide
YY_USE_CLASS


71 #ide
YYSTYPE


72 
	#YYSTYPE
 

	)

73 
	#YYSTYPE_IS_TRIVIAL
 1

	)

80 #ide
YY_r_DEBUG


88 #ide
YY_r_LSP_NEEDED


97 #ifde
YY_r_LSP_NEEDED


98 #ide
YY_r_LTYPE


99 #ide
BISON_YYLTYPE_ISDECLARED


100 
	#BISON_YYLTYPE_ISDECLARED


	)

102 
	syyy


104 
	mtimeamp
;

105 
	mf_le
;

106 
	mf_cumn
;

107 
	mϡ_le
;

108 
	mϡ_cumn
;

109 *
	mxt
;

111 
	tyyy
;

114 
	#YY_r_LTYPE
 
yyy


	)

119 #ide
YY_r_STYPE


120 
	#YY_r_STYPE
 

	)

124 #ide
YY_r_PARSE


125 
	#YY_r_PARSE
 
yyr


	)

128 #ide
YY_r_LEX


129 
	#YY_r_LEX
 
yyx


	)

132 #ide
YY_r_LVAL


133 
	#YY_r_LVAL
 
yylv


	)

136 #ide
YY_r_LLOC


137 
	#YY_r_LLOC
 
yyoc


	)

140 #ide
YY_r_CHAR


141 
	#YY_r_CHAR
 
yych


	)

144 #ide
YY_r_NERRS


145 
	#YY_r_NERRS
 
yyüs


	)

148 #ide
YY_r_DEBUG_FLAG


149 
	#YY_r_DEBUG_FLAG
 
yydebug


	)

152 #ide
YY_r_ERROR


153 
	#YY_r_ERROR
 
yyr


	)

156 #ide
YY_r_PARSE_PARAM


157 #ide
__STDC__


158 #ide
__lulus


159 #ide
YY_USE_CLASS


160 
	#YY_r_PARSE_PARAM


	)

161 #ide
YY_r_PARSE_PARAM_DEF


162 
	#YY_r_PARSE_PARAM_DEF


	)

167 #ide
YY_r_PARSE_PARAM


168 
	#YY_r_PARSE_PARAM
 

	)

173 #ide
YY_USE_CLASS


175 #ide
YY_r_PURE


176 #ide
yylv


177 
YY_r_STYPE
 
YY_r_LVAL
;

179 #i
yylv
 !
YY_r_LVAL


180 
YY_r_STYPE
 
YY_r_LVAL
;

189 
	#INCLUDE_FLAG
 258

	)

190 
	#LINE
 259

	)

191 
	#FILENAME
 260

	)

192 
	#INLINE
 261

	)

193 
	#IDENTIFIER
 262

	)

194 
	#CONSTANT
 263

	)

195 
	#STRING_LITERAL
 264

	)

196 
	#SIZEOF
 265

	)

197 
	#PTR_OP
 266

	)

198 
	#INC_OP
 267

	)

199 
	#DEC_OP
 268

	)

200 
	#LEFT_OP
 269

	)

201 
	#RIGHT_OP
 270

	)

202 
	#LE_OP
 271

	)

203 
	#GE_OP
 272

	)

204 
	#EQ_OP
 273

	)

205 
	#NE_OP
 274

	)

206 
	#AND_OP
 275

	)

207 
	#OR_OP
 276

	)

208 
	#MUL_ASSIGN
 277

	)

209 
	#DIV_ASSIGN
 278

	)

210 
	#MOD_ASSIGN
 279

	)

211 
	#ADD_ASSIGN
 280

	)

212 
	#SUB_ASSIGN
 281

	)

213 
	#LEFT_ASSIGN
 282

	)

214 
	#RIGHT_ASSIGN
 283

	)

215 
	#AND_ASSIGN
 284

	)

216 
	#XOR_ASSIGN
 285

	)

217 
	#OR_ASSIGN
 286

	)

218 
	#TYPE_NAME
 287

	)

219 
	#TYPEDEF
 288

	)

220 
	#EXTERN
 289

	)

221 
	#STATIC
 290

	)

222 
	#AUTO
 291

	)

223 
	#REGISTER
 292

	)

224 
	#CHAR
 293

	)

225 
	#SHORT
 294

	)

226 
	#INT
 295

	)

227 
	#LONG
 296

	)

228 
	#SIGNED
 297

	)

229 
	#UNSIGNED
 298

	)

230 
	#FLOAT
 299

	)

231 
	#DOUBLE
 300

	)

232 
	#CONST
 301

	)

233 
	#VOLATILE
 302

	)

234 
	#VOID
 303

	)

235 
	#STRUCT
 304

	)

236 
	#UNION
 305

	)

237 
	#ENUM
 306

	)

238 
	#ELLIPSIS
 307

	)

239 
	#CASE
 308

	)

240 
	#DEFAULT
 309

	)

241 
	#IF
 310

	)

242 
	#ELSE
 311

	)

243 
	#SWITCH
 312

	)

244 
	#WHILE
 313

	)

245 
	#DO
 314

	)

246 
	#FOR
 315

	)

247 
	#GOTO
 316

	)

248 
	#CONTINUE
 317

	)

249 
	#BREAK
 318

	)

250 
	#RETURN
 319

	)

257 #ide
YY_r_CLASS


258 
	#YY_r_CLASS
 
r


	)

261 #ide
YY_r_INHERIT


262 
	#YY_r_INHERIT


	)

265 #ide
YY_r_MEMBERS


266 
	#YY_r_MEMBERS


	)

269 #ide
YY_r_LEX_BODY


270 
	#YY_r_LEX_BODY


	)

273 #ide
YY_r_ERROR_BODY


274 
	#YY_r_ERROR_BODY


	)

277 #ide
YY_r_CONSTRUCTOR_PARAM


278 
	#YY_r_CONSTRUCTOR_PARAM


	)

281 #ide
YY_r_USE_CONST_TOKEN


282 
	#YY_r_USE_CONST_TOKEN
 0

	)

286 #i
YY_r_USE_CONST_TOKEN
 != 0

287 #ide
YY_r_ENUM_TOKEN


288 
	#YY_r_ENUM_TOKEN
 
yy_r_um_tok


	)

292 as
	cYY_r_CLASS
 
	mYY_r_INHERIT


294 
	mpublic
:

295 #i
YY_r_USE_CONST_TOKEN
 != 0

299 cڡ 
INCLUDE_FLAG
;

300 cڡ 
	mLINE
;

301 cڡ 
	mFILENAME
;

302 cڡ 
	mINLINE
;

303 cڡ 
	mIDENTIFIER
;

304 cڡ 
	mCONSTANT
;

305 cڡ 
	mSTRING_LITERAL
;

306 cڡ 
	mSIZEOF
;

307 cڡ 
	mPTR_OP
;

308 cڡ 
	mINC_OP
;

309 cڡ 
	mDEC_OP
;

310 cڡ 
	mLEFT_OP
;

311 cڡ 
	mRIGHT_OP
;

312 cڡ 
	mLE_OP
;

313 cڡ 
	mGE_OP
;

314 cڡ 
	mEQ_OP
;

315 cڡ 
	mNE_OP
;

316 cڡ 
	mAND_OP
;

317 cڡ 
	mOR_OP
;

318 cڡ 
	mMUL_ASSIGN
;

319 cڡ 
	mDIV_ASSIGN
;

320 cڡ 
	mMOD_ASSIGN
;

321 cڡ 
	mADD_ASSIGN
;

322 cڡ 
	mSUB_ASSIGN
;

323 cڡ 
	mLEFT_ASSIGN
;

324 cڡ 
	mRIGHT_ASSIGN
;

325 cڡ 
	mAND_ASSIGN
;

326 cڡ 
	mXOR_ASSIGN
;

327 cڡ 
	mOR_ASSIGN
;

328 cڡ 
	mTYPE_NAME
;

329 cڡ 
	mTYPEDEF
;

330 cڡ 
	mEXTERN
;

331 cڡ 
	mSTATIC
;

332 cڡ 
	mAUTO
;

333 cڡ 
	mREGISTER
;

334 cڡ 
	mCHAR
;

335 cڡ 
	mSHORT
;

336 cڡ 
	mINT
;

337 cڡ 
	mLONG
;

338 cڡ 
	mSIGNED
;

339 cڡ 
	mUNSIGNED
;

340 cڡ 
	mFLOAT
;

341 cڡ 
	mDOUBLE
;

342 cڡ 
	mCONST
;

343 cڡ 
	mVOLATILE
;

344 cڡ 
	mVOID
;

345 cڡ 
	mSTRUCT
;

346 cڡ 
	mUNION
;

347 cڡ 
	mENUM
;

348 cڡ 
	mELLIPSIS
;

349 cڡ 
	mCASE
;

350 cڡ 
	mDEFAULT
;

351 cڡ 
	mIF
;

352 cڡ 
	mELSE
;

353 cڡ 
	mSWITCH
;

354 cڡ 
	mWHILE
;

355 cڡ 
	mDO
;

356 cڡ 
	mFOR
;

357 cڡ 
	mGOTO
;

358 cڡ 
	mCONTINUE
;

359 cڡ 
	mBREAK
;

360 cڡ 
	mRETURN
;

366 
	eYY_r_ENUM_TOKEN
 { 
	mYY_r_NULL_TOKEN
=0

369 ,
	mINCLUDE_FLAG
=258

370 ,
	mLINE
=259

371 ,
	mFILENAME
=260

372 ,
	mINLINE
=261

373 ,
	mIDENTIFIER
=262

374 ,
	mCONSTANT
=263

375 ,
	mSTRING_LITERAL
=264

376 ,
	mSIZEOF
=265

377 ,
	mPTR_OP
=266

378 ,
	mINC_OP
=267

379 ,
	mDEC_OP
=268

380 ,
	mLEFT_OP
=269

381 ,
	mRIGHT_OP
=270

382 ,
	mLE_OP
=271

383 ,
	mGE_OP
=272

384 ,
	mEQ_OP
=273

385 ,
	mNE_OP
=274

386 ,
	mAND_OP
=275

387 ,
	mOR_OP
=276

388 ,
	mMUL_ASSIGN
=277

389 ,
	mDIV_ASSIGN
=278

390 ,
	mMOD_ASSIGN
=279

391 ,
	mADD_ASSIGN
=280

392 ,
	mSUB_ASSIGN
=281

393 ,
	mLEFT_ASSIGN
=282

394 ,
	mRIGHT_ASSIGN
=283

395 ,
	mAND_ASSIGN
=284

396 ,
	mXOR_ASSIGN
=285

397 ,
	mOR_ASSIGN
=286

398 ,
	mTYPE_NAME
=287

399 ,
	mTYPEDEF
=288

400 ,
	mEXTERN
=289

401 ,
	mSTATIC
=290

402 ,
	mAUTO
=291

403 ,
	mREGISTER
=292

404 ,
	mCHAR
=293

405 ,
	mSHORT
=294

406 ,
	mINT
=295

407 ,
	mLONG
=296

408 ,
	mSIGNED
=297

409 ,
	mUNSIGNED
=298

410 ,
	mFLOAT
=299

411 ,
	mDOUBLE
=300

412 ,
	mCONST
=301

413 ,
	mVOLATILE
=302

414 ,
	mVOID
=303

415 ,
	mSTRUCT
=304

416 ,
	mUNION
=305

417 ,
	mENUM
=306

418 ,
	mELLIPSIS
=307

419 ,
	mCASE
=308

420 ,
	mDEFAULT
=309

421 ,
	mIF
=310

422 ,
	mELSE
=311

423 ,
	mSWITCH
=312

424 ,
	mWHILE
=313

425 ,
	mDO
=314

426 ,
	mFOR
=315

427 ,
	mGOTO
=316

428 ,
	mCONTINUE
=317

429 ,
	mBREAK
=318

430 ,
	mRETURN
=319

437 
	gpublic
:

438 
YY_r_PARSE
(
YY_r_PARSE_PARAM
);

439 
vtu
 
	$YY_r_ERROR
(*
msg

YY_r_ERROR_BODY
;

440 #ifde
YY_r_PURE


441 #ifde
YY_r_LSP_NEEDED


442 
vtu
 
	$YY_r_LEX
(
YY_r_STYPE
 *
YY_r_LVAL
,
YY_r_LTYPE
 *
YY_r_LLOC

YY_r_LEX_BODY
;

444 
vtu
 
	$YY_r_LEX
(
YY_r_STYPE
 *
YY_r_LVAL

YY_r_LEX_BODY
;

447 
vtu
 
	$YY_r_LEX
(
YY_r_LEX_BODY
;

448 
YY_r_STYPE
 
YY_r_LVAL
;

449 #ifde
YY_r_LSP_NEEDED


450 
YY_r_LTYPE
 
YY_r_LLOC
;

452 
YY_r_NERRS
;

453 
YY_r_CHAR
;

455 #i
YY_r_DEBUG
 != 0

456 
public
:

457 
YY_r_DEBUG_FLAG
;

459 
public
:

460 
	`YY_r_CLASS
(
YY_r_CONSTRUCTOR_PARAM
);

461 
public
:

462 
YY_r_MEMBERS


463 
	}
};

468 #i
YY_r_COMPATIBILITY
 != 0

475 #ide
YYLTYPE


476 
	#YYLTYPE
 
YY_r_LTYPE


	)

478 #ide
YYDEBUG


479 #ifde
YY_r_DEBUG


480 
	#YYDEBUG
 
YY_r_DEBUG


	)

	@
1
.
0
9
104
c-standard.l
cl-standard.tab.c
cl-standard.tab.h
cl-standard.y
hello.c
symtab.c
symtab.h
test.c
y.tab.h
